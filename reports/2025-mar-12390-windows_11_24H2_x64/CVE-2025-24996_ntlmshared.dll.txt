{'patch_store_uid': 'cf73d068-b97f-4a64-a5ea-2a1cb78b4f56', 'file': 'ntlmshared.dll', 'confidence': 0.25, 'date': 1751865204.9416416, 'cve': 'CVE-2025-24996', 'change_count': 1, 'kb': 'KB5053598'}
--------------------------------------------------------------------
CVE-2025-24996 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows NTLM authentication library (ntlmshared.dll) – helper routine
wil::details::FeatureImpl<__WilFeatureTraits_Feature_2032163131>::
GetCachedFeatureEnabledState()

Vulnerability Class
--------------------------------------------------------------------
Logic / state-management error (feature flag bit-mask mishandling)
leading to security-feature bypass – maps best to CWE-73 secondary
effect, but primary coding flaw is an Incorrect Bitmask Calculation.

Detailed Root Cause Analysis
--------------------------------------------------------------------
GetCachedFeatureEnabledState() maintains a 32-bit cache word that
encodes several independent feature-state sub-flags:
  0x0001  – cached "enabled" indicator (LSB)
  0x0040  – FEATURE_ENABLED returned by policy engine
  0x0400  – variant/group bit A
  0x0800  – variant/group bit B
  ...     – other bits (interest not changed by patch)

Before the patch the routine collapsed those bits with the single
statement
    v13 = v10 | (v10 >> 6) & 1;
(v10 already contained the 0x40/0x400/0x800 encoding).  The right
shift copies bit 6 (0x40) straight into bit 0, unconditionally marking
the feature as fully "enabled" whenever 0x40 is present, even if the
higher order bits indicate that the feature is only partially rolled
out or explicitly disabled.

Consumers – including MsvpPasswordValidate() in the NTLM package –
subsequently test bit 0 to decide whether modern protection logic
(e.g. channel binding and hash-suppression) must be applied.  Because
bit 0 was set too broadly, callers deemed the security feature active
while the underlying policy still allowed legacy behaviour.  The
resulting mismatch let remote peers force the code down the insecure
path and obtain NTLM hashes that should have been withheld.

Patch logic:
  • Derive a temporary flag v12 that becomes TRUE only when *both*
    0x400 and 0x800 are set *and* 0x40 indicates Enabled.
  • Build the new cache word as
        v15 = (v12 ? 1 : 0) | v10;
    therefore bit 0 is asserted only under the stricter condition.
  • A fast-path early return was added when the cache already contains
    the final 0b110 state, reducing needless re-evaluation.
No other data structures or buffers are touched; the bug is pure
logic.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable (before)
v10 = ...;                    // 0x40/0x400/0x800 composition
v13 = v10 | (v10 >> 6) & 1;   // blindly propagates bit 6 to bit 0
...
*(_DWORD *)a2 = v13;          // cached and later queried by callers

// fixed (after)
v10 = ...;
char v12 = 0;
if ( (v10 & 0xC00) == 0xC00 )      // require both higher bits
    v12 = 1;
else if ( (v10 & 0x40) )           // 0x40 alone no longer enough
    /* fall through */;
int v13 = v12 ? 1 : 0;
...
v15 = v13 | v10;                  // strict enable decision
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Remote NTLM negotiation
 -> LSASS!MsvpPasswordValidate()
    -> ntlmshared!GetCachedFeatureEnabledState()
       (returns incorrectly formed cache word)
    -> Caller trusts bit0 == 1, skips modern protection
 -> Attacker receives or forges NTLM hash / proof

Attack Vector
--------------------------------------------------------------------
A network attacker able to pose as or redirect a server that requests
NTLM authentication convinces the victim host to authenticate.  Because
the feature state is mis-cached, the client believes protection is
active while actually sending legacy hash material, enabling spoofing
or relay attacks.

Patch Description
--------------------------------------------------------------------
1. Added quick return when cache already in stable state.
2. Re-implemented derivation of LSB ("enabled" bit):
   • Now requires 0x400 and 0x800 *plus* 0x40, instead of 0x40 alone.
3. Refactored variable names and inserted helper (char v12) for
   clarity; the surrounding atomic-compare-exchange loop is unchanged.
No memory layout or API surface modifications.

Security Impact
--------------------------------------------------------------------
Prior to the patch a remote, unauthenticated attacker could obtain or
relay NTLM hashes, defeating channel-binding protections and enabling
credential spoofing.  The flaw affects any client or service relying
on the cached feature flag to decide whether to send secure NTLM
responses.

Fix Effectiveness
--------------------------------------------------------------------
The new mask explicitly checks the previously ignored 0x400/0x800
state bits, eliminating the false-positive enablement.  Because the
code path is otherwise identical and no unsafe memory operations were
introduced, the patch fully neutralises the logic flaw.  No residual
bypass is evident in the diff.
