{'file': 'ntfs.sys', 'change_count': 17, 'confidence': 0.28, 'kb': 'KB5053598', 'patch_store_uid': 'e7ca9e07-1f84-451f-a10b-8a79bb74c0cb', 'cve': 'CVE-2025-24991', 'date': 1751829811.7602887}
--------------------------------------------------------------------
CVE-2025-24991 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows NTFS kernel driver (ntfs.sys) – path-parsing and
restart-log routines: NtfsFindStartingNode, DoAction, and
NtfsInitializeUpcaseInfo.

Vulnerability Class
--------------------------------------------------------------------
Out-of-bounds read / information disclosure (CWE-125).

Detailed Root Cause Analysis
--------------------------------------------------------------------
Several internal NTFS helpers calculate buffer lengths and flag words
coming from user-supplied path names or from on-disk structures.  In
NtfsFindStartingNode the variable that stores the FileNameFlags /
Ccb->Flags combination (v21) was declared as 64-bit (__int64).  The
code then copied the 32-bit field (*((DWORD*)a8+39)) into this 64-bit
location and performed bit tests and mask/clear operations:

    v21 = *((unsigned int *)a8 + 39);
    if ((v21 & 0x50) == 0 && (v21 & 0x20) != 0) …

Because v21 was 64-bit, the compiler sign-/zero-extended the 32-bit
value; later comparisons mixed the widened value with 32-bit constants
and were used to derive a path component length that is stored in
*WORD a8[8].  When the upper dword contained non-zero data the length
calculation silently overflowed, producing a length up to 0xffff’xxxx
bytes long.  Subsequent memmove and ExAllocatePoolWithTag calls copied
or allocated only the lower 16-bit element, while loops iterated over
the full (corrupted) 32-/64-bit size – reading beyond the caller’s
buffer into kernel memory.

Exactly the same width-truncation pattern existed in other helper
functions:
  • DoAction – several index-buffer routines used 64-bit temporaries
    to hold 32-bit size fields taken from log-records.
  • NtfsInitializeUpcaseInfo – 64-bit multiplications on DWORD array
    indexes could walk past NtfsKnownUpcaseInfoArray.

All three places could therefore read arbitrary kernel memory that is
subsequently returned to user mode (e.g. through STATUS_OBJECT_NAME_*
error buffering or via the log-file replay path).

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
__int64 v21 = *((unsigned int *)a8 + 39);   // sign/zero-extended
… if ((v21 & 0x400) != 0) { … }

// after
int v21  = *((_DWORD *)a8 + 39);            // width fixed
… unsigned int v24 = v22 & 0xFFFFFBFF;      // mask safely
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User thread opens/creates a crafted path on an NTFS volume.
2. IoCreateFile → NtfsCommonCreate → NtfsFindStartingNode.
3. The path component length field overflows due to widened flag word
   (step ➊ above).
4. memmove() in NtfsFindStartingNode copies data past the end of the
   user-supplied name buffer, leaking uninitialised kernel memory in
   the resulting UNICODE_STRING returned to user.
5. Similar over-reads are reachable during NTFS log replay via
   DoAction, which is executed in kernel context while mounting a
   dirty volume.

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker provides a specially crafted long file
name (or a malicious NTFS image) that abuses the flag-width
confusion.  No administrator rights are required; any process that can
access an NTFS volume can trigger the path parser.

Patch Description
--------------------------------------------------------------------
Microsoft changed all affected temporaries from 64-bit to 32-bit types
(int / unsigned int).  Additional size validation has been inserted:
• New checks against *WORD <= 0x1FE before memmove.
• Early bail-out when Feature_4251462969 is enabled (Upcase helper).
• Extra length sanity ( (length > 2 && last char == '\\') ) before
  stripping component.
These modifications prevent the length overflow and therefore stop the
out-of-bounds read.

Security Impact
--------------------------------------------------------------------
Before the patch, any local user could obtain arbitrary kernel stack
or pool contents that reside directly after a user-controlled UNICODE
buffer.  Leaked pointers and structure contents break KASLR and aid in
further privilege-escalation exploits.  The issue is classified as
Information Disclosure with CVSS base 5.5 (AV:L/AC:L/PR:L/UI:N/S:U/C:H
/I:N/A:N).

Fix Effectiveness
--------------------------------------------------------------------
The explicit down-cast to 32-bit together with additional length
sanity checks remove the integer-width confusion.  All code paths that
previously consumed the widened value now operate on the correct field
size, stopping the overflow.  No alternative uncontrolled path was
found in the updated routines, so the patch is deemed effective, though
other similar width-mismatches may still exist elsewhere in ntfs.sys.
