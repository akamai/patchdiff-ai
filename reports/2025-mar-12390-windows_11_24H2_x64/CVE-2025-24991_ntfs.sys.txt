{'file': 'ntfs.sys', 'kb': 'KB5053598', 'patch_store_uid': 'e7ca9e07-1f84-451f-a10b-8a79bb74c0cb', 'confidence': 0.19, 'change_count': 17, 'date': 1764763864.3121488, 'cve': 'CVE-2025-24991'}
--------------------------------------------------------------------
CVE-2025-24991 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows NTFS driver (ntfs.sys)
Affected routines: ReadRestartTable() and its consumer
InitializeRestartState().

Vulnerability Class
--------------------------------------------------------------------
Out-of-bounds read (CWE-125) leading to kernel information
leakage while parsing a restart record contained in an NTFS log
file.

Detailed Root Cause Analysis
--------------------------------------------------------------------
ReadRestartTable() processes a restart area that was previously
retrieved from the NTFS transaction log (LFS).  The function first
validates the outer log record with NtfsCheckLogRecord(), then calls
NtfsCheckRestartTable() to validate the embedded restart table.

Buggy offset computation (pre-patch)
1.  v9  = *(QWORD *)(a4 + 72)           // ptr to restart area
2.  offset_to_tbl = *(WORD *)(v9 + 4)   // value comes from log
3.  NtfsCheckRestartTable(v9 + offset_to_tbl, size, cookie)

The code trusts the 16-bit field at offset +4 of the restart area to
locate the first restart table.  If an attacker supplies a crafted
restart record in which this field is smaller than the actual header
size, NtfsCheckRestartTable() will be invoked on a memory range that
starts inside the header instead of at the real table.  Because the
size argument (derived from *(DWORD *)(a4 + 64)) is unchanged, the
routine reads past the caller-supplied buffer, disclosing adjacent
kernel memory.

Additional consequence: the return value (pointer returned to the
caller) is likewise computed from this untrusted field, so callers
such as InitializeRestartState() may later copy the out-of-bounds data
into pageable pool that is accessible to user mode via other
interfaces.

Patched behaviour
The patch discards the header-supplied offset.  Instead it derives the
correct header length from the number of client entries:

    hdr_len = (clients <= 1) ? 40 : (8 * clients + 32);
    NtfsCheckRestartTable(v10 + hdr_len, ...);

If the validation fails, execution now jumps to new corruption
handling code that raises STATUS_DISK_CORRUPT_ERROR before any out-of-
bounds access can occur.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// pre-patch (simplified)
WORD offset = *(WORD *)(RestartArea + 4);
if (!NtfsCheckRestartTable(RestartArea + offset,
                           Total - offset, Cookie))
    NtfsRaiseStatus(...);
```

```c
// post-patch
WORD clients = *(WORD *)(RestartArea + 14);
ULONG hdrLen = (clients <= 1) ? 40 : (8 * clients + 32);
if (!NtfsCheckRestartTable(RestartArea + hdrLen,
                           Total - *(WORD *)(RestartArea + 4),
                           Cookie))
    NtfsRaiseStatus(...);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User mounts or accesses a volume containing a malicious $LogFile.
2. NtfsMountVolume() → NtfsRestartVolume() → InitializeRestartState().
3. InitializeRestartState() reads the first restart area and calls
   ReadRestartTable().
4. ReadRestartTable() uses the untrusted 16-bit offset to pass an
   out-of-range buffer to NtfsCheckRestartTable(), which performs the
   actual out-of-bounds memory read.
5. The leaked data is later copied back into attacker-controlled disk
   structures or user-mapped memory, allowing disclosure.

Attack Vector
--------------------------------------------------------------------
Local attacker crafts an NTFS image (or directly edits $LogFile on an
existing volume) so that the Restart Area field at offset +4 contains
an undersized value.  Mounting or otherwise activating the volume on a
vulnerable system triggers the OOB read in kernel context.

Patch Description
--------------------------------------------------------------------
• Replaced the untrusted restart-table offset with a length computed
  from the verified client-count field (header_len = 40 or 32+8*n).
• Added multiple bailout paths (LABEL_14 / 17) which attach corruption
  info and raise STATUS_DISK_CORRUPT_ERROR before dereferencing.
• Introduced extra corruption codes (0xE2001E0391 etc.) for telemetry.
• Updated callers (InitializeRestartState) to use the new, safer
  contract.

Security Impact
--------------------------------------------------------------------
A successful exploitation reveals uninitialised kernel memory contents
to the attacker.  While no write primitive is provided, the disclosed
data may include pointers or other sensitive values that facilitate
further kernel exploitation.  The flaw therefore represents an
information-disclosure vulnerability in the Windows kernel and is
covered by CVE-2025-24991.

Fix Effectiveness
--------------------------------------------------------------------
The new code no longer trusts a log-supplied offset; it derives the
correct header length from validated fields and performs an early
integrity check.  All error paths now raise before any potential
out-of-range access.  Assuming no other unvalidated fields influence
hdr_len, the patch fully mitigates this specific OOB read.  Residual
risk remains only if the new feature flags are disabled at build or
boot time (unknown).
