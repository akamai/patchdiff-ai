{'kb': 'KB5053598', 'confidence': 0.19, 'date': 1751831492.943622, 'change_count': 424, 'file': 'shell32.dll', 'cve': 'CVE-2025-24071', 'patch_store_uid': 'fcefe295-6bdc-4231-8a6b-8a69f8045759'}
--------------------------------------------------------------------
CVE-2025-24071 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows shell32.dll – helper routine
std::_Traits_find_last_of<std::char_traits<ushort>,1>()
(used by File Explorer path-handling code)

Vulnerability Class
--------------------------------------------------------------------
Logic flaw / incorrect function body (symbol resolution error)
leading to incorrect path parsing; results in spoofing / information
exposure (CWE-200).

Detailed Root Cause Analysis
--------------------------------------------------------------------
In the pre-patch binary the symbol

  std::_Traits_find_last_of<std::char_traits<ushort>,1>

points to a completely unrelated lambda-destructor generated from
CPinnedList::ApplyPrependDefaultTaskbarLayout.  That stub does nothing
except call std::wstring::~wstring on

    (parameter2 + 0x70)           // 0x70 (112) bytes offset

and returns its result.  The routine clearly does **not** implement the
expected   find_last_of()  semantics (returning the last occurrence of
one of the supplied separator characters in a wide string).  Every call
site that expects an index (ssize_t) instead receives whatever value is
returned by the destructor – in practice usually –1 or a small heap
pointer.  Down-stream code that relies on the index to split or
canonicalise a path therefore sees corrupt data.

File Explorer uses this helper to locate the last '\\' or '/' in a
UNICODE path.  With the bogus implementation the search fails whenever
separator characters are involved, so the caller treats the **entire**
input as a file name instead of   <dir>\<file>.  A crafted remote share
name such as

   \\\\ATTACKER\public\..\really.docx                 

can therefore be mis-presented as a single "docx" item while internally
still resolving to an arbitrary ancestor directory.  The GUI shows the
spoofed value, but the underlying I/O APIs open the true location; this
constitutes a spoofing / information disclosure scenario.

The bug is entirely caused by a build/link fault: the template
specialisation with integral constant parameter ==1 never received its
proper body, leaving the compiler-generated destructor in its place.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – wrong body, just a lambda destructor
__int64 __fastcall CPinnedList::ApplyPrependDefaultTaskbarLayout_::_1_::dtor_3(
        __int64 a1, __int64 a2)
{
    return std::wstring::~wstring(a2 + 112);
}

// after patch – real implementation (excerpt)
__int64 __fastcall std::_Traits_find_last_of<...>(
        _WORD *str, __int64 len, __int64 pos,
        const wchar_t *search, __int64 searchLen)
{
    char mask[256] = {0};
    if (!searchLen || !len) return -1;
    for (const wchar_t *p = L"\\/"; p != search + searchLen; ++p) {
        if (*p >= 0x100)                 // non-ASCII => fall back
            return std::_Traits_find_last_of<...,0>(...);
        mask[(unsigned char)*p] = 1;
    }
    ...                                  // walk backwards and return idx
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. File Explorer constructs a UNICODE path string.
2. Path canonicalisation helper calls
   std::_Traits_find_last_of<ushort,1>() to locate the last separator.
3. Pre-patch, the call lands in the stray destructor.
4. A wrong value is returned -> caller uses bogus slice indices.
5. GUI renders spoofed file name; underlying file object resolves to a
different location.

Attack Vector
--------------------------------------------------------------------
An attacker controls a path presented to the victim (e.g. via a network
share, ZIP, or shortcut).  By embedding special directory components
and relying on the missing find_last_of() logic, the attacker can cause
File Explorer to display a misleading file/folder name, leading the user
to open or copy unintended content.

Patch Description
--------------------------------------------------------------------
Microsoft replaced the destructor stub with a full, bounds-checked ASCII
implementation of  std::_Traits_find_last_of<ushort,1>().  Key safety
measures:
• validates both string length (a2) and search-set length (a5)
• builds a 256-byte mask only for ASCII values; if a wchar_t >255 occurs
  it transparently defers to the generic template (parameter 0)
• walks the input string from the end to the beginning and returns a
  correct 0-based index, -1 on failure.

Security Impact
--------------------------------------------------------------------
Correcting the routine restores accurate path delimiter detection.  The
GUI can no longer be tricked into showing a falsified name, closing the
spoofing / info-leak hole.  No memory corruption remains reachable from
untrusted input.

Fix Effectiveness
--------------------------------------------------------------------
Because the faulty symbol was entirely replaced, all call sites now
receive valid indices.  The added high-value wchar_t check prevents any
future mask overrun.  Without other code paths mapping to the old stub,
this patch fully mitigates the identified vulnerability.
