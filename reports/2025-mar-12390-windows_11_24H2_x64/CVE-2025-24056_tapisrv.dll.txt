{'patch_store_uid': '0e82ece3-aaa2-4a39-8876-183ebba7b2c7', 'cve': 'CVE-2025-24056', 'file': 'tapisrv.dll', 'date': 1751866746.978345, 'kb': 'KB5053598', 'confidence': 0.27, 'change_count': 4}
--------------------------------------------------------------------
CVE-2025-24056 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Telephony Server (tapisrv.dll) – registry helper code that
builds in-memory priority-list strings:
  • GetPriorityList()
  • GetMediaModesPriorityLists()
  • LSetAppPriority()
These functions are reachable through RPC calls exposed by the
Telephony service (TAPI) running as NT AUTHORITY\SYSTEM.


Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow / out-of-bounds write (CWE-122) caused by
missing length validation and unsigned arithmetic underflow while
building wide-char strings.


Detailed Root Cause Analysis
--------------------------------------------------------------------
1. GetPriorityList()
   • Queries a registry value size into DWORD cbData.
   • Allocates cbData+2 bytes then copies cbData bytes at offset +2.
   • The code writes a terminating NULL with
       *(WORD *)&buf[ 2*((cbData-2)>>1 ) + 2 ] = 0;
   • When cbData is 0 or 1 the subtraction underflows (unsigned),
     resulting in a write far beyond the end of the heap block.
   • No guard existed when the internal feature flag
     Feature_1390216506__private_IsEnabledDeviceUsageNoInline() was
     disabled (default on down-level builds).

2. GetMediaModesPriorityLists() contained the same pattern while
   looping over registry values.  The identical underflow produces an
   out-of-bounds write for every malformed value.

3. LSetAppPriority() later concatenates / removes those priority
   strings.  Although not the primary corruptor, its logic assumes the
   earlier buffers are valid; once the heap is already corrupted the
   additional memmove/StringCb* operations can be steered into further
   memory corruption and eventual code execution.

Input parameters and structures involved
   HKEY            – caller-controlled registry key
   lpValueName     – value name enumerated by the service
   cbData (DWORD)  – size returned by RegQueryValueExW
   BYTE *buf       – heap buffer of size cbData+2 allocated from
                     ghTapisrvHeap (Process heap of the service)

Failure sequence
   cbData == 0/1                (attacker-supplied)
   cbData-2   => 0xFFFFFFFE/-1  (unsigned underflow)
   index_calc => huge offset
   2-byte NULL write past heap block -> heap metadata clobbered;
   subsequent HeapAlloc/Free triggers controlled corruption.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
if (RegQueryValueExW(..., buf+2, &cbData)) { ... }
* (WORD *)&buf[ 2 * (((unsigned long long)cbData - 2) >> 1) + 2 ] = 0;
```
```c
// after
if (RegQueryValueExW(..., buf+2, &cbData) || cbData < 2)
{
    Common::GlobalHeap::Free(buf);
    return;
}
* (WORD *)&buf[ 2 * (((unsigned long long)cbData - 2) >> 1) + 2 ] = 0;
```
The single extra test `cbData < 2` removes the underflow condition.


Trigger Flow (Top-Down)
--------------------------------------------------------------------
Client RPC -> lineSetAppPriority (winsrv interface)
            -> LSetAppPriority()
            -> GetMediaModesPriorityLists() / GetPriorityList()
            -> RegQueryValueExW() returns attacker-controlled size
            -> under-validated cbData triggers heap overflow.


Attack Vector
--------------------------------------------------------------------
An unauthenticated network attacker can invoke TAPI remote APIs to
force the Telephony service to open an attacker-writable registry key
(e.g. HKCU when impersonating the caller or a per-user mapping) and to
read a value whose data length is 0 or 1.  When the service processes
this value the out-of-bounds write corrupts the heap, allowing crafted
heap Feng-shui to gain code execution in the SYSTEM context.


Patch Description
--------------------------------------------------------------------
• Removed feature-flag dependent branches – size checks are now
  unconditional.
• Added explicit `cbData < 2` test after the second RegQueryValueExW
  in both GetPriorityList() and GetMediaModesPriorityLists(); failure
  aborts processing and frees the buffer.
• Reworked LSetAppPriority() to use the hardened helpers and removed
  obsolete arithmetic guarded by the same feature flag.
• No structural changes to the heap layout; only validation logic was
  added.


Security Impact
--------------------------------------------------------------------
Prior to the fix any user able to influence the registry value size
could achieve a 2-byte write at an attacker-controlled heap offset.
By grooming the Telephony service heap this primitive is sufficient
for reliable remote code execution with SYSTEM privileges.


Fix Effectiveness
--------------------------------------------------------------------
The added `cbData < 2` guard blocks the unsigned underflow, ensuring
that the terminating NULL is written **inside** the allocated
(cbData+2) buffer.  Re-testing with cbData == 0/1 now triggers the free
path and no out-of-bounds access occurs.  Static review shows no
remaining code paths that write beyond the allocation based solely on
cbData; therefore the patch fully addresses the identified issue.
