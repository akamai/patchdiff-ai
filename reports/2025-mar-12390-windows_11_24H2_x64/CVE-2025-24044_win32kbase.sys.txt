{'file': 'win32kbase.sys', 'date': 1751865321.099327, 'patch_store_uid': 'd1c166c6-3f59-4e1a-8a31-d1147277518d', 'change_count': 101, 'confidence': 0.57, 'kb': 'KB5053598', 'cve': 'CVE-2025-24044'}
--------------------------------------------------------------------
CVE-2025-24044 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
win32kbase.sys – NtRIMDeviceIoControl system call wrapper that fronts
RIMDeviceIoControl inside the Win32 (RIM) kernel graphics/input
sub-system.

Vulnerability Class
--------------------------------------------------------------------
Use After Free / Time-of-check-time-of-use (TOCTOU) on user-supplied
buffers (CWE-416).

Detailed Root Cause Analysis
--------------------------------------------------------------------
Prior to the patch, NtRIMDeviceIoControl simply forwarded the caller’s
buffer pointers (a3, a4, a6/Src) and sizes to the internal routine
RIMDeviceIoControl:

    RIMDeviceIoControl(a1,a2,a3,a4,a5,a6,a7,a8,0,0,a9,1);

No probing, capture, or duplication of the user virtual addresses
occurred.  RIMDeviceIoControl performs asynchronous work and can
reference the supplied buffers after NtRIMDeviceIoControl has returned
back to user mode.  Because the original storage resides in the
requester’s address space, the caller can immediately free, remap, or
reuse those pages.  When the kernel later dereferences the stale
pointer it touches freed/re-purposed memory – a classic use-after-free.

Affected parameters
  a4   – input buffer pointer (user mode)
  a6   – secondary buffer (user mode)
  a8   – pointer where result code is written

Structures
  There is no dedicated structure; the raw byte arrays are passed
directly and later interpreted by the RIM stack.

Failure sequence
1. Attacker allocates user buffer, fills it with crafted data.
2. Calls NtRIMDeviceIoControl passing that pointer.
3. Syscall returns; pointer is still recorded inside an internal RIM
   object/IRP.
4. Attacker frees or re-maps the pages, or maps them with RWX data.
5. Kernel worker thread later accesses the dangling pointer, operating
   on freed memory – enabling arbitrary read/write or controlled code
   execution in kernel context.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Before patch – no validation, no copy
return RIMDeviceIoControl(a1, a2, a3, a4, a5, a6, a7, a8, 0i64, 0, a9, 1);
```
```c
// After patch – allocate kernel buffers and copy user data
v14 = Win32AllocPoolZInitImpl(POOL_TAG, Size, 'Rtmp');
memmove(v14, a4, Size);   // safe kernel copy
...
RIMDeviceIoControl(..., v14, Size, v15, a7, &v20, ...);
memmove(Src, v15, a7);    // copy results back to user
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User-mode code calls NtRIMDeviceIoControl with attacker-controlled
   pointers.
2. Kernel saves the raw user addresses inside an internal request.
3. Syscall returns; attacker frees or re-maps those pages.
4. Later, RIM worker dereferences the now-invalid pointer.
5. Memory corruption occurs, leading to arbitrary kernel R/W or EoP.

Attack Vector
--------------------------------------------------------------------
Local.  Any process that has the right to call NtRIMDeviceIoControl
(available to normal user sessions) can supply malicious buffers to
achieve privilege escalation.

Patch Description
--------------------------------------------------------------------
The patch introduces a feature-flagged hardening path
(Feature_RIMDeviceIoControlUMAFix).  When enabled the wrapper:
1. Probes user addresses with MmUserProbeAddress bounds checks.
2. Allocates kernel pool memory (tag 'Rtmp').
3. Copies the user buffers into the private kernel allocations.
4. Passes only the kernel pointers to RIMDeviceIoControl.
5. After completion copies output back to user and frees the pool.
6. Validates a8 before writing the final status.
These steps eliminate any later dependence on user memory.

Security Impact
--------------------------------------------------------------------
Prior to the fix an attacker could gain kernel-mode arbitrary read/
write, leading to full SYSTEM privilege escalation.  The flaw can also
cause kernel crashes at an attacker-controlled address.

Fix Effectiveness
--------------------------------------------------------------------
Copying the data into dedicated kernel buffers removes the dangling
pointer condition and makes the lifetime of the memory fully owned by
the kernel.  Provided the new feature flag is permanently enabled
on supported builds, the patch completely blocks the UAF avenue.  No
obvious bypass remains in the modified code path.
