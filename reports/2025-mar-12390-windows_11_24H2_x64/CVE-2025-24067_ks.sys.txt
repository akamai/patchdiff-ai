{'change_count': 8, 'patch_store_uid': '885e1d78-ef78-499a-8de2-95ab2f6828b6', 'file': 'ks.sys', 'kb': 'KB5053598', 'date': 1751831437.6295638, 'cve': 'CVE-2025-24067', 'confidence': 0.23}
--------------------------------------------------------------------
CVE-2025-24067 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Kernel-Streaming driver (ks.sys).  Affected paths
include KsCreateDefaultAllocatorEx, KsProbeStreamIrp,   
CKsMdlcache::MdlCacheHandleThunkBufferIrp and   
CKsMdlcache::MdlCacheProcessPostProbeIrp – the code that parses
user-supplied KSSTREAM_HEADER structures, creates look-aside frame
allocators and builds MDLs for streaming I/O.

Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow / improper parameter validation (CWE-122).

Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  User code sends IRP_MJ_READ/WRITE or Ioctl 0x2F0007 to a KS pin.      
2.  The IRP contains one or more KSSTREAM_HEADER structures that may
    carry the flag KSSTREAM_HEADER_OPTIONSF_BUFFERED (0x1000) and an
    optional secondary buffer pointer/length located at offsets 0x88
    and 0x80 of the header.
3.  Before the patch the helpers below trusted these fields when
    allocating kernel objects:
      • KsProbeStreamIrp – allocates MDLs directly from
        Header->Data and Header->FrameExtent without verifying that
        Data2/Size2 are non-NULL/non-zero when OPTIONSF_BUFFERED is
        set.
      • CKsMdlcache::MdlCacheHandleThunkBufferIrp – repeats the same
        logic while building a private MDL cache.
4.  If an attacker sets OPTIONSF_BUFFERED, supplies FrameExtent > 0x80
    but leaves Data2 or Size2 NULL/0, the code reaches
        IoAllocateMdl(NULL, 0, …)
    which returns an MDL whose mapped buffer overlaps the driver’s
    own NonPagedPool allocation.  Subsequent data moves by
    KspCopyFrame overflow the original 0xB0-byte frame header buffer
    and corrupt adjacent pool memory – a classic heap overflow.
5.  A second entry point lay in KsCreateDefaultAllocatorEx.  When the
    internal *Feature_H2E_WPA3SAE* switch was disabled (default on
    desktop SKUs) the function accepted any FrameSize.  A non power-of
    two value is passed as the Size parameter to
    ExInitialize[NP]PagedLookasideList.  The look-aside code rounds
    the allocation down, so later writes that assume the full
    requested size run past the end of each block, again corrupting
    pool memory.
6.  Because all paths run in kernel mode, successful exploitation lets
    a normal user execute arbitrary code with SYSTEM privileges.

Key affected fields/structures
  KSSTREAM_HEADER
    0x00 – Size
    0x20 – FrameExtent
    0x24 – DataUsed
    0x40 – Options (bit 12 = 0x1000, BUFFERED)
    0x80 – Data2Length
    0x88 – Data2Pointer

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before – KsProbeStreamIrp
if ((hdr->Options & 0x1000) && FrameExtent>0x80 &&
    !IoAllocateMdl(hdr->Data2, hdr->Data2Length, ...))
    status = STATUS_INSUFFICIENT_RESOURCES;  // no pointer checks

// after – extra validation added
if ((hdr->Options & 0x1000) && FrameExtent>0x80) {
    if (!hdr->Data2 || !hdr->Data2Length) {
        RtlLogUnexpectedCodepath(...);
        return STATUS_INVALID_PARAMETER;
    }
    IoAllocateMdl(...);
}

// before – KsCreateDefaultAllocatorEx
if (!Feature_H2E_WPA3SAE_IsEnabled() || IsUserAllocator ||
    power_of_two(FrameSize))  // validation could be bypassed
    ExInitializeNPagedLookasideList(..., FrameSize, ...);

// after – feature gate removed, power-of-two enforced
if (!IsUserAllocator && !power_of_two(FrameSize))
    return STATUS_INVALID_PARAMETER;
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User mode
  Open pin -> DeviceIoControl(KSSTREAMING_IOCTL_CREATE_DEFAULT_ALLOC)
  -> send IRP_MJ_WRITE with crafted KSSTREAM_HEADER
Driver
  KsCreateDefaultAllocatorEx accepts non-power-of-two FrameSize
  -> look-aside list blocks smaller than header size
  KsProbeStreamIrp / MdlCacheHandleThunkBufferIrp allocate MDL for
     NULL Data2 pointer -> overlapping buffer
  -> KspCopyFrame writes past 0xB0-byte frame header
  -> pool corruption -> EoP.

Attack Vector
--------------------------------------------------------------------
Any local user that can open a KS pin (e.g. via DirectShow, Media
Foundation or win32ks APIs) can submit the malicious IRPs.  No
additional privileges are required beyond normal device access.

Patch Description
--------------------------------------------------------------------
• Removed obsolete feature-flag gate; validation is now unconditional.  
• KsCreateDefaultAllocatorEx now rejects FrameSize values that are not
  a power-of-two unless the caller supplies its own allocate routine.  
• KsProbeStreamIrp and MdlCacheHandleThunkBufferIrp now
  – verify Data2Pointer and Data2Length are both non-zero when
    OPTIONSF_BUFFERED is set,
  – log with RtlLogUnexpectedCodepath and fail with
    STATUS_INVALID_PARAMETER instead of continuing.
• Added clean-up code that zeroes Irp->MdlAddress on failure to avoid
  use-after-free.
• Replaced several direct assignments with safer helpers and corrected
  pointer arithmetic.

Security Impact
--------------------------------------------------------------------
Prior to the fix a crafted streaming IRP could corrupt kernel heap
memory, giving an attacker arbitrary read/write primitives and
allowing local privilege escalation to SYSTEM (ring-0).  The exploit
triggers from user mode without needing code execution in the device
context.

Fix Effectiveness
--------------------------------------------------------------------
The new size and pointer checks block the malformed headers before any
allocation occurs; IoAllocateMdl is never reached with an invalid
pointer and look-aside lists are initialised with a guaranteed safe
block size.  Combined with the unconditional enforcement (feature flag
removed) the vulnerable paths are no longer reachable, and no bypasses
are apparent in the patched logic.
