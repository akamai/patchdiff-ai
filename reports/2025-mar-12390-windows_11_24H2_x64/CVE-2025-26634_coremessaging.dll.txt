{'file': 'coremessaging.dll', 'change_count': 6, 'date': 1751831558.3559444, 'patch_store_uid': '6f119a53-a1ca-4e9d-8e9f-d31566198ac2', 'kb': 'KB5051987', 'cve': 'CVE-2025-26634', 'confidence': 0.32}
--------------------------------------------------------------------
CVE-2025-26634 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Core Messaging (coremessaging.dll) – ALPC message assembly
logic (AssembledChunk, AlpcConnection*)

Vulnerability Class
--------------------------------------------------------------------
CWE-122: Heap-based Buffer Overflow (unchecked pointer arithmetic /
missing size validation)

Detailed Root Cause Analysis
--------------------------------------------------------------------
CoreMessaging uses the AssembledChunk structure to re-assemble a large
ALPC request that was split into several ChunkComponent buffers.  When
a new chunk arrives AlpcConnection::LinkChunkedBufferInBatch() calls
AssembledChunk::AddChunkComponent() to copy the header and the fragment
payload into a pre-allocated heap buffer that belongs to the current
AssembledChunk.

In the original implementation (see snippet below) AddChunkComponent()
performs only two arithmetic checks:
  • is_mul_ok( v2 , *(this+0x54) ) – a 64-bit overflow helper
  • "v10 < v11" – underflow check
No upper-bound test ensures that
    dest   = payloadBase + (chunkIndex * chunkSize)
remains inside the allocated AssembledChunk buffer.  The function also
trusts the per-chunk payload length *(a2+0x48) without validating it
against the remaining space in the destination buffer.  A malicious
client can therefore provide:
  • an over-large current-chunk index (WORD at offset +0x50) or
  • an inflated DataLength field (WORD in the ALPC _PORT_MESSAGE) or
  • an excessive overall-chunk count
so that the computed copy destination (v10) points far beyond the heap
allocation returned by AssembledChunk::Initialize().  The subsequent
memcpy() will overflow the heap, corrupting adjacent objects and
leading to an elevation-of-privilege inside the privileged process
hosting CoreMessaging (e.g. Win32k, Windows Shell, or a system service
using CMBus).

Additional gaps that allowed the out-of-bounds copy:
  • AlpcConnection::ValidateBufferHeader() accepted an arbitrary
    MaxChunkCount (WORD 0x52) as long as MaxCount > Index.  No limit of
    0x50 enforced for MaxCount when the buffer was *not* already in a
    batch (BIT 0x10 cleared).
  • LinkChunkedBufferInBatch() forwarded the raw AlpcBuffer directly to
    AddChunkComponent() without verifying that the buffer had already
    been "chunk-enabled" (WORD 0x50 != 0).

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// coremessaging.dll  –  before patch
v2  = *((unsigned __int16 *)a2 + 40);          // current chunk index
...
if (!is_mul_ok(v2, *((unsigned __int16 *)this + 42)))
    return STATUS_INVALID;

v10 = (char *)v11 + v2 * *((unsigned __int16 *)this + 42); // dest
if (v10 < v11)                                             // only
    return STATUS_INVALID;                                 // underflow

memcpy_0(v10,                                            // <-- OOB
        (char *)a2 + 88,                                 // src start
        *((unsigned int *)a2 + 18) - 8i64);              // src size
```
The memcpy destination (v10) is attacker-controlled; no bound is
checked against the actual size of the AssembledChunk heap buffer.

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker sends crafted ALPC buffer to a CoreMessaging endpoint.
2. AlpcConnection::Callback_HandleReceivedBuffer()
   -> Callback_HandleRequest()
   -> LinkChunkedBufferInBatch()
   -> AssembledChunk::AddChunkComponent()
3. AddChunkComponent() copies payload beyond the allocated heap region
   using attacker-supplied size and index fields.

Attack Vector
--------------------------------------------------------------------
Any authenticated local user (including a sandboxed AppContainer) can
open the CoreMessaging ALPC port and send a malformed batched request.
No special privileges are required.  The overflow occurs inside a
system process (e.g. svchost, explorer, or a UWP broker) and can be
exploited to execute arbitrary code with the host process integrity
level, typically Medium-IL->High-IL or SYSTEM EoP.

Patch Description
--------------------------------------------------------------------
The patch replaces AddChunkComponent() with a rewritten version that:
  • Accepts the _PORT_MESSAGE header and explicit buffer-size argument.
  • Validates DataLength, chunk index, MaxChunkCount, TotalPayloadSize
    (this+0x58), and overall CopyLength against the current heap size.
  • Uses ULongLongMult() to perform checked multiplications.
  • Rejects any request that would exceed 0xA0 bytes of header or the
    accumulated payload size (0xFFA0 limit).
  • Introduces GetPortMessageForReply() to allocate/calculate safe
    header/payload pointers.
  • Tightens AlpcConnection::ValidateBufferHeader() so that
    MaxChunkCount <= 0x50, ChunkIndex < MaxChunkCount, and blocks
    non-null attribute pointers when the hardening feature flag is on.
  • Updates LinkChunkedBufferInBatch() to propagate the validated
    buffer size instead of the raw AlpcBuffer.

Security Impact
--------------------------------------------------------------------
Successful exploitation yields a heap overwrite in a privileged
process, enabling information disclosure, process takeover, or
execution of arbitrary code with elevated privileges.  The issue was
publicly assigned CVE-2025-26634 and classified as an Elevation of
Privilege vulnerability.

Fix Effectiveness
--------------------------------------------------------------------
The new code performs comprehensive bounds checking and uses safe math
helpers before every copy, eliminating the out-of-bounds condition.
Because all relevant header fields are now validated both when the
buffer is first received and again before every chunk copy, the window
for overflow is effectively closed.  Residual risk is limited to
future logic errors behind the feature flag, but the specific overflow
vector described here is fully mitigated.
