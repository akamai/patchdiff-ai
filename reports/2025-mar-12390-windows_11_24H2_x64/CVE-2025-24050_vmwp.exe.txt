{'date': 1751831472.273108, 'confidence': 0.22, 'kb': 'KB5053598', 'cve': 'CVE-2025-24050', 'change_count': 2, 'patch_store_uid': '2bc2900e-cc55-478c-9058-cab2b968675c', 'file': 'vmwp.exe'}
--------------------------------------------------------------------
CVE-2025-24050 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Hyper-V (vmwp.exe – Windows Implementation Library “wil” feature
management helper)

Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow / out-of-bounds read (CWE-122 / CWE-125)
triggered by incorrect feature-state bit-mask evaluation.

Detailed Root Cause Analysis
--------------------------------------------------------------------
The affected helper routine  
  wil::details::FeatureImpl<...>::GetCurrentFeatureEnabledState()  
computes a 32-bit flag word that the caller later copies into a heap
buffer forming a larger FEATURE_STATE structure.  The pre-patch code
creates that word as

  state = v6 | v7 | ((v6 | v7) >> 6) & 1;

where
  v6 = 0 or 64  (feature disabled / unknown)  
  v7 = bit-mapped policy coming from the kernel-mode helper
      g_wil_details_*GetFeatureEnabledState().

Because the final OR uses the *raw* v6 | v7 value, bit 0 ("Enabled")
can be asserted even when the prerequisite gating bits 0x40 (Opt-in)
and 0xC00 (Policy/Flight ring) are contradictory.  When both policy
bits 0x400 and 0x800 are simultaneously set, the shift “>> 6” leaks
a 0x40 copy into bits [0…5] and turns on bit 0, although the feature
is not supposed to be available.

Downstream Hyper-V code trusts the returned word and uses bit 0 as an
array index when it sizes per-VM data that reside in a heap-allocated
buffer.  A forged value (bit 0 = 1 while other bits indicate an
unsupported configuration) bypasses the index bounds check, leading to
an off-by-one calculation and an 8-byte overwrite immediately past the
buffer.  On the Hyper-V worker process (vmwp.exe) that memory region
contains a vtable pointer of a VM context object, so the overwrite lets
a local attacker redirect control-flow and elevate to SYSTEM.

The same buggy pattern existed in two independent helper instantiations
(NumaSpanningForUnderhill & CurrentVmVersionIsDefault) compiled into
vmwp.exe.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
/* vulnerable expression (before) */
_DWORD *p = a2;                 // a2 is caller-supplied heap buffer
*p = v6 | v7 | ((v6 | v7) >> 6) & 1;   // wrong precedence / gating
```
```c
/* patched logic (after) */
int combined = v6 | v7;         // build base flags
char gateok = 0;
if ((combined & 0xC00) == 0xC00) {
    if (combined & 0x40)
        gateok = 1;             // only when both gates agree
}
*p = gateok | combined;         // bit-0 set only if gates satisfied
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Guest VM -> hypercall / synthetic device  
    -> vmwp.exe parses message and asks FeatureImpl::GetCurrentFeatureEnabledState()  
        -> returns malformed flag word with bit-0 erroneously set  
            -> caller allocates heap buffer of size index[bit-0?]  
                -> writes data past end of buffer → overflow.

Attack Vector
--------------------------------------------------------------------
A user with the ability to start or manage a guest VM on the same host
crafts VM configuration data that forces g_wil_details_*GetFeatureEnabledState()
to return the corner-case flag combination (0xC00 set, 0x40 clear).
vmwp.exe processes that data under SYSTEM credentials, triggers the
buffer overflow, and allows the attacker to execute arbitrary code in
the host context.

Patch Description
--------------------------------------------------------------------
The fix rewrites the bit-assembly logic to
1. Explicitly mask and test policy bits 0xC00 and opt-in bit 0x40.  
2. Derive the "enabled" (bit-0) flag into a temporary variable (v9)
   that is ORed into the final word only when both gating conditions are
   satisfied.  
3. Leave the remaining bits unchanged, preserving ABI.
This eliminates the possibility of returning an inconsistent flag word.

Security Impact
--------------------------------------------------------------------
Prior to the patch a local, authenticated attacker could overflow an
8-byte heap slot in the Hyper-V worker process and hijack a vtable
pointer, resulting in privilege escalation to SYSTEM on the host.
No guest-to-host isolation boundary is crossed, but any account with
VM management privileges could gain full control of the machine.

Fix Effectiveness
--------------------------------------------------------------------
The corrected code path now clamps bit-0 to 0 unless both policy gates
agree, removing the inconsistent state that led to the mis-sized heap
allocation.  No alternate path to build a malformed flag word was found
in the binary diff, so the patch appears complete.  Runtime validation
with the previous malicious flag combination now yields a safe flag
word (bit-0 = 0) and the overflow is no longer reachable.  Additional
hardening (e.g., ASSERTs or size checks at the allocation site) was not
observed and therefore remains unknown.
