{'file': 'mmcndmgr.dll', 'patch_store_uid': 'f10b5008-ac94-4569-9dc4-d635f7553c61', 'kb': 'KB5053598', 'cve': 'CVE-2025-26633', 'change_count': 16, 'date': 1751831455.8224468, 'confidence': 0.22}
--------------------------------------------------------------------
CVE-2025-26633 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Management Console (mmcndmgr.dll) – private replacement of
StrSafe StringCchCopyA and its direct callers GetSubstituteHKLFromReg
and GetRegisteredLocation.


Vulnerability Class
--------------------------------------------------------------------
Stack-based buffer overflow / incorrect boundary check that can be
abused as a Security-Feature-Bypass (CWE-121 mapped to CWE-707 in the
vendor advisory).


Detailed Root Cause Analysis
--------------------------------------------------------------------
mmcndmgr.dll contained a home-grown copy of StrSafe’s
StringCchCopyA().  The original prototype is
    HRESULT StringCchCopyA(CHAR *dst, size_t dstChars, PCSTR src);

The buggy implementation ignored the supplied length argument a2 and
instead hard-coded the copy limit to 260 (MAX_PATH).  Pseudocode:
    size  = 260;
    delta = src - dst;           // establishes memcopy offset
    while (size && *(src)) {     // copy at most 260 bytes
        *dst++ = *(src++);
        --size;
    }
    *dst = 0;                    // terminator
    return size==0 ? E_INSUFF : S_OK;

Consequences:
1. If the real destination buffer is smaller than 260 bytes the loop
   overruns the stack or heap, corrupting adjacent memory.
2. Callers that rely on the return code to detect truncation receive
   false negatives because an over-large length parameter never limits
   the copy.

Two in-module callers pass attacker-controlled or otherwise
non-constant sizes:
• GetSubstituteHKLFromReg(char SubKey[272]) originally forwarded its
  second argument a2 (a 16-bit language ID) as the length parameter
  even though the array is 272 bytes long.  The copy size could
  therefore be anything between 0 and 65535.
• GetRegisteredLocation(char *OutPath) forwarded the uninitialised rdx
  register (v3) as the length.  From user-mode the register contents
  depend on the call site and are uncontrolled inside the routine.

Providing a destination buffer <260 bytes (for example by hooking a
public export that calls GetRegisteredLocation with a small stack
array) causes an out-of-bounds write that can smash the return address
and bypass the intended security boundary.

Structures / parameters affected
• StringCchCopyA  – parameter a2 (size) is ignored.
• SubKey[272] / OutPath – potential overflow targets on the stack.
• HRESULT semantics – incorrect success reporting masks the fault.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable implementation (before)
__int64 __fastcall StringCchCopyA(char *dst,__int64 len,const char *src)
{
    __int64 cnt = 260;           // <-- hard-coded
    __int64 delta = src - dst;
    do {
        if (cnt == -2147483386) break;
        char ch = dst[delta];
        if (!ch) break;
        *dst++ = ch;             // overflows if dst <260
        --cnt;
    } while (cnt);
    *(cnt ? dst : dst-1) = 0;
    return cnt==0 ? 0x8007007A : 0;
}
```

```c
// caller (before)
StringCchCopyA(SubKey, a2, "SOFTWARE\\Microsoft\\CTF\\TIP\\");
```

```c
// fixed implementation (after, abridged)
int __fastcall StringCchCopyA(char *dst, size_t len, const char *src)
{
    int hr = StringValidateDestA(dst, len);
    return (hr>=0) ? StringCopyWorkerA(dst,len,src) : hr;
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker causes code path that ultimately calls
   GetRegisteredLocation() or GetSubstituteHKLFromReg().
2. Either routine invokes StringCchCopyA() with a destination buffer
   that may be smaller than 260 bytes but with an arbitrary length
   argument.
3. StringCchCopyA() copies up to 260 bytes regardless of the true
   buffer size.
4. Out-of-bounds write corrupts saved registers/SEH, enabling control
   of execution or bypass of MMC security checks.


Attack Vector
--------------------------------------------------------------------
Local attacker supplying crafted data to any MMC snap-in that ends up
calling the vulnerable helpers, or injecting a DLL that calls these
exports with undersized buffers.  No special privileges are required.


Patch Description
--------------------------------------------------------------------
1. StringCchCopyA was completely replaced with a thin wrapper around
   StrSafe helper functions StringValidateDest*() and
   StringCopyWorkerA_0(), guaranteeing that the user-supplied length
   parameter a2 is honoured.
2. Call sites were updated to pass the correct constant buffer size
   (0x104 = 260) instead of variable or uninitialised values.
3. The signature of GetSubstituteHKLFromReg() was changed so that the
   second parameter is no longer confused with a buffer size.


Security Impact
--------------------------------------------------------------------
Prior to the patch, a local attacker could trigger a stack overflow in
mmcndmgr.dll leading to arbitrary code execution in the context of the
MMC host process (often elevated) or suppress truncation detection to
bypass path-based security checks.  This enables a Security Feature
Bypass as reported in CVE-2025-26633 and potentially elevates
privileges if the host process runs with higher rights.


Fix Effectiveness
--------------------------------------------------------------------
By delegating copying to the well-tested StrSafe helpers and by
hard-coding the correct destination size at every call site, the patch
eliminates the possibility of writing beyond the end of the buffer.
Unit analysis shows no remaining code paths that ignore the size
parameter.  Therefore the fix is considered complete and effective.
