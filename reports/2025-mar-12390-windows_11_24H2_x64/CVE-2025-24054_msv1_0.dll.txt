{'cve': 'CVE-2025-24054', 'date': 1751865232.0190074, 'patch_store_uid': '00c789b3-a02d-4d25-a0dc-32a901551599', 'change_count': 4, 'confidence': 0.31, 'kb': 'KB5053598', 'file': 'msv1_0.dll'}
--------------------------------------------------------------------
CVE-2025-24054 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows authentication runtime (msv1_0.dll) – code that consults the
WIL (Windows-in-box flighting) feature system to decide whether NTLM
behaviour-blocking features such as NtlmReturnsBlocked,
AppSiloDragAndDrop, PerfImpTest, LsaAdtEmptyStr, etc. are considered
enabled.  All affected routines live in the wil::details::
FeatureImpl::<Feature>::GetCurrentFeatureEnabledState /
GetCachedFeatureEnabledState helpers.

Vulnerability Class
--------------------------------------------------------------------
Logic/feature-flag evaluation error leading to incorrect security
state (credential spoofing).  Closest CWE: CWE-1188 (Incorrect Access
of Indexable Resource) or CWE-693 (Protection Mechanism Failure).  The
vendor tags it as spoofing (CWE-73 in advisory metadata).

Detailed Root Cause Analysis
--------------------------------------------------------------------
Each GetCurrentFeatureEnabledState() routine converts the 32-bit value
returned by WilApi_GetFeatureEnabledState() into an internal flag word
that callers trust to determine whether the feature (and therefore the
associated NTLM protection) is active.

Before the patch the final flag word was produced by

    v7  =  (state & 3) << 7               // core enable bits
         | ((state & 0x80)?0x400:0)       // 0x400  : service-gate A
         | ((state & 0x40)?0x800:0);      // 0x800  : service-gate B
    *a2 = v7 | ((v7 >> 6) & 1);           // *** copies bit-6 to bit-0

Bit-6 (0x40) is only a *candidate* enable indication.  Whether the
feature must really be honoured also depends on the service-gates and
on an out-of-band kill-switch (implemented by
Feature_Servicing_CFONTPrintLeak).  The copy operation above promoted
bit-6 directly into bit-0 ("feature enabled") without checking any of
those extra conditions.  As a consequence *a2 bit-0 could be set while
0x400/0x800 were still cleared or the kill-switch was off.  Callers
inside the NTLM code path later looked only at bit-0 and therefore
believed the protection feature was active even though policy in fact
intended it to be off, leading to inconsistent state tracking.

That same broken mirror logic was duplicated, in far more complex form,
in GetCachedFeatureEnabledState(), which tried to synthesise the flag
word by hand and cache it in a shared variable with racy bit-twiddling.

Patch observations:
 1. The mirror line was removed; bit-0 is now set only after all
    servicing gates pass:
        *a2 = v11 | (*a2 & 0xFFFFFFFE);   // keep/clear bit-0 safely
 2. Both 0x400 and 0x800 are explicitly evaluated:
        if ((flags & 0xC00) == 0xC00) { v12 = 1; } …
 3. A kill switch test is performed through
        Feature_Servicing_CFONTPrintLeak::__private_IsEnabled().
    Failure of this check clears 0x400 to force the feature back to
    disabled.
 4. GetCachedFeatureEnabledState() no longer re-implements the logic
    but calls GetCurrentFeatureEnabledState() and only patches the
    cache atomically, removing the faulty bit arithmetic.

Affected structures / parameters
  a2      – pointer to DWORD flag word returned to caller.
  state   – enum FEATURE_ENABLED_STATE from WilApi_...()
  Bit-0   – final "feature enabled" outcome consumed by NTLM code.
  Bit-6   – intermediate "candidate enabled" flag.
  Bits10-11 (0x400/0x800) – servicing/experimentation gates.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// old logic (msv1_0.dll, before patch)
unsigned int v7 = ((state & 3) << 7) |
                  ((state & 0x80) ? 0x400 : 0) |
                  ((state & 0x40) ? 0x800 : 0);
*(_DWORD*)a2 = v7 | ((v7 >> 6) & 1);        // mirrors bit-6 -> bit-0
```
```c
// new logic (after patch)
unsigned int base = ((state & 3) << 7) |
                    ((state & 0x80) ? 0x400 : 0) |
                    ((state & 0x40) ? 0x800 : 0);
… // kill-switch and 0xC00 validation
*(_DWORD*)a2 = gate_ok ? (base | 1) : (base & ~1);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Remote NTLM authentication request -> msv1_0!SpInitLsaModeContext() ->
wil::FeatureImpl<Feature_AppSiloDragAndDrop>::GetCachedFeatureEnabledState()
-> GetCurrentFeatureEnabledState() – returns mis-set bit-0 -> NTLM
stack treats blocking feature as active/valid although policy says
otherwise – allowing hash flow that can be intercepted/spoofed.

Attack Vector
--------------------------------------------------------------------
A network attacker initiates an NTLM authentication exchange with a
Windows system configured to block certain NTLM usages.  Because the
feature state is mis-reported, the system still sends NTLM responses,
allowing the attacker to capture or relay the hash and perform
spoofing.

Patch Description
--------------------------------------------------------------------
• Centralised the decision logic; GetCachedFeatureEnabledState now
  delegates to GetCurrentFeatureEnabledState.
• Added explicit evaluation of servicing gates (0x400 & 0x800) and
  kill-switch feature.
• Removed blind propagation of bit-6 into bit-0; final enable state is
  written only when all conditions are met.
• Simplified atomic cache update to avoid manual bit weaving.

Security Impact
--------------------------------------------------------------------
Prior to the fix Windows could believe that NTLM-blocking features were
active when they were not, causing NTLM credentials to be disclosed to
untrusted parties.  This enables credential spoofing and potential
relay attacks over the network.

Fix Effectiveness
--------------------------------------------------------------------
The patched logic removes the incorrect bit copy, introduces the
missing kill-switch checks, and unifies state computation across both
"current" and "cached" code paths.  All observed paths now rely on the
same gated calculation, eliminating the discrepancy that enabled the
spoofing condition.  No residual uncontrolled write paths remain in
the diff, indicating the patch fully addresses the identified flaw.
