{'confidence': 0.22, 'cve': 'CVE-2025-24051', 'kb': 'KB5053598', 'change_count': 4, 'date': 1751831404.304767, 'file': 'mprapi.dll', 'patch_store_uid': '5620f9a9-c1ab-4359-bde1-3e06a424ccfa'}
--------------------------------------------------------------------
CVE-2025-24051 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Routing and Remote Access Service (RRAS) â€“ user-mode library
mprapi.dll.  Affected helper routines are FilterSetInfo(),
MprInfoBlockAdd(), MprInfoBlockRemove(), and MprInfoBlockSet().  These
APIs manipulate RTR_INFO_BLOCK_HEADER blobs that travel through several
RRAS configuration RPC interfaces.

Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow / memory corruption (CWE-122).

Detailed Root Cause Analysis
--------------------------------------------------------------------
RTR_INFO_BLOCK_HEADER is a self-describing container:
  DWORD Version;      // offset 0
  DWORD Size;         // total length of buffer in bytes
  DWORD EntriesCount; // number of info blocks that follow
  INFO  Entries[...]

All subsequent offsets stored inside the header are considered trusted
by the manipulation helpers.  Prior to the patch the helpers performed
little or no sanity checking:

1. FilterSetInfo() received a buffer (ppGlobalInfo) plus its byte count
   (dwGlobalInfoSize) from MprConfigTransportGetInfo().  The only size
   gate was:
       if (FeatureX && dwGlobalInfoSize < Header->Size)
           return ERROR_INVALID_PARAMETER;
   When the feature flag was disabled (default on most systems) the
   function *skipped* the comparison entirely, allowing a header whose
   Size field exceeded the real allocation.

2. MprInfoBlockAdd/Set/Remove() accepted lpHeader, trusted Header->Size,
   and used it in arithmetic that ultimately feeds HeapAlloc() and
   memcpy() calls.  Because Header->Size could be larger than the buffer
   actually returned by the RRAS RPC server, the helpers would copy
   past the end of the caller-supplied heap block, corrupting the heap
   belonging to the RRAS service (running as LocalSystem).

3. Although a validation helper, ValidateRTRInfoBlockHeader(), existed
   it was only executed when the same optional feature flag was turned
   on.  Therefore in production builds header validation was effectively
   disabled.

With a malicious RTR_INFO_BLOCK_HEADER whose Size is larger than the
real buffer, an attacker controls the amount and content of data that
memcpy_0() writes beyond the heap allocation, yielding arbitrary heap
overwrite and ultimately remote code execution in the RRAS service
context.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// FilterSetInfo (before)
if (Feature_IsEnabled() && dwGlobalInfoSize < Header->Size)
    Handle = ERROR_INVALID_PARAMETER; // else continue with bad header

// MprInfoBlockAdd (before)
if (Feature_IsEnabled()) {
    if (!ValidateRTRInfoBlockHeader(lpHeader))
        return ERROR_INVALID_PARAMETER;
}

// MprInfoBlockAdd (after)
if (!ValidateRTRInfoBlockHeader(lpHeader))
    return ERROR_INVALID_PARAMETER;
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Remote attacker -> RRAS RPC interface -> FilterSetInfo() ->
MprConfigTransportGetInfo() -> returns attacker-controlled buffer ->
FilterSetInfo() (size check bypass) -> MprInfoBlockAdd/Set/Remove() ->
calculation using Header->Size -> HeapAlloc() / memcpy_0() overflow.

Attack Vector
--------------------------------------------------------------------
An unauthenticated network client that can reach the RRAS configuration
RPC endpoint supplies a crafted RTR_INFO_BLOCK_HEADER with an inflated
Size field (and matching internal offsets) in any request that ends up
executing FilterSetInfo().  No credentials are required because the
overflow occurs before access-control checks on the header contents.

Patch Description
--------------------------------------------------------------------
1. FilterSetInfo(): the size comparison logic is inverted and no longer
   gated by the feature flag.  The function now rejects when
      dwGlobalInfoSize < Header->Size.

2. MprInfoBlockAdd(), MprInfoBlockRemove(), MprInfoBlockSet():
   a) ValidateRTRInfoBlockHeader() is invoked unconditionally.
   b) Several pointer/size calculations were tidied; multiplication
      order was harmonised to avoid possible integer-truncation bugs.

3. Feature_4016915769__private_IsEnabledDeviceUsageNoInline() is removed
   from all sanity-check decisions.

Security Impact
--------------------------------------------------------------------
Before the patch a remote attacker could trigger a controlled heap
overflow inside the RRAS service running as NT AUTHORITY\SYSTEM.
Successful exploitation allows execution of arbitrary code with SYSTEM
privileges or a denial of service via process crash.

Fix Effectiveness
--------------------------------------------------------------------
The unconditional call to ValidateRTRInfoBlockHeader() and the explicit
buffer-length check in FilterSetInfo() close the primary trust boundary
violation.  All subsequent arithmetic is now performed only after the
header is proven internally consistent and not larger than the caller
supplied buffer, eliminating the observed overflow condition.  No
residual attack surface is apparent in the modified code paths.
