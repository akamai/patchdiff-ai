{'kb': 'KB5053598', 'confidence': 0.25, 'change_count': 8, 'file': 'ks.sys', 'cve': 'CVE-2025-24046', 'patch_store_uid': '885e1d78-ef78-499a-8de2-95ab2f6828b6', 'date': 1751831436.95033}
--------------------------------------------------------------------
CVE-2025-24046 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows ks.sys (Kernel Streaming service driver) – frame  
header/MDL handling within CKsQueue, CKsMdlcache and related helper  
routines.

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use-After-Free (stale internal pointer left in recycled  
KSPFRAME_HEADER structure).

Detailed Root Cause Analysis
--------------------------------------------------------------------
A KSPFRAME_HEADER object encapsulates buffer-mapping state for a  
streaming IRP.  Field  +0xA0 (expressed in the decompiler as  
LIST_ENTRY index 10 – `FrameHeader->Entry[10].Blink`) stores an  
auxiliary pointer used later by CKsQueue for access to GPU/VRAM or  
secondary MDL information.

1.  When a frame completes, CKsQueue::PutAvailableFrameHeader() is  
    called to recycle the header back into the per-queue lookaside  
    list  `m_FrameHeadersAvailable`.
2.  In the pre-patch version the code only cleared the extra pointer
    if the optional run-time feature flag
      `Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage_10()`
    was enabled:
        if (FeatureFlag) {
            if (hdr->ExtraPtr) { free; hdr->ExtraPtr = 0; }
        }
    When the flag was *not* enabled, the pointer was left intact even
    though the underlying allocation had just been freed or had gone
    out of scope (see earlier calls to DeleteMappingsTable /
    ExFreePoolWithTag).
3.  The recycled header therefore re-entered the available list with a
    dangling pointer.
4.  A subsequent IRP processed by CKsQueue::TransferKsIrp() removes a
    header from the same list and, in several code paths, blindly
    dereferences that field (e.g. when duplicating MDL state or when
    mapping VRAM via MapVramPhysicalAddress).  Because the storage had
    already been freed, the dereference becomes a classic UAF that  
    corrupts pool memory and allows an attacker with the ability to  
    queue crafted streaming IRPs to elevate privileges.

Additional evidence reinforcing the root cause:
*  TransferKsIrp originally wrote to the same field only under the
   same feature flag, but the patched version always initialises it to
   zero (`*((_QWORD *)PoolWithTag + 21) = 0i64;`).
*  KsProbeStreamIrp / MdlCache* functions now contain multiple new
   sanity checks that raise STATUS_INVALID_PARAMETER or
   STATUS_UNSUCCESSFUL when header or MDL members are inconsistent –
   protecting the later dereference paths.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before – CKsQueue::PutAvailableFrameHeader
if (FeatureFlag()) {
    LIST_ENTRY *p = hdr->ExtraPtr;   // v4[10].Blink
    if (p) { p->Blink = 0; hdr->ExtraPtr = 0; }
}
...
ExInterlockedInsertTailList(&Available, hdr, ...);
```

```c
// after – same function (feature guard removed)
LIST_ENTRY *p = hdr->ExtraPtr;       // captured early
...
if (p) {
    p->Flink = 0;
    hdr->ExtraPtr = 0;               // always cleared now
}
```

```c
// CKsQueue::TransferKsIrp before
if (FeatureFlag())
    hdr->ExtraPtr = v20 + 32;        // may leave stale value otherwise
```

```c
// CKsQueue::TransferKsIrp after
hdr->ExtraPtr = 0;                   // header always sanitised
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User mode opens a KS pin and submits a large sequence of streaming
   IRPs containing crafted buffers.
2. Each IRP is accepted by CKsQueue::TransferKsIrp, which allocates a
   KSPFRAME_HEADER and sets `ExtraPtr`.
3. The IRP completes; PutAvailableFrameHeader frees associated mapping
   tables and (in the vulnerable build) *does not* null `ExtraPtr`.
4. The header returns to the free list.
5. A second IRP is processed; CKsQueue::TransferKsIrp dequeues the same
   header and interprets `ExtraPtr` as valid, dereferencing freed pool
   memory – leading to arbitrary kernel memory corruption.

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker sends crafted IOCTL/IRP traffic through
any Kernel Streaming interface (for example ks.sys filter exposed by a
camera or audio device).  No special privileges beyond device access
are required.

Patch Description
--------------------------------------------------------------------
• Removed all feature-flag conditions that previously guarded pointer
  initialisation / clearing.  The pointer in slot +21 of the frame
  header (ExtraPtr) is now *always* set to 0 on allocation and *always*
  cleared on recycle.
• Additional STATUS checks and `RtlLogUnexpectedCodepath()` calls were
  inserted in KsProbeStreamIrp, CKsMdlcache functions, etc., to abort
  processing when header or MDL fields are missing or malformed.
• Several mutex/probe paths were un-conditionally enabled (DXG mutex,
  lookaside initialisation) to make cleanup symmetrical.

Security Impact
--------------------------------------------------------------------
Prior to the fix, a dangling pointer within a recycled
KSPFRAME_HEADER allowed a local user to achieve kernel-mode arbitrary
write via pool-memory reuse, ultimately leading to elevation of
privilege (ring-0 code execution).

Fix Effectiveness
--------------------------------------------------------------------
The patch eliminates the stale reference by clearing the field in all
configurations and adds multiple guard rails that abort processing if
similar inconsistencies are detected.  No remaining code path leaves
ExtraPtr non-NULL after header release; therefore the original UAF is
no longer reachable.  The additional validations further reduce the
attack surface, making the fix robust.
