{'confidence': 0.23, 'file': 'clfs.sys', 'change_count': 2, 'kb': 'KB5053598', 'cve': 'CVE-2025-24059', 'patch_store_uid': 'eac50653-b423-456c-aaff-ceb853a1fd0d', 'date': 1751831414.796584}
--------------------------------------------------------------------
CVE-2025-24059 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Common Log File System (CLFS) kernel driver, clfs.sys.  The
affected routines are CClfsLogFcbPhysical::WriteRestart() and
CClfsLogFcbPhysical::PurgeCacheSection().

Vulnerability Class
--------------------------------------------------------------------
Integer-overflow/incorrect numeric conversion leading to out-of-bounds
cache purge and potential kernel memory corruption (CWE-681, CWE-125).

Detailed Root Cause Analysis
--------------------------------------------------------------------
CLFS identifies log positions with a 64-bit CLS_LSN structure:
  bits 63..32 – cidContainer   (logical container number)
  bits 31..9  – idxRecord      (record number within container)
  bits 8..0   – BlockOffset    (byte offset within physical sector)

Two weaknesses existed:
1.  WriteRestart() accepted an attacker-controlled restart-LSN (plsn)
    without verifying that BlockOffset was inside the physical sector
    size held in this->cbPhysicalSector ( *(this+0x2B8) ).  A value >=
    sector size let idxRecord/BlockOffset pair map outside the current
    container when later translated to a byte offset.
2.  PurgeCacheSection() converted two user supplied LSNs to byte
    offsets using 32-bit arithmetic:
       v17 = ((idx & 0xFFFFFE00) + sector*cid) - base;
    The result was stored in signed 64-bit and aligned to 4 KiB.  A
    crafted cidContainer or idxRecord caused the subtraction to wrap
    and produce a negative (very large) value.  The value was then
    handed to CcPurgeCacheSection(), forcing the cache manager to purge
    pages far outside the valid file mapping – effectively an
    arbitrary in-kernel memory invalidation primitive.

    Because the same unchecked LSN first reaches WriteRestart() from
    user FSCTLs (e.g. CLFS_IOCTL_WRITE_RESTART_AREA) and is cached in
    memory, the attacker can force CLFS to operate on addresses beyond
    the intended section object, leading to EoP via memory corruption.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
v17 = ((unsigned int)ullOffset & 0xFFFFFE00) +
      *((_QWORD *)this + 87) * HIDWORD(v21) -
      ((*v15 & 0xFFFFFE00) + *((_QWORD *)this + 87) * v16);
FileOffset = v17 & 0xFFFFFFFFFFFFF000ULL;   // may wrap

// after – start/end LSNs are realigned, overflow paths rejected
if ((plsn->idxRecord & 0x1FF) != 0 ||
    ClfsLsnBlockOffset(plsn) >= this->cbPhysicalSector)
    return STATUS_INVALID_PARAMETER;
...
FileOffset.QuadPart = CClfsLogFcbPhysical::LsnToCacheOffset(...)
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
user-mode               -> NtFsControlFile( CLFS_IOCTL_WRITE_RESTART )
  -> clfs.sys           -> CClfsBaseFile::WriteRestart()
    -> CClfsLogFcbPhysical::WriteRestart()
      * accepts attacker LSN, no BlockOffset check (old)
      -> CClfsLogFcbPhysical::PurgeCacheSection()
         * converts LSN to byte offset with 32-bit math
         * calls CcPurgeCacheSection() with wrapped offset
         * cache manager purges arbitrary kernel pages

Attack Vector
--------------------------------------------------------------------
Any local user able to open a CLFS log file (CreateFile on a log or
TXF transaction file) can send the restart-area FSCTL with a crafted
CLS_LSN whose BlockOffset >= sector-size and/or oversized
cidContainer.  No administrator privileges are required.  Successful
exploitation yields arbitrary kernel memory invalidation and therefore
local privilege escalation to SYSTEM.

Patch Description
--------------------------------------------------------------------
1. WriteRestart():
   – Added explicit validation:
       if (BlockOffset >= this->cbPhysicalSector)
           return STATUS_INVALID_PARAMETER;
   – Realigned earlier arithmetic to 64-bit safe helpers.

2. PurgeCacheSection():
   – Introduced manual clearing of BlockOffset bits (idx&0x1FF) before
     arithmetic.
   – Rewrote offset computation using 64-bit helpers
     LsnToCacheOffset() and defensive alignment.
   – Added extra bounds checks against first-record pointer held in the
     FCB ( *(this+1368) ).
   – Early exit paths return success without touching cache when the
     requested range is invalid.

Security Impact
--------------------------------------------------------------------
Before the patch a crafted CLS_LSN could push CLFS into computing a
negative or over-large CACHE_OFFSET that is forwarded to the cache
manager, corrupting kernel memory and granting the attacker arbitrary
code execution with kernel privileges (Elevation of Privilege).

Fix Effectiveness
--------------------------------------------------------------------
The added BlockOffset-vs-SectorSize check completely blocks the
original path.  New 64-bit calculations remove wrapping behaviour and
all purge offsets are clamped to valid ranges.  No alternate path to
CcPurgeCacheSection() was found in the diff, suggesting the fix is
comprehensive, though other CLFS routines that accept raw CLS_LSNs
should be audited for identical assumptions.
