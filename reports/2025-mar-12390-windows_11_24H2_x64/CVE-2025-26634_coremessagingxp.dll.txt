{'confidence': 0.15, 'file': 'coremessagingxp.dll', 'cve': 'CVE-2025-26634', 'kb': 'KB5051987', 'patch_store_uid': 'e19b9e54-3f95-43e5-bee8-cd5d47012c93', 'change_count': 1, 'date': 1751831546.933251}
--------------------------------------------------------------------
CVE-2025-26634 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Core Messaging (coremessagingxp.dll)  
Function: Microsoft::CoreUI::Dispatch::UserAdapter::
           ReschedulePendingSendDispatchIfNecessary()


Vulnerability Class
--------------------------------------------------------------------
CWE-122: Heap-based Buffer Overflow caused by logic error in state
machine / flag handling


Detailed Root Cause Analysis
--------------------------------------------------------------------
The UserAdapter object owns an internal flag word located at offset
+0x18 (tested through *(v2+24)).  Bit 0x20 denotes that a "send
message" dispatch has already been scheduled.  The helper
ReschedulePendingSendDispatchIfNecessary() is supposed to clear that
bit and enqueue a new dispatch **only** when the global mitigation flag
`s_IsMissingSendMessageWorkaroundEnabled` is set.  

Before the fix the code executed in the following order:
1. Test if the queue is in an inconsistent state
   (bit 0x20 set *and* queue status does **not** report a pending
   send message).
2. Emit a diagnostic via TrackErrorWorker().
3. If the workaround flag is *disabled* it called FailFast() –
   theoretically terminating the process – otherwise execution
   continued.
4. Regardless of the result of the FailFast() call the compiler had
   already generated instructions that
      a) cleared bit 0x20
      b) called ScheduleDispatch(this,12,…)
      c) incremented telemetry

Because FailFast() is a normal __declspec(noreturn) routine that can be
bypassed (e.g. by installing a VEH handler or by fuzzing inside a
sandbox where the exception handler chain is under attacker control),
steps 4a–4c could still be reached with the workaround flag **false**.

Executing ScheduleDispatch() twice on the same adapter corrupts an
internal heap-allocated message block list.  The second call reuses a
pointer that is still linked in the active queue, resulting in a
classic heap-based buffer overflow during the next dequeue cycle.  The
overflow occurs inside the Core Messaging heap (user-mode) which is
shared between processes hosting UI stacks, so arbitrary memory can be
overwritten with attacker-controlled message data.

Affected data structures
  • UserAdapter flag word  (offset +0x18)
  • CM_THREAD_MESSAGE      (heap block passed to ScheduleDispatch)
  • Global boolean         s_IsMissingSendMessageWorkaroundEnabled


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// BEFORE
if (!UserAdapter::s_IsMissingSendMessageWorkaroundEnabled)
    Cn::FailFast::ForWin32();         // supposed to abort
_InterlockedAnd((int*)(v2+24),0xFFFFFFDF);  // clear 0x20
UserAdapter::ScheduleDispatch(this,12, *((QWORD*)this+4));
UserAdapter::IncrementSendMessageWorkaroundTelemetry(v5);

// AFTER
if (UserAdapter::s_IsMissingSendMessageWorkaroundEnabled)
{
    _InterlockedAnd((int*)(v2+24),0xFFFFFFDF);
    UserAdapter::ScheduleDispatch(this,12, *((QWORD*)this+4));
    UserAdapter::IncrementSendMessageWorkaroundTelemetry(v5);
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
Attacker manipulates window messages so that:
 1. Bit 0x20 is set on an adapter (Send scheduled)
 2. The real message is removed, clearing QUEUESTATUS_SENDMESSAGE
 3. Victim thread calls ReschedulePendingSendDispatchIfNecessary()
 4. FailFast() is intercepted / bypassed -> execution continues
 5. ScheduleDispatch() runs twice for the same heap block
 6. Subsequent dequeue overruns heap buffer, gaining code execution


Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker (or low-privileged sandboxed code)
crafts a sequence of Win32 SendMessage / PostMessage calls that
force the adapter into the inconsistent state, then exploits an
instrumented VEH/SEH to survive the FailFast() path and trigger the
overflow in a higher-integrity UI or service process.


Patch Description
--------------------------------------------------------------------
The fix simply moves the flag-clearing and dispatch-rescheduling code
inside the `if (s_IsMissingSendMessageWorkaroundEnabled)` block and
removes the FailFast() call entirely.  As a result:
  • When the workaround is *disabled* nothing further happens – no
    state is modified, so the corrupt double-schedule path disappears.
  • When the workaround is *enabled* the original behaviour is kept but
    is now explicitly gated, eliminating the inconsistent branch.


Security Impact
--------------------------------------------------------------------
Prior to the patch a local attacker could achieve an arbitrary heap
overwrite inside a higher-privileged Core Messaging host, leading to
Elevation of Privilege (EoP).  Remote exploitation is theoretically
possible via UI-accessible surfaces exposed over the network (e.g.
RemoteApp), matching the vendor classification.


Fix Effectiveness
--------------------------------------------------------------------
The conditional block ensures the vulnerable code is unreachable unless
the global workaround flag is set.  Assuming the flag is disabled in
shipping builds, the overflow is fully mitigated.  No additional bounds
checks were necessary.  Residual risk is limited to configurations
where administrators deliberately enable the workaround registry switch
– "unknown" outside Microsoft.
