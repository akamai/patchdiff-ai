{'cve': 'CVE-2025-21247', 'date': 1751831457.0947282, 'confidence': 0.13, 'kb': 'KB5053598', 'patch_store_uid': '83b7efe5-5e7b-4cba-a708-89e8ea257391', 'file': 'urlmon.dll', 'change_count': 10}
--------------------------------------------------------------------
CVE-2025-21247 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
urlmon.dll  (URL Moniker / MapUrlToZone helper)
Affected routine: GetServerShareFromIUriPriv()

Vulnerability Class
--------------------------------------------------------------------
Logic error / security-feature bypass
CWE-41: Improper Resolution of Path Equivalence

Detailed Root Cause Analysis
--------------------------------------------------------------------
GetServerShareFromIUriPriv translates an IUri into a canonical \server\
share string that later drives zone classification in MapUrlToZone.

Step-by-step before the patch:
1. All leading slashes are skipped:
      for(i = str ; *i == '\\' || *i == '/' ; ++i) ;
2. The code then calls IsDrive(i).  IsDrive only checks for the
   pattern  "<alpha>:"  (e.g.  "C:"), returning TRUE whenever the
   first character is an ASCII letter followed by a colon.
3. If IsDrive() is TRUE the path is treated as a *local drive*:
      *v57 = 1;          // mark as local drive
      *pszDest = DriveTypeA(...);
   Subsequent logic therefore believes the resource is on the local
   machine or LAN.

Problem:  UNC paths that encode an IPv6 literal server name also start
with a single hex digit and a colon, for example:
    "\\fe80::1\share"  ->  after the slashes  i == "fe80::1..."
Because the first two characters are  'f' ':'  IsDrive() returns TRUE.
The remote IPv6 UNC is mis-classified as a local drive, so the caller
(CSecurityManager / MapUrlToZone) places the resource in Local Machine
or Intranet zone instead of Internet.  All zone-based defenses
(scripting, ActiveX, download prompts, etc.) are therefore bypassed.

The patch replaces the call with IsDriveAndNotIPv6(), a stricter helper
that refuses the match when a second consecutive colon ("::") follows
— the distinguishing feature of IPv6 literals.  No other functional
changes are made; the faulty branch is simply skipped for IPv6 names.

Data/variables involved:
  i           – pointer to first non-slash char of path component
  *v57        – flag telling later code "this is a drive letter path"
  pszDest     – receives the drive type (local, network, etc.)

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
for(i = pbstr[1]; *i == '\\' || *i == '/'; ++i);
if ((unsigned int)IsDrive(i))            // TRUE for "fe80::1" !!
{
    *v57 = 1;                            // mark as local drive
    ...
}

// after
for(i = pbstr[1]; *i == '\\' || *i == '/'; ++i);
if (IsDriveAndNotIPv6(i))               // extra IPv6 exclusion
{
    *v57 = 1;
    ...
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
CSecurityManager::GetSecurityId(..)
  -> GetServerShareFromIUriPriv(..)
       1. Caller supplies a URL such as
          "file:////fe80::1/share/doc.htm"   or
          "\\fe80::1\share\doc.htm"
       2. Function mis-identifies the IPv6 host as a drive letter.
       3. *v57 set => later zone calculation treats it as local/LAN.
  -> MapUrlToZone returns Local Machine / Intranet zone.

Attack Vector
--------------------------------------------------------------------
Any API or component that relies on MapUrlToZone (e.g., Internet
Explorer, WebBrowser control, Office, Outlook) can be coerced into
loading remote content with local-zone privileges by supplying a UNC
path whose server portion starts with  "<hex_digit>:"  followed by the
rest of the IPv6 address.
An attacker could embed such a link in HTML, a document, or script that
runs in a lower-privilege zone; the security checks are silently
bypassed over the network.

Patch Description
--------------------------------------------------------------------
Single-line logic fix:
  if (IsDrive(...))            =>   if (IsDriveAndNotIPv6(...))
IsDriveAndNotIPv6() performs the original drive-letter test *and*
verifies the character after the colon is *not* another colon, thereby
excluding IPv6 literals.  No other state or structure is altered.

Security Impact
--------------------------------------------------------------------
Prior to the fix, remote UNC paths containing IPv6 literals could be
mistaken for local drive paths, allowing remote content to inherit the
less restrictive Local Machine / Intranet zone.  This negates sandbox
and scripting restrictions and constitutes a Security Feature Bypass.
Remote, unauthenticated attackers could abuse the flaw to run active
content or bypass download warnings.

Fix Effectiveness
--------------------------------------------------------------------
The additional check correctly differentiates drive letters from IPv6
literals, closing the demonstrated bypass.  Effectiveness is high for
IPv6-based vectors; other malformed inputs with a single colon may need
independent review (unknown).  No residual vulnerable path is evident
in the patched code.
