{'file': 'lsasrv.dll', 'confidence': 0.21, 'kb': 'KB5053598', 'patch_store_uid': '312449ae-99b8-496d-a3af-1fc02b542384', 'date': 1751831437.9137857, 'cve': 'CVE-2025-24072', 'change_count': 54}
--------------------------------------------------------------------
CVE-2025-24072 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Local Security Authority Sub-system Service (lsasrv.dll),
function GetClientString(), invoked by the LPC password-change path
(LpcChangeAccountPassword).

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use-After-Free (invalid free of attacker-controlled pointer)

Detailed Root Cause Analysis
--------------------------------------------------------------------
GetClientString() is responsible for copying a UNICODE_STRING that the
client embeds in an LPC message into an LSASS-owned buffer.  The
initial implementation performs a structure assignment

    *a2 = *a1;

a2 (server-side) therefore inherits *all* fields coming from the
untrusted client, including the Buffer pointer.  Immediately
afterwards the function performs parameter validation:

    if (a2->Length > 0xFFFC)
        return STATUS_INVALID_PARAMETER;

If this length check fails GetClientString() returns early.  The
callers (e.g. LpcChangeAccountPassword) run generic clean-up code that
unconditionally frees a2->Buffer through LsapSubProv_FreeRoutine().
Because a2->Buffer still contains the user supplied address, LSASS
attempts to free memory it never allocated.  Depending on the supplied
pointer this leads to:

  * freeing an arbitrary kernel heap block twice (UAF), or
  * freeing an address that is under attacker control, enabling
    arbitrary pointer overwrites in the heap allocator.

Any subsequent heap allocation in LSASS occurs in a memory region now
controlled or previously freed by the attacker, enabling elevation of
privilege in the highly-privileged LSASS process.

Important data structures and parameters:
  UNICODE_STRING  {USHORT Length; USHORT MaximumLength; PWSTR Buffer}
  a1              – client-supplied structure inside LPC message
  a2              – server-side copy that the caller later frees
  Buffer pointer  – fully attacker-controlled prior to patch

The fault is triggered only when the length check fails (or any later
error that exits before the server overwrites Buffer with a freshly
allocated pointer), so reliability is very high.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable fragment (before patch)
*a2 = *a1;                     // copies attacker buffer ptr
...
if (a2->Length > 0xFFFCu)      // validation fails
    return STATUS_INVALID_PARAMETER; // caller will free a2->Buffer
```
```c
// fixed fragment (after patch)
if (FeatureEnabled)            // always true after patch rollout
    a2->Length = a1->Length;   // copy only scalar field
else
    *a2 = *a1;                 // legacy path (disabled)
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker sends LPC request to LSASS via LpcChangeAccountPassword.
2. Embedded UNICODE_STRING contains
     Length = 0xFFFE (or any value > 0xFFFC),
     Buffer = pointer chosen by attacker.
3. LpcChangeAccountPassword calls GetClientString().
4. GetClientString() structure-copies Buffer, fails length check,
   returns STATUS_INVALID_PARAMETER.
5. Caller executes error-handling path and frees a2->Buffer.
6. LSASS frees attacker pointer, corrupting the heap -> code exec.

Attack Vector
--------------------------------------------------------------------
Requires a local authenticated session that can call password-related
LSA APIs (e.g. through LSA RPC).  No special privileges are needed
beyond the ability to invoke LpcChangeAccountPassword.

Patch Description
--------------------------------------------------------------------
The patch stops copying the client-supplied Buffer pointer into the
server structure.  When the corresponding feature flag is enabled the
code now copies only the Length field, leaving Buffer NULL until the
server allocates its own memory.  All subsequent frees therefore act
only on trusted allocations.

Security Impact
--------------------------------------------------------------------
Successful exploitation yields arbitrary heap free write within LSASS
leading to elevation of privilege to SYSTEM.  Because LSASS runs with
high integrity and extensive privileges, full local compromise is
achieved.

Fix Effectiveness
--------------------------------------------------------------------
The new code path ensures that a2->Buffer is never attacker-derived
when an error path executes.  Provided the feature flag remains
permanently enabled, the UAF is eliminated.  The legacy path (*a2 =
*a1) still exists behind the flag; if that flag is ever disabled the
original vulnerability would resurface.
