{'change_count': 27, 'confidence': 0.19, 'file': 'usbvideo.sys', 'cve': 'CVE-2025-24055', 'patch_store_uid': '13c1e87d-a065-4d51-b526-a46f95d9c939', 'kb': 'KB5053598', 'date': 1751831452.051123}
--------------------------------------------------------------------
CVE-2025-24055 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows usbvideo.sys – USB Video Class (UVC) kernel-mode
functionality used while enumerating / operating USB cameras.


Vulnerability Class
--------------------------------------------------------------------
Out-of-bounds read (CWE-125) leading to kernel information disclosure.


Detailed Root Cause Analysis
--------------------------------------------------------------------
During device enumeration usbvideo.sys iterates over variable-length
USB descriptors contained in the device-supplied Configuration
Descriptor.  Multiple helper routines (e.g. CountTopologyComponents,
GetColorDescriptor, GetVideoSpecificDescriptor, GetEndpointDescriptor,
GetTerminalUnitForInterface, GetStatusInterruptEndpointIndex, etc.)
walk the descriptor list with logic similar to

    desc = USBD_ParseDescriptors(buf, total, cur, type);
    cur  = (UCHAR *)desc + desc->bLength;   // advance blindly

No check verified that the advertised bLength value is non-zero and
still inside the confines of DescriptorBuffer->wTotalLength.  A
malicious UVC device can therefore report a small or zero bLength which
causes the pointer to advance past the end of the buffer.  Subsequent
reads interpret unrelated kernel memory as further USB descriptors,
leaking stack or pool contents back to user space (e.g. through the
Video Probe & Commit negotiation or topology reporting IOCTLs).  The
problem is pure read-out-of-bounds; writes are never performed.

The patch introduces a new helper USBParseDescriptorWrapper() that
receives the buffer base and its total length and refuses to return a
pointer if
  • desc->bLength == 0,
  • desc lies beyond the supplied length, or
  • desc->bLength would cross the buffer end.

All former direct calls to USBD_ParseDescriptors / manual pointer math
are replaced with this wrapper or augmented with explicit
length-vs-offset comparisons.  Additional sanity checks were added (e.g.
verifying that InterfaceSpecific[11] < InterfaceSpecific->bLength+12).
When an invalid descriptor is detected execution aborts with
STATUS_INVALID_PARAMETER (0xC000000D) or STATUS_NOT_FOUND
(0xC0000225).

Affected structures / parameters
  • USB_CONFIGURATION_DESCRIPTOR  (wTotalLength)
  • USB_INTERFACE_DESCRIPTOR      (bLength / bInterfaceSubClass)
  • Class-specific CS_INTERFACE / CS_ENDPOINT descriptors (bLength)
  • Parsing functions that previously trusted these fields.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// CountTopologyComponents – BEFORE
for (i = USBD_ParseDescriptors(v12, len, v12, 36); ;
     i = (UCHAR*)((ULONG_PTR)i + i->bLength))   // <- unchecked advance
{
    if (!i) break;                              // may already be OOB
    ...
}

// AFTER
for (i = (UCHAR*)USBParseDescriptorWrapper(cfg, len, v12, 36, 4);
     i; i = (UCHAR*)USBParseDescriptorWrapper(cfg,len,i+i->bLength,36,4))
{
    ...                                         // pointer only returned
}                                               // if still in bounds
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker plugs a crafted USB/UVC device.
2. PnP manager loads usbvideo.sys and issues
   IRP_MN_START_DEVICE -> SelectDeviceConfiguration().
3. Driver parses configuration via CountTopologyComponents(),
   GetColorDescriptor(), GetEndpointDescriptor(), etc.
4. Malformed descriptor with short/zero bLength causes pointer past end
   of DescriptorBuffer.
5. Subsequent reads disclose neighbouring kernel memory to user space –
   e.g. through topology IOCTLs or Ks property queries.


Attack Vector
--------------------------------------------------------------------
Local physical.  An attacker needs to connect a specially crafted USB
camera or adapter that advertises invalid (short) video descriptors.
No elevated privileges are required once the device is inserted.


Patch Description
--------------------------------------------------------------------
• Introduced USBParseDescriptorWrapper() performing strict length-range
  verification before returning a descriptor pointer.
• Replaced direct pointer arithmetic and USBD_ParseDescriptors calls
  with the safe wrapper.
• Added explicit size checks such as
    if (desc->bLength < expectedMin) return STATUS_INVALID_PARAMETER;
• Added Feature_* gating so the new code path can be enabled broadly
  (registry/feature switch).
• Added early returns with STATUS_INVALID_PARAMETER for malformed
  descriptors instead of continuing parsing.


Security Impact
--------------------------------------------------------------------
Prior to the patch a malicious USB device could force the kernel driver
to read beyond allocated memory, allowing disclosure of kernel-resident
information to user-mode processes or the attacker (information
leakage).  Although no write occurs, leaked pointers or pool contents
can be used to bypass KASLR or as a primitive for further exploitation.


Fix Effectiveness
--------------------------------------------------------------------
The new wrapper enforces both starting offset and descriptor length to
stay inside the advertised Configuration Descriptor size, preventing the
out-of-bounds read demonstrated by the PoC.  All known code paths that
previously advanced blindly were updated.  No residual unchecked pointer
arithmetic was observed in the supplied diff, indicating the fix is
comprehensive; nevertheless, other unmodified parsing helpers should be
reviewed to rule out similar issues.

