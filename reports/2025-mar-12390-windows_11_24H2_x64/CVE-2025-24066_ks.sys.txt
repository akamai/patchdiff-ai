{'file': 'ks.sys', 'cve': 'CVE-2025-24066', 'confidence': 0.26, 'kb': 'KB5053598', 'patch_store_uid': '885e1d78-ef78-499a-8de2-95ab2f6828b6', 'date': 1751831352.1044295, 'change_count': 8}
--------------------------------------------------------------------
CVE-2025-24066 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Kernel Streaming driver (ks.sys).  The vulnerable logic
resides in the streaming-IRP probing path and the MDL-cache helper
routines that manipulate caller–supplied KSSTREAM_HEADER arrays:
  • KsProbeStreamIrp()
  • CKsMdlcache::MdlCacheHandleThunkBufferIrp()
  • CKsQueue::TransferKsIrp()
  • CKsQueue::PutAvailableFrameHeader()

Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow / insufficient input validation (CWE-122).

Detailed Root Cause Analysis
--------------------------------------------------------------------
A user-mode client submits a Read / Write (stream) IRP that contains
one or more KSSTREAM_HEADER structures.  Each header carries:
  Size           @ +0x00   (dword)
  DataUsed       @ +0x20   (dword)   [array index 9]
  Data           @ +0x28   (qword)   [index 10]
  OptionsFlags   @ +0x30   (dword)   [index 12]
  MetaDataPtr    @ +0x88   (qword)   [index 17]
  MetaDataSize   @ +0x80   (dword)   [index 32]

Before the patch KsProbeStreamIrp() and
MdlCacheHandleThunkBufferIrp() performed only superficial checks.
If OptionsFlags contained KSSTREAM_HEADER_OPTIONSF_VARIABLESIZE
(0x1000) the code still accepted headers whose
   • MetaDataPtr == NULL, **or**
   • MetaDataSize == 0

Yet the same functions later attempted to call IoAllocateMdl() for
MetaDataPtr/MetaDataSize and to memmove() the meta data into a fixed
0x80-byte buffer inside a 0xB0-byte frame header object.  When a
malicious caller supplied VariableSize headers with a large Size
field (>0x80) but zero MetaData, the driver:
 1. Allocated an MDL of length 0 or 0x1000.
 2. Copied the attacker-controlled header (Size bytes) into the small
    0x80-byte area (CKsQueue::TransferKsIrp), overflowing heap memory.
 3. The overwrite occurs in the non-paged pool under the
    ‘PcFhKd’ / ‘KsMcS’ tags, granting arbitrary kernel write.

The original code path (excerpt):
```c
/* before */
if ((UserBuf[12] & 0x1000) && v8 > 0x80 &&
    !IoAllocateMdl(UserBuf[17], UserBuf[32], 1, 1, Irp)) {
    status = STATUS_INSUFFICIENT_RESOURCES;
}
```
No NULL / zero-length checks were present.

Patch adds explicit validation and early bail-out:
```c
/* after */
if ((hdr->Options & 0x1000) && hdr->Size > 0x80) {
    if (!hdr->MetaDataPtr) FAIL;
    if (!hdr->MetaDataSize) FAIL;
    IoAllocateMdl(...);
}
```
Equally, KsProbeStreamIrp() now rejects headers <0xA0 when the
VARIABLESIZE flag is set and refuses NULL/zero meta data pointers.
Pointers inside released frame headers are also cleared to prevent
use-after-free.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// 1. Missing validation (before)
if ((UserBuffer[12] & 0x1000) != 0 && v8 > 0x80 &&
    !IoAllocateMdl(*((PVOID*)UserBuffer+17), UserBuffer[32], ...))
    status = STATUS_INSUFFICIENT_RESOURCES;

// 2. Fixed (after)
if ((hdr->Options & 0x1000) && hdr->Size > 0x80) {
    if (!hdr->MetaDataPtr || !hdr->MetaDataSize) {
        RtlLogUnexpectedCodepath(...);
        return STATUS_INVALID_PARAMETER;
    }
    IoAllocateMdl(hdr->MetaDataPtr, hdr->MetaDataSize, ...);
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User process opens a KS pin (e.g. camera) and sends a READ/WRITE
   stream IRP with crafted KSSTREAM_HEADER chain.
2. KsProbeStreamIrp() copies the headers into kernel pool without
   validating VariableSize meta data fields.
3. CKsMdlcache::MdlCacheHandleThunkBufferIrp() allocates zero-length
   MDL, leaving the subsequent copy unchecked.
4. CKsQueue::TransferKsIrp() builds a 0xB0-byte frame header and
   memmoves Size bytes (>0x80) into the 0x80-byte internal buffer,
   overflowing heap memory.
5. Overwrite of adjacent pool objects yields kernel code execution
   when attacker-controlled function pointers / list entries are hit.

Attack Vector
--------------------------------------------------------------------
Any local, low-privileged user that can open a Kernel Streaming
endpoint (e.g. /Device/Camera, audio pin, etc.) can send the
malformed IRP.  No special privileges are required beyond device
access.

Patch Description
--------------------------------------------------------------------
• Added strict NULL / zero-length checks for VARIABLESIZE (0x1000)
  headers in KsProbeStreamIrp(), MdlCacheHandleThunkBufferIrp(), and
  TransferKsIrp().
• Rejects mis-aligned or undersized headers (<0xA0 when 0x1000 set).
• Logs and returns STATUS_INVALID_PARAMETER on bad input instead of
  continuing.
• Clears dangling pointers when frame headers are recycled.
• Removes feature-flag short-cuts; validation is now unconditional.

Security Impact
--------------------------------------------------------------------
Prior to the fix an attacker could trigger a heap-based buffer
overflow in non-paged pool, leading to arbitrary kernel memory write
and reliable local elevation of privilege (ring-0 execution) or
system crash.

Fix Effectiveness
--------------------------------------------------------------------
The new guards exit early before any MDL allocation or memmove when
meta-data pointer/size fields are invalid, and object fields are
sanitised on recycle.  No unchecked path that copies >0x80 bytes into
0x80-byte buffers remains, so the original overflow is removed.
