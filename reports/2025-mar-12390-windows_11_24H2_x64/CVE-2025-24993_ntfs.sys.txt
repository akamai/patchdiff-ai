{'patch_store_uid': 'e7ca9e07-1f84-451f-a10b-8a79bb74c0cb', 'date': 1751831476.842607, 'change_count': 17, 'confidence': 0.37, 'file': 'ntfs.sys', 'cve': 'CVE-2025-24993', 'kb': 'KB5053598'}
--------------------------------------------------------------------
CVE-2025-24993 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows NTFS kernel driver (ntfs.sys).
Affected routines process the NTFS restart area while a volume is
mounted or recovered:
  • ReadRestartTable()
  • InitializeRestartState()
  • NtfsInitializeUpcaseInfo()

Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow caused by insufficient bounds validation
(CWE-122).

Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  While mounting / recovering an NTFS volume, ntfs.sys reads a log
    record that contains a variable-length RESTART TABLE.  The parser
    is implemented by ReadRestartTable().

2.  Before the fix the routine performed only two integrity checks:
        NtfsCheckLogRecord()
        NtfsCheckRestartTable(base + Offset, Size, ctx)
    where Offset is *(USHORT*)(hdr+4) and Size is
        LogRecordLength – Offset.

3.  Immediately afterwards it derived another internal offset that
    depends on the restart table entry count (EntryCount):
        EntryHdr  = *(USHORT*)(base + 14)
        Variable  = 8 * EntryHdr + 32 (or 40 if EntryHdr<=1)
        NumberOfBytes = LogRecordLength – Variable                (A)

4.  Neither EntryHdr nor Variable was validated.  If an attacker stores
    an oversized EntryHdr in the on-disk log record, expression (A)
    underflows, producing a very large unsigned length.  NumberOfBytes
    is returned to the caller (InitializeRestartState) where it is
    used as the allocation size:
        ExAllocatePoolWithTag(NonPagedPoolNx, NumberOfBytes, …)
        memmove(dst, RestartTable, NumberOfBytes);

5.  The destination buffer is the requested large size, but the source
    buffer lives inside a fixed 4-kB log page.  The memmove therefore
    reads far past the end of the mapped log record and copies the
    data into kernel heap.  The read overflow is immediately followed
    by attacker-controlled writes when subsequent NTFS bookkeeping
    code manipulates the over-sized heap buffer.  Crafted data can be
    used to corrupt pool metadata and gain arbitrary kernel code
    execution.

6.  Additional unchecked tables are later copied in
    InitializeRestartState() and NtfsInitializeUpcaseInfo(); the patch
    adds parallel mitigations there to catch malformed indexes and
    version fields that previously permitted further heap corruption.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// BEFORE – ReadRestartTable (excerpt)
v10 = *(unsigned __int16 *)(v9 + 14);
v11 = 8 * v10 + 32;
if ((unsigned __int16)v10 <= 1)
    v11 = 40;
*a5 = *(_DWORD *)(v5 + 64) - v11;   // may under-flow
return v9 + v11;

// AFTER – new size validation
v11 = *(unsigned __int16 *)(v10 + 14);
v12 = 8 * v11 + 32;
if ((unsigned __int16)v11 <= 1)
    v12 = 40;
if (!NtfsCheckRestartTable(v10 + v12,
        *(_DWORD *)(a4 + 64) - *(USHORT *)(v10 + 4), ctx))
    /* corruption path */
*a5 = *(_DWORD *)(a4 + 64) - v12;
return v10 + v12;
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User forces Windows to mount a crafted NTFS volume (USB stick, VHD,
   remote iSCSI, etc.).
2. NtfsMountVolume → NtfsRestartVolume → InitializeRestartState →
   ReadRestartTable.
3. Malicious restart log page is parsed; EntryCount triggers arithmetic
   underflow, NumberOfBytes becomes huge.
4. InitializeRestartState allocates a large heap buffer and performs
   memmove(), reading past the end of the log page and corrupting heap
   data.
5. Subsequent NTFS operations operate on the corrupted structures,
   allowing attacker-controlled memory writes and eventual arbitrary
   kernel code execution.

Attack Vector
--------------------------------------------------------------------
Any attacker who can supply an NTFS image to a victim machine can
exploit the bug.  Typical vectors:
  • Plugging in a malicious removable drive.
  • Mounting a malicious VHD / ISO.
  • Opening a network share that exposes a crafted NTFS volume.
No prior privileges are required; the vulnerability is triggered during
automatic mount processing in the kernel.

Patch Description
--------------------------------------------------------------------
• Added an early size-aware call to NtfsCheckRestartTable() that uses
  the computed Variable offset (header+array) before returning control
  to callers.
• Guarded the new check behind Feature_* runtime flags for rollout.
• Added multiple new corruption handlers (labels LABEL_14 / _17 etc.)
  that raise STATUS_DISK_CORRUPT_ERROR instead of continuing.
• InitializeRestartState() now performs:
    – Revalidation of copied restart tables.
    – Index-range enforcement when moving individual table entries.
    – Extensive duplicate / overlap detection.
• NtfsInitializeUpcaseInfo() now clamps the version fields and clears
  them when a new feature flag is enabled.

Security Impact
--------------------------------------------------------------------
Before the fix a crafted NTFS log could cause an out-of-bounds read
followed by controlled heap corruption inside the kernel non-paged
pool, leading to local or remote (via removable media) kernel-mode
arbitrary code execution (RCE).  Successful exploitation yields SYSTEM
privileges and full OS compromise.

Fix Effectiveness
--------------------------------------------------------------------
The added NtfsCheckRestartTable() invocation prevents the arithmetic
underflow by verifying that (Variable <= LogRecordLength).  All paths
that previously used the unchecked NumberOfBytes now bail out with
STATUS_DISK_CORRUPT_ERROR if the table is malformed.  Additional
integrity checks in InitializeRestartState and NtfsInitializeUpcaseInfo
close secondary heap-corruption avenues.  Provided the checks are
correct and Feature_* gates are enabled system-wide, the original
overflow is fully mitigated.
