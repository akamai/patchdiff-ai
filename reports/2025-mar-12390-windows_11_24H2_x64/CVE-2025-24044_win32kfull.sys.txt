{'kb': 'KB5053598', 'confidence': 0.2, 'patch_store_uid': '7b1dcdbb-3e7e-4a53-a50f-fbbffa9ec78d', 'date': 1751865338.3707876, 'file': 'win32kfull.sys', 'cve': 'CVE-2025-24044', 'change_count': 138}
--------------------------------------------------------------------
CVE-2025-24044 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
win32kfull.sys – several helper APIs that read/write window-private
memory across process boundaries.  The vulnerable entry points that
lead to the same root flaw are:
  • NtUserGetScrollBarInfo()
  • GetSharedPropForFilteredProcesses()
  • SetSharedPropForFilteredProcesses()
Other touched helpers (EditionCreateWindowStation*,
ValidateGlyphDataAndBitmap,  NtGdiMakeObjectUnXferable) were refactored
but are not directly related to the UAF that received the CVE.

Vulnerability Class
--------------------------------------------------------------------
Use-After-Free / Dangling-pointer dereference (CWE-416).

Detailed Root Cause Analysis
--------------------------------------------------------------------
Window objects (tagWND) keep a pointer (pti->pClientInfo) that, in the
owning GUI process, references an   in-process   client structure.  That
structure contains two dynamic arrays:
    offset 0x18  : PVOID lpFilteredSharedProps   // array header
    offset 0x60  : tagSHAREDPROP[64]             // 24-byte entries
Each tagSHAREDPROP element holds:
    WORD  id;       // +0x10 in Get/Set loops
    QWORD value;    // +0x18 in Get/Set loops

Prior to the patch the kernel functions executed roughly the following
logic when *another* process queried / modified the properties or
requested scroll-bar information of that window:

1. Resolve the window handle → `pwnd`.
2. Read the cached pointer on the window:
       pShared = *(PVOID *)(GETCLIENTWNDINFO(pwnd)+0x18);
   NOTE: GETCLIENTWNDINFO returns a USER-mode address belonging to the
   *owner* process, not to the calling thread.
3. Iterate the 64 entry array directly, performing only
   ProbeForRead/Write with the current (caller) mode.  No process‐attach
   (KeAttachProcess / W32AttachToProcess) and no lifetime check is done.
4. While the kernel is walking the array, the owner process can free the
   memory (DestroyWindow, logout, etc.).  The pointer in step #2 is now
   dangling – any further dereference is a classic UAF leading to
   arbitrary read/write in Ring-0.

A local, low-privilege attacker can therefore:
 • create or steal a window owned by a higher-privilege process;
 • make that process exit (or destroy the window) so the shared buffer
   is freed;                                                                           
 • re-allocate controllable data at the same address from the attacker
   process;
 • call NtUserGetScrollBarInfo / SetSharedProp… on the stale handle;
   win32k dereferences the crafted memory and operates with attacker
   controlled pointers, allowing privileged memory overwrite and thus
   escalation to SYSTEM.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// pre-patch NtUserGetScrollBarInfo (excerpt)
v9 = ValidateReceivingHwnd(a1, 1);
...
LODWORD(v21) = *(_DWORD *)a3;        // buffer in caller
ScrollBarInfo = xxxGetScrollBarInfo(v9,a2,&v21); // <- NO attach!
...
```
```c
// pre-patch GetSharedPropForFilteredProcesses (excerpt)
for (i = *(char **)(GETCLIENTWNDINFO(pwnd)+24); i; i = *(char **)v7){
    ProbeForRead(i,0x618, wow64?1:4);                // probe *caller* mem
    for (j=0;j<64;++j){
        WORD id = *((WORD*)i + j*12 + 8);            // UAF here
        if (id==prop) return *((QWORD*)i + j*3 + 1);
    }
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker obtains or dupes a HANDLE of a window owned by a privileged
   service.
2. Owner frees its client-side shared property buffer.
3. Attacker allocates memory at the same VA inside its process.
4. Attacker invokes NtUserGetScrollBarInfo / GetSharedProp… on the stale
   handle.
5. win32k dereferences attacker-controlled memory → arbitrary kernel
   R/W → privilege escalation.

Attack Vector
--------------------------------------------------------------------
Local; any authenticated user can exploit by interacting with GUI
objects (window handles) shared system-wide.

Patch Description
--------------------------------------------------------------------
1. Introduced process-ownership check and secure attach:
      if (OwnerProcess != PsGetCurrentProcess())
          W32AttachToProcessAndExecute(...)
   so all dereferences happen in the correct address space.
2. Added upfront `ProbeForRead/Write` on the *owner* process structures
   after the attach.
3. Added secondary validation path that walks window-station linked list
   (`pti->ppi->pClientInfoBase`) instead of the stale cached pointer.
4. Hardened other callers by removing obsolete feature-flag gates and
   tightening pointer arithmetic / bounds checks.

Security Impact
--------------------------------------------------------------------
Exploiting the dangling pointer grants the attacker controlled kernel
memory accesses, allowing privilege escalation from any user account to
SYSTEM.  No additional privileges are required beyond the ability to run
code on the local machine.

Fix Effectiveness
--------------------------------------------------------------------
The updated code now:
 • guarantees the thread is attached to the target GUI process while
   accessing its memory;
 • validates all owner-side pointers with ProbeForRead/Write;
 • rejects the operation if the window has been destroyed or the buffer
   is empty;
Thus the original use-after-free condition can no longer be triggered
across process boundaries, effectively neutralising CVE-2025-24044.

