{'confidence': 0.22, 'cve': 'CVE-2025-24061', 'patch_store_uid': '83b7efe5-5e7b-4cba-a708-89e8ea257391', 'file': 'urlmon.dll', 'change_count': 10, 'date': 1751865234.205103, 'kb': 'KB5053598'}
--------------------------------------------------------------------
CVE-2025-24061 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
urlmon.dll – function GetServerShareFromIUriPriv(), used by the URL
Security Manager (CSecurityManager) when it computes the security ID
and zone for a supplied IUri / file: URL.

Vulnerability Class
--------------------------------------------------------------------
Logic error / security-feature bypass (CWE-693 – Protection Mechanism
Failure).

Detailed Root Cause Analysis
--------------------------------------------------------------------
GetServerShareFromIUriPriv() tries to decide whether the path part of a
file: URI refers to a local drive ("C:") or to a network resource.  It
first skips leading back-slashes, then calls IsDrive() to test the next
segment.  If IsDrive() returns TRUE the code assumes a local drive,
queries the drive type, and – if the drive is not a mapped network
drive – treats the file as local (Local Machine zone, no MOTW).

IsDrive() only looks for the pattern "<char>:" and is unaware of IPv6
literals inside UNC names, e.g. "\\[2001:db8::1]\share".  After the
leading "\\" are skipped, the first segment is "[2001:db8::1]"; the
colon found inside that segment makes IsDrive() return TRUE even though
this is *not* a drive letter.  Consequently the function sets

  *v57 = 1           ; marks path as drive
  *pszDest = <type>  ; drive type
  v51   = 1          ; early-exit flag

and finally hands back a security ID that corresponds to a local path.
All downstream checks therefore believe the resource is on the local
machine and do not honour Mark-of-the-Web, sandboxing, etc.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
for ( i = pbstr[1]; *i == '\\' || *i == '/'; ++i )
    ;
if ( (unsigned int)IsDrive(i) )     // mis-detects "[IPv6]" as drive
{
    ...
}

// after
for ( i = pbstr[1]; *i == '\\' || *i == '/'; ++i )
    ;
if ( IsDriveAndNotIPv6(i) )         // extra IPv6 guard
{
    ...
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Victim opens a file/URL that eventually reaches:
  CSecurityManager::GetSecurityId* -> GetServerShareFromIUriPriv()
  1. Function skips leading "\\".
  2. IsDrive() wrongly accepts first segment of an IPv6 UNC as "C:".
  3. Function flags path as local drive and returns security ID.
  4. Caller assigns Local Machine / Intranet zone, bypassing MOTW.

Attack Vector
--------------------------------------------------------------------
Any local context that causes Windows to evaluate a file: URL or UNC
path controlled by an attacker (e.g. a shortcut, HTML, or script) can
exploit the bug.  A path such as:
    file:////[2001:db8::dead:beef]/share/evil.docx
is interpreted as a local drive, allowing active content to run without
Mark-of-the-Web restrictions.

Patch Description
--------------------------------------------------------------------
The patch replaces the bare IsDrive() call with a new helper
IsDriveAndNotIPv6().  The new routine returns TRUE only when the segment
is a single-letter drive designator and *not* an IPv6 literal.  No other
code changes were needed.

Security Impact
--------------------------------------------------------------------
Prior to the fix an attacker could store content on a remote share that
is addressed through an IPv6 literal and have Windows treat that content
as coming from the local machine zone.  This bypasses the Mark-of-the-
Web flag and all mitigations that rely on it (Protected View, Office
mode, Smart App Control, etc.).  Result: arbitrary code execution with
user privileges by opening a crafted document or archive.

Fix Effectiveness
--------------------------------------------------------------------
By introducing an explicit IPv6 check the direct mis-classification path
is closed.  No alternative entry in GetServerShareFromIUriPriv() keeps
the old IsDrive() behaviour, so the fix appears complete for this code
path.  A defence-in-depth review of other callers of IsDrive() is still
recommended.
