{'cve': 'CVE-2025-24995', 'change_count': 3, 'confidence': 0.62, 'patch_store_uid': '3e5bdaf1-34d7-4c95-a38c-0592491ee613', 'file': 'ksthunk.sys', 'kb': 'KB5053598', 'date': 1751831366.416786}
--------------------------------------------------------------------
CVE-2025-24995 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Kernel-mode driver ksthunk.sys (Kernel Streaming WOW Thunk
Service – used by 32-bit applications to reach 64-bit KS filters).

Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow caused by signed/unsigned and 32-bit/64-bit
integer-overflow errors in length calculations that precede pool
allocations and subsequent memory moves.

Detailed Root Cause Analysis
--------------------------------------------------------------------
Three IOCTL helper paths relied on 32-bit arithmetic when computing
buffer sizes, offsets, and running totals.  The variables involved were
later used to allocate pool memory but were re-used as SIZE_T sources
for memmove / Probe* APIs, leading to a classic alloc-smaller / copy-
bigger scenario.

1. CKSAutomationThunk::ThunkDisableEventIrp
   Size field at (EventHeader-56) is incremented by 16:
       v13 = v11 + 16;
   The only wrap-around check was gated behind the feature flag
   Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage_5().  When the
   flag was disabled the addition could overflow (v13 < v11) and the
   corrupted length was written back, letting later callers use an
   arbitrarily small length that still points inside attacker-supplied
   data.

2. CKSAutomationThunk::ThunkEnableEventIrp
   OutSize (32-bit) is aligned then added to InputSize to form the
   allocation length:
       v12 = (OutSize + 23) & ~7;
       ExAllocatePool2(…, v12 + v9, …);
   The expression was evaluated with 32-bit temporaries; values near
   0xFFFF_FFFF wrapped, producing a tiny allocation.  memmove then
   copied v9 bytes (trusted) plus OutSize bytes (attacker controlled)
   into the undersized buffer, overflowing the look-aside pool.

3. CKSThunkPin::ThunkStreamingIrp
   The per-packet loop maintains two counters: remaining stream buffer
   (v6) and totalBytesToRead (v53).  Both were unsigned 32-bit.  A
   crafted KSSTREAM_HEADER whose Size field exceeds 4 GB causes:
       v53 += ExtendedHeader + 56;
   to wrap and later pass the truncated length to
   ExAllocatePoolWithTag, followed by memcpy of the real, much larger
   stream, smashing the heap.  The patch moves the counters to SIZE_T,
   adds explicit (newCounter < oldCounter) checks, and introduces
   RtlLogUnexpectedCodepath() for anomalous headers.

In every case the overflowed heap buffer resides in kernel, letting a
local attacker overwrite adjacent pool metadata or objects and achieve
arbitrary code execution in ring-0.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// ThunkEnableEventIrp – before
v12 = ((_DWORD)OutSize + 23) & 0xFFFFFFF8;   // 32-bit wrap
ExAllocatePool2(…, v12 + v9, …);             // tiny alloc
memmove((void *)(v12 + buf), src, v9);       // large copy

// ThunkDisableEventIrp – before
v13 = v11 + 16;                              // may wrap
if (!IsEnabledFlag && v13 < v11) { … }       // check skipped
*(_DWORD *)(hdr-56) = v13;                   // corrupt length

// ThunkStreamingIrp – before
v53 += ExtendedHeaderSize + 56;              // 32-bit add
if (v53 + 56 < v53) ExRaiseStatus(...);      // missing
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User mode → DeviceIoControl(<KS pin>, IOCTL_KS_WRITE_STREAM, …)
   ↳ ksthunk!CKSThunkPin::DispatchIoctl
     ↳ ThunkStreamingIrp / ThunkEnableEventIrp / ThunkDisableEventIrp
       ↳ attacker-controlled buffer processed as shown above
       ↳ integer wrap → undersized pool allocation
       ↳ memmove / memcopy overruns pool → EoP.

Attack Vector
--------------------------------------------------------------------
Any local, authenticated user able to open a KS pin exposed through the
WOW thunk service can send crafted IOCTL_KS_WRITE_STREAM / ENABLE_EVENT
/ DISABLE_EVENT requests containing malicious length fields to trigger
the overflow.

Patch Description
--------------------------------------------------------------------
• Replaced 32-bit arithmetic with SIZE_T / 64-bit variables.
• Added wrap-around checks using pattern (newSize < oldSize).
• Made checks unconditional by removing dependency on feature flags.
• Added extra ProbeForRead/Write validation of metadata pointers.
• Introduced RtlLogUnexpectedCodepath() to record malformed headers.
• Updated function prototypes to use NTSTATUS* and const-correct types.

Security Impact
--------------------------------------------------------------------
Prior to the patch a local attacker could corrupt kernel heap memory and
execute arbitrary code in kernel context, achieving elevation of
privilege (ring-0).  The overflow occurs in the kmalloc pool, so SMEP/
SMAP do not mitigate it.

Fix Effectiveness
--------------------------------------------------------------------
The new size calculations are done in 64-bit space and every critical
addition is followed by a wrap-around test, eliminating the immediate
integer-overflow vector.  Additional pointer validation and logging
should detect malformed structures early.  No residual unchecked size
additions were observed in the patched diff, so the fix appears
comprehensive for the affected paths.
