{'change_count': 2, 'file': 'eventtracingmanagement.dll', 'cve': 'CVE-2025-49660', 'confidence': 0.26, 'kb': 'KB5062553', 'patch_store_uid': '804dd8b4-5422-406c-8d96-73156c78ca46', 'date': 1752036208.162443}
--------------------------------------------------------------------
CVE-2025-49660 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Event Tracing (ETW) management library
(eventtracingmanagement.dll) – implementation of Windows
Implementation Library (WIL) feature-flag helpers
Feature_TestValidate / Feature_TestConfNum

Vulnerability Class
--------------------------------------------------------------------
Use-after-free (CWE-416)

Detailed Root Cause Analysis
--------------------------------------------------------------------
The helpers generated by WIL for the feature flag
"Feature_TestValidate" expose an internal routine named
__private_IsEnabled() (see pre-patch listing).  The routine takes a
pointer to the feature-cache structure (arg a1) and performs the
following sequence:

1.  Calls GetCachedFeatureEnabledState(a1,&state) which may allocate
    or re-allocate the per-feature cache block and, on a configuration
    change, *free* the previous block.
2.  Immediately dereferences *a1 and other fields (e.g. a1+2) without
    any form of synchronisation or reference counting.
3.  Passes a1+2 to ReportUsageToService(), a long-running call that may
    execute after another thread has invalidated or freed the feature
    cache memory.

Because the cache can be torn down asynchronously by configuration-
change callbacks, the pointer stored in a1 can become stale between
step 1 and step 3.  Subsequent reads or the pointer forwarded to
ReportUsageToService() touch memory that has already been returned to
the heap, creating a classical use-after-free window.

GetCurrentFeatureEnabledState() (Feature_TestConfNum) indirectly
exercises the same bug: it tests special bits (0x400 / 0x40) and, when
set, calls __private_IsEnabled().  A racing configuration change thus
propagates the dangling pointer into higher-level ETW code paths where
kernel-mode consumers may operate on attacker-controlled memory.

Affected data:
  * wil::details::FeatureImpl  (first dword is flag field)
  * Offset +0x08 contains the per-feature usage context forwarded to
    ReportUsageToService().
  * Flags 0x2 and 0x4 determine whether the cache is current and
    subscribed.

Lack of locking on those fields is the direct cause of the UAF.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// pre-patch __private_IsEnabled()
wil::details::FeatureImpl<...>::GetCachedFeatureEnabledState(a1,&v7);
...
wil::details::ReportUsageToService(a1 + 2, 50565209i64,
    (v2>>10)&1, (v2>>11)&1, &v5, v3, 0);   // <- a1 now dangling
```
```c
// post-patch ReportUsage()
...
while (1) {
    v11 = v6;
    ...
    v12 = _InterlockedCompareExchange((volatile long*)a1,v11,v6);
    if (v6 == v12) break;                // lock the cache atomically
    v6 = v12;
}
...
return wil::details::ReportUsageToService((char*)a1+8, ...);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User thread A
  -> wil::Feature<TestConfNum>::GetCurrentFeatureEnabledState()
     -> __private_IsEnabled()        // obtains pointer p
User thread B or configuration daemon
  -> changes feature configuration
     -> frees old cache block (p)
Thread A resumes
  -> ReportUsageToService(p+0x08)    // p is freed -> UAF

Attack Vector
--------------------------------------------------------------------
A local, authenticated attacker repeatedly toggles the corresponding
feature flag (via registry or Feature Management API) while racing one
or more threads that query ETW feature state.  Precise timing yields a
use-after-free that allows heap corruption inside the privileged ETW
service context, leading to elevation of privilege.

Patch Description
--------------------------------------------------------------------
• Replaced __private_IsEnabled() with a new ReportUsage() routine that
  performs:
  – Atomic CompareExchange loops to lock the feature-cache flags.
  – Explicit EnsureSubscribedToFeatureConfigurationChanges() and
    SubscribeFeatureStateCacheToConfigurationChanges() so the cache is
    not freed while in use.
  – Updates to the local copy (v18) only after the cache is secured.
• All higher-level callers (e.g. GetCurrentFeatureEnabledState()) were
  updated to call the new safe routine instead of the old one.
• The dangerous direct pointer (a1+2) is still used, but only after
  the structure is proven stable by the lock.

Security Impact
--------------------------------------------------------------------
Without the patch, a local attacker can trigger heap use-after-free in
a process running with higher privileges (typically SYSTEM), leading
to controlled memory corruption and elevation of privilege.

Fix Effectiveness
--------------------------------------------------------------------
The introduction of atomic locking and subscription reference holding
removes the window where the cache memory could be released between
state retrieval and usage, thereby neutralising the UAF.  No remaining
unsynchronised dereferences of the cache structure are visible in the
patched code, indicating the fix is effective for the identified
vector.
