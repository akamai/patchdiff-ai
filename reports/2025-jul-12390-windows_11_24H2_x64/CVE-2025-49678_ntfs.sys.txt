{'kb': 'KB5062553', 'patch_store_uid': '95d78374-0237-4b2b-8b2f-195a09bd2cbc', 'confidence': 0.13, 'file': 'ntfs.sys', 'cve': 'CVE-2025-49678', 'change_count': 12, 'date': 1752037009.9736843}
--------------------------------------------------------------------
CVE-2025-49678 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows NTFS kernel driver (ntfs.sys); affected routines are
mainly LfsLsnFinalOffset(), ReadRestartTable(),  InitializeRestartState()
and their callers that process the NTFS Log-file Service (LFS)
restart-area structures during mount / replay.

Vulnerability Class
--------------------------------------------------------------------
CWE-476  : NULL-pointer dereference in kernel space
CWE-190  : Integer overflow leading to out-of-bounds pointer
CWE-362  : Race on shared restart-table resources

Detailed Root Cause Analysis
--------------------------------------------------------------------
LfsLsnFinalOffset() converts an LSN into a byte offset within a log
page.  The vulnerable pre-patch code performs the calculation

    v9 = a3 + *(USHORT *)(LogFileCtx + 96);
    result = (pageOffsetMask & ...) + v9;
    *(DWORD *)a4 += result;     // update caller-supplied pointer

The operand *a3* is the caller-supplied length of the log-record body
(ultimately controlled by on-disk metadata).  Both *a3* and the header
constant are held in 32-bit variables.  If the sum overflows
(0xFFFF_FFFF + 1 → 0), *v9* becomes very small and the final addition
produces a pointer that may equal 0.  Down-stream functions
(ReadRestartTable → InitializeRestartState) trust this pointer and
blindly dereference it while still executing in kernel mode and under
shared VCB locks.  An attacker that can provide a crafted NTFS image or
VHD therefore forces the kernel to touch address 0x00000000, causing a
BSOD or, if the NULL page is mapped and prepared, controlled code
execution in ring-0.

Because normal file-system operations are performed under the VCB
resource, a second thread can unmap / remap the malicious image in the
small timing window between pointer computation and use, turning the
logic flaw into a race-condition EoP.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch (ntfs!LfsLsnFinalOffset)
v9  = a3 + *(unsigned __int16 *)(a1 + 96);   // no overflow check
...
result = v8 + v9;
*(DWORD *)a4 += result;                      // may wrap to NULL
```
```c
// after patch (excerpt)
v11 = a3 + *(unsigned __int16 *)(a1 + 96);
if ( Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage_11() &&
     v11 < a3 )                               // detects wrap-around
    ExRaiseStatus(STATUS_INTEGER_OVERFLOW);
...
*a4 += v11 + (uint64_t)v9;                    // pointer now guaranteed
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Low-privileged attacker mounts a crafted NTFS image / VHD.
2. NtfsRestartVolume() → InitializeRestartState()
3. InitializeRestartState() calls ReadRestartTable() to fetch the on-disk
   restart table.
4. ReadRestartTable() passes user-controlled *DataLength* to
   LfsLsnFinalOffset().
5. Integer overflow → *a4 == 0*.
6. ReadRestartTable() immediately dereferences the NULL pointer → kernel
   fault (or controlled write if NULL page is mapped).

Attack Vector
--------------------------------------------------------------------
Local attacker creates/mounts a specially crafted NTFS volume, or plugs
in removable media containing the malicious log-file.  No
administrative rights are required—only the ability to mount a
filesystem (e.g. through Plug-and-Play or Virtual-Disk APIs).

Patch Description
--------------------------------------------------------------------
• LfsLsnFinalOffset():
  – switched *a3* to unsigned 32-bit and added an explicit overflow
    check (v11 < a3) that raises STATUS_INTEGER_OVERFLOW.
  – performs all subsequent offset math in 64-bit variables.

• ReadRestartTable(), InitializeRestartState(), NtfsQueryDirectory() and
  related helpers were updated to use the new safe offset, to validate
  header-derived lengths, and to remove brittle Feature-flag shortcuts.

• Extra NULL/size checks were added before any pointer is dereferenced.

Security Impact
--------------------------------------------------------------------
A successful exploit lets a non-admin local user execute code in the
kernel or force a system crash, resulting in privilege elevation to
SYSTEM.  The bug is reachable during a standard mount path and can be
triggered repeatedly.

Fix Effectiveness
--------------------------------------------------------------------
The integer-overflow detection stops the wrap-around at its source and
propagates a hard failure that is handled safely by the call chain.
All subsequent consumers now receive validated 64-bit offsets, making
NULL (or otherwise attacker-controlled) pointers impossible.  No new
race paths were introduced.  The patch therefore fully mitigates the
reported vulnerability.
