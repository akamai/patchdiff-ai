{'file': 'cdp.dll', 'date': 1752037862.1026502, 'kb': 'KB5062553', 'cve': 'CVE-2025-49724', 'change_count': 49, 'patch_store_uid': 'aaea9f18-70e5-42d7-9e7c-0a120680be78', 'confidence': 0.26}
--------------------------------------------------------------------
CVE-2025-49724 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Connected Devices Platform Service (cdp.dll)
Affected routines:
  • cdp::ClientChannelManager::HandleAuthorizationDataRequest()
  • cdp::HostChannelManager::HandleAuthorizationDataResponse()
  • cdp::TransportManager::OnTransportReceivedDataInternal()


Vulnerability Class
--------------------------------------------------------------------
Use-After-Free / Dangling-pointer dereference (CWE-416)


Detailed Root Cause Analysis
--------------------------------------------------------------------
Both Client- and Host-side managers must forward channel-authorization
messages to a per-session *authorization provider* object that is kept
inside a registry as a weak_ptr.  The original code performed the
following sequence:

1.  `weak_ptr::lock()` (via internal helper at vtbl+32) returns a raw
    provider interface pointer (v8 / v23).  If the provider had already
    been destroyed by another thread the call returns **nullptr**.
2.  The code immediately dereferenced the returned pointer (`(**ptr)
    + 24`) and executed a virtual method
    (`GetAuthorizationResponseDataAsync` / `AuthorizeUserAsync`).
3.  When the pointer was null or referenced memory already freed, the
    service accessed freed memory, resulting in a classic UAF.

Because the object life-time is controlled by remote peers (the client
can disconnect at any moment) an attacker can:
• establish a channel to create a provider,
• disconnect to let the provider be destroyed, then
• race a crafted *AuthorizationDataRequest / Response* message that
  still references the old session id.

The message is processed in the service’s network worker thread while
no global lock protects the provider.  The resulting UAF occurs in the
LocalSystem-privileged CDP service and can be turned into remote code
execution.

Primary affected parameters / structures
  weak_ptr< IDiscovery >  (Client path)
  weak_ptr< shared::Session > (Host path)
  std::_Ref_count_base *v17[0] / v21[0] – holds shared_ptr
  Raw provider pointer    – v15 (client), v23 (host)


Vulnerability Code Snippets
--------------------------------------------------------------------
Before (Client path)
```c
v8 = (*(...)(v21[0], &v15));          // lock weak_ptr
v9 = *(_QWORD *)v8;                   // v8 may be NULL / freed
v10 = (*(**(_QWORD **)v8 + 24))( ... ); // UAF
```

After
```c
(*(...)(v17[0], &v15));               // lock weak_ptr
IsEnabled = Feature_IsEnabled();
if (IsEnabled && !v15) {              // NEW NULL CHECK
    erase_pending_entry();            // cleanup & return
}
```
An analogous fix is applied in HostChannelManager.


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker opens a CDP channel (creates provider object).
2. Attacker closes the channel so the provider is freed.
3. Attacker immediately sends an AuthorizationData* message that
   references the stale channel id.
4. Service routine looks up provider through weak_ptr::lock().
5. Lock returns nullptr (or dangling pointer); old code dereferences it
   -> UAF -> potential RCE.


Attack Vector
--------------------------------------------------------------------
Unauthenticated remote network traffic to the Connected Devices
Platform Service (TCP-based NearShare, Bluetooth, etc.).  No local
privileges required; only the ability to send crafted authorization
messages at the right time.


Patch Description
--------------------------------------------------------------------
• Added feature-gated NULL checks (`Feature_Servicing_NullCheck_*
  _AuthProvider`).
• If `weak_ptr::lock()` returns nullptr the code now:
    – logs an error,
    – erases any pending bookkeeping entries,
    – releases all reference-counted objects, and
    – returns before any dereference.
• Similar early-exit added for unknown channel ids to avoid using
  uninitialised iterators.
• Extra decrement calls and destructor invocations guarantee balanced
  reference counts.
• TransportManager received defensive endpoint-throttling but is not
  directly related to the UAF.


Security Impact
--------------------------------------------------------------------
Prior to the patch a remote attacker could trigger a use-after-free in
a LocalSystem service.  Careful heap grooming allows execution of
arbitrary code in that context, yielding complete system compromise.


Fix Effectiveness
--------------------------------------------------------------------
The added NULL checks prevent dereferencing a freed authorization
provider pointer and therefore remove the immediate UAF primitive.
Both client and host codepaths are covered.  No residual code paths
were found in the diff that still dereference the provider without a
NULL test, indicating the fix is effective for the reported issue.
--------------------------------------------------------------------