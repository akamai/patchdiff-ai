{'patch_store_uid': 'd2a2978c-6afa-47a3-bbf7-4047bc1fb0a8', 'file': 'settingshandlers_notifications.dll', 'confidence': 0.34, 'cve': 'CVE-2025-49725', 'date': 1752037746.94411, 'change_count': 39, 'kb': 'KB5062553'}
--------------------------------------------------------------------
CVE-2025-49725 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows 10/11 Settings –  settingshandlers_notifications.dll  
(Quiet-Hours / Focus-Assist notification profile handling code)


Vulnerability Class
--------------------------------------------------------------------
CWE-416 : Use-after-free (dangling wide-string buffers returned from
IQuietHoursProfile* helpers)


Detailed Root Cause Analysis
--------------------------------------------------------------------
Several helper methods inside the Quiet-Hours settings handler obtain
profile identifiers that are returned through out-parameters of form
  unsigned short **ppId
where the callee allocates the buffer with CoTaskMemAlloc and expects
the caller to free it with CoTaskMemFree.

Prior to the patch every caller wrapped the returned pointer in a
wil::details::unique_storage< unsigned short * , CoTaskMemFree > local
variable.  The variable went out of scope – and the buffer was freed –
as soon as the function returned, **even when the pointer was still
observable by another live object**:

• DoGenericAsyncWork / QuickActionNextValue copied the pointer’s address
  into UI objects and async lambdas that out-lived the stack frame.
• GetValue / SetValue routines copied the *pointer value* into
  std::wstring objects that were then passed by const-reference to
  QuietHoursSingleton::SetActiveProfile.  SetActiveProfile keeps a
  **pointer reference only**, expecting the memory to remain valid, but
  the buffer was immediately destroyed when unique_storage ran.

Because the same memory region was re-used by subsequent heap
allocations, later access in QuietHoursSingleton de-referenced a freed
buffer – classic UAF.  A locally-logged-on attacker that can switch
Focus-Assist profiles (normal user privilege) can arrange for the freed
buffer to be re-allocated with attacker-controlled data and execute code
in a privileged context (the settings handler DLL is loaded into a
SYSTEM process).

Primary structures / parameters involved:
  • unsigned short **ppProfileId / ppDisplayName
  • wil::details::unique_storage< unsigned short * , CoTaskMemFree >
  • std::wstring temporary wrappers
  • QuietHoursSingleton::SetActiveProfile(const std::wstring &)


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Before
LPVOID pv = 0;
GetOffProfileId(this,(unsigned __int16 **)&pv);   // allocates string
std::wstring ws(&pv);               // SetActiveProfile keeps ptr only
QuietHoursSingleton::SetActiveProfile(v6,&ws);   // dangling
// ws and pv freed right here – UAF in later use
```
```c
// After
unsigned __int16 *pid = 0;
WRL::ComPtr<ClipboardDataObjectTask>::Attach((void**)&pid,nullptr);
GetOffProfileId(this,&pid);         // same allocator
std::wstring ws(pid);               // copy
QuietHoursSingleton::SetActiveProfile(v6,&ws);   // valid
// pid is still held by ComPtr wrapper until function end
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User opens Settings → System → Notifications → Focus Assist.
2. UI invokes QuietHoursEnabled::DoGenericAsyncWork (or similar helper)
   which switches the active profile.
3. Function builds a temporary std::wstring from a profile ID and calls
   QuietHoursSingleton::SetActiveProfile.
4. unique_storage immediately frees the ID buffer while
   QuietHoursSingleton still retains a raw pointer.
5. Any subsequent use of that pointer (timer callback, COM event etc.)
   touches freed memory – exploitable heap UAF.


Attack Vector
--------------------------------------------------------------------
Local – the attacker only needs the ability to flip Focus-Assist (Quiet
Hours) settings, something every standard desktop user can do through
UI or PowerShell.


Patch Description
--------------------------------------------------------------------
The fix changes *all* affected call sites so that the returned buffer is
first attached to a dummy Microsoft::WRL::ComPtr via
ComPtr::Attach(…,nullptr).  Because ComPtr obeys COM lifetime rules, the
buffer now remains allocated until the ComPtr instance is destroyed
(after all downstream consumers are done).  In addition, the
unique_storage instantiation was switched from <unsigned short *> to
<void *> to prevent template matching that previously triggered an early
CoTaskMemFree.


Security Impact
--------------------------------------------------------------------
A standard user could reliably reclaim the freed CoTaskMemAlloc’ed block
and craft data that is subsequently interpreted in the context of a
SYSTEM process (the settings host).  This yields local privilege
escalation.


Fix Effectiveness
--------------------------------------------------------------------
The patched code guarantees that profile-ID buffers stay alive for the
whole duration of the helper routine, and SetActiveProfile receives a
valid copy, eliminating the dangling reference.  No obvious alternate
code path retaining freed data remains, so the UAF is effectively
removed.
