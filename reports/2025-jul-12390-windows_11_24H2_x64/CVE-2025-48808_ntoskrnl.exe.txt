{'change_count': 508, 'confidence': 0.27, 'kb': 'KB5062553', 'date': 1752037959.6627135, 'cve': 'CVE-2025-48808', 'patch_store_uid': '877325f0-3361-4f8e-830a-96d6ce09ca35', 'file': 'ntoskrnl.exe'}
--------------------------------------------------------------------
CVE-2025-48808 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Event Tracing for Windows (ETW) – kernel-mode parser routine
EtwpValidateFlagExtension() in ntoskrnl.exe

Vulnerability Class
--------------------------------------------------------------------
Out-of-bounds read / information disclosure caused by missing lower
bound validation (CWE-200 / CWE-125)

Detailed Root Cause Analysis
--------------------------------------------------------------------
The ETW flag-extension header that precedes every EVENT_TRACE_HEADER
stores an offset (negative value stored in a1[18]) that points from
the start of the header to a variable-length list of flag/length
pairs.  Prior to the patch the routine EtwpValidateFlagExtension()
validated that
  • the high byte (BYTE2(v1)) equals 0xFF, and
  • total buffer size >= offset + 4, and
  • *EXT->Count * 4 <= remaining buffer.

Crucially it never verified that the *offset* itself is large enough
to be inside the fixed EVENT_TRACE_HEADER (0xB0 bytes) nor that the
list item-count is non-zero.  An attacker could therefore supply a
tiny but non-zero offset (e.g. 0x04) and a crafted Count value that
makes all subsequent size checks pass.  When the for-loop iterates
through the user–controlled “length” fields the code indexes past the
end of the caller-supplied buffer and starts reading adjacent kernel
memory, byte by byte, until the artificially constructed counter
(v6) underflows to zero.

Because EtwpValidateFlagExtension() returns STATUS_SUCCESS, the
caller treats the extension as valid and copies the over-read data
back to user space via ETW control APIs, disclosing uninitialised or
sensitive kernel memory to an un-privileged attacker.

Structures / parameters affected
  a1 -> EVENT_TRACE_HEADER (user supplied)
  a1[18]  : negative offset to FLAG_EXTENSION (attacker controlled)
  FLAG_EXTENSION->Count / Length : attacker controlled, drives read

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch (simplified)
v3 = *a1;                       // total buffer size
v4 = (USHORT *)((char*)a1 + (USHORT)v1);
if (*v4 && 4 * *v4 <= v3 - (USHORT)v1) {
    v5 = v4 + 2;
    v6 = *v4 - 1;              // remaining size counter
    for (i = 0; i < v4[1]; ++i) {
        if (!v6)       return STATUS_BUFFER_TOO_SMALL;
        v8  = *v5;            // user controlled length
        if (v6 < v8) return STATUS_BUFFER_TOO_SMALL;
        v6 -= v8;             // underflow possible
        v5 += 2*v8;           // out-of-bounds read here
    }
    if (!v6) return STATUS_SUCCESS;
}
```
```c
// after patch (excerpt)
if (Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage_71()) {
    if (BYTE2(v1) != 0xFF || (USHORT)v1 < 0xB0)
        return STATUS_BUFFER_TOO_SMALL;   // new lower bound check
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User opens an ETW session and supplies an EVENT_TRACE_PROPERTIES
   buffer with FlagExtensionOffset < 0xB0 and crafted list fields.
2. kernel -> EtwpValidateFlagExtension()
3. Missing lower-bound check allows pointer to land inside
   kernel-controlled memory.
4. for-loop reads beyond caller buffer, copying kernel data into the
   ETW reply.
5. User receives the buffer and extracts leaked memory.

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker running in user mode.  Requires the
ability to start or control an ETW session (TraceSetInformation /
StartTrace, available to normal users by default).

Patch Description
--------------------------------------------------------------------
Microsoft added strict lower-bound validation on the offset value
((USHORT)v1 >= 0xB0) when the mitigation feature flag is active and
mirrored the same logic for the legacy path.  Early exits now return
STATUS_BUFFER_TOO_SMALL or STATUS_DATATYPE_MISALIGNMENT before any
pointer arithmetic occurs, completely preventing the out-of-bounds
read.

Security Impact
--------------------------------------------------------------------
The flaw allows disclosure of up to several kilobytes of uninitialised
kernel memory per request.  An attacker may repeatedly query ETW to
harvest sensitive information such as kernel pointers or memory
contents, facilitating further exploitation (KASLR bypass, credential
material, etc.).

Fix Effectiveness
--------------------------------------------------------------------
The added lower-bound check removes the ability to supply an offset
that targets kernel memory; all subsequent calculations operate on a
validated, in-bounds pointer.  No alternative path that re-introduces
the out-of-bounds read remains, therefore the patch is effective.
