{'cve': 'CVE-2025-49694', 'date': 1752036207.6193054, 'kb': 'KB5062553', 'change_count': 3, 'patch_store_uid': '5456a6ce-eca9-4fc6-9a2d-36e0f655bea2', 'file': 'bfs.sys', 'confidence': 0.24}
--------------------------------------------------------------------
CVE-2025-49694 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Brokering File System kernel driver (bfs.sys).  Affected
routines are BfsCheckAndApplyPolicy(), BfsInsertNotPresentPolicyEntry()
and BfsInsertPolicyEntry().  The vulnerable logic runs in the file-
system filter path (IRP_MJ_CREATE handling).

Vulnerability Class
--------------------------------------------------------------------
NULL pointer dereference / improper handling of an un-initialised
pointer (CWE-476).

Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  In the original build BfsCheckAndApplyPolicy() verifies that a
    policy entry already exists for the caller SID:

        if (BfsPolicyEntryExists(...)) {
            PolicyEntry = BfsGetPolicyEntry(FltObject,
                                            a2,
                                            &gBfsPolicyTable,
                                            TokenSid);
            if (PolicyEntry < 0) { … }
            FileName = BfsGetFileName(...);
            v19 = (volatile signed __int32 *)v34;   // <- use
    }

    The routine expects BfsGetPolicyEntry() to return a STATUS­_x code
    while simultaneously *filling* local variable v34 with a pointer to
    the retrieved _BFS_POLICY_ENTRY structure.  However the call is made
    without passing v34’s address, so the callee never initialises it.
    v34 therefore remains NULL.

2.  v34 is copied to v19 and later dereferenced multiple times, e.g.

        Policy = BfsGetPolicy(*((QWORD *)v34 + 6), …);

    On failure of BfsGetPolicyEntry() the code path still dereferences
    v34, producing a kernel-mode NULL pointer dereference in an
    attacker-controlled thread context.

3.  BfsInsertPolicyEntry() suffers from the same pattern: it finally
    stores the obtained entry into caller-supplied *a7, yet uses the
    uninitialised local variable during cleanup when insertion fails.

4.  BfsInsertNotPresentPolicyEntry() allocates two SID buffers then
    conditionally frees or reuses them.  When feature flag
    Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage_1() was disabled
    the old code could leave one of the two internal SID pointers NULL
    and later dereference it.

Parameters / structures involved:
• local pointer v34 (BfsCheckAndApplyPolicy) / v44 (patched)
• structure _BFS_POLICY_ENTRY, offsets +64 / +72 are traversed after the
  faulty assignment.
• Returned NTSTATUS from BfsGetPolicyEntry() is ignored on the faulty
  dereference path, making the crash attacker-triggerable.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
PolicyEntry = BfsGetPolicyEntry(FltObject, a2, &gBfsPolicyTable,
                               *(_QWORD *)TokenInformation);
...
v19 = (volatile signed __int32 *)v34; // v34 never initialised
...
// after
PolicyEntry = BfsGetPolicyEntry((DWORD)FltObject,
                               *(PSID *)P[0],
                               (__int64)&v34);   // &v34 passed
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-mode open/create request ->
  FS filter callback BfsPreCreateOperation ->
  BfsCheckAndApplyPolicy()
    └─ BfsPolicyEntryExists()==TRUE, BfsGetPolicyEntry() fails
       └─ v34 remains NULL
       └─ later dereference of v34 (+0x30…) triggers bug.
Complementary insertion paths hit the same bug in
BfsInsertPolicyEntry() when a policy insertion attempt fails.

Attack Vector
--------------------------------------------------------------------
Any local, authenticated process able to perform file create/open
operations that are monitored by bfs.sys can trigger the vulnerable
path.  Supplying a token SID for which a policy lookup fails forces the
function to dereference the NULL pointer in kernel context, resulting in
a system crash and potential privilege escalation (exact exploitation
method beyond the provided diff is unknown).

Patch Description
--------------------------------------------------------------------
• All callers now pass the *address* of the output pointer to
  BfsGetPolicyEntry(), ensuring the local variable is initialised before
  use.
• Added conditional feature-flag code that nulls internal SID fields
  when not required, preventing later accidental dereference.
• Numerous defensive checks were introduced (e.g., verify allocation
  success before use, early bailout paths unified).

Security Impact
--------------------------------------------------------------------
Prior to the patch a local attacker could force a NULL pointer
Dereference in kernel mode, leading to a bug check (Denial of Service)
or, in conjunction with additional techniques, elevate privileges to
SYSTEM.  The crash occurs in the BFS filter driver, causing complete
system instability.

Fix Effectiveness
--------------------------------------------------------------------
The patched build initialises the pointer before every use and adds
extra validity checks.  No code path that follows an error status can
now reach a dereference on an uninitialised pointer, so the original
NULL dereference is fully mitigated.
