{'kb': 'KB5062553', 'change_count': 14, 'date': 1752037661.84171, 'confidence': 0.24, 'patch_store_uid': '8b054c6c-22c7-4df0-9ed4-9b3236e74784', 'file': 'storsvc.dll', 'cve': 'CVE-2025-49760'}
--------------------------------------------------------------------
CVE-2025-49760 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Storage Service (storsvc.dll) – directory-handling
helper classes found in RecursiveUtil::* and public entry point
StorageService::DeleteDirectoryTree/RecursiveScanDirectory.

Vulnerability Class
--------------------------------------------------------------------
Path spoofing / directory traversal caused by inconsistent and
incomplete canonicalisation of user-controlled paths
(CWE-73 External Control of File Name or Path).

Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  When StorageService is asked to delete or enumerate a directory it
    eventually calls
       RecursiveUtil::NtObjectPath::NtObjectPath(HANDLE)
    to obtain a textual representation of the directory HANDLE that is
    later compared – purely as a string – with other paths produced
    during the recursion.

2.  Prior to the patch the constructor contained two code paths that
    were selected by the runtime feature flag
    Feature_Servicing_InvalidPathHandling (id 2578215227):
      • enabled  → safe path:  GetFinalPathNameByHandleW(handle,
        buf, 256, VOLUME_NAME_NT /*2*/, FILE_NAME_OPENED /*8*/)
        returned a stable native NT path ("\\?\Volume{GUID}\...").
      • disabled → legacy path: GetFinalPathNameByHandleW was invoked
        with no flags (default 0) and the resulting buffer was copied
        into a std::wstring after a manual length scan.  Depending on
        the handle type this frequently produced an *alternate*
        representation (e.g. "C:\dir" or "\\?\C:\dir") that is *not*
        string-equal to the NT form although it refers to the same
        object.

3.  RecursiveUtil::RecursiveScanDirectory() relies on
    NtObjectPath::operator== to decide whether it is still operating
    inside the original root.  Because the comparison is textual,
    providing a path that resolves to the same directory but that is
    rendered in the alternative syntax bypasses the check.  The service
    will therefore recurse, copy or delete data outside the caller’s
    authorised tree – a classic spoofing scenario.

4.  On top of the divergent path formats, the legacy code built
    sub-paths with PathAllocCanonicalize / PathAllocCombine using option
    0x01 (PATHCCH_ALLOW_LONG_PATHS) which *does not* normalise all
    segments.  Dot-dot sequences or embedded NT device names could thus
    survive and be concatenated with the un-normalised root producing
    further traversal opportunities.

5.  The public API StorageService::DeleteDirectoryTree exposes the
    vulnerable flow.  An authenticated attacker that can feed a crafted
    path (e.g. via an SMB share or local RPC call) can convince the
    Storage Service that the target is inside an authorised directory
    while it actually points elsewhere, leading to unintended actions
    (creation, enumeration or deletion) on arbitrary file system
    locations.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// NtObjectPath::NtObjectPath  – OLD (unsafe branch)
wil::GetFinalPathNameByHandleW<unique_any_t<...>,256>(a2,&v9); // no flags
...
std::wstring::assign(this, v9);             // blind copy
```
```c
// NtObjectPath::NtObjectPath – NEW (always used)
int rc = wil::GetFinalPathNameByHandleW<std::wstring,256>(
        a2, this, 2 /*VOLUME_NAME_NT*/, 8 /*FILE_NAME_OPENED*/);
if (rc < 0) throw;
```
```c
// RecursiveScanDirectory – canonicalisation change
// OLD (flag depended)
PathAllocCanonicalize(path, 1 /*ALLOW_LONG_PATHS*/, &ppszPathOut);
// NEW (always)
PathAllocCanonicalize(path, 0x10 /*ENSURE_EXTENDED_LENGTH*/, &ppszPathOut);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
StorageService::DeleteDirectoryTree()
  → RecursiveUtil::DeleteDirectoryTree()
     – opens root handle
     – NtObjectPath ← *unsafe formatting*
  → RecursiveUtil::RecursiveScanDirectory()
     – builds/combines child paths (legacy normalisation)
     – compares NtObjectPath strings → spoofing bypass
  → unintended file-system operations executed under SYSTEM account.

Attack Vector
--------------------------------------------------------------------
An authenticated user (local or over the network via SMB/RPC) supplies a
crafted directory name that:
  • can be opened by the service, *and*
  • has an alternative textual form (e.g. Volume GUID path vs drive
    letter, extended-length "\\?\" prefix, mixed case, etc.).
String comparison fails, enabling the attacker to masquerade an
arbitrary directory as a sub-directory of an authorised tree, resulting
in spoofing of Storage Service operations.

Patch Description
--------------------------------------------------------------------
• Removed all feature-flag branches – the secure behaviour is now
  unconditional.
• NtObjectPath always requests VOLUME_NAME_NT | FILE_NAME_OPENED, giving
  a unique canonical NT path.
• All path builds now use PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH (0x10)
  and no longer permit un-normalised segments.
• Large re-factoring of RecursiveScanDirectory / DeleteDirectoryTree to
  pass validated parameters only.

Security Impact
--------------------------------------------------------------------
The service can no longer be tricked into treating two textual paths
that refer to the same directory as different, closing the spoofing
hole.  Attempts to traverse outside the authorised root are stopped
because paths are normalised and compared in a single canonical form.
Potential consequences such as arbitrary directory deletion or data
corruption under SYSTEM privileges are eliminated.

Fix Effectiveness
--------------------------------------------------------------------
The vulnerable code paths have been completely removed; all callers are
forced through the safe canonicalisation routine with strict flag
settings.  No residual alternate-format path can bypass the equality
check, so the fix fully addresses the identified weakness.

