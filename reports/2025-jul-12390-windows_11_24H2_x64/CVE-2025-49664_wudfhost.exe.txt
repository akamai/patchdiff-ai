{'date': 1752036556.3928156, 'kb': 'KB5062553', 'patch_store_uid': 'f5a39d17-a41a-4ba7-a3f8-80ad1a2a1237', 'confidence': 0.34, 'file': 'wudfhost.exe', 'change_count': 3, 'cve': 'CVE-2025-49664'}
--------------------------------------------------------------------
CVE-2025-49664 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows User-Mode Driver Framework Host (wudfhost.exe).
Affected routines are BusInterfaceStandard::GetBusData(),
CWudfIoIrp::RetrieveClientBuffers(), and
CWudfIoIrp::RetrieveBuffers().

Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow / missing length check leading to
information disclosure (CWE-120 / CWE-200).

Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  BusInterfaceStandard::GetBusData accepts a caller-supplied
    destination pointer (Buffer) and its declared size (Length).
    After issuing WUDF_QICMD_BUS_GET_BUS_DATA the helper structure
    _WUDF_QUERY_INTERFACE is returned with ResultLength, the number
    of bytes the control device actually produced.

2.  In the unpatched build the function executed
        memcpy(Buffer, param.Buffer, ResultLength);
    without first confirming that ResultLength <= Length.  If a
    malicious bus driver (running in the same host process) returns
    a larger ResultLength (up to 0x100 bytes) while the caller
    declared a smaller Length, memcpy overruns the heap block owned
    by the caller.  The overrun copies attacker-controlled data into
    adjacent heap memory, thereby exposing the overrun region to the
    caller once it subsequently reads the buffer.  The defect is an
    unchecked size mismatch between two trust boundaries: data
    supplied by the bus driver vs. buffer size supplied by a user-
    mode component.

3.  CWudfIoIrp::RetrieveClientBuffers and
    CWudfIoIrp::RetrieveBuffers contained similar missing-failure-
    checks.  They marked m_ClientBuffer.Valid = 1 even when one of
    the per-direction buffer retrieval helpers failed.  Subsequent
    logic would treat uninitialised heap pointers as valid, letting
    the caller read stale heap data.  The patch replaces the open-
    coded logic with calls to a new helper (RetrieveClientOutputBuffer)
    and sets Valid only when both input and output retrieval succeed.

4.  The net effect is that an authorised local attacker who controls
    a UMDF driver or can coerce the bus interface can make WUDFHOST
    copy arbitrary heap contents beyond the intended buffer and
    return them to the attacker, violating confidentiality.

Vulnerability Code Snippets
--------------------------------------------------------------------
Before:
```c
if (BusInterfaceStandard::SendToControlDevice(...,&param) < 0)
    return 0;
memcpy(Buffer, param.BusGetSetData.Buffer,
       param.BusGetSetData.ResultLength);  // no bounds check
```
After:
```c
ResultLength = param.BusGetSetData.ResultLength;
if (ResultLength > Length)
    return 0;                // new guard – abort on overflow
memcpy(Buffer, param.BusGetSetData.Buffer, ResultLength);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Caller component -> BusInterfaceStandard::GetBusData(...,Length)
  -> SendToControlDevice()  (malicious driver sets large ResultLength)
  -> unchecked memcpy overruns Buffer
  -> caller reads back Buffer and gains leaked heap data.

Attack Vector
--------------------------------------------------------------------
A locally authenticated attacker loads or compromises a UMDF bus
driver running in the WUDFHOST process, or uses an existing driver
interface, then issues GetBusData with a deliberately undersized
Length.  The malicious driver returns an inflated ResultLength,
triggering the overflow and leaking process memory to the caller.

Patch Description
--------------------------------------------------------------------
1. Inserted explicit comparison:
       if (ResultLength > Length) return 0;
   before copying data in GetBusData().
2. Replaced home-grown output-buffer retrieval paths in
   RetrieveClientBuffers / RetrieveBuffers with a common helper that
   returns an error if any individual buffer retrieval fails, and
   sets m_ClientBuffer.Valid only on success.
3. Updated trace-logging helpers (WPP_SF_qdd_0 -> WPP_SF_qLd) –
   cosmetic.

Security Impact
--------------------------------------------------------------------
Prior to the fix a malicious local component could read up to 256
bytes of WUDFHOST heap memory per call, potentially disclosing
kernel object addresses, pointers, or other sensitive data that may
facilitate further exploitation.  Although the primitive is a write
past the end of the destination buffer, Microsoft classified the
issue as Information Disclosure because the attacker controls the
recipient buffer and primarily gains access to data, not code
execution.

Fix Effectiveness
--------------------------------------------------------------------
The added ResultLength > Length guard converts the copy to a strictly
size-checked operation, eliminating the overflow.  The revised Irp
helpers further prevent stale pointers from being exposed.  No new
paths bypassing the check are visible in the diff, so the patch is
considered effective.
