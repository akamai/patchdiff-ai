{'date': 1752036256.3771136, 'change_count': 2, 'cve': 'CVE-2025-48811', 'confidence': 0.17, 'kb': 'KB5062553', 'file': 'vertdll.dll', 'patch_store_uid': '140b6365-8efd-482c-91c1-75c13615cfcb'}
--------------------------------------------------------------------
CVE-2025-48811 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
vertdll.dll (VBS Enclave run-time), function
RtlpEnterCriticalSectionContended

Vulnerability Class
--------------------------------------------------------------------
CWE-353  Missing Support for Integrity Check (trusting untrusted
shared-memory content)

Detailed Root Cause Analysis
--------------------------------------------------------------------
RtlpEnterCriticalSectionContended is the enclave implementation of the
NT critical-section slow-path.  Before the patch the routine decided
whether a critical section should use the adaptive spin logic by
reading the system logical-processor count from absolute address
0x7FFE036A:

    if (MEMORY[0x7FFE036A] > 1)
        { use spin counters }

0x7FFE0000 – 0x7FFE0FFF is the user-mode shared data page that the
kernel maps read-only for normal processes.  Inside a VBS enclave this
page is **not measured or protected**; the host process (running
outside the enclave and therefore untrusted) supplies the backing
page during the #VE (#PF-intercept) that occurs on first access.

Because the enclave code treated the value at 0x7FFE036A as trusted, a
malicious host could return any 16-bit value.  When the value is forced
>1, two effects follow:

1.  v4 is set, enabling the path that continuously adjusts the high
    byte and the lower 24 bits of the SpinCount/Flags field at offset
    +0x20 of the RTL_CRITICAL_SECTION struct referenced by a1.

2.  v3 is loaded with the lower 24 bits of the same field and is later
    incremented/decremented without any bounds check when v4 is true.

Because the critical-section struct is supplied by the untrusted host
(the enclave merely receives a pointer), unverified arithmetic on that
field allows the host to make the enclave **write an attacker-chosen
24-bit value** back to a1+0x20.  The struct resides outside the
enclave, so the write crosses the trust boundary and constitutes an
integrity violation.  If the host maps that memory over sensitive data
(e.g., another enclave page or a host-controlled object) the enclave
performs a privileged write on behalf of the attacker, enabling local
privilege escalation.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable read – trusts shared user data
if (MEMORY[0x7FFE036A] > 1u)
{
    v3 = *(_QWORD *)(a1 + 32) & 0xFFFFFFi64;
    v4 = (*(_QWORD *)(a1 + 32) & 0x2000000i64) != 0;
}

// patched read – explicit enclave helper marks data as untrusted
if (*(_WORD *)(RtlEnclaveUntrustedSharedUserData + 874) > 1u)
{
    v3 = *(_QWORD *)(a1 + 32) & 0xFFFFFFi64;
    v4 = (*(_QWORD *)(a1 + 32) & 0x2000000i64) != 0;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Host process enters a VBS enclave that subsequently calls
   RtlEnterCriticalSection on a host-allocated RTL_CRITICAL_SECTION.
2. The first attempt to acquire the lock fails, redirecting to
   RtlpEnterCriticalSectionContended.
3. Function dereferences 0x7FFE036A; page fault exits enclave (#VE).
4. Host returns crafted page with NumberOfProcessors > 1.
5. Enclave sets v4=TRUE and later writes manipulated value v10 back to
   a1+0x20, modifying host memory with enclave trust level.

Attack Vector
--------------------------------------------------------------------
Local, low-privilege attacker able to create or load a VBS enclave
(gaining code-execution inside it) and control the memory layout
outside the enclave.  By supplying a forged shared-data page the
attacker provokes an unchecked write from the enclave into arbitrary
host-process memory, leading to privilege escalation.

Patch Description
--------------------------------------------------------------------
The single-line change replaces the hard-coded absolute pointer
0x7FFE036A with RtlEnclaveUntrustedSharedUserData + 874.  The helper
symbol resolves, at build time, to the enclave API that performs the
mandatory integrity segregation between trusted enclave pages and
untrusted host-supplied pages.  Effectively the patch:

1. Uses the documented enclave gateway for shared user data.
2. Explicitly labels the data as untrusted, disabling any write-backs
   based on that information.
3. Removes the implicit trust of host-controlled content.

Security Impact
--------------------------------------------------------------------
Before the fix a host process could coerce enclave code to issue an
arbitrary 24-bit write outside the enclave boundary, enabling local EoP
from user-mode to the more-privileged enclave context or to SYSTEM if
a privileged enclave is loaded.

Fix Effectiveness
--------------------------------------------------------------------
The new access path funnels the read through the enclave runtime, which
puts the page in the untrusted mapping and forbids speculative use of
its contents for integrity-sensitive decisions.  No direct dereference
of 0x7FFEXXXX survives, eliminating the primitive used for the attack.
Regression or alternative bypass is not visible in the diff.
