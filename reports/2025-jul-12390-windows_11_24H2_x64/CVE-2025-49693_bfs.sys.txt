{'date': 1752036206.8688338, 'patch_store_uid': '5456a6ce-eca9-4fc6-9a2d-36e0f655bea2', 'change_count': 3, 'kb': 'KB5062553', 'cve': 'CVE-2025-49693', 'confidence': 0.27, 'file': 'bfs.sys'}
--------------------------------------------------------------------
CVE-2025-49693 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Brokering File System filter driver (bfs.sys) – policy entry
management routines BfsInsertPolicyEntry, BfsInsertNotPresentPolicyEntry
and their consumer BfsCheckAndApplyPolicy.

Vulnerability Class
--------------------------------------------------------------------
Double Free / Use-after-free – CWE-415

Detailed Root Cause Analysis
--------------------------------------------------------------------
Both entry-insertion helpers allocate private copies of two caller
supplied SIDs:

  Pool2 – caller SID (SourceSid)
  v8/v5  – AppContainer SID (Sid)

The copies are made with ExAllocatePool2 + RtlCopySid and then stored
inside the freshly allocated BFS_POLICY_ENTRY structure
(offset +0x18/+0x20).

Old logic subsequently reaches the common function epilogue that frees
any non-NULL local allocations:

    if (Pool2) ExFreePoolWithTag(Pool2,0);
    if (v8)    ExFreePoolWithTag(v8,0);

Because ownership of the buffers had already been transferred to the
policy entry, this first free leaves dangling pointers inside the entry.
When the entry reference count later drops to zero
(BfsDereferencePolicyEntryEx) the same pointers are released a second
time, corrupting the kernel pool.  The identical pattern exists in
BfsInsertNotPresentPolicyEntry.

The bug is only reachable after a successful insertion (status
STATUS_SUCCESS) and therefore can be driven from user mode by:
  1. Creating a valid policy entry (first free happens in epilogue)
  2. Triggering any code path that destroys the entry
     (second free inside BfsDereferencePolicyEntryEx)
This yields reliable memory corruption in ring-0.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
*(_QWORD *)(Entry+0x18) = Pool2;
*(_QWORD *)(Entry+0x20) = v8;
...
ExReleasePushLockExclusiveEx(...);
...
if (Pool2)
    ExFreePoolWithTag(Pool2,0);   // 1st free
if (v8)
    ExFreePoolWithTag(v8,0);      // 1st free
// 2nd free occurs when Entry is dereferenced later
```
```c
// after
*(_QWORD *)(Entry+0x18) = Pool2;
*(_QWORD *)(Entry+0x20) = v8;
if (Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage_1())
    Pool2 = 0;                   // ownership transferred – prevent free
if (Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage_1())
    v8    = 0;                   // same for second SID
...
if (Pool2)
    ExFreePoolWithTag(Pool2,0);   // no longer executed twice
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User-mode client issues IOCTL that eventually calls
   BfsInsertPolicyEntry / BfsInsertNotPresentPolicyEntry.
2. Function allocates SID copies, builds BFS_POLICY_ENTRY and inserts it
   into the hash table (first reference increment).
3. Epilogue frees local SID pointers (first free).
4. Later, BfsDereferencePolicyEntryEx is called when entry is removed;
   it frees the same SID buffers again (second free) -> pool corruption.

Attack Vector
--------------------------------------------------------------------
Any local user able to communicate with the Brokering File System filter
(IOCTL or named pipe undocumented interface) can trigger the faulty
insert-and-destroy sequence to cause a kernel double free, leading to
arbitrary code execution in kernel mode and privilege escalation.

Patch Description
--------------------------------------------------------------------
The fix nulls the local variables that hold the SID buffer addresses
immediately after the pointers are stored in the policy entry.  This
prevents the epilogue from freeing memory that is now owned by the
entry.  Auxiliary changes:
  • Same mitigation applied to BfsInsertNotPresentPolicyEntry.
  • BfsCheckAndApplyPolicy updated to cope with the new entry type and
    additional feature-flag checks.
  • Error-handling labels shuffled but semantics unchanged.
No structural changes to reference counting or hash-table logic were
needed.

Security Impact
--------------------------------------------------------------------
Exploiting the double free allows an authenticated but unprivileged
attacker to achieve kernel-mode pool corruption, resulting in local
privilege escalation (LPE).  The flaw executes in the filter driver
context, so successful exploitation yields SYSTEM privileges.

Fix Effectiveness
--------------------------------------------------------------------
By clearing the local pointers once ownership is transferred, the
patched driver guarantees each SID buffer is released exactly once.
Static review shows all exit paths honour the new NULL assignments, so
no remaining double-free on these objects is possible.  No additional
side effects were introduced, and reference counts remain balanced.
