{'kb': 'KB5062553', 'patch_store_uid': '98639a85-78bf-46dc-98f7-63d18b92622c', 'file': 'ssdpsrv.dll', 'date': 1752036212.1162534, 'change_count': 16, 'cve': 'CVE-2025-47976', 'confidence': 0.25}
--------------------------------------------------------------------
CVE-2025-47976 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows SSDP Service (ssdpsrv.dll)
Most affected code lives in class CSsdpNotifyRequestManager and the
RPC entry-points GetNotificationRpc / WakeupGetNotificationRpc /
RemoveSyncHandle etc.

Vulnerability Class
--------------------------------------------------------------------
Use-After-Free (CWE-416) that can be driven from a low-privileged
client through the SSDP RPC interface, resulting in local elevation of
privilege.

Detailed Root Cause Analysis
--------------------------------------------------------------------
SSDP maintains several singly-linked lists that hold active
CSsdpNotifyRequest objects and their associated synchronisation
semaphores:
  offset +0x28  : main request list   (old)
  offset +0x58  : secondary list      (old)
  offset +0x88  : rundown list        (new)
  offset +0xB8  : deferred-free list  (new)
Each list is supposed to be protected by its own critical section, but
in the pre-patch build only two critical sections existed (at +0x00 and
+0x30).  Multiple threads therefore traversed and modified the same
lists under inconsistent locking.

•  GetNotificationRpc() walks the request list looking for the element
   whose embedded semaphore pointer (Request+0xD0) matches the HANDLE
   supplied by the caller.  It holds CS at offset +0x00 while
   dereferencing list nodes located at offset +0x28.

•  RemoveSyncHandle() ultimately calls
   CSsdpNotifyRequestManager::HrRemoveInternal() with the same HANDLE.
   HrRemoveInternal() unlinks the request node and immediately frees it
   (DXGPROCESSSHAREDACCESS::`scalar deleting destructor') while holding
   **a different critical section** (+0x30).

Because the enumerator and the deleter do not use the same lock, the
following inter-thread sequence is possible:
  T1: GetNotificationRpc() obtains pointer p to node N, releases +0x00
      and is pre-empted before using p.
  T2: RemoveSyncHandle() acquires +0x30, removes N, frees the memory
      and releases +0x30.
  T1: resumes and dereferences p (now freed) -> UAF on heap memory that
      can be attacker-controlled.

A local attacker who owns a notification handle can therefore cause the
service (running as LocalService or SYSTEM depending on configuration)\n to execute on freed memory and gain code-execution in the service
context.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// pre-patch GetNotificationRpc (excerpt)
EnterCriticalSection(&CSsdpNotifyRequestManager::s_instance);
v8 = &qword_18004DB28;          // list head @ +0x28
...
LeaveCriticalSection(&CSsdpNotifyRequestManager::s_instance);
```
```c
// pre-patch HrRemoveInternal (excerpt)
EnterCriticalSection((LPCRITICAL_SECTION)this); // +0x00
v11 = (void **)((char *)this + 40);             // list head @ +0x28
...
LeaveCriticalSection((LPCRITICAL_SECTION)this);
...
DXGPROCESSSHAREDACCESS::`scalar deleting destructor'(v9, v8); // free
```
(The same node is walked under one lock and freed under another.)
```
// post-patch HrRemoveInternal
EnterCriticalSection((LPCRITICAL_SECTION)((char *)this + 48)); // new CS
v11 = (void **)((char *)this + 88);            // new list head
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Client process
  └─► RPC call RemoveSyncHandle(handle)
         └─► HrRemoveInternal()  (frees CSsdpNotifyRequest)

Thread in SSDPSRV handling notifications
  └─► GetNotificationRpc(handle)
         └─► dereferences freed CSsdpNotifyRequest ➜ crash / exploit

Attack Vector
--------------------------------------------------------------------
Any authenticated local user owning a notification semaphore obtained
via InitializeSyncHandle() can race the SSDP service by:
1. Spawning two threads.
2. Thread-A: loops GetNotificationRpc(h).
3. Thread-B: calls RemoveSyncHandle(&h) to force object destruction.
Heap spraying during the race yields controllable UAF of an object that
contains virtual function pointers, enabling EOP.

Patch Description
--------------------------------------------------------------------
1. Added dedicated critical sections and list heads (+0x48, +0x90,
   +0xC0) and initialised them in the constructor; destructor updated.
2. All list enumeration functions (GetNotificationRpc,
   FIsSearchResponseInListNotify, HrCheckListNotifyForAliveOrByebye,
   etc.) now lock the same critical section (+0x48) that the remover
   uses, eliminating the race.
3. A new rundown list (+0xB8) is used; objects are moved there and
   freed only after all concurrent users have left.
4. Validation helpers IsNotifySemaphoreInList() added to reject stale
   or attacker-supplied HANDLEs before use.
5. Numerous RPC stubs now early-return ERROR_INVALID_PARAMETER (87) if
   the semaphore is not in the manager list.

Security Impact
--------------------------------------------------------------------
Pre-patch, a local attacker could obtain code execution in the SSDP
service (running with service privileges) by exploiting the UAF.  This
allows privilege escalation from a standard user to LocalService /
SYSTEM, depending on deployment.

Fix Effectiveness
--------------------------------------------------------------------
The fix introduces proper list ownership checks and enforces single
locking discipline, eliminating the dangling-pointer race window.  All
RPC entry points validate caller-supplied handles.  Unless other
unprotected lists remain, the UAF condition is fully mitigated.
