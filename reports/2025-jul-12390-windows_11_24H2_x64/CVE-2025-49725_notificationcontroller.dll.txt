{'date': 1752037649.194947, 'kb': 'KB5062553', 'change_count': 6, 'patch_store_uid': '0914d6e7-7ad7-4bc6-b8a1-89f9fb113719', 'cve': 'CVE-2025-49725', 'confidence': 0.23, 'file': 'notificationcontroller.dll'}
--------------------------------------------------------------------
CVE-2025-49725 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Notification Platform – notificationcontroller.dll,   
particularly wil::details helper templates used for automatic    
resource management of kernel objects (CloseHandle / thread-pool   
timers) and feature-flag bookkeeping code.

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use After Free (dangling pointer to kernel   
_threadpool timer / handle object)

Detailed Root Cause Analysis
--------------------------------------------------------------------
The vulnerable helper lives in the wil::details::unique_storage<> 
template which owns kernel objects and frees them inside reset().  
Two instantiations are relevant:                                   
  • unique_storage<resource_policy< void*, &CloseHandle >>         
  • unique_storage<resource_policy<_TP_TIMER*, &DestroyThreadPool  
    Timer>>                                                        
                                                                  
BEFORE the patch both reset() overloads invoked an *incorrect*     
cleanup routine for the currently stored pointer:                  
  – For generic HANDLEs it called ReleaseMutex() instead of        
    CloseHandle().                                                 
  – For thread-pool timers it called CloseHandle() instead of      
    DestroyThreadPoolTimer().                                      
                                                                  
DestroyThreadPoolTimer() is special – it blocks until all pending  
callbacks have completed and then frees the _TP_TIMER structure.   
CloseHandle() merely drops the kernel handle reference and         
immediately frees the backing object.  Any callback already       
queued by SetThreadpoolTimer keeps a raw pointer to the *same*     
_TP_TIMER.  Therefore:                                             
 1. reset() closes the handle while callbacks are still pending.   
 2. The _TP_TIMER memory is returned to the allocator.             
 3. A queued callback later fires and dereferences the stale       
    pointer, yielding a classic UAF in the Notification            
    Controller service.                                            
                                                                  
Because notificationcontroller.dll runs inside a privileged        
service, an attacker who can trigger notification timers can       
arrange controlled heap re-allocation of the freed slab and gain   
arbitrary code execution in the service context (EoP).            
                                                                  
Additional mishandling (ReleaseMutex vs CloseHandle) follows the   
same pattern: a wrong API is executed for the underlying object,   
producing dangling references or double release depending on the   
object type.                                                       

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before – wrong cleanup for timer
v2 = *this;                    // current _TP_TIMER*
if (*this) {
    wil::last_error_context lec;
    wil::details::CloseHandle(v2);   // WRONG
}
*this = ptr;                  // pointer now dangling
```
```c
// after – correct
v2 = *a1;
if (*a1) {
    wil::last_error_context lec;
    wil::details::DestroyThreadPoolTimer<wil::details::SystemThreadPoolMethods,0>::Destroy(v2); // RIGHT
}
*a1 = a2;
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-mode code -> Notification APIs ->                             
NotificationPacketProcessor::CreateNotificationItem() ->           
unique_storage<_TP_TIMER>::reset()                                 
  (object replaced or cleared)                                     
→ CloseHandle incorrectly frees _TP_TIMER                          
→ previously queued timer callback executes → deref freed memory   
→ UAF leads to controlled write / RIP hijack.                      

Attack Vector
--------------------------------------------------------------------
Local, low-privileged attacker crafts notifications that create    
thread-pool timers, forces a reset() path (e.g. by dismissing the  
notification) while still having pending callbacks, and heap-sprays
replacement data so that the subsequent callback executes attacker
controlled memory in the Notification Service (running as SYSTEM).

Patch Description
--------------------------------------------------------------------
1. Replaced ReleaseMutex() with CloseHandle() for generic handle   
   resource_policy.                                                
2. Replaced CloseHandle() with DestroyThreadPoolTimer() for        
   _TP_TIMER resource_policy, guaranteeing cancellation and safe   
   memory reclamation.                                             
3. Minor type/logic adjustments in feature-flag helpers; these do  
   not affect the UAF but were cleaned up together.                

Security Impact
--------------------------------------------------------------------
Prior to the patch a non-admin user could achieve a use-after-free 
inside a SYSTEM service, enabling elevation of privilege or        
service crash (DoS).  The vulnerability is rated Elevation of      
Privilege (EoP).                                                   

Fix Effectiveness
--------------------------------------------------------------------
The corrected code now calls the exact destruction routine that    
performs synchronized teardown of thread-pool timers and proper    
handle closing, removing the dangling pointer window.  No further  
paths call the wrong API, so the UAF condition is eliminated.      
Static inspection shows no remaining mismatched resource frees;    
therefore the patch is considered effective.                       
