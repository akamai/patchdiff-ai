{'date': 1752037573.05667, 'change_count': 10, 'kb': 'KB5062553', 'confidence': 0.33, 'cve': 'CVE-2025-49691', 'patch_store_uid': '4ef1e8c5-21bc-43d3-be26-c42eb1322e57', 'file': 'miradisp.dll'}
--------------------------------------------------------------------
CVE-2025-49691 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
miradisp.dll – Miracast input back-channel (UIBC) network listener
class CUibcNetworkListener (Windows Media Wireless Display stack)

Vulnerability Class
--------------------------------------------------------------------
Heap–based buffer overflow (CWE-122)

Detailed Root Cause Analysis
--------------------------------------------------------------------
The Miracast listener keeps one receive buffer that is permanently
allocated at *this+15 (size 0xFFFF = 65535 bytes).  The current fill
level of that buffer is stored at *this+32.

On every asynchronous socket completion the callback
CUibcNetworkListener::OnReceive is executed.  Before the patch the code
performed the following steps:

1.  v51 ← number of bytes just received from the network
2.  v13 ← *this+32  +  v51                         (line ➊)
3.  ParseUibcPacket(buffer,v13,…) is called.
4.  When ParseUibcPacket returns STATUS_BUFFER_OVERFLOW (-2147024774)
    the implementation copies the still-unparsed data to the start of
    the buffer:

    memmove(buffer, cursor, v13);                  (line ➋)
    *this+32 = v13;                                (line ➌)

Lines ➋/➌ are executed **without any size validation**.  If v13 is
larger than the real buffer length (0xFFFF) memmove writes beyond the
heap allocation, corrupting adjacent memory.

Because v13 is computed from externally controlled data (the peer can
send an arbitrarily large TCP payload) the overflow is fully
attacker-controlled.  A malicious Miracast source situated on the same
Wi-Fi network can therefore overwrite heap metadata or other
application objects inside the Media foundation process that hosts
miradisp.dll, ultimately gaining remote code execution.

Patch Behaviour
--------------------------------------------------------------------
The patched code inserts two independent guards that eliminate the
overflow condition:

 • After computing the prospective length (v13) the value is **clamped
   to 0xFFFF** when it would exceed the buffer capacity and an
   RtlLogUnexpectedCodepath() entry is issued.

 • Before every packet is consumed the header field
   HIWORD(packet_length) is validated; if it is larger than the number
   of buffered bytes it is truncated to the available size, again with
   a diagnostic log.

In addition, OnAccept now resets *this+32 to 0 when the connection is
established, guaranteeing that no stale length survives across
sessions.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
v13 = *((DWORD *)this + 32) + v51;              // ➊ unchecked
...
memmove_0(v40, v12, v13);                       // ➋ overflow
*((DWORD *)this + 32) = v13;                    // ➌

// after
v13 = v71 + *((DWORD *)this + 32);
if (v13 > 0xFFFF) {                             // clamp
    v13 = 0xFFFF;
    RtlLogUnexpectedCodepath(...);
}
...
if (HIWORD(v76[0]) > v13) {                     // header check
    v76[0] = (v13 << 16) | LOWORD(v76[0]);
    RtlLogUnexpectedCodepath(...);
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker establishes a Miracast session (OnAccept).
2. Attacker sends >64 kB of UIBC data in a single TCP frame.
3. Async read completes; OnReceive is invoked with v51 > 0xFFFF.
4. v13 becomes larger than 0xFFFF (➊).
5. ParseUibcPacket fails with ERROR_MORE_DATA.
6. memmove_0 copies v13 bytes into the fixed 64 kB heap buffer (➋)
   – heap corruption occurs.

Attack Vector
--------------------------------------------------------------------
Adjacent-network attacker controlling the Miracast source can transmit
crafted UIBC packets over the established TCP channel to the Windows
Miracast sink.

Patch Description
--------------------------------------------------------------------
• Hard upper bound on accumulated buffer length (0xFFFF).
• Per-packet length field validated against current buffer content.
• Logging via RtlLogUnexpectedCodepath for any truncation event.
• Buffer-length reset on new connections.
• Fixes are protected by a feature flag but compiled in-place.

Security Impact
--------------------------------------------------------------------
Prior to the fix a remote attacker could trigger a heap-based buffer
overflow in a SYSTEM process hosting the Wireless Display stack,
leading to denial-of-service or arbitrary code execution in the
context of the Windows Audio/Video service (RCE, adjacent network).

Fix Effectiveness
--------------------------------------------------------------------
The added clamping and header validation ensure that no copy/memmove
operation can exceed the 0xFFFF-byte receive buffer, completely
removing the out-of-bounds write primitive.  No alternative data path
capable of restoring the vulnerability was observed in the patched
code.
