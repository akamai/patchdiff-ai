{'date': 1752036218.6311412, 'patch_store_uid': '6ec70d6d-1a31-46eb-8cd5-59303ae7b690', 'confidence': 0.23, 'kb': 'KB5062553', 'change_count': 4, 'file': 'afd.sys', 'cve': 'CVE-2025-49661'}
--------------------------------------------------------------------
CVE-2025-49661 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Ancillary Function Driver for WinSock (afd.sys) – routines
handling RPC-marshalled DNS record lists, mainly
MarshalRpcRecordListToDnsRecordList_New() and its callers
WskKnrExtractRpcResults() / AfdConnect().

Vulnerability Class
--------------------------------------------------------------------
Untrusted pointer dereference / kernel pool corruption (CWE-822).

Detailed Root Cause Analysis
--------------------------------------------------------------------
Inbound DNS responses obtained through the velocity-DNS RPC path are
returned to kernel mode as an array of DNS_RPC_RECORD structures.  The
original MarshalRpcRecordListToDnsRecordList_New(void **ListHead)
walked this user-controlled list and, for each entry:

1.  Looked at the RR type and at bit 0x4000 of the Flags field to decide
    whether MarshalRpcRecordToDnsRecord() or
    RpcRecalculateDataLength() should be called.
2.  Unconditionally dereferenced or freed the following structure
    members that come directly from the RPC buffer:
       * Record->pData (qword index +4)
       * Record->pNext   (qword index +0) during list relinking
3.  When the conversion path was taken it executed
       ExFreePoolWithTag(record->pData, 'DnsR')
    **without first validating that pData really points to pool
    memory**; the same address was later written back into the list.

Because no consistency checks were performed, an attacker-supplied DNS
record could lie about

* whether variable data is present (HasVariableData vs flag 0x4000),
* whether nested owner names exist, or
* whether RR types 249 / 250 (OPT/RRSIG) legally allow external
  pointers.

Supplying a forged record whose flag combination causes the old code to
enter the "variable data" path while pData contains an arbitrary kernel
address makes the kernel call ExFreePoolWithTag() on that address and
later treat the same value as a valid list element.  This yields
arbitrary free / use-after-free, enabling local EoP.

The exploit chain is:
  user → Winsock → AFD → WskKnrExtractRpcResults() →
  MarshalRpcRecordListToDnsRecordList_New() → ExFreePoolWithTag(addr)

All steps run in kernel context, so a normal user only needs the ability
to trigger a DNS query that is satisfied through the velocity RPC
transport.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// old – no validation, will free attacker pointer
if (v8) {                           // flag 0x4000 set
    v4 = MarshalRpcRecordToDnsRecord(v5,&v12);  // may succeed
    *v12 = *v5;                    // copy header
    v10 = (void*)v5[4];            // pData from RPC
    if (v10)
        ExFreePoolWithTag(v10,'DnsR'); // <-- arbitrary free
    ExFreePoolWithTag(v5,'DnsR');
}

// new – added consistency and safety checks
if (g_fVelocityRpcMarshalFree) {
    if ((type-249)<=1 && *((DWORD*)rec+21))  FAIL;
    if (((flags>>13)&1) != (rec->pNext!=NULL)) FAIL;
    if (RecordHasNestedData(type) != expected) FAIL;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User application performs a crafted network/DNS operation.
2. Winsock sends velocity DNS RPC; kernel receives results in AFD.
3. WskKnrExtractRpcResults() hands the raw record list to
   MarshalRpcRecordListToDnsRecordList_New().
4. Old code frees / dereferences attacker-controlled pointer, corrupting
   kernel pool and allowing privilege escalation.

Attack Vector
--------------------------------------------------------------------
Any local account capable of issuing Winsock DNS queries (default) can
supply malicious RR data through the RPC channel and reach the vulnerable
code path, gaining SYSTEM privileges.

Patch Description
--------------------------------------------------------------------
The update makes three broad changes:
1.  Introduces global switch g_fVelocityRpcMarshalFree, enabled in
    DriverEntry(), to activate hardened behaviour.
2.  Adds strict per-record validation before any pointer dereference:
      • Type-specific check (types 249/250 must not contain pData)
      • Flag 0x2000 (nested owner names) and 0x4000 (variable data)
        must match the actual presence of the corresponding pointers.
3.  Reworks cleanup logic: if validation fails, records are freed with
    new helper Dns_RecordListRpcSafeFree(), which never touches pData
    when consistency checks failed, preventing arbitrary free.

Security Impact
--------------------------------------------------------------------
Prior to the fix, a local attacker could cause arbitrary kernel pool
free/dereference, leading to elevation of privilege (SYSTEM) or a kernel
crash.  The issue is now assigned CVE-2025-49661.

Fix Effectiveness
--------------------------------------------------------------------
The added invariant checks stop malformed records before any dangerous
pointer is touched, and the safe-free path prevents the release of
untrusted addresses.  Therefore the specific arbitrary free path is
closed.  Because the mitigation is gated by g_fVelocityRpcMarshalFree,
its correct initialisation is essential; with the feature enabled the
patch appears effective.
