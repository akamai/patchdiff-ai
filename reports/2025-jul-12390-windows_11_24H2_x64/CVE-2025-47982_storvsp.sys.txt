{'change_count': 2, 'cve': 'CVE-2025-47982', 'file': 'storvsp.sys', 'kb': 'KB5062553', 'confidence': 0.19, 'patch_store_uid': '414cbe0c-e398-454a-bd6e-f517b1fef2ce', 'date': 1752036209.8177946}
--------------------------------------------------------------------
CVE-2025-47982 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Storage VSP (storvsp.sys) kernel driver, specifically the
routine InsertEventEntryInLookUpTable that manages internal
"event-entry" bookkeeping structures.

Vulnerability Class
--------------------------------------------------------------------
Improper input validation that results in an index calculation
overflow / out-of-bounds write (CWE-20, CWE-833, CWE-787).

Detailed Root Cause Analysis
--------------------------------------------------------------------
The driver stores performance / telemetry statistics in a per-driver
hash table of EVENT_ENTRY objects.  InsertEventEntryInLookUpTable()
receives five parameters:
  a1 – context block
  a2 – event-id
  a3 – provider-id byte
  a4 – pointer to caller-supplied statistics block
  a5 – **caller-supplied element count** (number of 16-byte fields to
       merge)

Pre-patch logic treated a5 as an *unsigned* byte and used it directly
as the upper bound of the aggregation loop:
  do
  {
      ... use index v12 ...
  }
  while ((unsigned __int8)v12 < (unsigned int)a5 + 2);

v12 starts at 2, thus the loop processes (a5+2-2) == a5 iterations.
Because the driver never validates that a5 is less than the number of
16-byte field slots that were actually allocated inside the target
EVENT_ENTRY, an attacker can pass an arbitrarily large value (e.g.
0xFF).  The subsequent pointer arithmetic
    base = *(QWORD *)(EventEntry+16);
    dst  = base + 16*index;
walks past the allocated array and the helper _InterlockedAdd64/
CompareExchange64 routines then **write** to memory outside the object.

The overwrite occurs while the global shared spin-lock is held, so no
immediate crash is guaranteed; adjacent kernel objects or pointers can
be corrupted, enabling privilege escalation.

Patch actions show the intent clearly:
 • The fifth parameter type was changed from unsigned __int8 to *signed
   char* to disallow values >127.
 • The aggregation loop was rewritten to bound the index by **internal
   metadata (v21)** taken from the existing EVENT_ENTRY instead of by
   caller-supplied a5.
 • All arithmetic that adds an offset to the base pointer is now
   performed only after the new bound check.

Together these changes eliminate the attacker-controlled upper bound
and therefore the out-of-range memory access.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
LOBYTE(v12) = 2;
if (a5) {
    do {
        v19 = **(_QWORD **)(a4 + 16 * (unsigned __int8)v12);
        v20 = *(_QWORD *)(v16 + 16);
        v21 = *(unsigned __int8 *)(v20 + 16 * (unsigned __int8)v12 + 13);
        v22 = *(volatile signed __int64 **)(v20 + 16 * (unsigned __int8)v12);
        ... write through v22 ...
        LOBYTE(v12) = v12 + 1;
    } while ((unsigned __int8)v12 < (unsigned int)a5 + 2);
}

// after
v19 = 2;
if (a5) {
    do {
        AggregateField(base + 16 * v19,
                       **(_QWORD **)(a4 + 16 * v19),
                       *(UINT8 *)(base + 16 * v19 + 13));
        ++v19;
    } while (v19 < v21);      // v21 == internal field count
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker causes storvsp.sys to call InsertEventEntryInLookUpTable
   with a crafted statistics packet.
2. a5 is set to a large value (e.g. 0xFF).
3. Function hashes the entry and locates/creates the destination
   EVENT_ENTRY.
4. Aggregation loop iterates a5 times; index > real array size.
5. Pointer arithmetic steps outside EVENT_ENTRY; interlocked writes
   corrupt adjacent kernel memory.

Attack Vector
--------------------------------------------------------------------
Any local attacker able to invoke the Storage VSP IOCTL path (e.g.
Hyper-V guest or a privileged user-mode component on the host) can
supply a malicious statistics block with an excessive element count.
No special privileges are required beyond the ability to open the
storage VSP device handle.

Patch Description
--------------------------------------------------------------------
• Changed parameter type to signed char to halve the representable
  range.
• Replaced user-controlled loop bound (a5) with a trustworthy value
  extracted from the target EVENT_ENTRY (v21).
• Removed duplicate pointer/size calculations and centralized them in
  helper AggregateField().
• Minor refactoring of lock-handling code; no effect on semantics.

Security Impact
--------------------------------------------------------------------
Prior to the patch a local, authenticated attacker could trigger an
out-of-bounds 8-byte interlocked write in kernel context, leading to
arbitrary kernel memory corruption and therefore Elevation of Privilege
up to SYSTEM.

Fix Effectiveness
--------------------------------------------------------------------
The new bound check uses only internal, validated metadata and the
pointer arithmetic is unchanged; therefore the out-of-bounds condition
is no longer reachable.  No residual path keeps the attacker’s value
as an index, making the fix complete.
