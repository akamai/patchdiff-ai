{'patch_store_uid': 'ba2ef105-a8a4-4a54-9cea-df9f8d8b6528', 'date': 1752036411.4948244, 'kb': 'KB5062553', 'change_count': 5, 'cve': 'CVE-2025-49675', 'confidence': 0.26, 'file': 'ks.sys'}
--------------------------------------------------------------------
CVE-2025-49675 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows ks.sys – Kernel Streaming WOW Thunk Service driver.
Vulnerable routines reside in the MDL-cache path that prepares user
streaming IRPs:
  • CKsMdlcache::MdlCacheProcessPostProbeIrp()
  • CKsMdlcache::MdlCacheHandleThunkBufferIrp()
  • KsProbeStreamIrp()
  • CKsPin::Property_ConnectionState()

Vulnerability Class
--------------------------------------------------------------------
Use-after-free / dangling pointer (CWE-416).

Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  MdlCacheProcessPostProbeIrp() removes an entry that represents a
    KSPMDLCACHED_STREAM_POINTER from an internal doubly-linked list that
    is protected by a spin-lock (see original lines around LABEL_62).

2.  Depending on several flag combinations (0x8000, 0x10000, 0x1000
    etc.) the routine can fall into a failure branch where it calls
      ExFreePoolWithTag(v24, 'KSmd')
    thereby releasing the list entry’s pool memory.

3.  The address of the just-removed entry had been cached earlier in the
    local variable v7 and *always* copied back to the caller at function
    exit:
      *a4 = v7;            // <– returned unconditionally

4.  When the failure branch frees the entry, v7 is left untouched.  The
    caller therefore receives a pointer to freed pool memory and will
    treat it as a live KSPMDLCACHED_STREAM_POINTER on later use.  Every
    subsequent read/write through that pointer results in a use-after-
    free on non-paged pool.

5.  Trigger conditions are completely controllable from user mode via
    crafted KS streaming IRPs:
      – MasterIrp[12] must contain 0x8000 (MDL present) and/or
        0x1000/0x10000 flag mixtures.
      – The data length and secondary buffer fields steer the execution
        into the error branches that free the object but still return it.

6.  Because the object lives in kernel non-paged pool, reuse of the freed
    chunk grants an attacker arbitrary kernel read/write primitive and
    therefore local elevation of privilege.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch (simplified)
if (error_path) {
    ExFreePoolWithTag(v24, 'KSmd');   // free list entry
    v7 = (struct _KSPMDLCACHED_STREAM_POINTER *)(v22 - 10);
    ...
}
...
LABEL_77:
    *a4 = v7;        // returned even when freed
```
```c
// after patch
ExFreePoolWithTag(&v22[-4].Header.WaitListHead.Blink, 'KSmd');
p_Blink = 0;          // pointer explicitly nulled
...
LABEL_61:
    *a4 = p_Blink;   // safe – NULL when object was freed
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-mode → DeviceIoControl(IRP_MJ_DEVICE_CONTROL, KS streaming ioctl)
        → KsProbeStreamIrp()
        → CKsMdlcache::MdlCacheProbeStreamIrp()
        → CKsMdlcache::MdlCacheProcessPostProbeIrp()
             ‑ frees MDL-cache object but still returns its address
        → caller later dereferences *ReturnedStreamPointer → UAF

Attack Vector
--------------------------------------------------------------------
A local, authenticated attacker sends a crafted Kernel-Streaming IRP to
ks.sys (e.g.
IOCTL_KS_WRITE_STREAM/IOCTL_KS_READ_STREAM) containing specially chosen
fragment sizes and flag bits (0x8000 / 0x1000 / 0x10000).  The malformed
IRP forces the driver to enter the error branch that frees the MDL cache
entry yet returns its stale address.  Re-using the dangling pointer
allows arbitrary kernel memory access and privilege escalation.

Patch Description
--------------------------------------------------------------------
•  After every code path that frees a KSPMDLCACHED_STREAM_POINTER the
   patch resets the working variable (p_Blink) to NULL before the return
   value is propagated.
•  Additional length / flag sanity checks were added so that erroneous
   descriptors are rejected earlier, preventing the free-then-return
   sequence.
•  Similar pointer-nulling and stricter validation were applied to
   MdlCacheHandleThunkBufferIrp(), KsProbeStreamIrp(), and
   Property_ConnectionState() to harden adjacent paths.
•  Cosmetic refactoring (variable renaming, trace-ID changes) but no
   functional impact.

Security Impact
--------------------------------------------------------------------
Prior to the fix, a local user could reliably obtain a dangling kernel
pointer and reuse the freed non-paged-pool object, achieving arbitrary
read/write in kernel space and full SYSTEM privileges.  The flaw is
reachable without administrator rights.

Fix Effectiveness
--------------------------------------------------------------------
The patch removes the fundamental bug by ensuring that a freed object’s
address is never returned to the caller and by adding extra validation
that blocks the erroneous control flow.  No obvious new dangling pointer
paths remain; therefore the fix is considered effective.
