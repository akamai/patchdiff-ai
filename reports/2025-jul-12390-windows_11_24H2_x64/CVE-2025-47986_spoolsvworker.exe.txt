{'confidence': 0.24, 'patch_store_uid': '90c79bb9-c311-42d0-967c-20ed5bb84c1d', 'date': 1752037744.894354, 'file': 'spoolsvworker.exe', 'change_count': 40, 'cve': 'CVE-2025-47986', 'kb': 'KB5062553'}
--------------------------------------------------------------------
CVE-2025-47986 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Printing Sub-system – spoolsvworker.exe (Universal Print
Management Service) RPC async handlers and helper routines.

Vulnerability Class
--------------------------------------------------------------------
Use-after-free (CWE-416) triggered by uncontrolled string length /
missing parameter validation.

Detailed Root Cause Analysis
--------------------------------------------------------------------
Many async RPC entry points (e.g. RpcAsyncEnumPrinters, EnumPorts,
AddMonitor, DeletePrinterKey, DeletePrinterDataEx, AddPrinter, etc.)
create a heap object derived from NThreadingLibrary::TWorkItem via
TFunction<N>::CreateInstance().

The original code blindly forwards caller-supplied UTF-16 strings
(printer name, port name, driver name, form name, monitor name, etc.)
into that CreateInstance() helper.  Internally these names are copied
into fixed-size stack/heap buffers (typically 0x104 or 0x400 WCHARs).
When a caller specifies an over-length string, the copy overruns the
allocation, corrupts the reference-count field that lives just before
/ after the buffer, and subsequently causes the work-item object to be
prematurely released while still queued – classic use-after-free.  A
local low-privilege client can then reclaim the freed chunk with
controlled data and execute code in the privileged
spoolsvworker.exe (runs as LocalSystem).

Affected structures / variables
• NThreadingLibrary::TWorkItem      – ref-count at offset +8
• TFunction<N>::CreateInstance()    – copies strings into embedded
  WCHAR[0x104]/[0x400] buffer without bounds checking
• RpcAsync* wrappers                – no wcslen/wcsnlen verification

Once the corrupted WorkItem is dequeued the worker thread calls the
virtual destructor through the overwritten vftable pointer, leading to
arbitrary code execution in kernel printing context and privilege
escalation.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// BEFORE (RpcAsyncEnumPrinters)
TFunction8<...>::CreateInstance(v12, a3, ... , a4);
// no length check on a3 / a4 (printer & server name)

// AFTER
if ( wil::details::FeatureImpl<...>::__private_IsEnabled(...)
     && a4 && wcsnlen(a4, 0x104) >= 0x104 ) {
    LOWORD(a3)=ERROR_INVALID_PARAMETER; /*87*/
    RpcAsyncCompleteCall(...);
    return; /* bail out safely */
}
```
(Almost every RpcAsync* entry received the same pattern – verify string
length against 0x104 or 0x400 and fail early.)

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Client (local user) → RPC endpoint "winspool" → any *RpcAsync*Xxx
procedure → overly long WCHAR string passed → TFunction<N>::CreateInstance
copies into small buffer → ref-count / vtable memory smashed → work item
freed while still referenced → later dereference in worker thread → UAF
and arbitrary code execution.

Attack Vector
--------------------------------------------------------------------
Local authenticated user, or sandboxed process able to call the
Spooler RPC interface, sends an async RPC request with an over-sized
printer / port / driver / form / monitor string (>0x104 or >0x400
WCHARs depending on call) to spoolsvworker.exe.

Patch Description
--------------------------------------------------------------------
1. Input sanitisation:
   • All vulnerable RpcAsync* entry points now validate each incoming
     UTF-16 string with wcsnlen(…, MAX) where MAX is 0x104 (260) or
     0x400 (1024) chars.  Oversized inputs immediately return
     ERROR_INVALID_PARAMETER (87) and no work-item is created.
2. Feature flag gating (Wil feature 1286131003): length checks are only
   active when the feature is enabled – the update turns it on.
3. Hardened helper routines (DeleteSymbolicLink(), FeatureImpl::
   GetCurrentFeatureEnabledState(), etc.) but the critical fix is the
   uniform parameter length validation.

Security Impact
--------------------------------------------------------------------
Prior to the patch a local attacker could reliably corrupt heap control
structures inside a privileged service, gaining SYSTEM privileges.
Because the service is always running, the issue enables a full local
Elevation of Privilege (EoP).

Fix Effectiveness
--------------------------------------------------------------------
The added wcsnlen() checks guarantee that no string longer than the
internal buffer is accepted, preventing the buffer overrun and the
subsequent ref-count corruption/UAF.  No further code paths were found
that bypass these guards; therefore the patch is considered effective
for the described vulnerability.
