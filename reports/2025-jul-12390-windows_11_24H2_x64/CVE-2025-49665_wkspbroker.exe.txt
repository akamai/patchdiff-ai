{'file': 'wkspbroker.exe', 'kb': 'KB5062553', 'date': 1752036349.628539, 'patch_store_uid': 'e43d5629-7223-4ec4-8d8e-51658717fd49', 'confidence': 0.23, 'cve': 'CVE-2025-49665', 'change_count': 25}
--------------------------------------------------------------------
CVE-2025-49665 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Workspace Broker (wkspbroker.exe) – COM broker responsible for
subscription/initialisation of remote-desktop workspaces.  Affected
routines are
  • CWorkspaceBroker::InitializeWorkspaceSubscription
  • CWorkspaceBroker::SubscribeToWorkspace
  • CWorkspaceBroker::InitializeWorkspaceThread
  • CWorkspaceBroker::SetupWorkspaceConfigThread

Vulnerability Class
--------------------------------------------------------------------
CWE-362: Race condition (improper locking of a shared object)
CWE-416: Use-after-free triggered by that race

Detailed Root Cause Analysis
--------------------------------------------------------------------
The broker launches background worker threads to complete long-running
operations.  Object lifetime is managed through the CWorkspaceBroker
COM reference count (AddRef = vtable[1], Release = vtable[2]).

BEFORE the patch the parent thread *did not* take an extra reference
prior to calling CreateThread.  The very first instruction executed in
both worker threads performs
    (*this->vftable[1])(this)   // AddRef
but this happens *after* the new thread is scheduled.  Between
CreateThread() returning and the AddRef in the worker, another client
thread may call Release() and drop the final reference, freeing the
object.  When the worker eventually starts it dereferences a dangling
pointer – classic UAF.  Memory corruption is under attacker control
because the attacker controls both the timing window and object
contents released back to the pool, enabling elevation of privilege to
SYSTEM (the broker’s security context).

Patch changes show that a new WIL feature flag
Feature_2578215227 (internal) governs an updated lifetime scheme:
  • Parent thread now executes vtable[1] (AddRef) *before* the
    CreateThread call.
  • If thread creation fails the extra reference is balanced via
    vtable[2] (Release).
  • In the worker threads the initial AddRef is skipped when the flag
    is on, so the reference count remains balanced (AddRef in parent /
    Release in worker).

By holding the reference through the vulnerable window the object
cannot be freed prematurely, eliminating the race that led to the
use-after-free.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// BEFORE (InitializeWorkspaceSubscription)
Thread = (IStream*)CreateThread(..., this, ...);
// no AddRef beforehand

// Worker (InitializeWorkspaceThread)
(*(void (__fastcall **)(char *))(*(_QWORD *)Parameter + 8))(Parameter); // AddRef
...
(*(void (__fastcall **)(char *))(*(_QWORD *)Parameter + 16))(Parameter); // Release
```
```c
// AFTER
if (FeatureEnabled)
    (*((void (__fastcall **)(LPSTREAM *))*this + 1))(this); // AddRef
Thread = CreateThread(...);
if (!Thread)
    (*((void (__fastcall **)(LPSTREAM *))*this + 2))(this); // Release

// Worker
if (!FeatureEnabled)
    AddRef(this);   // only when the parent did not
Release(this);      // always executed at thread end
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Client process -> InitializeWorkspaceSubscription / SubscribeToWorkspace
  -> CreateThread launches InitializeWorkspaceThread /
     SetupWorkspaceConfigThread
     (gap: object has no extra ref)
  -> Another client calls Release() -> object deleted
  -> Worker thread scheduled -> accesses freed memory (UAF)

Attack Vector
--------------------------------------------------------------------
Any local user that can call the Workspace Broker COM interface or the
associated RPC endpoint.  By rapidly creating a subscription and
immediately releasing the obtained broker interface the attacker wins
the race and forces the worker thread to operate on freed memory,
leading to code execution in the high-privilege broker process.

Patch Description
--------------------------------------------------------------------
1. Introduced WIL feature guard 2578215227.
2. Parent routines now AddRef the broker object before spawning worker
   threads and undo that reference only on thread-creation failure.
3. Worker threads skip the redundant AddRef when the feature is
   enabled, retaining a balanced AddRef/Release pair.
4. All diagnostic trace GUIDs updated (cosmetic).

Security Impact
--------------------------------------------------------------------
The race made it possible to achieve a use-after-free in a SYSTEM
process, giving an attacker arbitrary code execution in Session 0 and
thus full local privilege escalation (EoP).  No external mitigation
existed.

Fix Effectiveness
--------------------------------------------------------------------
Holding a reference across thread creation completely removes the
window in which the object could be freed.  Because both entry points
now unconditionally perform the AddRef under the feature flag, and the
worker threads still Release, reference counting is correct and the
UAF path is closed.  No obvious bypass remains in the modified code.