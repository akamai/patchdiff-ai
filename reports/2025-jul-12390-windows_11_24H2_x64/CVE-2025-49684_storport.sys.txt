{'cve': 'CVE-2025-49684', 'patch_store_uid': '7c8f520c-dd3a-4dd7-9ec9-5d381bf153a0', 'file': 'storport.sys', 'change_count': 301, 'date': 1752036878.5295446, 'confidence': 0.18, 'kb': 'KB5062553'}
--------------------------------------------------------------------
CVE-2025-49684 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Storage Port Driver (storport.sys) – code that
constructs symbolic-link names (StorDeleteSymbolicLink) and
compatible-ID strings for SCSI / NVMe devices
(NvmeNamespaceGetCompatibleIds) and the driver-local
implementation of the STRSAFE helper StringCchPrintfW.


Vulnerability Class
--------------------------------------------------------------------
CWE-126: Buffer Over-read / Information Disclosure


Detailed Root Cause Analysis
--------------------------------------------------------------------
The driver builds several variable-length strings in stack or pool
buffers and relies on an in-module copy of the STRSAFE routine
StringCchPrintfW to perform the formatted output.  Two independent
bugs combine to give an attacker a controllable one- or two-wide-
character read past the end of an allocated buffer.

1.  Poor parameter validation inside the local
    StringCchPrintfW implementation
    -------------------------------------------------------------
    The original helper accepted the caller-supplied destination
    pointer and character count without any checks apart from a
    superficial   if (cchDest-1 <= 0x7FFFFFFE)  test.  No attempt
    was made to verify that the pointer was valid, that the count
    was non-zero, or that the pointer/count pair really described
    an accessible buffer.  Consequently any subsequent call to
    _vsnwprintf could legally probe beyond the intended region.

2.  Off-by-one accounting in NvmeNamespaceGetCompatibleIds
    ------------------------------------------------------
    The routine allocates a 76-byte (38 WCHAR) non-paged pool
    buffer and fills it with two strings separated by a single
    NUL:

        "NVME\\Disk\0RAW\0"   (NVMe path)
        "SCSI\\Disk\0RAW\0"    (SCSI path)

    After the first call to RtlStringCchPrintfExW the end-pointer
    ppszDestEnd is advanced by one character ( ++ppszDestEnd ),
    but pcchRemaining is **not decremented**.  The second
    printf therefore believes one more WCHAR is available than
    actually fits in the 38-character buffer.  _vsnwprintf writes
    the mandatory final NUL at offset 38, which lies just beyond
    the allocation.

    Immediately afterwards RaFixupIds walks the buffer until it
    encounters a double-NUL terminator, copying every WCHAR into
    an output buffer that will eventually be returned to the
    requesting user-mode caller (e.g. via a SCSI query IOCTL).
    The word at offset 38 therefore leaks whatever happened to be
    located in the adjacent pool slot at the time of the call – a
    classical kernel information disclosure.

    The same error path can also be hit when the first printf
    fails (e.g. because of a truncated format string).  In that
    case the uninitialised ppszDestEnd is still dereferenced,
    causing _vsnwprintf to read arbitrary kernel memory.

The patch fixes both contributing issues.  The new
RtlStringCchPrintfW_0 wrapper first calls StringValidateDestW,
which rejects invalid or user-mode pointers and zero-length
buffers.  NvmeNamespaceGetCompatibleIds now decrements
pcchRemaining when the pointer is advanced,
propagates error codes correctly, guarantees termination, and
avoids any second printf when the first one fails.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// NvmeNamespaceGetCompatibleIds – BEFORE (simplified)
ppszDestEnd = Pool;             // 38 WCHARs total
pcchRemaining = 38;
RtlStringCchPrintfExW(Pool, 0x26, &ppszDestEnd, &pcchRemaining, 0,
                      L"NVME\\%hs", "Disk");
++ppszDestEnd;                  //  <-- pcchRemaining NOT updated
RtlStringCchPrintfExW(ppszDestEnd,
                      pcchRemaining - 1,       // off-by-one
                      &ppszDestEnd,
                      &pcchRemaining,
                      0,
                      L"NVME\\%hs", "RAW");
...
RaFixupIds(Pool, 1, 38);        // walks past the allocation
```

```c
// StringCchPrintfW – BEFORE (simplified)
if (cchDest - 1 <= 0x7FFFFFFE) {
    _vsnwprintf(pszDest, cchDest-1, pszFormat, Args);
    ...
}
// no pointer / size validation, no probe of user addresses
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-mode code (e.g. disk management utilities or crafted IOCTL)
--> IOCTL to disk class driver
--> Class driver forwards request to storport miniport
--> Miniport calls StorPortGetId / StorPortGetDeviceBase etc.
--> NVMe path enters NvmeNamespaceGetCompatibleIds
--> Off-by-one leads to 1-WCHAR overwrite
--> RaFixupIds copies leaked WCHAR back into IDENTIFY buffer
--> IoCompleteRequest returns buffer to user, disclosing memory.


Attack Vector
--------------------------------------------------------------------
The attacker needs the ability to issue I/O control requests to a
storage device handled by storport.sys (any authenticated local
user can open a physical drive handle).  By triggering the NVMe
namespace enumeration path repeatedly the attacker causes the
kernel to return one uninitialised WCHAR from pool memory per
call, eventually building an arbitrary kernel-memory disclosure.


Patch Description
--------------------------------------------------------------------
1. New function RtlStringCchPrintfW_0 replaces the insecure helper.
   It invokes StringValidateDestW to verify that:
   • the destination pointer is non-NULL and points to writable
     kernel memory
   • the length is non-zero and within 2 GB.
   Safe formatting is then delegated to StringVPrintfWorkerW.

2. NvmeNamespaceGetCompatibleIds
   • Properly decrements pcchRemaining after ++ppszDestEnd.
   • Propagates NTSTATUS from each printf and aborts on failure.
   • Guarantees final NUL termination even on error paths.
   • Adds extra state checks before attempting the optional third
     printf.

3. StorDeleteSymbolicLink
   • Validates the miniport extension signature before touching
     internal members.
   • Zero-initialises the UNICODE_STRING structure prior to use,
     preventing stale stack leakage in the debug build.


Security Impact
--------------------------------------------------------------------
Prior to the patch a local, authenticated attacker could perform a
series of crafted queries and receive one WCHAR of uninitialised
kernel pool data per request.  Repeating the operation allows
controlled leakage of arbitrary kernel addresses and other
sensitive values, undermining ASLR/KASLR and aiding further kernel
exploitation.  No privilege elevation is obtained directly, but
information disclosure considerably lowers the bar for chaining
bugs.


Fix Effectiveness
--------------------------------------------------------------------
The updated helper refuses invalid pointers/sizes, and the
allocation accounting error in NvmeNamespaceGetCompatibleIds is
removed.  Static examination shows no remaining path in which
pcchRemaining can become inconsistent with ppszDestEnd, and every
error return ensures the buffer is explicitly NUL-terminated.
Consequently the out-of-bounds read and inadvertent disclosure are
no longer possible through the original call sequence.
