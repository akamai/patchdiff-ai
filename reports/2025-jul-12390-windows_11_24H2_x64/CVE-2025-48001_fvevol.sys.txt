{'cve': 'CVE-2025-48001', 'change_count': 42, 'date': 1752036361.500981, 'file': 'fvevol.sys', 'confidence': 0.19, 'patch_store_uid': '546cc225-5ff3-4cd7-be6d-d4d62c9a8c45', 'kb': 'KB5062553'}
--------------------------------------------------------------------
CVE-2025-48001 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft BitLocker full-volume encryption driver (fvevol.sys) –
ICE (Inline Crypto Engine) key-management and hardware-wrap support
routines.

Vulnerability Class
--------------------------------------------------------------------
Time-of-check / time-of-use (TOCTOU) race condition combined with
inadequate parameter validation that allows a security-feature
bypass.

Detailed Root Cause Analysis
--------------------------------------------------------------------
Several helper routines that process hardware-wrapped FVEK material
trusted size and capability values that were read **before** the
actual key-wrap/unwrap operations were executed.  The original code
assumed:
  • the caller-supplied WRAP_KEY_REQUEST structure had already been
    validated (FveIsValidWrapKeyRequest)
  • driver-global ICE-capability data were static and could be used
    without re-checking (SimIceKmiWrapKey / SimIceKmiInsertChallenge)
  • the requested key-blob length could be represented as
    KeySize+24 without risk of integer wrap (former
    FveIceKeyToFveKeyInfo)

Attackers could exploit those assumptions in a physical or
pre-boot/DMA scenario:
 1. Issue IOCTLs that deliver a small (≤0x14-byte) request buffer.
 2. Race the device so that, between the driver’s initial size check
    and its later use, a much larger buffer is DMA-written.  Because
    the driver never re-validated the buffer and had already
    allocated a pool chunk based on the old size, the new data
    overwrite adjacent kernel memory.
 3. By carefully crafting the overrun, the attacker can force the
    driver to accept a forged FVEK as ‘hardware wrapped’, causing
    BitLocker to mount the volume without the original TPM/USB/ PIN
    unlock material.

Functions involved (before patch)
  • FveIceKeyToFveKeyInfo()  – no integer-overflow guard when adding
    24 bytes to user length
  • SimIceKmiWrapKey() / SimIceKmiInsertChallenge() – no capability
    enquiry; only constant 0x20/0x40 size checks
  • FveIsValidWrapKeyRequest() – accepted any request ≤0x20 bytes;
    never compared against device capabilities.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// pre-patch – SimIceKmiWrapKey
if (!a2 || !a3 || !a4 || *a3 > 0x20u)      // ignores hw limits
    return STATUS_INVALID_PARAMETER;
...
* a4 >= 0x118u && a5                       // accepts huge copy
memmove(a5 + 88, a2 + 24, *(USHORT*)(a2+22));
```
```c
// fixed – FveIceKmiValidateUnwrapKey (new)
if ((int)KeyLen + 24 < KeyLen)             // overflow guard
    return STATUS_INTEGER_OVERFLOW;
...
Kmi = SimIceKmiQueryCapabilities(dev,&Caps);
if ((Caps.Flags & 1) && KeyLen > Caps.Max) // re-check caps
    return STATUS_INVALID_PARAMETER;
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
IOCTL_FVE_HW_WRAP_FVEK → IoctlFveHardwareWrapFvek()
  → FveIsValidWrapKeyRequest()  (size only)
  → SimIceKmiWrapKey()/InsertChallenge()  (alloc based on stale size)
  → overwrite pool → corrupted ICE key structure → BitLocker mounted
    with attacker-supplied key.

Attack Vector
--------------------------------------------------------------------
An attacker with physical access (pre-boot console, DMA, or malicious
storage controller firmware) supplies a malicious
WRAP_KEY/CHALLENGE_KEY buffer whose size is changed after the initial
check but before the driver copies the data.  The corrupted in-kernel
ICE key bypasses normal BitLocker unlock requirements.

Patch Description
--------------------------------------------------------------------
1. Introduced FveIceKmiValidateUnwrapKey() – performs atomic
   capability query, integer-overflow detection, and single, trusted
   copy of user data.
2. Re-wrote FveIsValidWrapKeyRequest(), SimIceKmiWrapKey() and
   SimIceKmiInsertChallenge() to:
   • call SimIceKmiQueryCapabilities() and honour per-device limits
   • bail out on any inconsistency between reported and actual sizes
   • zeroise and free on all failure paths.
3. Added ExAllocatePool2()/RtlZeroMemory hardened allocations and
   explicit integer-addition overflow checks ((len+24) < len).
4. Added extensive WPP tracing for failure paths.

Security Impact
--------------------------------------------------------------------
Prior to the patch an attacker could substitute or forge a wrapped
FVEK and convince BitLocker to use it, effectively decrypting the
volume without the original protectors.  This bypasses the encryption
feature and may expose all plaintext data (Security Feature Bypass;
compromises confidentiality & integrity).

Fix Effectiveness
--------------------------------------------------------------------
The new code eliminates the TOCTOU window by validating size and
capabilities **after** copying into driver-owned memory and before
use, adds integer-overflow checks, and rejects any request that
exceeds the device-reported maximum.  All affected paths now zero and
free sensitive buffers on error, preventing both the race and memory
corruption.  No bypass has been found with the patched logic.
