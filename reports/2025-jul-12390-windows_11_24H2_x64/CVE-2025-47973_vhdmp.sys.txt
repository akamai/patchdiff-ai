{'date': 1752037585.7622366, 'kb': 'KB5062553', 'confidence': 0.25, 'cve': 'CVE-2025-47973', 'file': 'vhdmp.sys', 'patch_store_uid': '1fdcaa6b-f557-418e-8f89-7cebf651f2f4', 'change_count': 1}
--------------------------------------------------------------------
CVE-2025-47973 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Virtual Hard Disk kernel driver (vhdmp.sys)
Function: InsertEventEntryInLookUpTable

Vulnerability Class
--------------------------------------------------------------------
CWE-126: Buffer Over-read / Out-of-bounds indexed access

Detailed Root Cause Analysis
--------------------------------------------------------------------
InsertEventEntryInLookUpTable aggregates per-stream accounting data
for VHDX change-tracking events.  The caller supplies the number of
streams to process in argument 5 (a5).

In the vulnerable build the parameter was declared as
"unsigned __int8 a5" and is trusted without range checking.  The code
initialises the loop index to 2 and iterates while
  (unsigned __int8)index < a5 + 2
For each iteration it indexes two different arrays:
  a4 + 16 * index                (source buffer)
  *(v16 + 16) + 16 * index       (destination buffer)
Both buffers are fixed-length per VHD specification (max 2 extra
streams).  Supplying a5 > 0 therefore lets the loop read beyond the
end of both structures.  Because the access is performed in kernel
mode, any out-of-bounds address is dereferenced with full privilege,
causing an information disclosure and potential stack/heap memory
corruption during the later aggregation logic (_InterlockedAdd64 /
_InterlockedCompareExchange64).

No validation of a5 versus the real number of allocated streams or
against the constant structure size is performed; the only guard is
"if (a5)", so any non-zero value is accepted.  An attacker able to
craft or modify the VHDX metadata such that the driver calls this
routine with an inflated a5 can therefore trigger the over-read while
running in the context of the SYSTEM process that mounts the VHD.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// pre-patch
LOBYTE(v12) = 2;
if (a5) {
    do {
        v19 = **(_QWORD **)(a4 + 16i64 * (unsigned __int8)v12);
        v20 = *(_QWORD *)(v16 + 16);
        ...
        LOBYTE(v12) = v12 + 1;
    } while ((unsigned __int8)v12 < (unsigned int)a5 + 2);
}

// post-patch (simplified)
v19 = 2;
if (a5) {
    do {
        AggregateField(...);
        v19++;
    } while (v19 < v21);   // v21 is a constant, not user controlled
}
```
The patch eliminates the direct use of a5 as the upper bound and
replaces it with v21, a value derived inside the function (constant
per internal structure).  The parameter type was also demoted from
unsigned char to signed char, capping it at 127, but the main defence
is the new bound.

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Mount/mutate VHDX file  ->  vhdmp!VhdmpProcessLogEntry
-> vhdmp!InsertEventEntryInLookUpTable (with attacker-controlled a5)
-> out-of-bounds read in aggregation loop

Attack Vector
--------------------------------------------------------------------
Local attacker supplies a crafted VHDX image (or manipulates change
tracking metadata) and mounts it through the Windows storage stack.
The driver receives an inflated stream count, causing the loop in
InsertEventEntryInLookUpTable to read past the end of fixed buffers in
kernel memory, leading to information disclosure and potential memory
corruption that can be leveraged for local privilege escalation.

Patch Description
--------------------------------------------------------------------
1. Parameter 5 changed from unsigned char to signed char.
2. Loop rewritten: the attacker-controlled value is no longer used as
the termination condition; instead a constant (v21) calculated from
internal metadata bounds the iterations.
3. New helper AggregateField encapsulates the update logic, removing
inline pointer arithmetic.
4. Superfluous variable reuse removed; lock-release logic unchanged.

Security Impact
--------------------------------------------------------------------
Before the fix, out-of-bounds kernel memory access could be triggered
by any unprivileged user able to mount a malicious VHDX, yielding
information disclosure or memory corruption in the kernel.  Successful
exploitation grants SYSTEM privileges (EoP).

Fix Effectiveness
--------------------------------------------------------------------
The revised loop ceases once the index reaches the internal constant
limit, independent of attacker input, fully eliminating the original
out-of-bounds path.  No remaining code path references a5 for buffer
indexing, so the specific over-read is resolved.  Comprehensive fuzz
coverage would be required to rule out additional related issues.
