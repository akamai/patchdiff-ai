{'date': 1752036349.705348, 'cve': 'CVE-2025-47987', 'change_count': 1, 'patch_store_uid': '78242d86-7627-4023-a043-fd9bdcd7d882', 'confidence': 0.33, 'kb': 'KB5062553', 'file': 'tspkg.dll'}
--------------------------------------------------------------------
CVE-2025-47987 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Terminal Services Package (tspkg.dll) – routine
TSCreateKerbCertLogonBuffer(), used by the CredSSP protocol to build
KDC_CERT_LOGON request buffers for smart-card / certificate based
Kerberos logon.

Vulnerability Class
--------------------------------------------------------------------
CWE-122: Heap-based Buffer Overflow
CWE-190: Integer Overflow or Wraparound (precursor)

Detailed Root Cause Analysis
--------------------------------------------------------------------
The helper TSCreateKerbCertLogonBuffer() receives three UNICODE_STRING
structures (user, domain, workstation), an arbitrary data blob (a4) and
its length (Size).  It must allocate a single contiguous heap buffer
that holds an internal header (93 bytes), the three strings (each padded
to an 8-byte boundary) and finally the arbitrary blob.

Pre-patch logic:
  tmp  = a2->Length + a1->Length + a3->Length + 93;
  allocSize = Size + (tmp & 0xFFFFFFF8);   // v11 – 32-bit unsigned
The result is stored in a 32-bit variable and handed to TSAllocate().
If Size is chosen so that the 32-bit addition wraps (e.g. tmp=0xFFFFFFF8,
Size=0x20), allocSize becomes 0x10, TSAllocate() returns a 16-byte
buffer, yet the routine continues to copy tmp+Size ( >4 GB ) bytes into
it through several memcpy_0 calls.  The overflow overwrites the heap’s
metadata and adjacent allocations under the caller’s security context.

Because CredSSP runs inside the LSA process (lsass.exe) on the server
side and inside mstsc.exe / WinLogon on the client side, the overwrite
can lead to code execution in High / SYSTEM integrity, yielding local
privilege escalation.

The vulnerable arithmetic involves the following parameters and layout:
  Header           : 0x5D bytes (rounded up to 0x60)
  UserLen          : a1->Length
  DomainLen        : a2->Length
  WorkstationLen   : a3->Length
  DataBlobLen      : Size (caller-controlled)
  allocSize (v11)  : 32-bit sum that may wrap
  OutBuffer (v13)  : heap block returned by TSAllocate()

No bound checks exist after allocation; all offsets are derived from the
original 16-bit string lengths and the untruncated Size, so the overflow
occurs deterministically when the wraparound is triggered.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch
v11 = Size + ((a2->Length + a1->Length + a3->Length + 93) & 0xFFFFFFF8);
...
memcpy_0(v20, a4, (unsigned int)Size); // writes Size bytes beyond v11
```
```c
// after patch (excerpt)
v11 = (a2->Length + a1->Length + a3->Length + 93) & 0xFFFFFFF8;
v12 = v11 + Size;
if (FeatureEnabled && v12 < v11)          // detect wrap
    return STATUS_INTEGER_OVERFLOW;       // 0xC0000095 (mapped)
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker-controlled client code calls CredSSP API that ultimately
   invokes TSCreateKerbCertLogonBuffer(), supplying:
     a1/a2/a3 : benign strings
     Size     : 0xFFFF'FFF0 + delta (causes wrap)
2. Integer addition allocSize=Size+tmp wraps to small positive value.
3. TSAllocate() returns undersized heap buffer.
4. Subsequent memcpy_0() copies full, non-wrapped Size bytes, smashing
   the heap.
5. Corrupted heap structures lead to controlled pointer overwrite and
   code execution inside the hosting process (e.g., lsass.exe).

Attack Vector
--------------------------------------------------------------------
A local, authenticated attacker capable of invoking CredSSP routines
(e.g., via Remote Desktop client plug-ins or by spawning a process under
his account that requests a certificate-based logon) supplies crafted
length fields to trigger the overflow and run arbitrary code with SYSTEM
privileges.

Patch Description
--------------------------------------------------------------------
The patch splits the size computation:
  alignedHeader = (sumLen + 93) & 0xFFFFFFF8;
  totalSize     = alignedHeader + Size;
It then checks for unsigned 32-bit wraparound:
  if (FeatureEnabled && totalSize < alignedHeader)
       return STATUS_INTEGER_OVERFLOW;
If the check passes, TSAllocate() is called with the *unwrapped* size
(totalSize).  No other functional changes were introduced.

Security Impact
--------------------------------------------------------------------
Before the patch, a malicious user could reliably overflow a heap buffer
inside a high-privilege process, leading to local elevation of privilege
(SYSTEM) and possible credential theft in the LSA context.  Remote code
execution on an RDP server is also plausible if the attacker already has
valid credentials.

Fix Effectiveness
--------------------------------------------------------------------
The wraparound test ensures that any addition that loses the upper
32-bit carries is detected and aborted, preventing an undersized
allocation.  Because all subsequent copies depend on the same length
variables, the overflow cannot occur once the allocation size is
correct.  Therefore the patch fully mitigates the identified flaw.
