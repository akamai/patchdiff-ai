{'change_count': 22, 'patch_store_uid': 'ab70aca1-b754-48e9-a911-6baa7a69e726', 'cve': 'CVE-2025-48799', 'file': 'servicinguapi.dll', 'confidence': 0.04, 'kb': 'KB5062553', 'date': 1752036927.3165164}
--------------------------------------------------------------------
CVE-2025-48799 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Update Servicing Stack (servicinguapi.dll) – specifically the
Arbiter code that builds update “action lists” via
CreateActionListInternalExclusive() and the feature-flag helper
GetCachedFeatureEnabledState().

Vulnerability Class
--------------------------------------------------------------------
CWE-59: Improper Link Resolution Before File Access ("Link Following")

Detailed Root Cause Analysis
--------------------------------------------------------------------
CreateActionListInternalExclusive() is meant to guarantee that only one
writer at a time can build an action list by taking a named mutex
("BDA50A95-17AC-40FE-83B6-DAE899448200").  In the pre-patch version the
function contained a short-circuit:
  • If either Cbscore.dll or ServicingUAPI.dll was already loaded the
    code concluded that it had been invoked from the servicing stack
    itself and executed the update logic **without ever taking the
    mutex** (see "skip locking" message in the old code).

Because GetModuleHandleExW only checks the module table, an unprivileged
process running inside the Windows Update service could pre-load one of
those DLL names (Built-in DLL search order or side-load).  The service
would then enter the mutex-free path while still running with SYSTEM
rights.

Once inside this path CreateActionListInternal() performs extensive file
operations under %windir%\Servicing.  No validation is performed to
verify that every destination resides on an ordinary directory entry.
An attacker can therefore plant a hard-link or directory junction that
redirects one of those writes to an arbitrary file.  When the service
later opens the file with SYSTEM privileges it follows the link (CWE-59)
and overwrites the attacker-chosen target, yielding an elevation of
privilege.

Secondary issues fixed at the same time:
  • If CreateMutexW failed the handle variable remained NULL but
    WaitForSingleObject was still called, creating undefined behaviour.
  • Several early-error paths leaked the mutex handle, allowing a
    subsequent call to believe the lock had been taken.
  • GetCachedFeatureEnabledState() contained complex, error-prone bit
    twiddling when caching the feature flag.  While not directly
    exploitable, it drove the faulty logic that decided whether the
    mutex could be skipped.

Patch Description
--------------------------------------------------------------------
1.  A new feature gate (Feature_Servicing_ARBOffGlobal) was introduced.
    Only when this flag is **explicitly enabled** will the code bypass
    locking; the previous implicit test on the two module names is
    removed.
2.  All mutex handling was rewritten around AutoMutexLocker:
      – the mutex handle is always validated,
      – acquisition failures are converted to HRESULTs and returned,
      – every exit path releases and closes the handle.
3.  GetCachedFeatureEnabledState() was reduced to a minimal and safe
    implementation that simply queries the current flag and writes the
    cache atomically.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Pre-patch : lock is skipped purely on module presence
if (ModuleHandle || v16) {
    LogAdapter::TraceAtLevel(...,"skip locking");
    goto LABEL_36;            // runs with no mutex
}
...
MutexW = CreateMutexW(...);
if (!MutexW)                  // NULL handle can reach WaitForSingleObject
    ...                       // undefined behaviour
```
```c
// Post-patch : lock bypass gated by explicit feature flag
if (FeatureImpl<...ARBOffGlobal>::__private_IsEnabled(...)) {
    // Offline/servicing-stack paths still allowed, but *only* when
    // the flag is set through flighting policy.
    LogAdapter::TraceAtLevel(...);
} else {
    Handle = CreateMutexW(...);
    AutoMutexLocker::Lock(&Handle, timeout);
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker gains the ability to run code in the same process as the
   Windows Update service (e.g. via COM interface call).
2. Attacker LoadLibraryW(L"Cbscore.dll") to satisfy the module test.
3. Attacker prepares a hard-link or junction from a Servicing target
   file to an arbitrary protected file.
4. Service calls CreateActionListInternalExclusive(); mutex is skipped.
5. Service writes through the link with SYSTEM privileges.
6. Arbitrary file overwrite -> privilege escalation.

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker who can co-load a DLL or otherwise invoke
Servicing APIs inside the Windows Update service context.

Security Impact
--------------------------------------------------------------------
Elevation of Privilege – attacker obtains SYSTEM-level write access to
arbitrary files, allowing full takeover of the operating system.

Fix Effectiveness
--------------------------------------------------------------------
The patch removes the unsafe implicit mutex bypass and replaces it with
an opt-in feature flag that is disabled by default.  All code paths now
validate that a real mutex handle exists and is held for the duration of
critical file operations, eliminating the window where a crafted link
could be followed.  No bypass has been identified in the new logic.
