{'kb': 'KB5062553', 'confidence': 0.28, 'date': 1752037050.1421149, 'file': 'dxgkrnl.sys', 'cve': 'CVE-2025-49732', 'change_count': 32, 'patch_store_uid': '0f2cb206-ae7c-4acb-8f90-b17c6b1fd390'}
--------------------------------------------------------------------
CVE-2025-49732 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Graphics Kernel Driver (dxgkrnl.sys), function
DXG_HOST_VIRTUALGPU_VMBUS::VmBusQueryAdapterInfo handling the
DXGKVMB_COMMAND_QUERYADAPTERINFO command that is delivered over the
Virtual GPU VMBus channel.

Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow caused by missing input validation / zero
length mis-handling (CWE-122).

Detailed Root Cause Analysis
--------------------------------------------------------------------
The VM-bus packet at *a1 contains a command-specific header
(QUERYADAPTERINFO) followed by a caller-supplied buffer whose size is
stored at header offset +0x1C ("OutputBufferSize").  The vulnerable
function performs these steps:

1. Pulls OutputBufferSize into v7 / v5.
2. Computes AllocSize = OutputBufferSize + 4 (DWORD for status) and
   stores it in v8 / v6.
3. If OutputBufferSize is non-zero it allocates AllocSize bytes and
   populates D3DKMT_QUERYADAPTERINFO.PrivateDriverData.
4. When OutputBufferSize is *zero* the old code skipped the allocation
   (v6/v8 remains NULL) and continued execution.
5. Later, if the guest protocol version is >= 0x27, the function stores
      *v6 = Status;
   where v6 is still NULL.  This writes four bytes to address 0x00000000,
   corrupting the first heap segment (or triggering an access fault
   depending on pool tagging).

Because the allocation is controlled by the guest, a malicious caller
can always choose OutputBufferSize == 0 and a version >= 0x27.  This
predictably corrupts kernel heap metadata and allows crafting of
adjacent pool headers, ultimately enabling local elevation of privilege.

Key data involved:
  header+0x18   : QUERYADAPTERINFO.Type (benign)
  header+0x1C   : OutputBufferSize (attacker sets to 0)
  v6 / v8       : pointer returned by operator new[](AllocSize)
  a1[38]        : guest protocol version field (>=0x27 triggers write)

Before the patch there was no defensive check for zero, and therefore no
allocation, before the dereference.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable (before)
if ((_DWORD)v7) {                     // v7 = OutputBufferSize
    ... allocate v6 = new[v7+4] ...
} else if (Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage_34()) {
    ... treat as error only under flag ...
}
...
if (*((DWORD *)a1 + 38) >= 0x27) {    // new protocol
    *v6 = v13;                       // NULL write if no alloc done
}
```

```c
// fixed (after)
if (!(_DWORD)v5) {
    WdLogSingleEntry0(...);
    ... bail out, no later dereference ...
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-mode -> dxgkrnl.sys -> ioctl / escape to virtual GPU path ->
DXG_HOST_VIRTUALGPU_VMBUS::VmBusProcessPacket ->
VmBusQueryAdapterInfo()
   -> Parses header
   -> OutputBufferSize == 0 passes old validation
   -> No allocation
   -> GuestVersion >= 0x27 path writes to *v6 (NULL)
   -> Kernel heap corruption and potential code execution.

Attack Vector
--------------------------------------------------------------------
A local, sandboxed Windows user with access to the graphics device (any
standard user) can craft and send a QUERYADAPTERINFO VM-bus packet with
OutputBufferSize = 0 and protocol version >= 0x27.  No special
privileges beyond GPU access are required, making the issue suitable for
local privilege escalation.

Patch Description
--------------------------------------------------------------------
The patch adds a strict check that treats an OutputBufferSize of zero as
invalid *unconditionally*.  When the size is zero it now logs, records
a telemetry entry via RtlLogUnexpectedCodepath, and exits the function
before any further processing.  All subsequent logic is unchanged but is
now unreachable with a NULL allocation pointer.

Security Impact
--------------------------------------------------------------------
Prior to the fix an attacker could reliably write four controlled bytes
to the NULL page, leading to heap metadata corruption inside the kernel
pool.  This can be leveraged to obtain arbitrary kernel code execution
and therefore escalate privileges from local user to SYSTEM.  The crash
is also triggerable for a denial-of-service.

Fix Effectiveness
--------------------------------------------------------------------
The single added guard cleanly removes the only control flow path where
a NULL allocation pointer could be dereferenced.  No other write or copy
operation uses the buffer without first allocating it, so the patch is
considered effective.  No signs of residual integer-truncation or upper
bound errors were observed in the modified code.
