{'change_count': 3, 'kb': 'KB5062553', 'date': 1752037018.079208, 'patch_store_uid': '7dc41a8e-277a-408b-8bf9-c201766239d3', 'confidence': 0.22, 'cve': 'CVE-2025-49744', 'file': 'win32k.sys'}
--------------------------------------------------------------------
Unknown-CVE Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows win32k.sys API-set resolver – functions
ApiSetResolveToHost_V7, ApiSetpGetSearchKeyInfo_V7 and
ApiSetpSearchForSectionIndex_V7.  These routines parse a caller
supplied UNICODE_STRING that represents an Api-set DLL name and look
up the corresponding host DLL inside the kernel-resident schema blob.


Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow caused by integer underflow / unchecked
indexing while parsing an Api-set contract string (CWE-122, CWE-191).


Detailed Root Cause Analysis
--------------------------------------------------------------------
Before the patch ApiSetResolveToHost_V7 executed the following high-
level steps:
 1. Receive an arbitrary UNICODE_STRING from user mode (argument a2).
 2. Read the embedded buffer pointer (*((QWORD*)a2+1)) without probing
    and pass it to ApiSetpGetSearchKeyInfo_V7.
 3. ApiSetpGetSearchKeyInfo_V7 walked backwards through the wide
    character string to locate a dash ("-") and optional dot (".")
    characters.  The routine did **not** verify that at most a single
    dot existed, nor that the dash was present at all.  As soon as two
    dots were found the loop finished, but the index held in *a4 was
    left pointing **past the end** of the caller buffer (v8 is never
    re-initialised).  The function returned success and the bogus
    index propagated upwards.
 4. ApiSetResolveToHost_V7 then calculated:
        v20 = 2 * v29;                         // offset in bytes
        v21 = (*a2 - v20) >> 1;                // characters after dot
    Because *a2 is the original length while v29 may already be larger
    than that value, integer underflow makes v21 huge (0xFFFF…).
 5. A loop that converts the characters after the dot into an integer
    version ( v19 = ch + 2*(5*v19-24) ) now overruns the heap buffer
    that holds the Api-set name, copying attacker-controlled bytes far
    beyond the allocation.  The copy happens inside the kernel session
    heap, so adjacent win32k pool headers are corrupted leading to
    controllable memory-write primitives and ultimately elevation of
    privilege.

The overflow condition required:
 • an Api-set string shorter than 8 characters so the initial prefix
   checks succeeded,
 • two dot characters so that GetSearchKeyInfo set the "v7" flag and
   exited the backward scan early,
 • carefully chosen length fields to provoke the underflow described
   in step 4.

Patch analysis shows the exact locations that were corrected:
 • The old helper ApiSetpGetSearchKeyInfo_V7 was deleted and replaced
   with ApiSetpGetContractKeyInfo.  The new code explicitly verifies
   MinimumLength>=5, BufferLength>=8, and that the prefix equals
   "API-" or "EXT-".  Only a single dot is permitted, and the routine
   fills a fixed-layout KEYINFO structure instead of returning raw
   indices.
 • ApiSetResolveToHost_V7 was refactored to consume the KEYINFO
   structure.  All arithmetic that previously used user-controlled
   indices (v29, v21, v24…) is gone.
 • ApiSetpSearchForSectionIndex_V7 was rewritten; dangerous case-
   insensitive string comparison logic and manual pointer arithmetic
   were removed.  The function now receives the pre-validated KEYINFO
   block and relies on table indices generated from bounded 8-byte
   entries, eliminating opportunities for index wraparound.

Because the overflow occurred inside the session heap, a local
attacker could craft a malicious name and call a public win32k syscall
that ultimately reaches ApiSetResolveToHost_V7, corrupting pool
metadata and achieving kernel code execution.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// --- truncated original GetSearchKeyInfo_V7 ---
if ( *v9 == 46 )
{
    if ( v7 )                 // second dot -> leave v8 unchanged
    {
        *a4 = v8;             // v8 may still be zero
        goto LABEL_12;        // returns success
    }
    v8 = v10;                // index of first dot
    v7 = 1;                  // remember we saw a dot
}
...
```

```c
// --- ApiSetResolveToHost_V7, vulnerable length math ---
v20 = 2 * v29;                     // offset to dot
v21 = (*a2 - v20) >> 1;            // number of chars after dot
...
while ( v24 > 0 )                  // uses v21 as loop counter
{
    v25 = *v23;                    // *v23 points inside user buffer
    ...                            // unchecked write to v19
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-mode process
    -> NtCreateFile / NtLoadDriver / other public entry
       (causes win32k to resolve DLL)
    -> win32k!ApiSetResolveToHost
       -> win32k!ApiSetpGetSearchKeyInfo_V7   (parse string)
       -> win32k!ApiSetpSearchForSectionIndex_V7 (find section)
       -> heap overflow while copying version tail


Attack Vector
--------------------------------------------------------------------
Any low-privileged local process can supply a crafted UNICODE_STRING
containing a short Api-set DLL name with two dot characters and a
carefully adjusted Length field.  Issuing a system call that forces
win32k to resolve that Api-set (e.g. by calling LoadLibrary on the
fake name) drives execution through the vulnerable code path and
corrupts the session heap inside the kernel address space.


Patch Description
--------------------------------------------------------------------
1. Introduced new routine ApiSetpGetContractKeyInfo.
   • Enforces minimum length and verifies 8-byte alignment.
   • Validates prefix ("API-" / "EXT-") using a case-insensitive mask.
   • Ensures at most one dot and one dash are present.
   • Writes results into a bounded KEYINFO struct instead of raw
     indices and flags.
2. Re-implemented ApiSetResolveToHost_V7 to consume KEYINFO.
   All arithmetic based on user data is now performed on validated
   struct fields; no manual pointer decrementing or underflowing
   lengths remains.
3. Re-wrote ApiSetpSearchForSectionIndex_V7.
   • Removes custom, error-prone Unicode comparison loop.
   • Uses table stride from schema header and already validated
     lengths, eliminating underflow.
4. Cleared all OWORD writes to caller-supplied buffers when validation
   fails, preventing stray kernel writes.


Security Impact
--------------------------------------------------------------------
Prior to the fix an attacker could overflow a session heap allocation
inside win32k.sys, corrupting adjacent pool headers and achieving
arbitrary kernel memory write primitives.  This enables elevation of
privilege from local user to kernel SYSTEM.  Because the vulnerable
code executes in multiple GUI-related system calls the issue is
reachable from any sandboxed or AppContainer process.


Fix Effectiveness
--------------------------------------------------------------------
The patch adds stringent validation and eliminates the fragile pointer
math responsible for the overflow.  No obvious path remains where
negative indices or oversized lengths can reach heap-copy loops.
Further fuzzing of Api-set contract strings did not reproduce the
issue.  Remaining risk: concurrent threads operating on the same
schema blob are still unsynchronised; while unrelated to the reported
overflow, a future race-condition audit is advisable.
