{'confidence': 0.37, 'cve': 'CVE-2025-47981', 'patch_store_uid': 'd4ae947a-39d5-4531-8f40-8b422c42f9bb', 'change_count': 4, 'kb': 'KB5062553', 'file': 'negoexts.dll', 'date': 1752036319.733206}
--------------------------------------------------------------------
CVE-2025-47981 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows authentication stack – negoexts.dll, function
WSTParseMessages().  This routine parses incoming SPNEGO-Extended
Negotiation (NEGOEX) messages received by LSASS and other SSP consumers.

Vulnerability Class
--------------------------------------------------------------------
CWE-122: Heap-based (and adjacent-stack) buffer overflow caused by an
under-sized destination pointer that is later over-written with network
data via memcpy().

Detailed Root Cause Analysis
--------------------------------------------------------------------
NEGOEX messages contain two variable-length arrays that are copied out
of the network buffer:
  • 12-byte  AUTH_SCHEME records – count stored at msg+0x5C
  • 16-byte  GUID list         – count stored at msg+0x54

Old logic tried to optimise for small sizes:
  1. Calculate required length L = 12*SchemeCnt or 16*GuidCnt.
  2. If L is below g_ulMaxStackAllocSize it does an alloca(L) to get
     stack space; otherwise it calls g_pfnAllocate(L+8) to get heap
     space.
  3. Regardless of which branch is taken, it *replaces* the destination
     pointer (v31 / v12) with the address of a local 8-byte variable
     (&v93 / &v94) before performing the copy:
        v31 = &v93; v93 = (__int64*)&v93;
        memcpy(v31, attacker_data, L);   // L is attacker-controlled

Because the real buffer is discarded, memcpy() writes up to L-8 bytes
past the tiny pointer variable into adjacent memory.  If the allocation
path was taken the overwrite starts inside the freshly allocated heap
chunk header, turning the bug into a bona-fide heap overflow.  When the
stack path is taken it clobbers stack frames, producing a classic stack
smash.  In both cases the attacker fully controls the over-written
bytes (copied from the network), enabling control-flow hijacking inside
LSASS.

Key affected fields / parameters
  Size check:   totalLen  (msg[20] / msg[16])
  Count fields: *(WORD*)(msg+0x5C)  – auth scheme count
                *(WORD*)(msg+0x54)  – GUID count
  Buffers:      v31 / v12 (destination of memcpy)

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable (before)
v31 = &v93;            // points to an 8-byte local on stack
v93 = (__int64 *)&v93;
...
memcpy_0(v31, &v8[offset], 12*iCount);   // overflow L bytes

// fixed (after)
if (use_stack)
    buf = alloca(L);
else
    buf = g_pfnAllocate(L+8);
...
v22 = buf;             // real buffer retained
memcpy_0(v22, &v12[offset], 12*iCount);  // copy is now in-bounds
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Remote attacker sends crafted NEGOEX message with large scheme / GUID
   counts and consistent length fields.
2. LSASS calls negoexts!WSTParseMessages() with the attacker buffer.
3. Size sanity checks pass; function enters overflow path.
4. Destination pointer replaced with &v93 / &v94 (8 bytes).
5. memcpy() copies L (attacker-chosen) bytes – corrupting heap or
   stack.
6. Subsequent heap free / unlink or return from function allows code
   execution under SYSTEM.

Attack Vector
--------------------------------------------------------------------
Network.  Any protocol that negotiates authentication via SPNEGO/NEGOEX
(SMB, HTTP, RPC, etc.) can deliver the malicious buffer without prior
credentials.

Patch Description
--------------------------------------------------------------------
The patched version completely rewrites the temporary-buffer logic:
  • Keeps the pointer returned by alloca()/g_pfnAllocate() and never
    aliases it with a small local variable.
  • Adds VerifyStackAvailable() guard and max-size checks before alloca.
  • Falls back to heap allocation if stack is not safe.
  • Introduces proper clean-up (WSTDereferencePackage, allocator-aware
    frees) on all exit paths.
  • Reorganises control flow to remove duplicated risky code.

Security Impact
--------------------------------------------------------------------
Prior to the patch an unauthenticated attacker could send a single SMB
or HTTP request that causes LSASS to overflow heap metadata or a stack
frame, leading to remote code execution in the Local Security Authority
process (SYSTEM integrity) or, at minimum, process crash (DoS).

Fix Effectiveness
--------------------------------------------------------------------
Static diff confirms that the only memcpy() sites now use buffers that
originate from verified alloca() or heap allocations.  Pointer
aliasing with small locals is removed, additional length checks were
added, and free paths were hardened.  No residual unchecked copies
remain; the overflow condition is eliminated.
