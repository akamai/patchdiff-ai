{'file': 'ssdpsrv.dll', 'confidence': 0.26, 'change_count': 16, 'date': 1752036344.319198, 'patch_store_uid': '98639a85-78bf-46dc-98f7-63d18b92622c', 'cve': 'CVE-2025-47975', 'kb': 'KB5062553'}
--------------------------------------------------------------------
CVE-2025-47975 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows SSDP Service (ssdpsrv.dll) – RPC helpers handling client
notification semaphores (GetNotificationRpc / RemoveSyncHandle /
WakeupGetNotificationRpc) and related list-management code in
CSsdpNotifyRequestManager.

Vulnerability Class
--------------------------------------------------------------------
CWE-415: Double Free / Duplicate Close of kernel HANDLE resulting in
use-after-free and local Elevation-of-Privilege.

Detailed Root Cause Analysis
--------------------------------------------------------------------
The SSDP service exposes several RPC entry points that take a caller
supplied synchronization HANDLE (actually a semaphore created in
InitializeSyncHandle() and returned to the caller).  Prior to the
patch the service never recorded which semaphores had been created, nor
whether a semaphore had already been removed.  Every subsequent RPC
call trusted the raw HANDLE value passed in from user mode and directly
performed kernel operations on it:
 • GetNotificationRpc()  – WaitForMultipleObjects() / close logic
 • WakeupGetNotificationRpc() – ReleaseSemaphore()
 • RemoveSyncHandle()   – CloseHandle() and list removal.

Because the same HANDLE could be supplied repeatedly, or a forged value
could be provided, the service could invoke CloseHandle() (or
ReleaseSemaphore()) multiple times on the same kernel object.  The
first call releases the underlying object; a second call frees the same
kernel object again – a classic double-free.  Since the SSDP service
runs as NT AUTHORITY\LocalService in a system process, an attacker who
can connect to the RPC interface can repeatedly free and re-allocate
kernel objects and, through kernel handle recycling, manipulate memory
owned by a privileged process, achieving local privilege escalation.

Structures / members affected (offsets are pre-patch):
 • CSsdpNotifyRequestManager::m_listNotifyRequests   (at +0x28)
 • No dedicated list existed for semaphore handles – validation never
   occurred.
 • Removal path in HrRemoveInternal() moved list elements to a local
   stack list (v25) and unconditionally called
   CSsdpNotifyRequest::HrShutdown() followed by CloseHandle().

Once a malicious client invoked RemoveSyncHandle() twice with the same
pointer, CloseHandle() was executed twice, freeing the semaphore twice
inside the SSDP service’s process context.

Vulnerability Code Snippets
--------------------------------------------------------------------
Before (RemoveSyncHandle):
```c
BOOL __fastcall RemoveSyncHandle(void **a1)
{
    void *h = *a1;
    HrRemoveInternal(&CSsdpNotifyRequestManager::s_instance, 0,0,h,0);
    CloseHandle(h);          // second/third close allowed
    *a1 = 0;
    return TRUE;
}
```
After (validation added):
```c
if (!hSemaphore ||
    !CSsdpNotifyRequestManager::IsNotifySemaphoreInList(...,hSemaphore))
    return ERROR_INVALID_PARAMETER;
...
CSsdpNotifyRequestManager::HrRemoveNotifySemaphoreFromList(...,hSemaphore);
CloseHandle(hSemaphore);      // executed exactly once
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Client calls InitializeSyncHandle – receives HANDLE H.
2. Legitimate/attacker calls RemoveSyncHandle twice with the same H.
3. Pre-patch path executes CloseHandle(H) twice – double free.
4. Memory corruption in SSDP service leads to controlled data reuse
   and local privilege escalation.

Attack Vector
--------------------------------------------------------------------
Local attacker authenticates to the SSDP RPC interface and supplies a
crafted or previously freed semaphore HANDLE to RemoveSyncHandle(),
WakeupGetNotificationRpc() or GetNotificationRpc().  No privileges are
required beyond the ability to talk to the service.

Patch Description
--------------------------------------------------------------------
• Introduced a dedicated list of active notification semaphores inside
  CSsdpNotifyRequestManager (+new critical section at +0xC0).
• Added helper APIs:
    – HrAddNotifySemaphoreToList()
    – HrRemoveNotifySemaphoreFromList()
    – IsNotifySemaphoreInList()
• InitializeSyncHandle() now records a newly created semaphore in the
  list and fails if the insert fails.
• All RPC entry points now:
    1. Guard with Feature flag 2578215227.
    2. Validate that the incoming HANDLE is non-NULL AND present in the
       internal list; otherwise return ERROR_INVALID_PARAMETER (87).
• RemoveSyncHandle() removes the semaphore from the list before calling
  CloseHandle(), guaranteeing a single close.
• Extensive refactoring of internal list offsets / critical-section
  usage to match the new data members, and updated destructor code to
  free the new list correctly.

Security Impact
--------------------------------------------------------------------
The fix prevents any caller from causing the service to operate on a
semaphore HANDLE that is not tracked by the service, eliminating the
possibility of a duplicate CloseHandle()/ReleaseSemaphore() and the
resulting use-after-free memory corruption.  This closes the privilege
escalation path.

Fix Effectiveness
--------------------------------------------------------------------
All entry points that previously accepted arbitrary HANDLEs now perform
constant-time list membership checks under appropriate locks.  A HANDLE
is added exactly once and removed exactly once, making a second close
or release impossible.  No residual code paths operating on unchecked
handles were observed in the provided diffs; therefore the patch
appears effective, provided IsNotifySemaphoreInList() itself is
correctly implemented.
