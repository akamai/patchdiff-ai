{'file': 'capabilityaccessmanager.dll', 'confidence': 0.19, 'kb': 'KB5062553', 'patch_store_uid': 'd459e9d2-5ece-4dbe-85a3-559484eefa8a', 'change_count': 131, 'cve': 'CVE-2025-49690', 'date': 1752036629.2136416}
--------------------------------------------------------------------
CVE-2025-49690 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Capability Access Management Service (camsvc)
capabilityaccessmanager.dll – specifically the classes
  Windows::Internal::CapabilityAccess::Private::
    CapabilityConsentManager
  Windows::Internal::CapabilityAccess::Private::
    ModernPolicy::PolicyManager

Vulnerability Class
--------------------------------------------------------------------
Concurrent execution using shared resource with improper
synchronization (race condition).  Memory-corruption side effect can
manifest as double free / use-after-free.

Detailed Root Cause Analysis
--------------------------------------------------------------------
CapabilityConsentManager keeps the caller identity string in member
m_callingUser (std::wstring located at object offset +0x68 / 104).
The class also owns an SRWLOCK at offset +0x120 / 288 that is intended
to serialize access to mutable state.

Prior to the patch, the setter
    CapabilityConsentManager::put_CallingUser(const std::wstring&)
performed the following sequence:
 1. Log the new name.
 2. Throw access-denied if the object is not initialized.
 3. Unconditionally assign the new string directly to m_callingUser
    via std::wstring::operator=.

No lock was acquired, so multiple threads could enter the function – or
a parallel reader could access the same std::wstring instance – while
the string’s internal buffer was being freed or reallocated.  The C++
standard library does not guarantee thread-safety for concurrent writes
(or write/read) to the same std::wstring object.  A collision therefore
creates memory corruption:
 • double free when two writers destruct the previous buffer at nearly
the same time,
 • use-after-free when a reader dereferences a buffer that a writer has
  just released.

Because camsvc runs with SYSTEM privileges and exposes public COM / RPC
endpoints, a local attacker can schedule concurrent requests that call
put_CallingUser from separate threads, race the mutation, corrupt heap
metadata, and pivot to arbitrary code execution in the SYSTEM process,
thereby gaining elevation of privilege.

The companion change in
PolicyManager::QueryCapabilitiesWithBoolPolicySet() shows the same
pattern: all accesses to the global policyCache tree are now wrapped in
AcquireSRWLockShared/Exclusive, indicating that the broader fix is to
guard every shared container with the appropriate lock.

Vulnerability Code Snippets
--------------------------------------------------------------------
Before patch (no locking):
```c
__int64 __fastcall ...put_CallingUser(__int64 this, __int64 newStr)
{
    ...
    // access check omitted
    return std::wstring::operator=(this + 104, newStr); // unprotected
}
```
After patch (locking added):
```c
if (!Feature606399802Disabled) {
    RTL_SRWLOCK *lock = (RTL_SRWLOCK*)(this + 288);
    AcquireSRWLockExclusive(lock);
    std::wstring::operator=(this + 104, newStr);
    ReleaseSRWLockExclusive(lock);
    return;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker spawns two (or more) client threads/processes.
2. Each client calls a camsvc method that leads to
   CapabilityConsentManager::put_CallingUser.
3. Both threads enter the function almost simultaneously.
4. Thread A frees the old std::wstring buffer; thread B still holds a
   pointer to it -> use-after-free / double free.
5. Heap metadata corruption allows attacker-controlled overwrite ->
   arbitrary code execution in camsvc (SYSTEM).

Attack Vector
--------------------------------------------------------------------
Local, unauthenticated user sends concurrent requests to camsvc’s public
COM / RPC surface, forcing simultaneous execution of
put_CallingUser on shared CapabilityConsentManager instances.

Patch Description
--------------------------------------------------------------------
• Added AcquireSRWLockExclusive/ReleaseSRWLockExclusive around the
  std::wstring assignment in put_CallingUser.
• Wrapped PolicyManager enumeration in AcquireSRWLockShared.
• Lock pointer is stored on the stack and released via RAII
  wil::details::unique_storage to guarantee unlock even on exception.
• Minor line-number adjustment in error-reporting call sites.

Security Impact
--------------------------------------------------------------------
Prior to the fix, unsynchronized mutation of std::wstring allowed heap
corruption inside a SYSTEM service, providing a reliable local
privilege-escalation primitive.  Successful exploitation yields SYSTEM
code execution.

Fix Effectiveness
--------------------------------------------------------------------
Locking eliminates data races on m_callingUser and the policy cache, so
the specific double-free/use-after-free window is closed.  Protection is
conditioned by a feature flag, but that flag is enabled in supported OS
builds; if disabled, the race would still exist (status unknown).  No
other affected members were observed; therefore the patch is assessed as
effective for the reported vulnerability.
