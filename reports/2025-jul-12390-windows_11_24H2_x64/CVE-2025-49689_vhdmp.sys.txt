{'file': 'vhdmp.sys', 'cve': 'CVE-2025-49689', 'patch_store_uid': '1fdcaa6b-f557-418e-8f89-7cebf651f2f4', 'date': 1752036476.08178, 'change_count': 1, 'confidence': 0.17, 'kb': 'KB5062553'}
--------------------------------------------------------------------
CVE-2025-49689 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows kernel-mode driver vhdmp.sys (Virtual Hard Disk
sub-system).  Vulnerable routine: InsertEventEntryInLookUpTable(),
address 0x1C0060090, responsible for inserting/merging VHDX runtime
telemetry "event entries" into an in-memory hash table.

Vulnerability Class
--------------------------------------------------------------------
Integer overflow / out-of-bounds access (CWE-190, CWE-125) leading to
kernel memory corruption and privilege elevation.

Detailed Root Cause Analysis
--------------------------------------------------------------------
InsertEventEntryInLookUpTable() receives, among other parameters,

    a5  – caller-supplied count of per-event statistic fields
           (documented size: 0-8)

The original implementation performs per-field aggregation after it
locates an existing hash node:

  LOBYTE(v12) = 2;                    // start with field index 2
  do {
      base  = *(QWORD *)(v16+16);     // dst event array
      dst   = base + 16*v12;          // 16-byte slot
      src   = *(QWORD *)(a4+16*v12);  // src slot
      ...   // add / min / max writes
      v12++;
  } while ((u8)v12 < (u32)a5 + 2);

The loop limit `(u32)a5 + 2` is derived **directly** from caller input.
No upper bound is enforced on `a5`, yet every iteration indexes both the
source (a4) and destination (v16) arrays by `16*v12`.  When `a5` is
larger than the actual array (max 10 elements), `v12` quickly overruns
object bounds causing:

  • out-of-bounds reads from attacker-controlled memory at `a4+...`
  • out-of-bounds writes (_InterlockedAdd/CompareExchange64) into kernel
    memory after `v16+...`.

Because the driver executes at IRQL <= DISPATCH_LEVEL under a shared
spin-lock, the corruption is immediate and deterministic; arbitrary
64-bit values can be written to chosen, pointer-relative offsets.  An
unprivileged user who can mount or open a crafted VHD/VHDX file (or send
the matching IOCTL) fully controls `a5` and the backing buffers,
enabling local elevation of privilege.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable aggregation loop (before patch)
LOBYTE(v12) = 2;
if (a5) {
    do {
        v19 = **(_QWORD **)(a4 + 16 * (u8)v12);     // src
        v20 = *(_QWORD *)(v16 + 16);                // dst array base
        v21 = *(u8 *)(v20 + 16 * (u8)v12 + 13);     // op code
        v22 = *(volatile i64 **)(v20 + 16 * (u8)v12); // dst value ptr
        ...                                         // add/min/max
        LOBYTE(v12) = v12 + 1;
    } while ((u8)v12 < (u32)a5 + 2);                // NO BOUND CHECK
}
```

```c
// fixed aggregation (after patch)
v19 = 2;
if (a5) {
    do {
        AggregateField(
            *(_QWORD *)(*(_QWORD *)(v16 + 16) + 16 * v19),
            **(_QWORD **)(a4 + 16 * v19),
            *(u8 *)(*(_QWORD *)(v16 + 16) + 16 * v19 + 13));
        v19 = v20 + 1;                              // loop variable is
                                                   // independent of a5
    } while (v19 < v21);        // v21 == real array size (internal)
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User opens or mounts a crafted VHD/VHDX image or issues an IOCTL that
   forces the driver to log an event entry with an oversized field count
   (a5 > 8, up to 0xFF).
2. vhdmp!VhdmpLogEventEx() (exact caller unknown) passes the unchecked
   `a5` to InsertEventEntryInLookUpTable().
3. Function hashes the entry, locates an existing bucket, then executes
   the vulnerable aggregation loop.
4. Loop crosses buffer boundary, corrupting adjacent kernel memory.
5. Attacker leverages corruption to obtain SYSTEM-level code execution.

Attack Vector
--------------------------------------------------------------------
Local, low-privilege attacker.  Requires the ability to feed malformed
metadata to the Virtual Hard Disk stack (e.g., attach a crafted VHDX
file or send DeviceIoControl to the vhdmp device).  No special
privileges are necessary beyond file/IOCTL access.

Patch Description
--------------------------------------------------------------------
• Replaced bespoke aggregation logic with a helper
  AggregateField() that receives *validated* operands.
• Loop index now iterates up to `v21`, an internally computed constant
  representing the real number of fields in the destination entry;
  external parameter `a5` is no longer used as the upper bound.
• Removed manual _Interlocked operations and reused a single safe helper
  => eliminates duplicated, error-prone bounds logic.
• Parameter `a5` changed from unsigned __int8 to signed char, signalling
  that only small positive values are expected (semantic change only).
• Temporary stack buffer expanded (`v24[11]`) to avoid accidental reuse
  of stale pointer (`v28`).

Security Impact
--------------------------------------------------------------------
Prior to the patch, any local user could trigger kernel out-of-bounds
writes, leading to pool corruption, arbitrary kernel pointer overwrite,
and ultimately elevation of privilege (SYSTEM).  The issue is
exploitable at will because the vulnerable code path executes in the
filesystem stack during normal VHD operations.

Fix Effectiveness
--------------------------------------------------------------------
The new aggregation loop is bounded by an internally validated size and
no longer trusts caller-supplied `a5`.  All pointer arithmetic is
performed inside AggregateField(), which can enforce further checks.
Therefore the specific integer-overflow / OOB condition is fully
mitigated.  No residual paths referencing `a5` for array limits remain
in this routine; effectiveness appears complete, subject to code audit
of AggregateField().
