{'patch_store_uid': '88ce6717-5b60-4794-aa8d-0d9061718185', 'date': 1752036872.0307715, 'change_count': 22, 'cve': 'CVE-2025-47980', 'file': 'windowscodecs.dll', 'kb': 'KB5062553', 'confidence': 0.24}
--------------------------------------------------------------------
CVE-2025-47980 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Imaging Component (WIC) – windowscodecs.dll.  Affected helper
routines reside in pixel-format conversion, bitmap lock and TIFF
unpack logic (CopyPixelsHelper / HrCheckBufferSize / HrLockInit /
UnpackLine, etc.).

Vulnerability Class
--------------------------------------------------------------------
Integer overflow / buffer-size mis-calculation that leads to out-of-
bounds memory access and information disclosure (CWE-190 + CWE-200).

Detailed Root Cause Analysis
--------------------------------------------------------------------
Older code translated a MilPixelFormat value into a bits-per-pixel
(BPP) constant via huge switch/case tables, multiplied the BPP by the
requested pixel count and shifted the product to obtain the needed
byte count:

    bytes = (width * bpp + 7) >> 3;

The calculation used 32-bit signed intermediates (int / unsigned int).
For large image widths the intermediate product (width * bpp) silently
wrapped above 0xFFFFFFFF, yielding a much smaller value.  Subsequent
size checks therefore believed the destination buffer was large enough
and memcpy() / memcpy_0() copied past the end of the caller-supplied
memory (or read past the source).  Functions affected include:

  • CBitmap::CopyPixelsHelper()
  • CFormatConverter::CopyPixelsHelper()
  • HrCheckBufferSize(..)  (both overloads)
  • CBitmapLock::HrInit()
  • CSystemMemoryBitmap::HrLockInternal()
  • CLibTiffDecoderBase::UnpackLine()

The same faulty pattern appeared in several call-sites, so an attacker
could reach it through many public WIC entry points such as
IWICBitmapSource::CopyPixels, IWICBitmapLock, IWICFormatConverter, and
the TIFF decoder.

Key parameters / structures involved
  width/height ............... taken from caller or image
  bpp ........................ derived from MilPixelFormat::Enum
  stride / cbBufferSize ...... caller-supplied output buffer size

Because the stride/size mis-match was not detected, WIC leaked process
memory to the attacker (information disclosure) and could also crash.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// old (e.g. CopyPixelsHelper) – 32-bit maths overflows
v15 = (a3 * v13 + 7) >> 3;      // a3 = pixel count, v13 = bpp
if (a3 > 0x7FFFFFF8 / v13) ...   // attempted but insufficient guard
...
memcpy_0(dst, src, v15);         // copies past end when v15 wrapped

// patched – use GetPixelFormatSize + 64-bit and explicit checks
size64 = (uint64)width * GetPixelFormatSize(fmt);
if (size64 > 0xFFFFFFFF || size64 + 7 < size64) error;
needed = (uint32)((size64 + 7) >> 3);
if (needed > callerStride) error;
```
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Caller (e.g. IWICBitmapSource::CopyPixels) ➜
  CBitmap::CopyPixels ➜ CopyPixelsHelper ➜
    HrCheckBufferSize (wrong arithmetic) ➜
      memcpy() overruns caller buffer ➜
        stale heap / stack bytes returned to attacker.

Attack Vector
--------------------------------------------------------------------
Any local program that can feed crafted parameters or image data to
WIC APIs.  Typical scenarios: opening a specially crafted TIFF / BMP /
RAW file inside an application that relies on windowscodecs.dll, or
invoking the public ImagingFactory COM interfaces directly.  No
special privileges are required – the process calling WIC leaks its
own memory to the attacker.

Patch Description
--------------------------------------------------------------------
1. Replaced per-call switch tables with GetPixelFormatSize(), avoiding
   manual constants.
2. Performed all size/stride multiplications in 64-bit (unsigned long
   long) and compared against 0xFFFFFFFF to detect overflow.
3. Added additional bounds checks (e.g. stride < needed, total
   < callerBuffer) before any memcpy.
4. Hardened callers by propagating the new safe helpers and changing
   several parameters from signed to unsigned.
5. Updated TIFF unpack path to exercise the central normalisation
   table instead of ad-hoc bit manipulations.

Security Impact
--------------------------------------------------------------------
Before the fix an attacker could read uninitialised heap / stack
contents belonging to the calling process, potentially exposing
sensitive information such as credentials or ASLR offsets.  Depending
on use-case the bug could also lead to out-of-bounds writes and crash.
The issue is therefore an information-disclosure vulnerability in
user-mode (CVE-2025-47980).

Fix Effectiveness
--------------------------------------------------------------------
The revised code removes all 32-bit arithmetic, employs central helper
GetPixelFormatSize() and double-checks every calculation for overflow
before memory access.  All affected paths were updated uniformly, so
the patch fully mitigates the originally reachable overruns.
