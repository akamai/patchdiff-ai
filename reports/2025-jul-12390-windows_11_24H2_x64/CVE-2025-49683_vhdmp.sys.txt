{'confidence': 0.26, 'file': 'vhdmp.sys', 'cve': 'CVE-2025-49683', 'patch_store_uid': '1fdcaa6b-f557-418e-8f89-7cebf651f2f4', 'date': 1752037585.7486537, 'kb': 'KB5062553', 'change_count': 1}
--------------------------------------------------------------------
CVE-2025-49683 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Virtual Hard Disk driver (vhdmp.sys) – routine
InsertEventEntryInLookUpTable(), which maintains the per-device event
aggregation look-up table used by the VHDX logging/telemetry code.

Vulnerability Class
--------------------------------------------------------------------
CWE-190: Integer overflow / wraparound
CWE-122: Heap-based buffer overflow (out-of-bounds read/write)

Detailed Root Cause Analysis
--------------------------------------------------------------------
The vulnerable routine receives five arguments.  The last one, a5,
represents the caller-supplied number of event payload fields that
must be merged into an existing aggregation entry:

    InsertEventEntryInLookUpTable(ctx, Id, Level, pEvent, a5)

PRE-PATCH
  • a5 is declared as    unsigned __int8 (0–255) and is *implicitly*
    trusted – no range or consistency check is performed.
  • When an identical aggregation entry already exists (v16 != 0),
    the function executes the following loop in order to merge the
    individual 64-bit statistics of each field:

        v12 = 2;                     // start at field index 2
        do {
            ... use index v12 ...
            v12 = (unsigned __int8)(v12 + 1);
        } while ((unsigned __int8)v12 < a5 + 2);

  • The loop counter is **truncated to 8 bits** each iteration, while
    the upper bound is evaluated with normal (32-bit) arithmetic.  If
    the attacker makes a5 >= 254, the counter reaches 0xFF, overflows
    to 0x00, and the condition (0 < a5+2) is still true.  The loop
    therefore continues with a wrapped-around index and proceeds to
    dereference:

        *(pEvent + 16 * v12)   and
        *(v16   + 16 * v12)

    using an index that is **well beyond the allocated array** that
    only holds 11 fields (indices 0–10).  This causes uncontrolled
    kernel memory access, leading to heap corruption in non-paged
    pool and potential execution of attacker-controlled data.

  • Because the corruption happens while vhdmp.sys holds only a shared
    spinlock, the window for concurrent exploitation is large and can
    be reached from low-integrity user mode by mounting a malicious
    VHD/VHDX image.

POST-PATCH
  • a5 is changed to a signed char (char) and is *ignored* as a loop
    bound.
  • The merge logic now determines the real number of stored fields
    from the existing entry itself (v21) and uses a wider, non-
    truncating index (unsigned __int8 v19) that is compared directly
    to that trusted length.
  • The brittle arithmetic (a5+2, cast to 8 bits) is completely
    removed and replaced with a call to the new helper
    AggregateField().
  • A fixed-size local array (v24[11]) is used for the temporary
    entry pointer, eliminating previous pointer aliasing problems.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// PRE-PATCH (excerpt)
LOBYTE(v12) = 2;
if (a5) {
    do {
        v19 = **(_QWORD **)(a4 + 16i64 * (unsigned __int8)v12);
        ...
        LOBYTE(v12) = v12 + 1;              // wraps at 0x100
    } while ((unsigned __int8)v12 < (unsigned int)a5 + 2);
}

// POST-PATCH (excerpt)
v19 = 2;
if (a5) {
    do {
        AggregateField(
            *(_QWORD *)(*(_QWORD *)(v16 + 16) + 16i64 * v19),
            **(_QWORD **)(a4 + 16i64 * v19),
            *(unsigned __int8 *)(*(_QWORD *)(v16 + 16) + 16i64 * v19 + 13));
        v19 = v19 + 1;
    } while (v19 < v21);     // v21 = real field count of entry
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker crafts a VHDX image with a malformed metadata record that
   forces InsertEventEntryInLookUpTable() to be called with a5 >= 254.
2. The virtual disk service mounts the image, vhdmp.sys parses the
   metadata, hashes the event and finds a matching table entry.
3. Loop counter overflows; driver reads/writes past the end of both
   the source event buffer (a4) and the destination aggregation entry
   (v16).
4. Corrupted pool memory is later reused, resulting in arbitrary code
   execution in kernel context or an immediate bugcheck.

Attack Vector
--------------------------------------------------------------------
Local, low-privileged attacker providing a specially crafted VHD/VHDX
file to any component that mounts virtual disks (e.g. DiskMgmt.msc,
Mount-VHD PowerShell cmdlet, Hyper-V).  No additional privileges are
required.

Patch Description
--------------------------------------------------------------------
• Changed type of parameter a5 from unsigned __int8 to signed char and
  stopped using it as the upper loop bound.
• Introduced trusted length v21 obtained from the existing event entry
  itself and compared with an 8-bit non-wrapping index.
• Replaced manual min/max/add code with AggregateField() helper, which
  implicitly validates the index and operation type.
• Added fixed-size local array v24[11] to safely hand entry pointers to
  CreateNewEventEntry() instead of using a single shared variable that
  could be left dangling.
• Removed obsolete third parameter when releasing the pushlock.

Security Impact
--------------------------------------------------------------------
Before the fix, a malicious VHDX could force vhdmp.sys to perform
out-of-bounds reads and writes in non-paged pool, enabling local
privilege escalation to kernel (arbitrary code execution) or a system
crash (DoS).  The issue is rated Remote Code Execution because the
malicious disk image may reside on network shares or removable media.

Fix Effectiveness
--------------------------------------------------------------------
The patched code no longer relies on attacker-controlled data for loop
termination, thereby eliminating the 8-bit wraparound and the
resulting buffer overflow.  The trusted field count (v21) is obtained
from validated internal structures, and all arithmetic uses wider
integer types, so no further overflow path is apparent.  The fix is
therefore considered effective.
