{'kb': 'KB5062553', 'date': 1752036543.4536552, 'file': 'gdi32full.dll', 'patch_store_uid': 'f41ac86d-0d34-4686-9680-a62744423435', 'cve': 'CVE-2025-47984', 'change_count': 9, 'confidence': 0.27}
--------------------------------------------------------------------
CVE-2025-47984 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows GDI (gdi32full.dll) – EMF record handler MRSTARTDOC::bPlay,
invoked while playing an EMF+ MR_STARTDOC record (StartDocW setup).

Vulnerability Class
--------------------------------------------------------------------
Protection-mechanism failure / insufficient input validation causing
out-of-bounds read (CWE-693 leading to CWE-125).

Detailed Root Cause Analysis
--------------------------------------------------------------------
An MR_STARTDOC record stores up to three variable-length WCHAR strings
(lpszDocName, lpszOutput, lpszDatatype) packed back-to-back after the
fixed header.  Each string is NUL-terminated and padded to a 4-byte
boundary.  The record body therefore contains:

  Offset 0x00  : fixed MR_STARTDOC header (size, flags, etc.)
  Offset hdr+0 : DocName[?]
  Offset ...   : Output[?]
  Offset ...   : Datatype[?]

For safe playback MR::bValidOff() must be called with *the exact byte
count from the start of the record* to the end of the referenced field.
The pre-patched code validated each field *individually* but forgot to
add the running offset when DocName is present:

  1. lengthDoc  = StringCbLengthW(DocName)
  2. alignedDoc = (lengthDoc + 6) & ~3
  3. bValidOff(record, alignedDoc)          <-- OK for DocName
  4. ptr = ptr + alignedDoc                 <-- cursor now outside hdr
  5. lengthOut  = StringCbLengthW(Output)
  6. bValidOff(record, (lengthOut + 5) & ~3) <-- BUG – offset resets

Step 6 merely checked the *size* of Output, not size+offset.  An
attacker can craft a record where alignedDoc pushes the cursor beyond
the end of the record and still supply a small lengthOut so that check
passes.  The pointer subsequently handed to StartDocW (in user mode)
therefore references memory outside the EMF buffer.  The routine reads
that memory to build the DOCINFOW structure and returns it to the
caller or the print spooler, leaking uninitialised heap/stack data.

Affected variables/structures:
  v3   – running pointer to the next string inside the record
  v15  – aligned length of DocName
  DOCINFOW.lpszDocName / lpszOutput – exported to StartDocW
  MR::bValidOff() – boundary check helper (mis-used)

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Before
v11 = (v15 + 6) & 0xFFFFFFFC;          // aligned DocName size
if (!MR::bValidOff(this,a3,v11))       // OK
    return 0;
v3 += v11;                             // advance pointer
...
if (!MR::bValidOff(this,a3,(lenOut+5)&~3)) // BUG – offset reset
    return 0;
```
```c
// After
v15 = (v21 + 6) & ~3;
if (FeatureFlag) {
    if (lpszOutput &&
        !MR::bValidOff(this,a3,(int)v15 + (int)v3 - (int)this)) {
        RtlLogUnexpectedCodepath(...);
        return 0;                      // new combined-offset check
    }
} else if (!MR::bValidOff(this,a3,v15)) {
    return 0;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker supplies crafted EMF file.
2. Victim app calls PlayEnhMetaFile / SetEnhMetaFileBits.
3. GDI32 traverses records -> MRSTARTDOC::bPlay.
4. DocName present, Output present.
5. Length of DocName chosen to move cursor past record end.
6. Second bValidOff() passes; pointer now OOB.
7. StartDocW receives out-of-bounds pointers and copies memory,
   disclosing process data to attacker (e.g., via print job or network).

Attack Vector
--------------------------------------------------------------------
Opening or previewing a malicious EMF file (e-mail attachment, web
content, print-to-file, or remote print job) that is parsed by any
Windows process using GDI32 record playback.

Patch Description
--------------------------------------------------------------------
The fix adds a second boundary check that takes the running cursor
position into account.  When the optional Output string is present the
code now calls:

  MR::bValidOff(this,a3, alignedDoc + (v3 - this));

This validates the *absolute* end offset of DocName inside the record
instead of the relative size alone.  Similar logic behind a feature
flag is applied to Output.  Additional diagnostic logging via
RtlLogUnexpectedCodepath() was introduced for failed checks.

Security Impact
--------------------------------------------------------------------
Prior to the patch an attacker could read arbitrary process memory
located immediately after the EMF buffer, leaking secrets such as ASLR
bases, heap metadata, or document contents.  While no write primitive
exists, the disclosure can be chained with other bugs to defeat modern
mitigations.  The issue is therefore classified as an information
leak with network vector (CVSS base 5.5 / 4.3 depending on scoring
model).

Fix Effectiveness
--------------------------------------------------------------------
The new bounds check covers the missing condition and is executed every
path where both strings are present.  Combined with existing length
checks this closes the out-of-bounds read window.  No remaining path
was found where a string pointer can exceed the record size, so the fix
appears complete.
