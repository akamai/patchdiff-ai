{'cve': 'CVE-2025-48804', 'date': 1752036514.3144295, 'patch_store_uid': '546cc225-5ff3-4cd7-be6d-d4d62c9a8c45', 'kb': 'KB5062553', 'confidence': 0.18, 'change_count': 42, 'file': 'fvevol.sys'}
--------------------------------------------------------------------
CVE-2025-48804 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft BitLocker driver (fvevol.sys) – ICE (Inline Crypto Engine)
key-management and hardware-wrapping support code.

Vulnerability Class
--------------------------------------------------------------------
Acceptance of Extraneous Untrusted Data with Trusted Data (CWE-349)
leading to a security-feature bypass.

Detailed Root Cause Analysis
--------------------------------------------------------------------
Several IOCTL and internal helper paths that create, verify, or insert
hardware-wrapped FVEKs (Full-Volume Encryption Keys) trusted the caller
supplied buffer length and key-size fields without checking them against
what the active ICE Key-Management Interface (KMI) actually supports.

Old behaviour (examples):
  • SimIceKmiWrapKey() accepted *any* requested clear-key size up to
    0x20 bytes irrespective of the capability of the attached KMI and
    copied caller data straight into the wrapping request.
  • SimIceKmiInsertChallenge() accepted any challenge length up to 0x20
    bytes and any output buffer >=0x118 without checking KMI limits.
  • FveIsValidWrapKeyRequest() only compared the caller-provided lengths
    internally, it never queried KMI capabilities and therefore could
    be tricked by oversized values that over-indexed later memmove.
  • FveIceKmiValidateUnwrapKey(), FveIceVerifyHwWrappedFvek() and
    FveIceHwWrapFvek() trusted (*WORD)v5 and similar size fields and
    performed arithmetic that could wrap or allocate undersized pools.

Because the KMI layer later calculated pool sizes from these unchecked
lengths, an attacker able to issue the IOCTL_FVE_HARDWARE_WRAP_FVEK or
communicate with the ICE KMI could supply an over-large key/challenge
length.  The driver then:
  1. Allocated a buffer that was too small (integer-truncation to
     unsigned ‑> wrap at 0xFFFF, or bit size not supported by ICE).
  2. memmove()’d attacker data beyond the end of that buffer, or
     copied fewer bytes than expected into the device, leaving the rest
     attacker-controlled but treated as *trusted*.
  3. The corrupted structure was handed to the hardware for key
     wrapping/unwrapping, bypassing BitLocker policy (e.g. FIPS mode,
     KMI capabilities → allows 256-bit AES, attacker supplies 512-bit
     and forces wrap/unwrapped key that the policy should forbid).

Parameters/structures implicated
  • struct ICE_KMI_WRAP_KEY_REQUEST { WORD Total; WORD HeaderLen;
    WORD WrappingType; … }
  • (*WORD)v5 in FveIceKmiValidateUnwrapKey – attacker-controlled key
    length.
  • cbInput/keySize in FveCreateIceKey – calculated from unchecked
    a4/a5 bit-size.

Patch Description
--------------------------------------------------------------------
1. Each entry point now queries KMI capabilities first
   (SimIceKmiQueryCapabilities / FveIceKmiGetCapabilities) and rejects
   any request whose size exceeds the advertized maximum.
2. Additional integer-overflow checks added:
      if (v5+24 < v5) return STATUS_INTEGER_OVERFLOW;
3. Buffer allocations changed from sizeof(struct) (56) to 64 to ensure
   space for future-proof fields.
4. After use, allocated buffers are wiped with memset(0) and released.
5. FveDatumHwFvekGetWrappedTestKeyCopy introduced – copies wrapped key
   into driver memory instead of using caller pointer directly.
6. FveMatchIceHwCryptoDescriptor completely rewritten – validates block
   size, FIPS state, and ICE descriptor before accepting.
7. WPP trace-points updated; error paths hardened to early-return.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// old SimIceKmiWrapKey
if (!a2 || !a3 || !a4 || *a3 > 0x20u)           // only local checks
    return STATUS_INVALID_PARAMETER;
...
memmove(a5+88, a2+24, *(WORD*)(a2+22));          // unchecked copy

// patched
v8 = SimIceKmiQueryCapabilities(a1,&v10);
if (v8>=0) {
    if (!a2 || ((BYTE4(v10)&1)&&(!a3 || *a3>(WORD)v10)))
        return STATUS_INVALID_PARAMETER;
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-mode ⇒ DeviceIoControl(Fvevol, IOCTL_FVE_HW_WRAP_FVEK, …)
  ↳ IoctlFveHardwareWrapFvek()
      ‑ copies caller buffer to pool without real validation
      ↳ FveIsValidWrapKeyRequest()  (old: size only)
      ↳ FveIceHwWrapFvek()
            ↳ SimIceKmiWrapKey()/SimIceKmiInsertChallenge()
                 (unchecked memmove) ⇒ corrupted request
            ↳ Hardware wraps key ⇒ policy bypass.

Attack Vector
--------------------------------------------------------------------
Local adversary with physical or administrative access sends crafted
IOCTL_FVE_HARDWARE_WRAP_FVEK request containing oversized key/challenge
fields.  No authentication is required beyond ability to issue the
IOCTL; attack can be staged from WinPE or DMA-capable bus.

Security Impact
--------------------------------------------------------------------
By injecting extraneous data the attacker coerces BitLocker to accept
or generate hardware-wrapped FVEKs outside the allowed cryptographic
parameters, effectively disabling FIPS/key-size enforcement and
bypassing BitLocker’s hardware key-wrapping protections.  This enables
physical attacks that retrieve or substitute the volume master key and
thus decrypt data without the authorised key protectors.

Fix Effectiveness
--------------------------------------------------------------------
Patch adds capability-based size checks, integer-overflow guards,
secure buffer handling, and full cleanup, eliminating the original
unchecked memmove paths.  With these validations in place the crafted
oversized requests are rejected with STATUS_INVALID_PARAMETER or
STATUS_BUFFER_TOO_SMALL, preventing the bypass.  No bypass of the new
checks is apparent from the diff.
