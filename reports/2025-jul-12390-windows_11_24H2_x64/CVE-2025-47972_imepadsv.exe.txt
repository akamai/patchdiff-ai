{'date': 1752036220.1330292, 'patch_store_uid': 'd7c0a9d1-8246-4326-bb94-1833a08651cf', 'file': 'imepadsv.exe', 'cve': 'CVE-2025-47972', 'confidence': 0.33, 'kb': 'KB5062553', 'change_count': 3}
--------------------------------------------------------------------
CVE-2025-47972 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Input Method Editor (IME) – imepadsv.exe.  Specifically the
Windows Implementation Library (WIL) feature-state cache inside
wil::details::FeatureImpl<__WilFeatureTraits_Feature_TestValidate> and
wil::details::FeatureImpl<__WilFeatureTraits_Feature_TestConfNum>.

Vulnerability Class
--------------------------------------------------------------------
Race condition / improper synchronization on a shared 32-bit feature
state word (CWE-362).

Detailed Root Cause Analysis
--------------------------------------------------------------------
Each FeatureImpl object keeps an int32 flag field at offset 0 that
caches enable/disable and subscription bits (bit 1 == Cached,
bit 2 == CurrentStateValid, bit 4 == Subscribed, bit10/11 hold option
values, etc.).

Prior to the patch the helper
__private_IsEnabled(unsigned int *state) executed the following logic:
1. It copied *state into a local variable v2 without any lock.
2. If bit4 (Subscribed) was clear it reread the cache via a separate
   helper but still never wrote back to *state.
3. It then called ReportUsageToService() with values derived from the
   stale, non-atomically read v2.

Because *state is global to all threads using the feature, concurrent
callers could interleave the read-modify sequences and observe torn or
out-of-date flag combinations.  A second thread could set the enable
bits between the first thread’s two reads, causing step 3 to report an
incorrect configuration.  More importantly, other code paths (e.g.
GetCurrentFeatureEnabledState) expect bit2/bit4 transitions to be
atomic; when they are not, later logic clears security-critical bits
(0x400) based on wrong assumptions.  This creates a time-of-check/
time-of-use gap that may trick privileged IME service code into
believing a feature is validated when it is not, yielding elevation of
privilege.

GetCurrentFeatureEnabledState suffered from the same issue.  It called
__private_IsEnabled() and then rewrote *a2 depending on the returned
boolean – again with no atomic protection.  The function also set or
cleared bit0 (runtime-controlled “enabled”) non-atomically, so a race
could flip a feature from disabled to enabled while privilege
validation still assumed the old state.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// pre-patch: completely unsynchronised read
v2 = *a1;                     // <- torn read possible
...
if ((*a1 & 4) == 0)           // Subscribed?
    v7 = *(_QWORD *)GetCachedFeatureEnabledState(a1,&v8);
...
ReportUsageToService(a1 + 2, 50565209i64, (v2 >> 10) & 1,
                     (v2 >> 11) & 1, &v5, v3, 0);

// post-patch: atomic update loop
v6 = *(_DWORD *)a1;
...
while (1)
{
    v11 = v6 | newlyComputedBits;
    if (_InterlockedCompareExchange((volatile long *)a1, v11, v6)==v6)
        break;                // serialises writers
    v6 = v12;                 // retry with fresh value
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Any IME client or component -> FeatureImpl::GetCurrentFeatureEnabledState
   -> (pre-patch) __private_IsEnabled -> unsynchronised read/write
   -> incorrect flags -> ReportUsageToService running in IME service
   context -> mistaken trust decisions / privilege boundary crossed.

Attack Vector
--------------------------------------------------------------------
An authorised user launches parallel threads that repeatedly call IME
APIs which in turn query the vulnerable feature.  By racing the calls
an attacker can force inconsistent cache values, causing the IME
service (running with higher privilege) to treat the caller as
validated and execute elevated operations.  Network context is
"unknown"; the diff shows only local race paths.

Patch Description
--------------------------------------------------------------------
1. Old helper __private_IsEnabled was replaced by a new
   ReportUsage(bool,ReportingKind,UINT64) implementation.
2. The new code:
   • Performs an atomic compare-exchange loop on the shared 32-bit
     cache word to merge new bits safely.
   • Subscribes to configuration changes exactly once after the cache
     becomes valid.
   • Unconditionally uses the (now consistent) cached value when
     calling ReportUsageToService.
3. GetCurrentFeatureEnabledState signature expanded and now calls the
   new thread-safe ReportUsage instead of __private_IsEnabled.
4. All direct flag mutations are now done through the same atomic
   compare-exchange mechanism.

Security Impact
--------------------------------------------------------------------
The race allowed an attacker-controlled thread to desynchronise IME
feature state checks, resulting in incorrect privilege checks inside
the IME service process and enabling elevation of privilege.

Fix Effectiveness
--------------------------------------------------------------------
The added _InterlockedCompareExchange gives single-writer semantics to
the cache word and removes the window for torn or out-of-date reads.
Coupled with one-time subscription logic, the patch appears sufficient
against this specific race.  No remaining unsynchronised accesses were
observed in the modified paths.
