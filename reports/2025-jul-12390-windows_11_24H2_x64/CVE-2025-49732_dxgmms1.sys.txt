{'patch_store_uid': '9551c82f-46f7-42d2-98ac-de55ac8381a2', 'kb': 'KB5062553', 'cve': 'CVE-2025-49732', 'change_count': 1, 'file': 'dxgmms1.sys', 'confidence': 0.26, 'date': 1752036998.1668844}
--------------------------------------------------------------------
CVE-2025-49732 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Kernel Graphics Memory Manager (dxgmms1.sys),
function InsertEventEntryInLookUpTable.

Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow / out-of-bounds write leading to
privilege-escalation.

Detailed Root Cause Analysis
--------------------------------------------------------------------
InsertEventEntryInLookUpTable receives a caller-controlled field
"a5" that represents the number of performance counters to merge
into an existing event entry.  In the original build the parameter
is declared as an unsigned 8-bit value and is used directly to bound
an aggregation loop:

  start_index = 2;
  do { … } while (index < a5 + 2);

For every iteration the code dereferences two parallel arrays that
are allocated as part of an EVENT_ENTRY object:
  - *(QWORD *)(a4 + 16*index)          (source counter)
  - *(QWORD *)(v16 + 16) + 16*index    (target counter)
The EVENT_ENTRY allocation size is driven by an internal constant
(max 2 counters) and is **not** resized in relation to the caller
supplied "a5" value.  Supplying any value bigger than the internal
limit therefore causes the loop to walk past the end of both
arrays, performing _InterlockedAdd64 / _InterlockedCompareExchange64
on out-of-bounds memory.  Because the objects live in non-paged
pool, the writes corrupt adjacent heap data and can be groomed to
achieve arbitrary kernel code execution.

Key data involved:
  a5          – untrusted counter count (0..255 before patch)
  EVENT_ENTRY – contains +16 pointer to an array[2] of 16-byte
                 PERF_FIELD blocks { QWORD Value; BYTE Type; … }
  v12 / index – loop cursor fed by a5, starts at 2

The function may be reached from user-mode through several D3DKMT
ioctls that finally call dxgmms1!DxgkInsertEvent, propagating the
user-provided counter count unchanged.  No prior validation exists
in either user-mode or kernel-mode layers.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable build
LOBYTE(v12) = 2;
if (a5) {
  do {
    v19 = **(_QWORD **)(a4 + 16 * v12);
    v20 = *(_QWORD *)(v16 + 16);
    v22 = *(volatile signed __int64 **)(v20 + 16 * v12);
    _InterlockedAdd64(v22, v19);           // unchecked index
    LOBYTE(v12) = v12 + 1;
  } while ((unsigned __int8)v12 < (unsigned int)a5 + 2);
}
```

```c
// fixed build
v19 = 2;
if (a5) {
  do {
    AggregateField(
      *(_QWORD *)(*(_QWORD *)(v16 + 16) + 16 * v19),
      **(_QWORD **)(a4 + 16 * v19),
      *(BYTE *)(*(_QWORD *)(v16 + 16) + 16 * v19 + 13));
    v19 = v20 + 1;                         // v20 holds next safe idx
  } while (v19 < v21);                     // v21 == max allowed
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User process issues a D3DKMT ioctl supplying a crafted structure
   with an oversized counter count (e.g., 0xFF).
2. Dxgk.sys forwards the request to dxgmms1!InsertEventEntryInLookUpTable
   with a5 == 0xFF.
3. Function allocates a normal-sized EVENT_ENTRY (two counters).
4. The aggregation loop iterates 255 times and performs interlocked
   writes past the end of the allocation.
5. Pool metadata or neighbouring objects are corrupted, enabling EoP.

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker executing user-mode code that can call
public graphics interfaces (D3DKMT* / DirectX) under any desktop
session.  No special privileges are required beyond the ability to
open the device handle.

Patch Description
--------------------------------------------------------------------
• Parameter a5 changed from unsigned __int8 to *signed* char to
  emphasise range, but more importantly it is no longer used as a
  loop bound.
• New local variables (v19, v20, v21) hold the **sanitised** maximum
  number of counters; v21 is derived from an internal constant, not
  from caller input.
• Unsafe manual CAS logic replaced by AggregateField helper that
  operates on one field at a time.
• The former `(index < a5 + 2)` condition removed; loop now ends at
  the internally-defined limit, preventing any out-of-bounds access.

Security Impact
--------------------------------------------------------------------
Prior to the fix, user-supplied data could cause a heap buffer
overflow inside the kernel graphics stack, enabling elevation of
privilege or a kernel crash.  The issue scores as EoP because the
attacker already runs code locally but can jump to kernel context.

Fix Effectiveness
--------------------------------------------------------------------
The patched code eliminates direct use of the untrusted a5 in array
indexing and delegates updates to a range-checked helper.  Provided
AggregateField itself validates the index, the overflow path is
closed.  No remaining caller-controlled loop bound is observable in
this function, suggesting the fix is effective.  Unknown whether
other helper functions accept oversize indices.
