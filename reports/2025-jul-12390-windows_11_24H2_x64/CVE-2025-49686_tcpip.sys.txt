{'date': 1752036998.157082, 'kb': 'KB5062553', 'patch_store_uid': 'ca4affdb-057f-41ae-b23c-ab51ebba5ecc', 'file': 'tcpip.sys', 'confidence': 0.22, 'change_count': 113, 'cve': 'CVE-2025-49686'}
--------------------------------------------------------------------
CVE-2025-49686 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows TCP/IP driver (tcpip.sys) – routine WfpAleAuthorizeConnect(),
part of the Windows Filtering Platform (WFP) connection-authorisation
path used for outbound TCP connect processing.

Vulnerability Class
--------------------------------------------------------------------
NULL-pointer dereference (CWE-476) leading to controlled kernel read /
write and therefore local elevation of privilege.

Detailed Root Cause Analysis
--------------------------------------------------------------------
When the caller supplies a non-zero *RedirectRecord* (a11) and the
endpoint is marked with the flag 0x2000 (FWPM_NET_EVENT_FLAG_PROXY),
WfpAleAuthorizeConnect has to locate the original redirect record in
the per-flow list anchored at   SpinLock[56] (field “OriginalRedirect”
in the ALE endpoint).  

Before the patch the code performed:

  Original = AleFindOriginalRedirectRecordInList( *(QWORD*)(SpinLock+56) );
  Port     = *(USHORT *)(Original+72);
  Offset   = (Port==23) ? 80 : 76;          // choose IPv6 / IPv4
  AddrPtr  = (UINT32 *)(Original + Offset); // pointer to IP address

No verification of the returned pointer *Original* was carried out.
If AleFindOriginalRedirectRecordInList() failed and returned NULL, the
subsequent dereference *(USHORT *)(0+72) accessed the NULL page.  The
calculated AddrPtr became 0x4C or 0x50 and was immediately forwarded
to WfpAleValidateRemoteAddressAndProxyInRecord().  That helper routine
reads and writes through the supplied pointer, effectively turning the
NULL-pointer dereference into read-/write access to the first 128
bytes of kernel address space.  On systems where user–mode can map the
NULL page (or via a suitable kernel spraying technique) this behaviour
is exploitable to execute arbitrary code in kernel context, giving the
attacker SYSTEM privileges.

Key data items involved
  • SpinLock+56 : pointer to first redirect record (can be NULL)  
  • Flag 0x2000 : indicates proxy / redirect path is active  
  • a11         : caller-supplied redirect record handle  
  • OriginalRedirectRecordInList + 72/76/80 : protocol and address
    fields that are blindly dereferenced.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch
OriginalRedirectRecordInList = AleFindOriginalRedirectRecordInList(
                                  *((QWORD*)SpinLock + 56));
v74  = 80;
v75  = *(USHORT *)(OriginalRedirectRecordInList + 72); // <-- NULL deref
if ((USHORT)v75 != 23)
    v74 = 76;
v76  = (UINT32 *)(OriginalRedirectRecordInList + v74);
WfpAleValidateRemoteAddressAndProxyInRecord(v76, v75, a11);
```

```c
// after patch (simplified)
for (rec = *((QWORD*)SpinLock + 56); rec && *(QWORD*)(rec+48); rec = *(QWORD*)(rec+48))
    ;                                   // walk to last valid record
if (!rec)
    return STATUS_INVALID_PARAMETER;    // bail out – prevents NULL use
prot = *(USHORT *)(rec + 72);
addr = rec + ((prot==23)?80:76);
status = WfpAleValidateRemoteAddressAndProxyInRecord(addr, prot, a11);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User process initiates a TCP connection that is subject to WFP ALE
   connect-redirect.
2. Kernel ends up in WfpAleAuthorizeConnect() with:
     a11 = pointer to redirect record,
     SpinLock[13] bit 0x2000 set,
     SpinLock[56] deliberately NULL (malformed state).
3. Function calls AleFindOriginalRedirectRecordInList() which returns
   NULL because the list head is NULL.
4. Subsequent dereference at NULL+72 triggers kernel access to address
   0x48, later 0x4C/0x50, leading to controlled memory corruption /
   crash.

Attack Vector
--------------------------------------------------------------------
Requires local execution with the ability to install a callout or
policy that sets the 0x2000 flag and then trigger a connect request
that lacks a valid OriginalRedirect list.  WFP callouts running in
user-mode (BFE API) under standard user rights are sufficient, so an
unprivileged attacker can reach the vulnerable path.

Patch Description
--------------------------------------------------------------------
1. Function prototype adjusted: parameters are now strongly typed to
   avoid mis-ordering.
2. Replaced the single un-checked call to
   AleFindOriginalRedirectRecordInList() with an explicit while-loop
   that both guarantees *rec* is non-NULL and walks to the last valid
   redirect record.
3. Added early return with STATUS_INVALID_PARAMETER if the list head is
   NULL.
4. Introduced extensive allocation-failure handling and auditing code
   – but crucially, NULL pointers are no longer dereferenced.

Security Impact
--------------------------------------------------------------------
Prior to the fix an unprivileged local attacker could cause tcpip.sys
to dereference NULL and write to low kernel addresses.  By mapping the
NULL page (or via other memory-remapping tricks) the attacker gains
arbitrary kernel R/W which can be leveraged for privilege escalation to
SYSTEM.  In default configurations the bug also constitutes a local
Denial-of-Service (Blue Screen) vector.

Fix Effectiveness
--------------------------------------------------------------------
The patched loop verifies that a valid redirect record pointer exists
before any field dereference.  If the pointer is NULL the routine
returns an error and the code path aborts.  Because every subsequent
access now relies on a validated, non-NULL pointer, the NULL-pointer
issue and associated privilege-escalation primitive are removed.
