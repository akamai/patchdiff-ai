{'kb': 'KB5062553', 'change_count': 25, 'confidence': 0.22, 'file': 'netio.sys', 'date': 1752037021.095204, 'cve': 'CVE-2025-49686', 'patch_store_uid': '58900a0a-25aa-43c2-8117-0e5b23f9284e'}
--------------------------------------------------------------------
CVE-2025-49686 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows networking kernel driver  (netio.sys / tcpip.sys)
WFP (Stream classify / ALE flow-context) fast-path handling.

Vulnerability Class
--------------------------------------------------------------------
NULL-pointer dereference leading to controlled kernel write  
(CWE-476) – can be exploited for local elevation of privilege.

Detailed Root Cause Analysis
--------------------------------------------------------------------
The affected fast-path works on per-flow objects that are looked up in
several driver-global hash/lookup tables and then queued for deferred
inspection.  Prior to the patch the following sequence was possible:

1.  KfdClassify()->StreamPermitData() is entered for a new TCP stream.
2.  StreamPermitData() calculates the per-bucket pointer     
    (  v9 = &FlowTableBucket[13 * StreamFlagsToDataType(...)]  ) and
    immediately dereferences several fields (`v9[10]`, `v9[11]`,
    `v9[12]`) under the assumption that the bucket head has already
    been allocated and initialised.
3.  When the very first flow of a given type is processed the bucket
    entry is still NULL.  Because the old code only tested *one* of the
    three list heads, the execution continues with a NULL pointer in
    `v9[11]` and the driver performs the equivalent of

        *(NULL)->Flink = Entry;

    which raises a kernel exception (page-fault in supervisor code).
4.  The exception is taken while the caller still holds a shared spin
    lock (Acquired earlier with ExAcquireSpinLockShared), so normal
    bug-check processing is suppressed and the system crashes inside a
    raised IRQL.  A local attacker that can trigger WFP classification
    on demand can therefore cause a predictable crash in a write
    context.  With well-timed heap spraying this can be turned into a
    controlled write, giving kernel-mode code execution and hence
    elevation of privilege.

Objects/fields involved
  * `STREAM_FLOW`  – context structure (offsets +88 / +96 / +112 ...)
  * Global WFP handle table: `handleTableLock`, `handleTable`
  * Per-bucket head  :  bucket[0..31] = 8-byte pointer (volatile)
  * Spin lock that remains held on the exception path.

Patch changes
  * StreamPermitData():
      - Early return when bucket head is NULL or flow already processed.
      - Gated the potentially dangerous code behind a feature flag and
        a second explicit NULL check.
      - Allocates the bucket head with WfpAllocateFromPerProcessor­
        LookasideList() before first use.
  * KfdClassify(), KfdAleInitializeFlowTable(), *IndexTrieFree()* and
    several NSI validation helpers were modified to respect the new
    bucket initialisation and to propagate allocation failures.
  * Every dereference of the bucket head now sits behind
        if (BucketHead && BucketHead[...]) { ... }

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// pre-patch (StreamPermitData)
v9 = *(KSPIN_LOCK **)(a2 + 32);
if (*(_BYTE *)(v5 + 96))
    v9 += 13;
// <no NULL test here – v9 may point to unmapped page>
WfpAcquireSpinLock(v9 + 9, &LockHandle);
if ((_KSPIN_LOCK*)v9[10] == v9+10 && !v9[12])
    v8 = 1;                  // <-- NULL dereference
```
```c
// fixed version (StreamPermitData after patch)
if (!*(_QWORD *)(BucketHead + 128) &&
    (FlowFlags & 0x18000C) == 0) {
    StreamCompleteData(...); // safe early exit
}
...
BucketHead = WfpAllocateFromPerProcessorLookasideList(P,&WorkItem);
if (!BucketHead) { ReportError(); return STATUS_INSUFFICIENT_RESOURCES; }
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-mode (or remote) traffic ->
  NDIS -> tcpip.sys -> netio!KfdClassify() ->
  StreamPermitData() -> deref NULL bucket head -> crash / write.

Attack Vector
--------------------------------------------------------------------
Any local user capable of opening a raw TCP or SCTP socket can generate
new flows until the vulnerable bucket is accessed for the first time,
triggering the bug.  Remote traffic can also reach the path when the
system acts as a server.

Patch Description
--------------------------------------------------------------------
The update introduces a defensive allocation-first pattern:
  • Added feature flag *Feature_Firewall_BugFixes_2503_WFP_TCB_ref*.
  • StreamPermitData now allocates and initialises bucket heads from a
    per-CPU look-aside list and verifies success before use.
  • All callers (StreamPendInspection2503, KfdClassify, etc.) were
    changed to cope with allocation failures and to bail out cleanly.
  • Existing dereferences were wrapped in extra NULL checks.
  • Auxiliary helpers (NSI validators, IndexTrieFree, ... ) received
    similar hardening.

Security Impact
--------------------------------------------------------------------
Before the fix a local attacker could reliably crash the system and, by
forcing the write to land in controlled memory, achieve arbitrary
kernel write, leading to elevation of privilege (ring-0 execution).
After the fix the pointer is always valid or the function fails
gracefully, removing the primitive.

Fix Effectiveness
--------------------------------------------------------------------
Review of the patched code shows that every path to
`StreamPermitData` now ensures the bucket head is allocated and tested
for NULL before dereference.  All failure cases return an NTSTATUS
error and unwind the locks correctly, preventing both NULL pointer
usage and controlled writes.  No alternate path was found that still
uses the old logic; therefore the patch completely mitigates the
vulnerability.
