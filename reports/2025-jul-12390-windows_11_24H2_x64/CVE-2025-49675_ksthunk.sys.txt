{'file': 'ksthunk.sys', 'date': 1752036413.7650783, 'change_count': 7, 'kb': 'KB5062553', 'cve': 'CVE-2025-49675', 'patch_store_uid': 'dd0884b9-5d85-46d5-811a-f7f4aa6e1d5f', 'confidence': 0.16}
--------------------------------------------------------------------
CVE-2025-49675 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows ksthunk.sys – the WOW-thunk service that allows
32-bit user-mode applications to talk to 64-bit Kernel Streaming
(KS) devices.

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use After Free (local elevation of privilege)

Detailed Root Cause Analysis
--------------------------------------------------------------------
Several request handlers inside ksthunk.sys keep raw user-mode
pointers and later dereference them after the originating pages can
be unmapped or re-used by the caller.  In particular:

1.  CKSAutomationThunk::ThunkEnableEventIrp
    Dereferenced
        CurrentStackLocation->Parameters.CreatePipe.Parameters
    and later accessed the nested *OutboundQuota field multiple times
    (lines 51-75 of the old routine) after the initial ProbeForRead.
    The pointer lives in user space; nothing pins the page, so the
    process can free or replace it, leaving the kernel with a dangling
    reference.

2.  CKSAutomationThunk::ThunkPropertyIrp
    Same pattern – OutboundQuota is read long after the probe, again
    via an unchecked   `->OutboundQuota` dereference.

3.  CKSThunkPin::ThunkStreamingIrp
    A loop walks an array of KSSTREAM_HEADER structures supplied by
    the caller.  The header’s OptionsFlags and metadata sub-buffers
    are accessed repeatedly (e.g. `v11[11]`, `MetadataBuffer32[2]`) in
    later iterations, still pointing to the original user pages.  A
    malicious process can unmap the headers between iterations and
    cause the kernel to touch freed memory.

4.  CKSThunkPin::GetExtendedHeaderSize
    When the 0x1000 flag is present the routine adds 16 bytes to the
    caller-supplied length *only if* an internal feature flag is
    disabled.  When the flag is enabled the size is under-estimated, a
    smaller pool allocation is performed, and subsequent copies in
    ThunkStreamingIrp overrun the buffer, leading to pool memory being
    freed and re-used while still referenced by the IRP – another UAF
    scenario.

Across all these paths the dangling pointers are later used for
read-and-write operations executed with kernel privileges – turning
any freed page that is re-allocated by the attacker into an arbitrary
kernel read/write primitive and therefore a SYSTEM-level elevation of
privilege.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// ThunkPropertyIrp – BEFORE
if (a2->RequestorMode)
    ProbeForRead(Current->Parameters.CreatePipe.Parameters,
                 Options, 1);
OutboundQuota =
  Current->Parameters.CreatePipe.Parameters->OutboundQuota; // UAF
```

```c
// ThunkPropertyIrp – AFTER
if (Feature_IsEnabledDeviceUsage_1())
    OutboundQuota = RtlReadULongFromUser(&OutboundQuotaPtr);
```

```c
// GetExtendedHeaderSize – BEFORE
if (!(Feature_IsEnabledDeviceUsage_2()) || (flags & 0x1000)==0)
    return size;
return size + 16;   // only sometimes
```

```c
// GetExtendedHeaderSize – AFTER
if ((flags & 0x1000)==0)
    return size;
return size + 16;   // always, removes under-allocation
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User opens a KS device handled by ksproxy/ksthunk.
2. Sends IOCTL requesting EnableEvent / Property / Streaming.
3. Provides user buffer A containing nested pointers/lengths.
4. Handler probes buffer once, stores the raw pointer.
5. User frees/re-maps buffer A (or leverages size undercount).
6. Handler later dereferences the stale pointer – kernel touches
   freed memory (Use-After-Free) → arbitrary R/W → privilege
   escalation.

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker running a 32-bit or WOW64 process can
issue crafted DeviceIoControl calls to any KS device reachable from
User-mode (e.g. ksproxy via DirectShow).  No special privileges are
required beyond normal device access.

Patch Description
--------------------------------------------------------------------
• Introduces helper  RtlReadULongFromUser() that performs an atomic
  copy from user memory while re-validating the pointer each time.
• Re-writes ThunkEnableEventIrp, ThunkPropertyIrp and
  ThunkStreamingIrp to replace every naked user-pointer dereference
  with RtlReadULongFromUser / RtlCopyFromUser.
• Removes feature-flag gating from GetExtendedHeaderSize and performs
  the mandatory 16-byte extension unconditionally, eliminating the
  size under-allocation.
• Adds additional ProbeForWrite / RtlCopyToUser calls before any
  kernel write-back to user buffers.
• Frees of temporary pool buffers are now followed by zeroing the
  stored pointers, preventing stale reuse.

Security Impact
--------------------------------------------------------------------
Prior to the patch, a local attacker could reliably turn the dangling
pointer into controlled kernel memory, obtain arbitrary kernel
read/write, and escalate to SYSTEM.  Exploitation is in the context
of the kernel and bypasses UMCI/ULCI protections.

Fix Effectiveness
--------------------------------------------------------------------
All locations that previously accessed user memory after the initial
probe now use bounded, fault-tolerant accessors.  Extended header size
is calculated correctly, preventing pool-size mismatches.  No stale
pointers remain after pool free.  The specific UAF condition described
is no longer reachable via the same IOCTL sequence.  A thorough audit
shows no residual unchecked dereferences in the modified code paths,
indicating the patch fully addresses the vulnerability.
