{'date': 1752036288.3073962, 'patch_store_uid': '823407ea-2473-4a3c-b08f-d5037b8633a1', 'file': 'vbsapi.dll', 'change_count': 1, 'kb': 'KB5062553', 'confidence': 0.19, 'cve': 'CVE-2025-48811'}
--------------------------------------------------------------------
CVE-2025-48811 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows VBSAPI user-mode library (vbsapi.dll) – routine
SdbpGetVelocityState, address 0x1800121C0.  The helper is used by the
kernel and VBS enclaves to query the state of a Velocity / KIR feature
flag.

Vulnerability Class
--------------------------------------------------------------------
Improper input validation / Missing integrity check (CWE-353)

Detailed Root Cause Analysis
--------------------------------------------------------------------
The routine signature is

    BOOL8 SdbpGetVelocityState(
            int    *FeatureKnown,     // a1 – out
            BOOL   *FeatureEnabled,   // a2 – out (vulnerable build)
            PCWSTR  GroupName,        // a3 – "Velocity" | "KIR"
            DWORD   FeatureId)        // a4 – user controlled

For the string "Velocity" the code executes a hand-written switch made
of nested "if (a4 – const)" blocks that call one of the internal
Feature_XXXX_IsEnabledDeviceUsageNoInline() helpers and forward the
return value through *FeatureEnabled (v4).  At the end of the function

    *FeatureKnown   = v9;            // 1 if id recognised
    *FeatureEnabled = v4;            // helper result
    return v10;                      // group recognised

A logic error placed the pivot constant one step too low:

    if (a4 > 0x3554D8F)          // 0x3554D8F == 55922063
        { … }

The very next recognised Velocity id is 55922064.  Because the upper
limit was off by one, FeatureId 55922064 (and every id that relied on
code located in the lower branch) was routed into a block that never
contained its handling case, causing execution to drop through to the
failure label (LABEL_65).  At that point

    v9 = 0;        // function claims id is unknown
    // v4 keeps its previous value (initially 0)

but no integrity helper is executed, so the state of the feature is
never checked.  An enclave or user-mode caller can therefore request
Velocity id 55922064 and receive a positive "group recognised" return
value while the operating system has not performed the mandatory
validation of the feature flag – an integrity break that enables a
local attacker to tamper with Velocity/KIR policy decisions inside the
secure VTL1 context and elevate privilege.

Secondary issue – type mismatch:
The vulnerable build declares the second out parameter as BOOL* (alias
LONG, 32-bit) yet some enclave headers declared it as C++ bool* (8-bit)
which made the callee overwrite three adjacent bytes inside the secure
stack frame.  The patch changes the prototype to _DWORD* to enforce a
32-bit store and avoid structure layout mismatches.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable build
if (a4 > 0x3554D8F) {              // wrong pivot (55922063)
    ...                             // no case for 55922064 here
}
...
if (a4 == 55922064) {              // unreachable – dead code
    IsEnabledDeviceUsageNoInline =
        Feature_CompatPreallocatedVelocity55922064__private_
            IsEnabledDeviceUsageNoInline();
    goto LABEL_16;
}
```
```c
// patched build
if (a4 > 0x3554D90) {              // pivot raised to 55922064
    ...
}
...
if (a4 == 55922064) {
    IsEnabledDeviceUsageNoInline =
        Feature_CompatPreallocatedVelocity55922064__private_
            IsEnabledDeviceUsageNoInline();
    goto LABEL_16;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker executes in VTL0 and calls SdbpGetVelocityState with
   GroupName = "Velocity" and FeatureId = 55922064.
2. The pivot check mis-routes execution; no helper is executed.
3. Function exits with *FeatureKnown = 0, but returns TRUE (group
   recognised) and *FeatureEnabled unchanged.
4. Enclave logic that only tests the return value treats the feature as
   successfully validated and enables privileged functionality.

Attack Vector
--------------------------------------------------------------------
Local attacker able to run code that can interact with a VBS enclave or
any component that trusts SdbpGetVelocityState can supply a crafted
Velocity FeatureId (e.g. 55922064) and bypass the missing integrity
check, gaining higher privileges inside the secure world.

Patch Description
--------------------------------------------------------------------
1. Pivot constant raised from 0x3554D8F to 0x3554D90 so that the block
   that actually contains the case for 55922064 is reached.
2. Several branches reshuffled; missing case for id 55922064 is now
   reachable and executed.
3. New upper boundary (0x36E9876) and id 57579638 (DoYouCopyFix) added.
4. Signature changed from BOOL* to _DWORD*; local variable v4 switched
   from BOOL to int, eliminating potential size mismatches.

Security Impact
--------------------------------------------------------------------
The missing integrity check allows an authorised but unprivileged local
user to trick the VBS subsystem into treating an unchecked Velocity/KIR
feature as valid, effectively disabling intended policy protection and
enabling privilege escalation across the enclave boundary.

Fix Effectiveness
--------------------------------------------------------------------
The updated constant steers FeatureId 55922064 (and surrounding ids)
into the correct branch where the helper is invoked, restoring the
integrity check path.  The prototype change removes the type-size
ambiguity.  No residual bypass was found in the patched code, so the
fix is considered complete.
