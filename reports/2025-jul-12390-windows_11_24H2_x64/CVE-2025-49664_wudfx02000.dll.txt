{'kb': 'KB5062553', 'date': 1752036551.9958236, 'cve': 'CVE-2025-49664', 'patch_store_uid': 'ddd1599e-ccac-4065-8268-87f7edb17906', 'change_count': 2, 'confidence': 0.25, 'file': 'wudfx02000.dll'}
--------------------------------------------------------------------
CVE-2025-49664 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows User-Mode Driver Framework Host (wudfx02000.dll)
WIL feature-usage telemetry helpers
Function pairs:
  • FeatureImpl<Feature_TestConfNum>::GetCurrentFeatureEnabledState()
  • FeatureImpl<Feature_TestValidate>::ReportUsage()

Vulnerability Class
--------------------------------------------------------------------
Information disclosure through use of uninitialised stack / register
values (CWE-200, closely related to CWE-457 Uninitialised Variable).

Detailed Root Cause Analysis
--------------------------------------------------------------------
GetCurrentFeatureEnabledState() determines the enablement state of a
feature and, under certain bit-mask conditions, forwards the result to
Feature_TestValidate::ReportUsage() for telemetry.

Before the fix the call sequence was:
    ReportUsage(&impl, v12, v13, v14);
where
    v12  = (bool)dl  (lower 8-bit of RDX after a *previous* call)
    v13  = r8       (never written after entry)
    v14  = r9       (never written after entry)

Because the compiler generated code does not initialise those
variables after the preceding WilApi_GetFeatureEnabledState() and
__private_IsEnabled() calls, v12/v13/v14 contain whatever data were
already present in the respective volatile registers at that moment –
commonly stack pointers, return addresses or other process-internal
values.

ReportUsage() packages the three parameters into FEATURE_LOGGED_TRAITS
and forwards them to wil::details::ReportUsageToService(), which sends
an IPC message to the telemetry / diagnostic service running under the
caller’s context.  Any local user able to trigger the API (or read the
resulting ETW/diagnostic channel) can therefore retrieve up to 8 bytes
of out-of-scope stack/register data per invocation.

Structures / parameters involved
  • wil_details_FeatureStateCache  – 64-bit field copied verbatim
  • FEATURE_LOGGED_TRAITS.stage    – preset to 0x02 ("usage")
  • FEATURE_LOGGED_TRAITS.version  – always 0

The exposed cache/trait values can contain:
  – Saved frame pointers (ASLR bypass)
  – Previous function arguments
  – Potentially sensitive user data resident on the stack

Patch analysis shows all three uninitialised paths being removed.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// wudfx02000.dll – before patch (excerpt)
if ( wil::details::FeatureImpl<__WilFeatureTraits_Feature_Servicing_
        CFONTPrintLeak>::__private_IsEnabled(&impl, (wil::ReportingKind)v8) )
{
    wil::details::FeatureImpl<__WilFeatureTraits_Feature_Standalone_25_01_
        NonSec>::ReportUsage(&impl2, v12, v13, v14); // v12-14 UNINIT
    v9 = 1;
}
```
```c
// after patch
wil::details::FeatureImpl<__WilFeatureTraits_Feature_TestValidate>::
    ReportUsage(&impl, v11, v12, v13); // all vars initialised
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Client code calls WilApi_GetFeatureEnabledState(0x33B9AFF,…).
2. wudfx02000!Feature_TestConfNum::GetCurrentFeatureEnabledState()
   executes and sets bits 0xC00 or 0x40.
3. Condition true  -> enters telemetry path.
4. Legacy build: uninitialised v12/v13/v14 forwarded to ReportUsage().
5. ReportUsage() issues wil::details::ReportUsageToService().
6. Diagnostic channel now contains leaked process memory.

Attack Vector
--------------------------------------------------------------------
Any local, non-privileged process that can load wudfx02000.dll and call
WilApi_GetFeatureEnabledState() (exported by the DLL) can repeatedly
trigger the vulnerable code path and harvest the leaked values from
telemetry logs or by intercepting the IPC to the WIL reporting
service.

Patch Description
--------------------------------------------------------------------
• Reworked call site: removed __private_IsEnabled() dependency and
  replaced the three OUT parameters with explicitly initialised
  variables (v11/v12/v13).
• Changed ReportUsage() prototype; renamed parameters and rewrote the
  body so that it uses local, well-defined state.
• FEATURE_LOGGED_TRAITS.stage set to 3 (new stage) and the boolean
  "enabled" argument is now hard-coded to 1, eliminating uncontrolled
  data flow.

Security Impact
--------------------------------------------------------------------
Before the patch up to 8 bytes of stack/register data per call could be
sent to a service channel accessible by the attacker, enabling:
  • Disclosure of process memory (CVE-2025-49664)
  • Possible ASLR/KASLR bypass if code pointers are leaked.
No code execution or privilege escalation was identified; impact is
confined to information disclosure.

Fix Effectiveness
--------------------------------------------------------------------
The new build initialises every parameter passed into ReportUsage() and
eliminates reliance on volatile registers. Manual inspection of the
patched functions shows no remaining paths where uninitialised values
are referenced. Therefore the patch fully addresses the identified
leak.
