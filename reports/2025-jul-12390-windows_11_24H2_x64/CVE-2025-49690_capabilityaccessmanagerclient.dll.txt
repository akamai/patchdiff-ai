{'date': 1752036625.5737393, 'confidence': 0.33, 'file': 'capabilityaccessmanagerclient.dll', 'change_count': 62, 'patch_store_uid': '219520f9-4857-4345-8276-629218103cb4', 'kb': 'KB5062553', 'cve': 'CVE-2025-49690'}
--------------------------------------------------------------------
CVE-2025-49690 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Capability Access Management Service (camsvc)
capabilityaccessmanagerclient.dll – ModernPolicy::PolicyManager

Vulnerability Class
--------------------------------------------------------------------
CWE-362: Race Condition / Improper Synchronisation
Secondary symptom: CWE-415 Double Free (heap corruption)

Detailed Root Cause Analysis
--------------------------------------------------------------------
Policy objects are cached in the global map
  PolicyManager::m_policyCache
and protected by an SRW lock
  PolicyManager::m_policyLock.

Before the patch, GetPolicy() executed the following sequence
for an uncached capability-policy name:
1. AcquireSRWLockShared()  (shared)
2. std::tree::find() – name not found → release *shared* lock
3. Walk the *factory* map, build a new
   std::shared_ptr<CapabilityPolicy> via a factory callback
4. AcquireSRWLockExclusive()  (writer)
5. Re-check cache and, if still absent, insert the newly created
   policy object into m_policyCache
6. ReleaseSRWLockExclusive()

While step 2→5 is in progress another thread can race through the
same path for the same key.  The two threads create two identical
std::shared_ptr instances that both believe they are the *sole*
owners of the CapabilityPolicy instance.  Immediately after the
object is inserted, the temporary shared_ptr held in v16 is
explicitly decremented ( _Ref_count_base::_Decref(v17) ).
Whichever thread executes the decref last frees the object even
though the map still stores a dangling pointer.  Subsequent reads
of that entry (including from high-privilege RPC handlers) result
in use-after-free, double free and deterministic heap corruption
inside the SYSTEM process camsvc, providing an elevation primitive.

The defect is therefore the modification of a shared container
without holding an exclusive lock *while* a live reference is still
being released outside the lock, allowing two racing creators to
free each other’s object.

Structures / parameters involved:
  – std::_Tree (policy cache & factory maps)
  – SRWLOCK  m_policyLock
  – shared_ptr control block ( _Ref_count_base )
  – GetPolicy(std::wstring const& name)

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – shortened
AcquireSRWLockShared(&m_policyLock);
find(cache, name);
if (not_found) {
    ReleaseSRWLockShared(&m_policyLock);          // still R/O state
    make_shared<CapabilityPolicy>();              // new object
    AcquireSRWLockExclusive(&m_policyLock);
    insert(cache, name, new_obj);
    _Ref_count_base::_Decref(v17);                // may free obj
}
```
```c
// after patch – simplified
AcquireSRWLockShared(&m_policyLock);
find(cache, name);
if (not_found) {
    *out = nullptr;               // no creation while shared lock
} else {
    std::make_shared<CapabilityPolicy>(*ptr);
}
ReleaseSRWLockShared();
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Client (low-privilege) ➜ camsvc RPC ➜
  PolicyManager::GetPolicy("ModernTestPolicy_…")
    • Two or more concurrent calls with the *same* string
    • Both threads execute racing creation path above
    • Heap corruption occurs inside camsvc

Attack Vector
--------------------------------------------------------------------
A local attacker repeatedly invokes any interface that forces
camsvc to resolve an uncached capability policy (e.g. by supplying
crafted policy names through the public Capability Access APIs).
By running the calls in parallel the attacker wins the race,
corrupts heap metadata and executes arbitrary code in the SYSTEM
service context, thus achieving privilege escalation.

Patch Description
--------------------------------------------------------------------
1. GetPolicy() was rewritten:
   • Never allocates new policies under a shared lock.
   • If the name is missing, simply returns an empty shared_ptr.
   • No longer touches the factory map or performs manual _Decref.
2. Initialize() now pre-registers all supported policies *once*
   under an exclusive lock via AddTestPolicies(), eliminating the
   need for on-demand creation.
3. New helper QueryCapabilitiesWithBoolPolicySet() and other
   accessors iterate the cache only while holding a shared lock and
   perform no mutations.

Security Impact
--------------------------------------------------------------------
Prior to the patch, uncontrolled concurrent insertion freed policy
objects while still referenced, enabling reliable heap corruption
from a low-privileged context.  Because camsvc runs as LOCAL SYSTEM
this leads to local Elevation of Privilege (LPE).

Fix Effectiveness
--------------------------------------------------------------------
The dangerous read-modify-write window has been removed.  All cache
mutations now occur only during one-time initialization while the
exclusive lock is held.  Runtime code paths are strictly read-only
and covered by shared locks, so the original double free / race
condition is no longer reachable.  No residual race paths were
observed in the patched diff, indicating the fix is effective.
