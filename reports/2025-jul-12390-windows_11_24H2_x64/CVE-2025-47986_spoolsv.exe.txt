{'date': 1752037691.7664068, 'patch_store_uid': 'b78f26b8-8fd5-4b88-9d92-123234523668', 'cve': 'CVE-2025-47986', 'kb': 'KB5062553', 'change_count': 41, 'file': 'spoolsv.exe', 'confidence': 0.27}
--------------------------------------------------------------------
CVE-2025-47986 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Universal Print Management Service (spoolsv.exe) – several
RPC “Async*” entry-points handling printer, driver, port and monitor
management requests.

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use-After-Free (resulting in local elevation of privilege).

Detailed Root Cause Analysis
--------------------------------------------------------------------
Every affected RPC stub receives user-controlled Unicode strings
(printer name, driver name, port name, etc.) and immediately builds a
TWorkItem object through a templated CreateInstance<> helper.  The
TWorkItem is reference-counted; after the object is queued to the
thread-pool (AddItem) the caller releases its reference, leaving the
object owned solely by the worker crew.

Before the patch none of the stubs validated the length of the incoming
strings – they were passed straight to CreateInstance(), which in turn
allocates a fixed-size internal buffer (≈0x104 WCHAR) and copies the
content with wcscpy.  Supplying an over-long name (>0x104 WCHAR, or for
add-print-processor >0x207 WCHAR) overwrites the TWorkItem’s reference
counter and v-table pointer.  When the caller subsequently executes

    NCoreLibrary::TReferenceCount::Release( WorkItem );

on the already corrupted object, the manipulated ref-count reaches
zero and the object is freed, while a pointer to it is still en-queued
inside the worker thread list.  Any later access by the worker crew
operates on freed memory – a classic use-after-free that allows the
attacker to place a forged object/v-table and obtain arbitrary code
execution in the SYSTEM-level spoolsv.exe process.

Functions changed by the patch include (non-exhaustive):
  • RpcAsyncEnumPrinters
  • RpcAsyncEnumPrinterDrivers / _Datatypes / _Processors
  • RpcAsyncGet/SetPrinterData(Ex)
  • RpcAsyncAdd/Delete*  (Monitor, Driver, Port, Form, …)
Each of them shared the same vulnerable pattern.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Before – RpcAsyncEnumPrintProcessors
Reply = 0;
Instance = CreateInstance(&YEnumPrintProcessors, ...);
if (Instance < 0 ||
    (Instance = WorkCrew::AddItem(g_pWorkCrew, Reply),
     Release(Reply), Instance < 0))
{
    Reply = (USHORT)Instance;          // use-after-free window
    RpcAsyncCompleteCall(pAsync,&Reply);
}

// After – first lines of every stub
if (FeatureEnabled && (a3 && wcsnlen(a3,0x104)>=0x104 ||
                       a4 && wcsnlen(a4,0x104)>=0x104))
{
    LOWORD(a4)=87;            // ERROR_INVALID_PARAMETER
    RpcAsyncCompleteCall(...);
    return;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Low-privileged attacker opens the named pipe "\\.\pipe\spoolss".
2. Sends an RPC call to any of the vulnerable *Async* procedures with a
   very long printer/driver/port string.
3. spoolsv.exe allocates TWorkItem, overflows the fixed buffer and
   corrupts the object’s ref-count.
4. Caller releases the object – memory is freed.
5. Worker thread later dereferences the stale pointer, executing attacker
   data under SYSTEM integrity.

Attack Vector
--------------------------------------------------------------------
Local – requires the ability to talk to the spooler RPC interface.  Any
normal user on the machine can reach the interface, therefore the bug
enables a straightforward privilege escalation to SYSTEM.

Patch Description
--------------------------------------------------------------------
• Added strict length validation: every RPC stub now calls wcsnlen() and
  rejects strings longer than 0x104 (260) WCHARs, or 0x207 for the file
  name parameter in AddPrintProcessor.
• Returns ERROR_INVALID_PARAMETER (87) and completes the async call
  early when validation fails – no object allocation occurs.
• Added “Feature 2578215227” gate so that checks can be switched on/off
  through Windows feature flags.
• No structural change of TWorkItem – mitigation is purely input
  sanitisation to keep buffer copies within bounds.

Security Impact
--------------------------------------------------------------------
Before the fix a normal domain / local user could reliably corrupt heap
structures inside spoolsv.exe and run arbitrary code with SYSTEM
privileges – full local elevation.  No user interaction is required and
exploitation is entirely local.

Fix Effectiveness
--------------------------------------------------------------------
The patched stubs exit before any heap allocation when supplied with an
over-long string, fully preventing the overwrite that led to the use-
after-free.  No other code paths to CreateInstance() are reachable with
unchecked input, so the vulnerability is effectively closed.
