{'patch_store_uid': 'a044a89b-3736-4c86-bd97-0de8a0278948', 'cve': 'CVE-2025-49744', 'confidence': 0.25, 'date': 1752037013.991043, 'kb': 'KB5062553', 'file': 'win32kbase.sys', 'change_count': 66}
--------------------------------------------------------------------
CVE-2025-49744 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Graphics Component (win32kbase.sys) – function
Gre::Base::AllocateSessionGlobalsArea.

Vulnerability Class
--------------------------------------------------------------------
CWE-122: Heap-based Buffer Overflow (resulting from a structure size
mismatch).  An accompanying integer-related lapse (CWE-191) allowed the
incorrect size constant to persist.

Detailed Root Cause Analysis
--------------------------------------------------------------------
AllocateSessionGlobalsArea allocates memory for a per-session GDI
globals block and then fills the buffer with several predefined tables
and default values.  In the vulnerable build the buffer is obtained via

    PALLOCMEM(5752, 0x315E4C47)

which reserves exactly 0x1678 (5752) bytes.  Subsequent initialisation
stores reach offsets 0x1670, 0x1674 and later code paths reach 0x1678
and 0x167C:

  * original code wrote only a 4-byte DWORD at offset 0x1670
  * other kernel routines later upgraded that location to a QWORD
    (8 bytes) and introduced a new DWORD at 0x1678

Thus up to 12 bytes were written beyond the end of the 0x1678-byte
allocation, corrupting the adjacent pool chunk.  The overwrite occurs
while the session is being brought up, before the session pointer is
published, so the attacker controls execution timing by creating/
terminating sessions or by racing GDI API calls during logon.

Corrupted data include pointers (e.g. the reference-tracker vtable at
+0x1670) and counters; overwriting them lets an attacker smuggle
arbitrary kernel pointers into follow-up dereferences and obtain kernel
code execution in the current session context.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// allocation size (before)
v2 = (_OWORD *)PALLOCMEM(5752i64, 826754887i64);
…
// final writes that overflowed
*(_DWORD *)(v7 + 5744) = 0;          // in-bounds
// later (other code) treated same field as QWORD and
// additionally touched +5752 -> overflow
```
Patch
```c
// fixed allocation
v2 = (_OWORD *)PALLOCMEM(5760i64, 826754887i64);  // +8 bytes
…
*(_QWORD *)(v7 + 5744) = 0i64;        // now 8-byte store
*(_DWORD *)(v7 + 5752) = 0;          // new field, still in range
```
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Win32 session starts (e.g. logon or Fast User Switch).
2. W32GetSessionState() -> Gre::Base::AllocateSessionGlobalsArea().
3. Function allocates 5752-byte pool block, fills defaults.
4. Copy of 8-byte data at +0x1670 or later write at +0x1678 overruns
   the heap buffer, corrupting pool headers or neighbouring object.
5. Corruption is used by attacker-controlled data to escalate
   privileges when the corrupted object is subsequently executed or
   freed.

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker.  By creating a new desktop session or
forcing a session recycle (e.g. via RDP logon/off or Fast User Switch)
and racing GDI API calls, the attacker can influence the timing and
content of the out-of-bounds stores, leading to controlled kernel heap
corruption and privilege escalation.

Patch Description
--------------------------------------------------------------------
The fix increases the allocation size from 0x1678 (5752) to 0x1680
(5760) bytes, aligning the buffer with the enlarged structure layout.
Additional constants have been moved to new, versioned tables and the
code now stores an 8-byte zero at +0x1670 and a 4-byte zero at +0x1678
explicitly, both safely inside the new allocation.  No other logic
changes were required.

Security Impact
--------------------------------------------------------------------
A kernel-mode heap buffer overflow allows arbitrary pool corruption.
Because the overwritten area contains pointers used by win32k, an
attacker can gain execution as NT AUTHORITY\SYSTEM, resulting in a
local elevation-of-privilege.

Fix Effectiveness
--------------------------------------------------------------------
The updated constant (5760) fully covers all current stores up to
offset 0x167C.  Provided no future fields are appended without
updating the size, the immediate overflow is removed.  No residual
race or integer issues remain visible in this site, but continued code
reviews are recommended whenever SESSION_GDI_GLOBALS grows again.
