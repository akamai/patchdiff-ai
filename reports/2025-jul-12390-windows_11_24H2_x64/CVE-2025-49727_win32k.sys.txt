{'cve': 'CVE-2025-49727', 'kb': 'KB5062553', 'change_count': 3, 'patch_store_uid': '7dc41a8e-277a-408b-8bf9-c201766239d3', 'date': 1752036389.8671772, 'confidence': 0.19, 'file': 'win32k.sys'}
--------------------------------------------------------------------
CVE-2025-49727 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
win32k.sys – API-set contract resolver
(ApiSetpGetSearchKeyInfo_V7, ApiSetResolveToHost_V7 and
ApiSetpSearchForSectionIndex_V7)

Vulnerability Class
--------------------------------------------------------------------
Heap-based Buffer Overflow (CWE-122)

Detailed Root Cause Analysis
--------------------------------------------------------------------
The kernel routine ApiSetResolveToHost_V7 is responsible for turning an
import string such as "api-ms-win-core-path-l1-1-0" into the concrete
DLL name that should be loaded for the calling session.  Before the
patch the helper ApiSetpGetSearchKeyInfo_V7 parsed the user-controlled
UNICODE string and returned only two bytes of data:
    WORD  KeyLength   (placed at *a4)
    BYTE  HasVersion  (placed at *a5)
No other information about the string was verified or returned.

Down-stream code in ApiSetResolveToHost_V7 immediately used the raw
string again to
  • calculate a numeric index (v19) from every character that followed
a dot ‘.’, and
  • dereference that index inside heap-allocated API-set section
    tables (v18 / v27).

Because the old helper did not validate the shape of the import name,
a crafted string could provide two consecutive dots or a trailing ‘-’
so that the parser’s decimal-to-integer loop
    v19 = c + 2 * (5 * v19 – 24)
produced a value larger than the maximum index contained in the
section header.  The only bounds check was
    if (v19 <= *(unsigned __int8 *)(v18 + 18))
where *(v18+18) is also attacker-controlled via the same table.  By
reducing that byte the attacker could force the comparison to succeed
and the subsequent calculation
    v27 = base + v19 * stride – ImageBase
stepped outside the heap allocation.  A host-path structure found at
v27 was blindly copied into a caller-supplied output buffer via
    *(_QWORD *)(Out+8) = ...
    *(_WORD *)Out = 2 * *((WORD*)v27+2);
thus overwriting adjacent heap memory with attacker-controlled data.

The new routine ApiSetpGetContractKeyInfo introduces a 32-byte output
structure and performs extensive validation before anything else is
done:
  • minimum length (>=5 UTF-16 chars, >=8 bytes)
  • case-insensitive check that the string starts with "API-" or
    "EXT-"
  • single pass right-to-left tokenizer that rejects more than one dot
    or any non-digit in numeric fields
  • 16-bit range checks for version / index values
  • fills a full structure so that later code never re-parses the
    untrusted string.
ApiSetResolveToHost_V7 was rewritten to consume that structure through
a switch statement and to look up section tables only with the
validated index supplied by the tokenizer.  The helper
ApiSetpSearchForSectionIndex_V7 was accordingly simplified so that all
string comparison happens on trusted data.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// old – no length or prefix check
if (a2 > 1u) {
    while (1) {
        v9 -= 2;            // walk backwards
        --v10;
        if (*v9 == 45) break;   // '-'
        if (*v9 == 46) { ... }
        ...                 // NO overflow checks
    }
}

// new – strict validation and structured output
if (a2 < 5u) return 0;
if ((unsigned short)(2 * a2) < 8u) return 0;
if (( *a1 & 0xFFFFFFDFFFDFFFDFULL) != 0x2D004900500041 &&
    ( *a1 & 0xFFFFFFDFFFDFFFDFULL) != 0x2D005400580045) return 0; //
API- / EXT-
...
*(_OWORD *)a4 = 0;          // 32-byte output struct
*(_DWORD *)(a4+12) = SectionType;  // 1,2,3
*(_WORD  *)(a4+18) = NameLen;
*(_WORD  *)(a4+24) = Version;
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-mode passes a UNICODE_STRING -> win32k!ApiSetResolveToHost_V7 ->
win32k!ApiSetpGetSearchKeyInfo_V7 (old) -> invalid index computed ->
heap pointer v27 calculated out of bounds -> host-path structure copied
into kernel heap buffer -> overflow.

Attack Vector
--------------------------------------------------------------------
Any locally-running process that can load, register, or otherwise cause
win32k to resolve an API-set DLL name can supply the malicious string.
Typical primitives include creating a crafted DLL name in the import
directory of a PE image or using the low-level CSR / win32k API for
session start-up.  No special privileges are required beyond the
ability to start a program.

Patch Description
--------------------------------------------------------------------
1. Replaced ApiSetpGetSearchKeyInfo_V7 with ApiSetpGetContractKeyInfo
   – adds comprehensive validation and returns a fixed-size 32-byte
     description block instead of two bytes.
2. Reworked ApiSetResolveToHost_V7 to consume the new structure and
   to use a switch-based dispatcher that never indexes beyond table
   bounds.
3. Simplified ApiSetpSearchForSectionIndex_V7 so that it operates only
   on validated indices and no longer performs attacker-controlled
   string comparisons in kernel space.

Security Impact
--------------------------------------------------------------------
A local attacker can trigger a heap-based buffer overflow inside the
win32k.sys kernel module, leading to memory corruption and execution of
arbitrary code in kernel context.  Successful exploitation results in
privilege escalation to SYSTEM.

Fix Effectiveness
--------------------------------------------------------------------
The patch adds deterministic length, format, and range checks before
any heap offsets are calculated and moves all parsing into a dedicated
function that delivers already-validated data.  All sites that
previously re-parsed the attacker string now rely exclusively on the
sanitised structure.  No residual path allowing uncontrolled indices
or over-sized copies was observed in the patched code, indicating that
the overflow is fully mitigated.
