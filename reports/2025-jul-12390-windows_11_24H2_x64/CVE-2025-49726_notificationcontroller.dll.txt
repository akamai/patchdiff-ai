{'cve': 'CVE-2025-49726', 'change_count': 6, 'date': 1752037623.4818792, 'patch_store_uid': '0914d6e7-7ad7-4bc6-b8a1-89f9fb113719', 'kb': 'KB5062553', 'confidence': 0.24, 'file': 'notificationcontroller.dll'}
--------------------------------------------------------------------
CVE-2025-49726 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Notification Controller (notificationcontroller.dll)
Resource-management helpers in wil::details::{unique_storage,
FeatureImpl} templates that wrap kernel objects such as process
mutexes and thread-pool timers.

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use After Free (local Elevation of Privilege)

Detailed Root Cause Analysis
--------------------------------------------------------------------
notificationcontroller.dll uses the wil::details::unique_storage
template to automatically free kernel objects when a smart-pointer is
reset.  Two specialisations matter:

1. unique_storage<resource_policy<PEAX, … CloseHandle>>
   Manages arbitrary HANDLEs (represented as void *).
2. unique_storage<resource_policy<_TP_TIMER *, … DestroyThreadPoolTimer>>
   Manages thread-pool timers returned by CreateThreadpoolTimer().

Before the patch the Reset() helpers were generated incorrectly:

  • For the generic HANDLE specialisation the generated code called
    ReleaseMutex() instead of CloseHandle() when a HANDLE had to be
    released.
  • For the _TP_TIMER specialisation the generated code called
    CloseHandle(timer) and immediately discarded the pointer.

CloseHandle() merely closes the underlying handle and does *not*
provide the synchronisation guarantees required for thread-pool timer
objects.  Outstanding timer callbacks may still execute after
CloseHandle() completes.  Because Reset() then nulls the smart pointer
and often frees the associated notification object, subsequent timer
callbacks dereference freed memory belonging to higher-privileged
notification controller objects – a classic use-after-free.

If an unprivileged local attacker can cause a notification path to
create and quickly reset a thread-pool timer (e.g. by flooding the
Toast/Action Center API with specially crafted packets) they can trick
a privileged notification controller instance (running as SYSTEM in
some desktop scenarios) into executing stale callbacks on freed
objects, ultimately allowing controlled memory corruption and
privilege escalation.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Before: _TP_TIMER reset               // After (patched)
wil::details::CloseHandle(v2);           DestroyThreadPoolTimer(v2);
```
```c
// Before: generic HANDLE reset          // After (patched)
wil::details::ReleaseMutex(v2);          wil::details::CloseHandle(v2, v5);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-supplied notification packet ->
NotificationPacketProcessor::CreateNotificationItem() ->
unique_storage< _TP_TIMER >::reset(nullptr) ->
CloseHandle(timer)  // timer callbacks still queued ->
parent object freed ->
queued callback fires -> UAF on freed privilege-bearing object.

Attack Vector
--------------------------------------------------------------------
Local attacker able to interact with the Windows Notification Platform
(e.g. via UWP or COM Toast API) floods the service with crafted
notifications that force rapid creation and disposal of
thread-pool timers, racing the callback to hit freed memory and execute
arbitrary code in the higher-privileged context.

Patch Description
--------------------------------------------------------------------
The update regenerates the unique_storage Reset() helpers with correct
resource release functions and stricter typing:

  • Replaces ReleaseMutex() with CloseHandle() for generic HANDLEs.
  • Replaces CloseHandle() with DestroyThreadPoolTimer() for _TP_TIMER
    objects, guaranteeing that all callbacks are cancelled or waited
    for before the pointer is freed.
  • Updates parameter types from void ** to strongly-typed pointers,
    preventing accidental selection of the wrong release routine at
    compile time.
  • Minor cleanup in feature-reporting code (type fixes, no security
    impact).

Security Impact
--------------------------------------------------------------------
Prior to the fix, closing thread-pool timers with CloseHandle() led to
use-after-free of internal notification objects, enabling local EoP to
SYSTEM.  Handle-release mismatch for mutexes additionally caused
resource leaks but is not exploitable.

Fix Effectiveness
--------------------------------------------------------------------
DestroyThreadPoolTimer() waits for in-flight callbacks, fully removing
the UAF window.  The hardened type signatures make similar mix-ups
unlikely in future, so the patch is considered effective barring other
logic errors (none observed in the supplied diff).
