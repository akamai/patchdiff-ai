{'cve': 'CVE-2025-48819', 'patch_store_uid': 'a38814e4-f259-4c84-903d-d9b40fa9d663', 'kb': 'KB5062553', 'confidence': 0.26, 'change_count': 2, 'date': 1752037546.642898, 'file': 'upnphost.dll'}
--------------------------------------------------------------------
CVE-2025-48819 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Universal Plug-and-Play (UPnP) Device Host – upnphost.dll.
The vulnerable code sits in the Windows-Internal-Lockdown (WIL)
feature-management helpers:
  • FeatureImpl<…Feature_TestConfNum>::GetCurrentFeatureEnabledState()
  • FeatureImpl<…Feature_TestValidate>::ReportUsage()
These helpers run inside the UPnP service process (Svchost, Local
Service account) and are reachable whenever the service evaluates or
reports feature state.

Vulnerability Class
--------------------------------------------------------------------
Type confusion / wrong function prototype, leading to copying of
uninitialised or freed kernel-mode heap data into a global cache that
is not locked or cleared (CWE-591 – Sensitive Data Storage in
Improperly Locked Memory).

Detailed Root Cause Analysis
--------------------------------------------------------------------
1. In GetCurrentFeatureEnabledState() (TestConfNum) the pre-patch code
   tests additional policy bits by calling

      FeatureImpl<Feature_Servicing_CFONTPrintLeak>::__private_IsEnabled(
           &Feature_TestValidate::impl);

   The template specialisation requested (CFONTPrintLeak) does **not**
   match the object that is supplied (TestValidate).  Because the two
   feature-implementation structures have different internal layouts,
   the callee interprets unrelated memory as its own state fields.
   This causes:
     • Reads of stale/freed heap memory.
     • The read value to be copied into the global feature cache
       maintained by the UPnP host.

2. The same block immediately reports telemetry through
   Feature_TestValidate::ReportUsage().  The implementation of that
   method was declared as

       ReportUsage(_DWORD *impl, unsigned __int8 kind, …)

   while callers pass a full 64-bit value in the second register
   (RDX).  Because only the least-significant byte is consumed, the
   upper seven bytes contain indeterminate stack content that is also
   forwarded to wil::ReportUsageToService().  Consequently, memory from
   the service’s stack – potentially containing privileged handles or
   security tokens – is copied into WIL’s shared reporting buffers in
   plain text.

3. Those buffers are **never placed in locked pages**; they remain in
   pageable, readable process memory long after use.  Any code running
   in the service context, or any Info-leak primitive that can map the
   process, can harvest the leftover data and escalate privileges.

Patch changes
• Replaced the wrong IsEnabled() call with a direct call to
  Feature_TestValidate::ReportUsage(), eliminating the type confusion.
• Correctly widens temporary variables (v6, v9) to 64-bit, preventing
  truncation of the feature-state mask.
• Redefines ReportUsage() to accept a 64-bit ReportingKind argument and
  updates its internal stack layout, so no undefined bytes are
  propagated.
• Removes dead logic that conditionally cleared bit 0x400 based on the
  faulty IsEnabled() result.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// incorrect cross-type call (before)
if ((v9 & 0xC00) == 3072)
{
    if ((unsigned __int8)
        FeatureImpl<Feature_Servicing_CFONTPrintLeak>::__private_IsEnabled(
           &Feature_TestValidate::impl))
        …
}

// fixed logic (after)
if ((v9 & 0xC00) == 3072 || (v9 & 0x40))
{
    FeatureImpl<Feature_TestValidate>::ReportUsage(
        Feature_TestValidate::impl, v9, 0xC00, v6);
    …
}

// ReportUsage() prototype mismatch
// before
__int64 ReportUsage(_DWORD *impl, unsigned __int8 kind, __int64 a3, __int64 a4);
// after
__int64 ReportUsage(unsigned int *impl, __int64 kind, __int64 a3, __int64 a4);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker invokes a UPnP API that causes the service to evaluate the
   TestConfNum feature.
2. GetCurrentFeatureEnabledState() executes, enters the faulty branch
   (v9 bits 0xC00 or 0x40 set).
3. __private_IsEnabled() is called with the wrong object → reads random
   memory, writes it into the global cache.
4. ReportUsage() is called with a mismatched prototype → leaks stack
   bytes into the same cache.
5. Attacker subsequently reads the cache (e.g., via another benign
   API) and obtains privileged memory contents.

Attack Vector
--------------------------------------------------------------------
Exact public entry point is not shown in the diff.  Any API that
reaches GetCurrentFeatureEnabledState() for Feature_TestConfNum can be
used (unknown).

Patch Description
--------------------------------------------------------------------
• Removes the mis-typed IsEnabled() call and instead calls
  ReportUsage() on the correct feature.
• Corrects parameter and local-variable widths (32->64 bit).
• Rewrites Feature_TestValidate::ReportUsage() to take a 64-bit
  ReportingKind and sets deterministic stack variables before passing
  them to ReportUsageToService().
• Initialises the telemetry-support buffer with a constant (3) instead
  of leaving it zeroed.

Security Impact
--------------------------------------------------------------------
Before the patch, arbitrary kernel-pool or stack data could be
persisted in an unlocked, long-lived buffer inside the UPnP Device Host
service.  A local or adjacent attacker able to trigger the feature-eval
path could harvest that data to bypass ASLR, discover privileged
pointers, or steal authentication material, and subsequently mount an
Elevation-of-Privilege attack.

Fix Effectiveness
--------------------------------------------------------------------
The incorrect template invocation has been eliminated and the function
signatures now match their call sites, removing both the type
confusion and the uninitialised register leakage.  No residual paths
invoking CFONTPrintLeak methods with a TestValidate object remain in
upnphost.dll, so the root cause is fully addressed.
