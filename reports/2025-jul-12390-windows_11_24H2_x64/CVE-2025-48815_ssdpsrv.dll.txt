{'kb': 'KB5062553', 'file': 'ssdpsrv.dll', 'change_count': 16, 'confidence': 0.18, 'patch_store_uid': '98639a85-78bf-46dc-98f7-63d18b92622c', 'cve': 'CVE-2025-48815', 'date': 1752037491.5536797}
--------------------------------------------------------------------
CVE-2025-48815 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows SSDP Service (ssdpsrv.dll) – RPC helpers that manage client
notification semaphores:  GetNotificationRpc, RemoveSyncHandle,
WakeupGetNotificationRpc, InitializeSyncHandle and
RegisterNotificationHelper.

Vulnerability Class
--------------------------------------------------------------------
CWE-843  Access of Resource Using Incompatible Type (handle / type
confusion).  Also an instance of "untrusted handle validation /
confused-deputy" leading to privilege elevation.

Detailed Root Cause Analysis
--------------------------------------------------------------------
The SSDP notification workflow is supposed to work with a semaphore
created by InitializeSyncHandle and owned by the server.  The returned
handle is later passed back to several RPC calls so the service can
wait, signal or close it.

In the original code the HANDLE parameters (named a1, hSemaphore, *a2
etc.) are only tested for NULL:
    if (!a1) return ERROR_INVALID_PARAMETER;
No further verification is made that the supplied handle really refers
   • to a semaphore object, and
   • to a semaphore previously issued by InitializeSyncHandle.

Consequently any authenticated RPC client can transmit an arbitrary
HANDLE value.  The service – running with service privileges – then
performs privileged actions on that foreign object:
   • WaitForMultipleObjects(…, a1)               (GetNotificationRpc)
   • ReleaseSemaphore(a1, …)                     (Wakeup…)
   • CloseHandle(a1)                             (RemoveSyncHandle)

Because the kernel dispatches those syscalls according to the object
header referenced by the handle, supplying a handle of a different
object type constitutes a type confusion.  Examples:
   – Passing a handle to a process or thread makes the service close it
     or wait on it, potentially disturbing security-critical objects.
   – Passing a duplicated high-privilege token handle and getting it
     closed by the service can later allow the attacker to re-open the
     underlying kernel object and obtain escalated rights (classic
     handle squatting / EoP scenario).

No membership or ownership tracking existed – the internal lists
qword_18004DB28 / qword_18004DB58 kept only CSsdpNotifyRequest objects
and were never consulted for semaphore validity.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before – no validation at all
if (a1 && a2) {
    Handles[0] = ShutDownEvent;
    Handles[1] = a1;                     // attacker-controlled
    WaitForMultipleObjects(2, Handles, …);
    …
}

// after – accept only registered semaphores
if (!a1 || !a2 ||
    !CSsdpNotifyRequestManager::IsNotifySemaphoreInList(
          &CSsdpNotifyRequestManager::s_instance, 1, a1))
    return ERROR_INVALID_PARAMETER;
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker opens/duplicates an arbitrary handle (or creates a handle
   of a chosen type).
2. Attacker invokes any of the affected RPC methods and supplies that
   handle instead of the legitimate notification semaphore.
3. SSDPSRV service uses the handle inside privileged APIs
   (WaitForMultipleObjects / ReleaseSemaphore / CloseHandle).
4. Those operations are executed in the service’s security context and
   affect a resource the attacker could not otherwise manipulate.

Attack Vector
--------------------------------------------------------------------
Local, authenticated user able to call the SSDP RPC interface.
No special privileges are required beyond the ability to connect to the
\pipe\ssdpsrv named pipe.  Successful exploitation yields local
Elevation of Privilege.

Patch Description
--------------------------------------------------------------------
• A new semaphore tracking list is maintained by
  CSsdpNotifyRequestManager.
• InitializeSyncHandle now calls HrAddNotifySemaphoreToList to record
  freshly created semaphores.
• All later RPC helpers call
  IsNotifySemaphoreInList before using the handle; on failure they
  return ERROR_INVALID_PARAMETER (87).
• RemoveSyncHandle additionally removes the entry via
  HrRemoveNotifySemaphoreFromList.
• Legacy behaviour is kept behind a WIL feature flag so that the new
  validation can be enabled selectively.

Security Impact
--------------------------------------------------------------------
Prior to the fix an attacker could coerce the SSDP service to operate
on any kernel object handle, leading to:
   • unintended closing of privileged handles,
   • semaphore signalling on attacker-chosen objects,
   • or other undefined behaviour inside the kernel.
These primitives can be chained to obtain SYSTEM-level code execution
(Elevation of Privilege).

Fix Effectiveness
--------------------------------------------------------------------
The added positive list enforces strong handle provenance: only
semaphores created by the service are accepted.  All dangerous code
paths now bail out early with ERROR_INVALID_PARAMETER when presented
with an unknown handle, removing the confused-deputy condition.
Residual risk: systems where the new WIL feature flag is disabled will
still follow the legacy path; effectiveness therefore depends on proper
roll-out of the feature enablement policy.
