{'date': 1752036443.9542558, 'kb': 'KB5062553', 'change_count': 2, 'cve': 'CVE-2025-47991', 'file': 'imebroker.exe', 'patch_store_uid': 'd9a8762c-5eb8-49b2-b991-6bb9d51049c6', 'confidence': 0.24}
--------------------------------------------------------------------
CVE-2025-47991 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
imebroker.exe – Windows Input Method Editor (IME) feature-flag helper
code inside wil::details::FeatureImpl<*> that is linked into the
broker service running under elevated privileges.

Vulnerability Class
--------------------------------------------------------------------
Use After Free (CWE-416)

Detailed Root Cause Analysis
--------------------------------------------------------------------
Each FeatureImpl instance keeps a small, dynamically allocated cache
object that mirrors the current Feature Control (FC) configuration.
The first double-word of this cache is treated as a bit field:
  bit0  – cache initialised           (0x1)
  bit1  – current flag value valid     (0x2)
  bit2  – cache is subscribed to FC    (0x4)
If the object is not subscribed (bit2==0) the FC layer can free and
re-allocate it at any time when the configuration changes.

In the original helper
  wil::details::FeatureImpl<...>::__private_IsEnabled()
only bits0/1 were checked.  When bit2 was clear the function still
trusted the pointer returned by GetCachedFeatureEnabledState(), stored
it inside *a1, and immediately dereferenced it to obtain the 64-bit
state value:

    v7 = *(_QWORD *)GetCachedFeatureEnabledState(a1, &v8);
    v2 = v7;                     // use the contents

Because the object was **not** subscribed it could be freed by another
thread between the call and the dereference, leaving *a1 pointing to
released memory.  Any later read or write to the cache produced a use
after free inside the high-privilege IME broker process.

The same stale pointer path was reachable from
Feature_TestConfNum::GetCurrentFeatureEnabledState() which, in the
old build, called the vulnerable __private_IsEnabled() helper while
holding only its own stack variables.  An attacker able to cause
rapid FC state churn (e.g. through the public Feature Management
API) could win the race and force the broker to dereference freed
memory, leading to arbitrary code execution in the broker’s
context.

Parameters/structures involved
  a1   – pointer to the per-feature cache header (volatile ULONG)
  GetCachedFeatureEnabledState() – supplies, but does not pin, the
         dynamic cache block that may be freed asynchronously.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable – before patch
v7 = *(_QWORD *)wil::details::FeatureImpl<...>::GetCachedFeatureEnabledState(
        a1,
        &v8);          // &v8 is only 1 byte – wrong size is passed
v2 = v7;               // dereference possible freed block
...
if ( (*a1 & 4) == 0 )  // not subscribed
    ...same pattern again...
```
```c
// fixed – after patch
if ((*(_DWORD *)a1 & 4) == 0) {
    v8 = wil::details::EnsureSubscribedToFeatureConfigurationChanges(a1);
    ...
    // atomically set bits 1 and 2
    v12 = _InterlockedCompareExchange((volatile signed __int32 *)a1,
                                      v11,
                                      v6);
    ...
    wil::details::SubscribeFeatureStateCacheToConfigurationChanges(a1,
                                                                  3, v9);
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker toggles a WIL feature through the public API, forcing the
   FC service to free and re-allocate the per-feature cache.
2. A second thread in IMEbroker calls
      Feature_TestConfNum::GetCurrentFeatureEnabledState()
3. That routine calls the old
      Feature_TestValidate::__private_IsEnabled()
4. __private_IsEnabled() reads *a1 while bit2==0 and immediately
   dereferences the freed cache object – UAF.

Attack Vector
--------------------------------------------------------------------
Any local user that can call the Windows Feature Management APIs or
otherwise trigger rapid configuration changes can race the broker and
hit the dangling pointer.  No special privileges are needed to start
the race; exploitation yields code execution in the elevated
imebroker.exe process, enabling privilege escalation.

Patch Description
--------------------------------------------------------------------
Microsoft removed the unsafe __private_IsEnabled() helper and replaced
it with a new ReportUsage() routine that:
  • Calls EnsureSubscribedToFeatureConfigurationChanges() when bit2 is
    clear and, if needed, subscribes the cache by calling
    SubscribeFeatureStateCacheToConfigurationChanges().
  • Uses InterlockedCompareExchange to update the flag word atomically
    so that the cache is either fully initialised+subscribed or not
    used at all.
  • Never dereferences the cache pointer until subscription is in
    place, eliminating the window where the memory could be freed.

Security Impact
--------------------------------------------------------------------
Dereferencing a freed FC cache object allows the attacker to corrupt
process memory and execute arbitrary code inside imebroker.exe,
resulting in a local elevation of privilege (EoP) to the broker’s
integrity level (typically SYSTEM on desktop Windows).

Fix Effectiveness
--------------------------------------------------------------------
The patch adds the missing lifetime management (subscription and
atomic flag update), so the cache pointer can no longer become stale
between acquisition and use.  All direct calls to the old vulnerable
helper were removed.  Barring additional undiscovered cache paths the
UAF is fully mitigated.
