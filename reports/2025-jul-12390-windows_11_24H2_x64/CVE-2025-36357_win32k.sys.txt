{'file': 'win32k.sys', 'patch_store_uid': '7dc41a8e-277a-408b-8bf9-c201766239d3', 'cve': 'CVE-2025-36357', 'kb': 'KB5062553', 'confidence': 0.17, 'date': 1752037782.7629771, 'change_count': 3}
--------------------------------------------------------------------
CVE-2025-36357 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
win32k.sys  –  internal "Api-set" resolution helpers
(ApiSetpGetSearchKeyInfo_V7, ApiSetResolveToHost_V7 and
ApiSetpSearchForSectionIndex_V7)


Vulnerability Class
--------------------------------------------------------------------
Input-validation failure leading to out-of-bounds kernel memory
access (information disclosure / potential DoS)


Detailed Root Cause Analysis
--------------------------------------------------------------------
For Win32k to map an api-set DLL name (e.g. "api-ms-win-core‐…") to
its host DLL it first parses the UNICODE string to build a *contract
key* and then looks that key up in an on-disk table that is memory
mapped into the calling process.  Prior to the patch the parser
(ApiSetpGetSearchKeyInfo_V7) trusted almost every aspect of the
caller-controlled UNICODE_STRING:

•  Only the overall length (a2 > 1) was checked.
•  The routine walked the buffer **backwards** one WCHAR at a time and
   stopped at the first ‘-’ or ‘.’ without tracking how many such
   separators had already been seen.
•  When the terminating ‘.’ was found the position counter (v10) could
   legally be 0, yet the resulting length value (v29) was passed
   unchanged to the hash-search layer.

That length field is fed straight into ApiSetpSearchForSectionIndex_V7
where it is multiplied by a user-supplied, table-derived 8-bit factor
(`v4 = v4 * v12 + v15`).  Because neither operand was checked for
overflow, crafted inputs can wrap the 32-bit hash value, causing the
binary search to index *before* the start of the section table.  The
subsequent dereference `*(DWORD *)(v24 + a1)` therefore leaks or
faults arbitrary kernel memory located immediately before the api-set
mapping.

In addition, the original search routine compared the attacker-supplied
string against table entries with a home-grown, case-folding loop that
reads from both the user buffer and the section table without re-
checking the supplied length.  Over-long or unterminated strings could
therefore make the loop walk off the end of either buffer.

Patch 23183 introduces a completely new helper (ApiSetpGetContractKeyInfo)
that
  1. requires a minimum length of 5 WCHARs and at least 8 addressable
     bytes;
  2. validates that the first 7 bytes are either "API-" or "EXT-";
  3. guarantees that exactly one period and one dash are present;
  4. fully bounds-checks every component before returning a packed
     description to the caller.

Because the new structure includes the verified component lengths, the
re-written ApiSetResolveToHost_V7 and ApiSetpSearchForSectionIndex_V7
no longer need to trust the raw caller buffer, eliminating the out-of-
bounds accesses.

Affected parameters / structures
  IN  a2 – length of UNICODE_STRING (caller controlled)
  IN  *a1 / *a3 – start of caller buffer
  IN  *((BYTE*)a2+10) – per-table hash multiplier
  OUT v24 – computed table pointer, attacker-influenced pre-patch


Vulnerability Code Snippets
--------------------------------------------------------------------
Before (parser – no prefix / length validation)
```c
while (1) {
    v9 -= 2;          // move back one WCHAR
    --v10;            // position counter
    if (*v9 == '-') break;
    if (*v9 == '.') {
        if (v7) { *a4 = v8; goto done; }
        v8 = v10; v7 = 1;
    }
    v6 = *v9;         // un-checked char read
    if (v10 <= 1) return 0;
}
```
After (parser – strict validation & structure build)
```c
if (a2 < 5 || 2*a2 < 8) return 0;
v5 = *a1 & 0xFFFFFFDFFFDFFFDFui64;      // must be "API-"/"EXT-"
if (v5 != 0x2D004900500041 && v5 != 0x2D005400580045) return 0;
...
while (1) {
    v9 -= 2;  --v11;
    if (*v9 == '-') { if(!v10) break; ... }
    if (*v9 == '.') { if(v8||v7) return 0; ... }
    ... // numbers folded safely
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-mode sys-call that eventually invokes
  ApiSetResolveToHost_V7  ->
    ApiSetpGetSearchKeyInfo_V7 (old) / ApiSetpGetContractKeyInfo (new) ->
      ApiSetpSearchForSectionIndex_V7

Supplied UNICODE_STRING propagates unchanged through the chain until
used as an index into the kernel-resident api-set section table.


Attack Vector
--------------------------------------------------------------------
A local, low-privilege process passes a specially crafted api-set name
containing invalid placement of ‘.’ and ‘-’, extremely long number
fields, or truncated data to a win32k syscall that resolves api-set
hosts.  The malformed name forces the kernel to read outside the valid
section table, disclosing memory or crashing the system.


Patch Description
--------------------------------------------------------------------
1. Replaced ApiSetpGetSearchKeyInfo_V7 with ApiSetpGetContractKeyInfo
   that performs full syntax, prefix and length validation and returns
   a fixed, type-safe descriptor.
2. Re-implemented ApiSetResolveToHost_V7 to consume the new descriptor
   and to gate every code path on validated fields.
3. Simplified ApiSetpSearchForSectionIndex_V7; it now receives the
   descriptor instead of raw pointers, uses constant-time hashing, and
   no longer performs unsafe per-character comparisons.
4. Added multiple early-exit checks that prevent any table access when
   validation fails.


Security Impact
--------------------------------------------------------------------
Before the update an unprivileged user could trigger kernel
out-of-bounds reads (info-leak) or a controlled crash (DoS).  While no
write primitive was observed, the disclosure primitives are sufficient
for KASLR bypasses and for advancing further exploitation chains.


Fix Effectiveness
--------------------------------------------------------------------
The new parser rejects malformed strings early and guarantees that all
subsequent routines operate on internally verified offsets and
lengths.  Pointer arithmetic is confined to 64-bit math on validated
values, removing the original overflow and OOB conditions.  The patch
therefore fully mitigates the identified vulnerability.
