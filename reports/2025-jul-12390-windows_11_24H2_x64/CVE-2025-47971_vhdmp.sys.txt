{'date': 1752036220.1580298, 'confidence': 0.71, 'change_count': 1, 'cve': 'CVE-2025-47971', 'patch_store_uid': '1fdcaa6b-f557-418e-8f89-7cebf651f2f4', 'kb': 'KB5062553', 'file': 'vhdmp.sys'}
--------------------------------------------------------------------
CVE-2025-47971 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Virtual Hard Disk mini-port driver (vhdmp.sys). Vulnerable
routine is InsertEventEntryInLookUpTable(), responsible for storing
per-I/O statistics inside the driver-wide event table.

Vulnerability Class
--------------------------------------------------------------------
Out-of-bounds read / potential out-of-bounds write (CWE-126: Buffer
Over-read).

Detailed Root Cause Analysis
--------------------------------------------------------------------
InsertEventEntryInLookUpTable() receives five parameters.  The last
parameter (a5) represents the caller-supplied number of statistic
fields that must be aggregated into an existing EVENT_ENTRY structure.
In the pre-patch version this parameter is declared as
unsigned __int8 and is used directly as an upper-bound when iterating
through two fixed-length arrays:

  LOBYTE(v12) = 2;                    // start from field index 2
  do {                                // ..
      <read src field>
      <update dst field>
      v12++;
  } while (v12 < a5 + 2);             // stop after a5 iterations

The arrays accessed are
  SRC  : (QWORD **) a4           + 16 * index  (caller controlled)
  DEST : *(QWORD *)(v16 + 16)    + 16 * index  (driver object)
Each array is compiled-time sized (<=16 entries, exact maximum is
stored in the destination object at +13 within every field).  Because
a5 is never validated against that maximum, a malicious caller can
supply an arbitrarily large value (0xFF) which makes the loop walk past
the end of both arrays.  As a result the driver performs 64-bit atomic
loads and stores on adjacent kernel memory, leading to kernel memory
disclosure, data corruption, and ultimately elevation of privilege.

Important offsets / objects
  EVENT_ENTRY
      +0x10 : pointer to field array (16-byte elements)
      +0x28 : hash links
      +0x40 : cached hash value
  Function parameters
      a4 : pointer to caller’s source field array
      a5 : untrusted field-count (vulnerability trigger)

The bug is purely an intra-kernel flaw; no pool allocation overflows are
needed – incorrect indexing is enough to reach unrelated kernel data.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable loop (before patch)
LOBYTE(v12) = 2;
if (a5) {
    do {
        v19 = **(_QWORD **)(a4 + 16 * (unsigned __int8)v12);
        v20 = *(_QWORD *)(v16 + 16);
        v22 = *(volatile signed __int64 **)(v20 + 16 * (unsigned __int8)v12);
        _InterlockedAdd64(v22, v19);           // or cmpxchg variant
        v12++;
    } while ((unsigned __int8)v12 < (unsigned int)a5 + 2);
}

// fixed loop (after patch)
v19 = 2;
if (a5) {
    do {
        AggregateField(
            *(_QWORD *)(*(_QWORD *)(v16 + 16) + 16 * v19),
            **(_QWORD **)(a4 + 16 * v19),
            *(unsigned __int8 *)(*(_QWORD *)(v16 + 16) + 16 * v19 + 13));
        v19++;
    } while (v19 < v21);          // v21 = internal max field count
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User-mode opens or mounts a crafted VHD/X image or issues a custom
   IOCTL to vhdmp.sys.
2. The driver calls InsertEventEntryInLookUpTable() with parameters
   derived from the attacker-controlled request; in particular a5 holds
   an oversized field count.
3. The unchecked loop overruns the field array, touching memory beyond
   the allocated EVENT_ENTRY and source buffer.
4. Corrupted memory can crash the system or be massaged to overwrite
   adjacent kernel objects, yielding privilege escalation.

Attack Vector
--------------------------------------------------------------------
Local attackers that can mount or interact with virtual hard disks
(e.g., through Hyper-V, Disk Management, or direct DeviceIoControl)
provide an abnormally large field-count.  No special privileges are
required beyond the ability to reach the VHD stack.

Patch Description
--------------------------------------------------------------------
• Parameter type changed from unsigned __int8 to signed char, making it
  less convenient to pass very large positive values.
• The aggregation loop no longer uses attacker-controlled a5 as the
  terminating condition.  Instead it starts at index 2 and iterates
  until index < v21, where v21 is read from the destination EVENT_ENTRY
  (trusted, internal size).
• The field update logic has been moved into a new helper
  AggregateField() for clarity and centralised validation.
• Minor clean-ups: replaced single-pointer temp with local array v24[ ],
  removed unused push-lock argument, and consolidated spinlock exit
  code.

Security Impact
--------------------------------------------------------------------
Prior to the fix an unprivileged local user could execute arbitrary
kernel reads and writes within the vhdmp.sys address space, leading to a
BSOD or, with careful shaping, elevation of privilege to SYSTEM.

Fix Effectiveness
--------------------------------------------------------------------
The vulnerable loop is eliminated; iteration is now bounded by an
internally stored maximum, not by attacker input.  No remaining code
path uses a5 as an index, therefore the original out-of-bounds access
is removed.  The fix is considered effective so long as AggregateField()
validates the field descriptor it receives (not visible in the diff but
probable). No regressions observed in the surrounding logic.
