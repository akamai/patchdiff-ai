{'cve': 'CVE-2025-60708', 'patch_store_uid': 'e8e93d77-bd89-4400-b15b-f141d5cf5a60', 'change_count': 92, 'kb': 'KB5068861', 'confidence': 0.19, 'file': 'storport.sys', 'date': 1763409940.6051686}
--------------------------------------------------------------------
CVE-2025-60708 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft StorPort miniport driver (storport.sys) – routine
RaidGetSrbIoctlFromIrp(). The helper is used by the StorPort stack to
parse SRB_IO_CONTROL headers that arrive inside user-supplied
DeviceIoControl IRPs.


Vulnerability Class
--------------------------------------------------------------------
CWE-822: Untrusted Pointer Dereference / Out-of-bounds read that can
trigger a kernel page fault, resulting in denial-of-service (BSOD).


Detailed Root Cause Analysis
--------------------------------------------------------------------
RaidGetSrbIoctlFromIrp() receives a pointer (v7) to an SRB_IO_CONTROL
header that sits at Irp->AssociatedIrp.SystemBuffer.  One of the
accepted control types is SCSI_PASS_THROUGH_DIRECT (FunctionCode
0x1B, decimal 1 771 040).  The size of the header supplied by the
caller is taken from *(a1+184)+16 and stored in v8 (renamed v9 in the
patch).

Pre-patch logic performed only a minimal length test for this control
path:

    if ( IsEnabledDeviceUsage ? v8 < 0x34 : v8 < 0x28 )  // 40 bytes
         fail;                                           // rejected

If the private feature flag was clear (normal systems), a buffer of
only 0x28 (40) bytes satisfied the check.  A little later the function
unconditionally accessed fields located at offsets 36, 44 and 48
inside the same buffer:

    *(v7+36)     // QueueTag
    *(v7+44)     // DataBufferOffset
    *(v7+48)     // DataBufferLength

Because the minimum accepted length (0x28) is smaller than the largest
field offset used (0x48), the driver could read or dereference memory
past the end of the allocated SystemBuffer.  The buffer is mapped with
user-controlled contents; if it is not resident or is shorter than
required, the kernel dereferences an invalid address and raises a
bugcheck (KERNEL_SECURITY_CHECK_FAILURE / IRQL_NOT_LESS_OR_EQUAL).

Thus a local, non-privileged process could send a crafted IOCTL with an
undersized SRB_IO_CONTROL header to crash the system.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – undersized header accepted for Function 0x1B
if (!(IsEnabledDeviceUsage ? v15 < 0x34 : v15 < 0x28)) {
    // ...
    if ((unsigned int)v15 >= (unsigned int)v10)
        return v15 < *(unsigned int *)(v7 + 44) +
                     (unsigned __int64)*(unsigned int *)(v7 + 48)
               ? 0xC000000D : 0;   // uses offsets 44/48
}

// after patch – strict length check
if ((unsigned int)v9 < 0x34)
    return 0xC000000D;  // STATUS_INVALID_PARAMETER
```
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User process opens any device that is serviced through StorPort.
2. Send DeviceIoControl containing SRB_IO_CONTROL header:
   - HeaderLength   = 0x28 (40 bytes)
   - Signature      = "SCSIDISK" or compatible value
   - Function       = 0x1B000 (1771040)
3. RaidGetSrbIoctlFromIrp() accepts the request because 0x28 passes the
   old length test.
4. Function later reads *(Buffer+0x2C … 0x30) which lies beyond the
   40-byte buffer – page fault in kernel, system crash.


Attack Vector
--------------------------------------------------------------------
Local authenticated attacker sends a crafted IOCTL_SCSI_PASS_THROUGH_*
request to any StorPort-managed device (physical disk, virtual disk,
CD-ROM, etc.).  No special privileges beyond the ability to open the
device handle are required.


Patch Description
--------------------------------------------------------------------
The fix places the size validation at the very beginning and enforces a
strict minimum header size of 0x34 (52) bytes for the 0x1B* control
code, removing the earlier feature-flag exception.  Subsequent accesses
(v7+36, v7+44, v7+48) are now guaranteed to be within the caller’s
buffer.  Additional minor reorderings ensure that all length checks are
performed before any field dereference.


Security Impact
--------------------------------------------------------------------
Before the update a low-privilege user could cause a kernel fault and
system reboot, resulting in a local denial-of-service.  No information
leak or code execution was observed from the diff, but the out-of-
bounds access created instability and potential for further
exploitation.


Fix Effectiveness
--------------------------------------------------------------------
The new unconditional check (HeaderLength < 0x34) completely blocks the
original under-flow scenario.  All later field usages are bounded by
this size, closing the untrusted pointer dereference avenue.  No
further unsafe dereferences are visible in the patched routine, so the
repair is considered effective for this code path.
