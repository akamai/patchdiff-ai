{'file': 'windows.media.speech.dll', 'kb': 'KB5068861', 'confidence': 0.02, 'change_count': 2, 'date': 1763409889.6526575, 'patch_store_uid': '7ecaba2c-5f97-4e2c-9eaf-c3f8d624cce9', 'cve': 'CVE-2025-59508'}
--------------------------------------------------------------------
CVE-2025-59508 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Speech Runtime (windows.media.speech.dll) helper routines
IsPolicyManager_GetPolicyPresent()  and
IsIsEmbeddedModeAllowedPresent()  formerly named
IsMonikerLoadTypeLibPresent() / IsMonikerLoadTypeLibPresent_0()

Vulnerability Class
--------------------------------------------------------------------
CWE-362: Concurrent execution using shared resource with improper
synchronization (race condition)

Detailed Root Cause Analysis
--------------------------------------------------------------------
Both helper functions cache the presence of an internal PolicyManager
API-set by using a global 32-bit flag that is shared by every caller:
    dword_180164E4C  (for "@B")
    dword_180164E78  (for "HJ")

The flag is a tri-state value:
    0  -> uninitialized (query still needs to run)
    1  -> API-set present
    2  -> API-set absent

Old logic:
1. Read the flag.
2. If it is 1 return the flag itself (contents of the shared dword).
3. If it is 2 return 0.
4. Otherwise call ApiSetQueryApiSetPresence_0(), then update the flag to
   1 or 2, finally return the freshly queried byte.

No locking or memory-ordering primitives are used, so several threads
running on different cores can execute the sequence concurrently.  A
classic check-then-act race appears between Step 1 and Step 4:
• Thread A reads 0 and enters the query path.
• Before A completes, Thread B also reads 0 and enters the query path.
• Depending on timing, one of the threads may store a partially or
  completely attacker-controlled value into the shared dword while the
  other thread is still using it as a return value.

Because the pre-patch code returns the *actual contents* of
 dword_180164E4C / E78, any stale or corrupted value placed in the cell
is propagated to the caller.  All subsequent privilege and privacy
checks rely on a boolean return (0 / non-zero).  A malicious local
process that can spawn many racing threads can purposefully skew the
cache and force a non-zero byte to be observed even while the real
ApiSet is absent, tricking higher-level code into believing that Policy
Manager enforcement is active.

Once the speech runtime thinks Policy Manager exists, it defers security
and privacy decisions to it and silently grants elevated operations such
as changing system speech language or accessing microphone data, thereby
leading to a local elevation of privilege.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch, same bug pattern in both helpers
if ( dword_180164E4C == 1 )          // unsafe read of shared global
    return dword_180164E4C;          // returns potentially corrupted
if ( dword_180164E4C == 2 )          // second read, still unsynchronized
    return 0;                        // ...

// after patch
if ( dword_180164E4C == 1 )          // still tests the global
    return 1;                        // BUT no longer returns its value
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Windows::Media::Speech::CUserSpeechPreferences::GetAllowSpeechServices()
  -> IsPolicyManager_GetPolicyPresent()

Windows::Media::SpeechRecognition::TrySetSystemSpeechLanguageAsyncOperation::OnStart()
  -> IsIsEmbeddedModeAllowedPresent()

Attack Vector
--------------------------------------------------------------------
A local authenticated attacker repeatedly spawns threads that
simultaneously invoke speech APIs which, in turn, call the vulnerable
helper.  By racing the initialization path the attacker corrupts the
shared flag and forces a successful (non-zero) return, bypassing Policy
Manager checks and obtaining elevated speech privileges.

Patch Description
--------------------------------------------------------------------
The fix changes the early-return path so that, when the cached value is
"1" (API present), the function returns the constant literal 1 instead
of the contents of the shared global.  Therefore even if another thread
modifies dword_180164E4C/E78 after the comparison but before the return
instruction, the caller still receives the correct boolean.

Security Impact
--------------------------------------------------------------------
Before the patch an attacker could win a race and inject an arbitrary
non-zero value into the shared flag, causing privileged speech routines
to execute without enforcing Policy Manager restrictions.  This enables
a local elevation of privilege.

Fix Effectiveness
--------------------------------------------------------------------
Returning a constant removes the TOCTOU window between flag verification
and value propagation, eliminating the immediate race that allowed
incorrect results to be exposed.  The shared flag is still written
without locking, but it is no longer read back for the success path, so
the specific elevation primitive is neutralized.
