{'change_count': 1, 'kb': 'KB5068861', 'date': 1763409819.8502991, 'file': 'clfs.sys', 'cve': 'CVE-2025-60709', 'confidence': 0.24, 'patch_store_uid': 'c23df860-1044-46ff-9a48-1443517129b2'}
--------------------------------------------------------------------
CVE-2025-60709 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Common Log File System driver (clfs.sys), function
ClfsGetFirstRecord().  The routine is used by several higher-level
CLFS APIs to obtain a pointer to the first log record contained in a
supplied in-memory log container buffer.

Vulnerability Class
--------------------------------------------------------------------
Out-of-bounds read (CWE-125).  Insufficient validation of a caller-
controlled offset lets the kernel access memory located outside the
allocated log buffer.

Detailed Root Cause Analysis
--------------------------------------------------------------------
Input parameters
  a1 : pointer to an in-memory CLFS container buffer
  a2 : length, in bytes, of that buffer

Internal field
  *((uint32_t *)a1 + 10)  // offset of the first record, here called
                          // FirstRecordOffset (FRO)

Old logic
  1.  Read FRO into v2.
  2.  Fail if FRO >= 0xFFFFFFD8 (sanity guard against small negative
      values once interpreted as signed).
  3.  Return &a1[FRO] unless FRO > a2 + 40.

Problem
  The comparison in step 3 is incorrect.  The code must ensure that
  FRO + sizeof(CLFS_RECORD_HEADER) is still inside the user-supplied
  buffer.  Instead it only checks FRO against (a2 + 40).  Consequently
  any value satisfying:
      FRO        <= a2 + 40
      FRO + 0x28 >  a2
  will be accepted.  Subsequent code that parses the returned header
  will therefore read up to 0x28 bytes after the end of the callerâ€™s
  allocation.

  In addition, no lower-bound check on FRO existed.  Values below the
  minimum legal start offset (0x70) could be supplied, causing the
  function to point inside the CLFS super-block where no record really
  resides.

  Because CLFS runs in kernel mode, the out-of-bounds access occurs at
  elevated privilege and can leak or corrupt kernel memory once other
  record-handling helpers treat the bogus pointer as trustworthy.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// BEFORE (simplified)
if (!a1)
    return 0;
FRO = *((uint32_t *)a1 + 10);
if (FRO >= 0xFFFFFFD8)
    return 0;
if (FRO > a2 + 40)
    return 0;
return (CLFS_RECORD_HEADER *)&a1[FRO];

// AFTER (simplified)
FRO = *((uint32_t *)a1 + 10);
limit = FRO + 40;                 // include header size
if (FeatureFlagEnabled) {
    if (limit < 0x28 || FRO < 0x70 || limit > a2)
        return 0;
} else {
    if (limit < 0x28 || FRO > a2 + 40)
        return 0;
}
return (CLFS_RECORD_HEADER *)&a1[FRO];
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. A user-mode process causes the kernel to open or append a crafted
   CLFS log.
2. clfs.sys allocates a buffer for the container header and calls
   ClfsGetFirstRecord().
3. The attacker-controlled FRO passes the lax checks and points past
   the end of the buffer.
4. The returned pointer is dereferenced by record-parsing helpers,
   causing an out-of-bounds read (and potentially a write) in kernel
   space.

Attack Vector
--------------------------------------------------------------------
Local, authenticated.  The attacker provides or modifies a CLFS log
container (for example via public CLFS APIs or by supplying a crafted
.BLF file) and convinces a privileged component to process it.

Patch Description
--------------------------------------------------------------------
Microsoft added full range validation:
  * Enforces a lower bound on FRO (must be >= 0x70).
  * Enforces a minimum record header size (offset+40 >= 0x28).
  * Correctly checks that (FRO + 40) does not exceed the caller-
    supplied buffer length.
  * Introduces feature-flag guarded logic but both paths close the
    primitive by requiring offset+header <= buffer.

Security Impact
--------------------------------------------------------------------
Before the patch a crafted container could make the kernel read (and
later possibly write) beyond the end of a pool buffer, leading to
information disclosure, memory corruption, and ultimately elevation of
privilege.  Successful exploitation yields arbitrary kernel-mode read
and potentially write, allowing a local attacker to execute code with
SYSTEM privileges.

Fix Effectiveness
--------------------------------------------------------------------
The updated boundary checks cover both lower and upper bounds and use
inclusive tests on (offset + header_size), removing the off-by-40
window.  No obvious bypass remains in the shown code; therefore the
patch effectively eliminates the described OOB read vector.
