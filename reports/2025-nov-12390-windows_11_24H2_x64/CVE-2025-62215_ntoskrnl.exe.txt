{'confidence': 0.08, 'date': 1763410768.588055, 'change_count': 86, 'cve': 'CVE-2025-62215', 'file': 'ntoskrnl.exe', 'patch_store_uid': 'ffde7bce-1b70-400a-83c8-6714efbb59c3', 'kb': 'KB5068861'}
--------------------------------------------------------------------
CVE-2025-62215 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows NT kernel – Security Reference Monitor (SRM)
  •  SepCopyTokenAccessInformation
  •  SepDuplicateToken
  •  SepTokenDeleteMethod
These routines build, duplicate and destroy the kernel TOKEN object.


Vulnerability Class
--------------------------------------------------------------------
CWE-362: Race Condition / Improper Synchronisation
CWE-415: Double Free (resulting from the race)


Detailed Root Cause Analysis
--------------------------------------------------------------------
When the optional SID-sharing feature (SepTokenSidSharingEnabled) is
on, the TOKEN does not hold a private copy of the User/Groups SID
array.  Instead it points to a shared, reference-counted buffer that is
kept in *Token+0x470 (old code) / *Token+0x468 (new code).

1.  SepDuplicateToken
    •  Before the patch the routine merely copied the pointer of the
       shared buffer into the destination TOKEN (p_Body[19])
       but DID NOT increment the reference counter that lives eight
       bytes before the buffer.
    •  The pointer was therefore shared by an arbitrary number of
       TOKENs that all believed they owned the memory.

2.  SepTokenDeleteMethod
    •  On handle close the function called
       SepDeleteTokenUserAndGroups() which unconditionally freed the
       buffer pointed to by *Token+0x470 and set the field to NULL.
    •  No interlocked decrement was performed, no lock was taken and
       the other TOKEN instances still kept their (now dangling)
       pointer.

3.  Concurrent destruction of two such TOKENs therefore leads to the
   classic pattern:
       T1:  free(shared_buffer)
       T2:  free(shared_buffer)  <-- double free / UAF

Because the buffer is allocated from paged pool an attacker can race
thread T1 and immediately reclaim the freed slot with controlled data.
Later kernel reads/writes (e.g. SID membership tests or hash rebuilds)
are then performed on attacker supplied memory, allowing elevation of
privileges.

Additional unsigned-to-signed mistakes existed in
SepCopyTokenAccessInformation – length parameters were declared
‘int’, so negative values underflowed the size subtraction
(   v22 - a6   etc.) allowing out-of-bounds copies.  The patch converts
all length arguments to unsigned and adds explicit range checks; these
bugs became exploitable after the UAF because the attacker could craft
malformed length fields inside the reclaimed buffer.

Structures / fields affected (Windows 64-bit):
  TOKEN.UserAndGroups          at +0x098
  TOKEN.SharedSidHeader        at +0x470 (refcnt @-8)
  TOKEN.VariablePartSize       at +0x084 / +0x088


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// SepDuplicateToken – BEFORE
p_Body[19].UseThisFieldToCopy = v42 + *((_QWORD *)a1 + 19); // copy ptr
...
if (_InterlockedIncrement64((volatile signed __int64 *)
        (*(( _QWORD *)a1 + 141) + 8)) <= 1)
    __fastfail(0xE);               // increments *different* counter
```
```c
// SepTokenDeleteMethod – BEFORE
if (SepTokenSidSharingEnabled)
    SepDeleteTokenUserAndGroups(a1);   // frees shared buffer blindly
```
```c
// SepDuplicateToken – AFTER (excerpt)
if (SepTokenSidSharingEnabled) {
    v58 = 0;
    // take shared buffer pointer
    MEMORY[0x98] = *(_QWORD *)(a1 + 152) - a1;
    // *increment correct reference counter*
    if (_InterlockedIncrement64((volatile signed __int64 *)
            (MEMORY[0x98] - 8)) <= 1) __fastfail(0xE);
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker enables SID-sharing (system-wide GFlags or policy).
2. Thread A continuously duplicates its process token → many TOKENs
   share the same User/Group buffer.
3. Threads A and B close two TOKEN handles at the same time.
4. The first close frees the shared buffer; the second close frees the
   same address again.
5. Attacker reallocates the memory between the two frees, gains kernel
   read/write via stale pointer, and overwrites privilege bits/LUIDs.


Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker who can call DuplicateTokenEx and close
handles in parallel (e.g. from two threads in the same process).
No additional privileges are required because a normal user can always
open and duplicate its own primary token.


Patch Description
--------------------------------------------------------------------
1. All size/offset parameters in SepCopyTokenAccessInformation changed
   from signed ‘int’ to unsigned to eliminate underflow.
2. Introduction of strict per-copy bounds checks and loop counters when
   copying SID_AND_ATTRIBUTES arrays.
3. SepDuplicateToken now:
   • Takes an interlocked reference on every shared SID buffer
     (InterlockedIncrement64(ptr-8)).
   • Adds matching InterlockedDecrement in the error paths.
4. SepTokenDeleteMethod now:
   • Decrements the shared buffer refcount atomically; frees only when
     the count reaches zero.
   • Zeros the Token fields after free to prevent a second free.
   • Uses new helpers (SepDereferenceLowBoxNumberEntry, etc.) guarded
     by proper locks.
5. Numerous defensive NULL assignments and interlocked checks added.


Security Impact
--------------------------------------------------------------------
Before the fix a local attacker could trigger a race that leads to a
use-after-free / double-free of a paged-pool object inside the kernel.
Exploiting the dangling pointer allows arbitrary kernel memory writes
and therefore full SYSTEM privileges.


Fix Effectiveness
--------------------------------------------------------------------
The patch removes the unsafe signed arithmetic, introduces explicit
length validation, and converts the shared SID buffer to a properly
reference-counted object with atomic increment/decrement on every path
(duplication, deletion, and failure unwind).  Double free is therefore
no longer reachable and the original race window is closed.

