{'confidence': 0.25, 'patch_store_uid': 'ef35a2f2-7561-402f-9995-40a114a8900a', 'file': 'dxgkrnl.sys', 'date': 1763409983.1218996, 'kb': 'KB5068861', 'cve': 'CVE-2025-60716', 'change_count': 67}
--------------------------------------------------------------------
CVE-2025-60716 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows DirectX graphics kernel driver (dxgkrnl.sys),
function DXGDEVICESYNCOBJECT::DestroyCoreState.

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use After Free (kernel-mode privilege escalation).

Detailed Root Cause Analysis
--------------------------------------------------------------------
DestroyCoreState tears down several scheduler-side and video memory
objects that belong to a DXGDEVICESYNCOBJECT instance.  When the flag
bit held in the object at offset 0x5C ( ``(*((_BYTE *)this+92)&1)`` )
is set, the routine obtains a pointer to the scheduler sync object by
calling GetVidSchSyncObject and then calls a driver supplied destroy
callback located at:
    (*(void**)(VidSchSyncObjectVtable)+0x2A8)

Pre-patch, no check verified that the returned pointer was still
valid.  In several situations the pointer may already have been freed
or set to NULL:
  1. The adapter render object carries byte flag 0x209 signalling that
     scheduler teardown has already happened.
  2. Another thread running Feature_H2E_WPA3SAE_93 flow may destroy the
     object first.

If either case occurs, DestroyCoreState dereferences a stale pointer
and issues a virtual call, corrupting arbitrary kernel memory.
Because the pointer contents are attacker controlled pool memory, the
fault can be turned into arbitrary code execution inside the graphics
kernel, yielding SYSTEM privileges.

The defect is therefore a classic UAF caused by a missing liveness
check and by executing teardown logic after the associated adapter has
already released its core resources.

Structures / fields involved
  ADAPTER_RENDER +0x209   : SchedulerReleased flag (boolean)
  DXGDEVICESYNCOBJECT +0x5C: InCoreState flag bit 0 (0x1)
  Pointer to VID scheduler sync object stored inside the device sync
  object (returned by GetVidSchSyncObject).

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch
VidSchSyncObject = DXGDEVICESYNCOBJECT::GetVidSchSyncObject(this);
v6 = *(_QWORD *)(*(_QWORD *)(v5 + 16) + 736i64);
v7 = *(_QWORD *)(v6 + 8);
LOBYTE(v6) = (*((_DWORD *)this + 18) & 0x420) == 0;
(*(void (__fastcall **)(struct _VIDSCH_SYNC_OBJECT *, _QWORD, __int64,
                        _QWORD))(v7 + 680))(
        VidSchSyncObject,                      // may be freed
        *(_QWORD *)(v5 + 800),
        v6,
        *((_QWORD *)this + 3));                // use-after-free
```
```c
// after patch (trimmed)
IsEnabledDeviceUsage_93 = Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage_93();
if (IsEnabledDeviceUsage_93) {
    VidSchSyncObject = DXGDEVICESYNCOBJECT::GetVidSchSyncObject(this);
    if (!VidSchSyncObject)                      // new NULL check
        goto FreeLocalState;
}
VIDSCH_EXPORT::VidSchDestroyDeviceSyncObject(
    SchedulerExport,
    VidSchSyncObject,
    VidSchDevice,
    (Flags & 0x420) == 0,
    RegisteredCallback);
FreeLocalState:
    ... // safe local free
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User mode opens a D3DKMT device and creates a native fence / device
   sync object.
2. Through multithreaded or race operations the adapter core is torn
   down, clearing the scheduler object and setting adapter flag 0x209.
3. A final reference triggers DXGDEVICESYNCOBJECT::DestroyCoreState.
4. Legacy code skips the flag check, retrieves a stale pointer and
   calls into freed memory –> pool corruption –> EoP.

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker invokes crafted DirectX (D3DKMT) API
sequences to race object creation/destruction, forcing the graphics
kernel to call DestroyCoreState after the scheduler object is already
freed.

Patch Description
--------------------------------------------------------------------
1. Early exit: if adapter->CoreReleasedFlag (byte +0x209) is set the
   function returns immediately, avoiding any interaction with freed
   scheduler objects.
2. Introduced feature gate
   Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage_93().
   When the gate is on, the code now verifies that
   GetVidSchSyncObject() returns a non-NULL pointer before use.
3. Replaced manual virtual-table call with
   VIDSCH_EXPORT::VidSchDestroyDeviceSyncObject, consolidating
   validation in a single helper.
4. Log line numbers bumped (+1) to match new source.

Security Impact
--------------------------------------------------------------------
An attacker can obtain arbitrary kernel read/write and execute code in
ring-0, thereby escalating from a standard user to SYSTEM.  The bug is
triggerable from a standard desktop session and does not require admin
rights or physical access.

Fix Effectiveness
--------------------------------------------------------------------
The added adapter flag guard removes the path that allowed reuse after
scheduler teardown.  The extra NULL pointer check and the use of a
validated helper API eliminate the direct dereference of stale memory.
No remaining call sites of GetVidSchSyncObject inside DestroyCoreState
operate without validation.  Therefore the patch appears to close the
UAF; comprehensive fuzzing would be required to rule out parallel free
scenarios in other code paths (unknown).
