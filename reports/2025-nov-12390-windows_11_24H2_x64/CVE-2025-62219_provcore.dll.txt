{'change_count': 15, 'file': 'provcore.dll', 'patch_store_uid': 'e0153e30-b6d6-4f95-a5e6-5c7ee980e3fc', 'kb': 'KB5068861', 'date': 1763412749.1534865, 'confidence': 0.25, 'cve': 'CVE-2025-62219'}
--------------------------------------------------------------------
CVE-2025-62219 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Wireless Provisioning System – provcore.dll
(ProvisioningEngine COM class together with helper Feature* code)

Vulnerability Class
--------------------------------------------------------------------
CWE-415: Double Free
CWE-362: Race Condition (unsynchronised access to shared data)

Detailed Root Cause Analysis
--------------------------------------------------------------------
ProvisioningEngine keeps a per-object unique_ptr<std::deque<ulong64>>
called m_msgTimeWindow.  The deque is used from
ProcessNotification() to decide whether an incoming provisioning
message must be throttled (IsMessageThrottlingRequired()).

In the original code path the deque was accessed without any form of
synchronisation:
  • every call to ProcessNotification() looked at / modified the same
    deque instance; 
  • the same object could be reached from several STA / MTA threads
    through the IProvisioningEngine COM interface that is exposed by
a system service.

Because no critical-section protected the container, two threads could
concurrently pop / push elements causing the STL implementation to
free and re-allocate internal blocks while another thread still held
obsolete pointers.  When the second thread later executed an oper­
a­tion that triggered a new free() the allocator was presented with an
already freed block, corrupting the heap – a classic double free.

Additionally, object lifetime was mishandled:
  • ATL::CComAggObject and CComObject wrappers invoked the
    ExtensionPreloadData dtor instead of the real
    ProvisioningEngine dtor.  The real resources (deque + critical
    section) were therefore destroyed again when the inner object was
    finally deleted, producing a second double free avenue.

Exploiting either of the above allows an attacker running in the same
session to obtain heap-layout control and execute arbitrary code in
the service’s security context (SYSTEM).

Structures / members involved
  ProvisioningEngine
    +0x18  m_critsec   (CComSafeDeleteCriticalSection)
    +0x30  m_msgTimeWindowLock (added by patch)
    +0x58  m_msgTimeWindow (std::unique_ptr< deque<ulong64> >)

The race happens while ProcessNotification executes:
    IsMessageThrottlingRequired(*(deque**)&this->m_critsec.m_bInitialized)

Vulnerability Code Snippets
--------------------------------------------------------------------
Before (no lock, two threads can enter simultaneously)
```c
v9 = 0;
// … parameter validation …
if (IsMessageThrottlingRequired(*(std::deque<unsigned __int64>**)&this->m_critsec.m_bInitialized))
{
    CurrentThread = GetCurrentThread();
    if (SetThreadPriority(CurrentThread, 0x10000))
        v10 = 1;
}
```
After (explicit critical-section serialises access)
```c
EnterCriticalSection(&this->m_msgTimeWindowLock.m_cs);
lock.m_ptr = (_RTL_CRITICAL_SECTION *)&this->m_msgTimeWindowLock.m_cs;
bool throttle = IsMessageThrottlingRequired(
                    *(std::deque<unsigned __int64> **)&this->m_critsec.m_bInitialized);
// unique_any_t automatically leaves the CS on scope exit
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Low-privilege client obtains IProvisioningEngine instance
   (CreateInstance → COM out-of-proc service running as SYSTEM).
2. Client creates two or more threads.
3. All threads call ProcessNotification() with crafted but valid
   GUID / notification arguments.
4. Unsynchronised access to m_msgTimeWindow causes concurrent
   deque mutations.
5. Heap allocator frees the same chunk twice, leading to memory
   corruption and potential code execution in SYSTEM context.

Attack Vector
--------------------------------------------------------------------
Local authenticated attacker.  By invoking the public COM interface
(IProvisioningEngine) from any sandbox / desktop process and issuing
parallel ProcessNotification calls the race can be won reliably.

Patch Description
--------------------------------------------------------------------
1. Added new member m_msgTimeWindowLock (RTL_CRITICAL_SECTION).
2. ProvisioningEngine constructor now calls
   InitializeCriticalSectionEx() to create the lock.
3. Destructor now:
   • leaves and deletes the lock via DeleteCriticalSection;
   • explicitly destroys m_msgTimeWindow unique_ptr and existing
     CComSafeDeleteCriticalSection.
4. ProcessNotification now unconditionally serialises access to the
   deque with EnterCriticalSection/LeaveCriticalSection wrapped by
   wil::unique_any_t.
5. All wrapper classes (CComObject/CComAggObject and their creators)
   were updated to call the correct ProvisioningEngine ctor / dtor so
   resources are released exactly once.

Security Impact
--------------------------------------------------------------------
An attacker could execute arbitrary code with SYSTEM privileges or
cause a service crash, resulting in an elevation of privilege (EoP).
The issue is memory-safety critical and bypasses standard user /
service isolation boundaries.

Fix Effectiveness
--------------------------------------------------------------------
The critical-section eliminates concurrent access to the shared deque
and therefore removes the race that led to the double free.  Correct
constructor / destructor routing ensures resources are released once
only.  No further double-free code paths are visible in the patched
binary; effectiveness is considered HIGH, although stress testing
under extreme concurrency is recommended.
