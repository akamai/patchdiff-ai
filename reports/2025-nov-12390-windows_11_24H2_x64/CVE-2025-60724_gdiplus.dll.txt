{'patch_store_uid': '4e9b8fa4-bb62-4ecd-8978-b314a888dcd5', 'confidence': 0.11, 'date': 1763409955.261717, 'kb': 'KB5068861', 'cve': 'CVE-2025-60724', 'file': 'gdiplus.dll', 'change_count': 9}
--------------------------------------------------------------------
CVE-2025-60724 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft GDI+ (gdiplus.dll) – region processing and scan–bitmap
blending routines (DpRegion::ValidateAndSet, EpScanBitmap::NextBuffer
and EpScanBitmap::NextBufferWithBounds).

Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow / integer-handling error (CWE-122).

Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  EpScanBitmap::NextBufferWithBounds originally declared its fifth
    parameter (pixel count / span width) as unsigned int.  When the
    caller supplied a negative size the value was implicitly converted
    to a large positive 32-bit integer.

2.  The helper EpScanBitmap::NextBuffer receives this value (a5) as a
    signed int, but immediately stores it in an unsigned local
    variable (v7).  Therefore a negative span (e.g. –1) becomes
    0xFFFF FFFF (4 294 967 295).

3.  The old code tried to clamp the span only when the (optional)
    feature flag 2578215227 was active *and* when
        a5 >= imageWidth – currentX
    The comparison is performed *before* the signed-to-unsigned cast
    and therefore fails for negative numbers.  As a result v7 keeps the
    enormous value.

4.  v7 is passed to EpAlphaBlender::Blend as the *pixel count* to copy
    from the source buffer (*this + 177) into the destination buffer
    (*this + 171).  Blend iterates width * bytesPerPixel bytes and thus
    overruns the heap allocation backing the bitmap row.

5.  Because all pointers involved point to fully attacker-controlled
    image data, the overflow can corrupt adjacent heap structures and
    ultimately lead to arbitrary code execution in the calling
    process.

6.  The auxiliary routine DpRegion::ValidateAndSet was also updated.
    Although not the primary crash site, the original implementation
    mixed signed/unsigned variables when building a dynamic array of
    spans (PathBound).  Crafting rectangles that triggered the
    overlooked negative-value path (label 16/23) could leave the
    builder in an inconsistent state and later cause similar heap
    corruption during Set().  The patch rewrote the loop and removed
    the flag that allowed this path to be taken.

Key structure members affected
  * this+0x08 (DWORD  currentX)
  * this+0x0C (DWORD  currentY)
  * this+0x510 (QWORD rowBufferPointer, index 171)
  * this+0x528 (QWORD bitmapBase, 168)
  * this+0x0144 (DWORD bitmapWidth, 328)

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// EpScanBitmap::NextBuffer (before)
if (a5 && rowBuf) {
    if (FeatureEnabled) {
        if (a5 + currentX > bitmapWidth)
            RtlLogUnexpectedCodepath(...);
        if (a5 >= bitmapWidth - currentX)
            v7 = bitmapWidth - currentX;   // clamp
    }
    EpAlphaBlender::Blend(..., v7, ...);   // v7 can be 0xFFFFFFFF
}

// NextBufferWithBounds (before)
void *NextBufferWithBounds(..., unsigned int a5, ...)
{
    ...
    if ((signed int)(currentX + a5) > maxX)
        maxX = currentX + a5;              // a5 wrapped from negative
}

// After patch
void *NextBufferWithBounds(..., int a5, ...)
{
    ...
    if (currentX + a5 > maxX)
        maxX = currentX + a5;              // signed addition
}

if (FeatureEnabled && a5 >= bitmapWidth - currentX)
    v7 = bitmapWidth - currentX;           // no dangerous addition
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Malicious image -> GDI+ decoder -> EpScanBitmap::NextBufferWithBounds
   (negative width) -> EpScanBitmap::NextBuffer (width cast to huge
   unsigned) -> EpAlphaBlender::Blend (memcpy-style loop) -> heap buffer
   overflow.

Attack Vector
--------------------------------------------------------------------
A crafted image, metafile or remote canvas operation that causes GDI+
layout code to request a scanline with a negative span length.  The
attack can be delivered via any channel that causes the target
application to load or manipulate the image (web content, email, or
network share).

Patch Description
--------------------------------------------------------------------
1. Changed NextBufferWithBounds parameter type from unsigned int to int
   and removed the signed-cast shortcut in max-bound calculation.
2. In NextBuffer, removed the unsafe addition (a5 + currentX) and only
   clamps when the span itself exceeds the remaining row width.
3. Re-ordered variables and reduced the number of signed/unsigned
   casts.
4. Rewrote DpRegion::ValidateAndSet loop to prevent an illegal merge
   path and to ensure DynamicArray::Grow failure cleanly aborts.

Security Impact
--------------------------------------------------------------------
An attacker can overflow a heap buffer inside GDI+, leading to memory
corruption and potential remote code execution in the context of the
calling process.  Any application that processes untrusted images with
GDI+ is affected (Office, browsers, preview pane, etc.).

Fix Effectiveness
--------------------------------------------------------------------
The patch eliminates the unsigned wrap by enforcing signed arithmetic
for the span length and removes the dangerous addition that could
overflow.  It also improves span clamping in NextBuffer and tightens
rectangle validation in DpRegion.  No remaining obvious path to
produce an oversized copy was found, suggesting the fix is effective.

