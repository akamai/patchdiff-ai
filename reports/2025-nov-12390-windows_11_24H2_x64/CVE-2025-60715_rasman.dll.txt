{'kb': 'KB5068861', 'file': 'rasman.dll', 'patch_store_uid': 'dd18337a-8fdc-4617-8570-c6658f6d2e1e', 'date': 1763409826.190237, 'confidence': 0.23, 'cve': 'CVE-2025-60715', 'change_count': 2}
--------------------------------------------------------------------
CVE-2025-60715 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Routing and Remote Access Service (RRAS)
(user-mode module rasman.dll – functions RasPortEnum() and
SubmitRequest()).

Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow / integer-truncation (CWE-122).

Detailed Root Cause Analysis
--------------------------------------------------------------------
RasPortEnum() enumerates modem/port structures that the RRAS
service (via SubmitRequest()) returns to the caller.  The caller
supplies two size parameters:
  * a3 – total size, in bytes, of the caller-supplied output buffer
  * a4 – receives the number of PORT_INFO records that are returned

Before the patch RasPortEnum() derived three different sizes from
those two values and silently mixed 32-bit and 64-bit arithmetic:

  requestSize  = 208 * ( *a3 / 0xD8 )   // 208-byte internal entry
  copySize     = 216 * ( v26 / 0xD0 )   // 216-byte public entry
  allocSize    = (unsigned int)requestSize   <-- truncated to 32 bit

1.  The 208 and 216 constants do not match.  The division rounds
    *down*, so requestSize can be smaller than the number of entries
    actually returned by the service ( *a4 ).
2.  allocSize is truncated to 32 bits and passed to LocalAlloc().
    For large a3 values (>= 0x100000000) the high dword is silently
    lost, producing a much smaller allocation than the caller
    expects.
3.  After the service returns, RasPortEnum() copies
    *a4 × 208 bytes from the heap block into the caller’s buffer:

        v22 = &v9[208 * vIndex];   // v9 points to heap block
        ...  *(_OWORD *)(dest) = *(src) ...

    The loop is bounded only by *a4; it does **not** verify that the
    source buffer (v9/allocSize) is large enough.  If allocSize is
    smaller than *a4×208 the copy continues past the end of the heap
    block, corrupting the process heap.

Because SubmitRequest() is an RPC helper that forwards data to the
remote RRAS service, an authenticated network attacker can control
both *a3 (via the RPC call) and the returned *a4 value, giving him
full control over the overflow size and content.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – RasPortEnum()
requestSize = 208i64 * (*a3 / 0xD8u);    // r19
v9 = LocalAlloc(0x40u, (unsigned int)requestSize); // truncated
...
v18 = 216i64 * (v26 / 0xD0);             // bytes needed later
...
while (v8 < *a4)                         // uses *a4 directly
{
    v22 = &v9[208 * vIndex];             // v9 may be too short
    /* 208-byte copy into 216-byte caller buffer */
}
```
```c
// after patch – RasPortEnum()
unsigned __int64 tmp = 208i64 * (*a3 / 0xD8u);
if (tmp > 0xFFFFFFFF) return ERROR_INVALID_PARAMETER; // new guard
v9 = LocalAlloc(0x40, (SIZE_T)tmp);
...
if (*a3 < requiredBytes)   // new size check
    return ERROR_BUFFER_TOO_SMALL;
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Remote client invokes RasRpcPortEnum → RRAS service → RasPortEnum().
2. RasPortEnum() calculates truncated allocSize and allocates heap
   buffer v9.
3. SubmitRequest() returns more PORT_INFO records than fit into v9.
4. Copy loop overruns v9 by (*a4×208 – allocSize) bytes, corrupting
   heap metadata.
5. Subsequent heap operation results in controlled memory smash →
   arbitrary code execution under the RRAS service account
   (typically SYSTEM).

Attack Vector
--------------------------------------------------------------------
Requires the ability to send RRAS management RPCs (normally
restricted to authenticated users).  The attacker supplies an
excessively large a3 value and later forces the service to return a
large *a4, causing the heap overflow inside the RRAS process.

Patch Description
--------------------------------------------------------------------
1. Unified the code path – removed feature-flag specific branch.
2. Performed all size computations in 64-bit (unsigned __int64).
3. Added explicit  >0xFFFFFFFF check before the value is cast to
   32-bit and passed to LocalAlloc().
4. Added explicit buffer-size comparison:
      if (*a3 < requiredBytes)  →  ERROR_BUFFER_TOO_SMALL
   which aborts before the copy loop.
5. Consistently frees the temporary buffer on all error paths.

Security Impact
--------------------------------------------------------------------
Prior to the patch an authenticated attacker could reliably overflow
a heap allocation inside the RRAS service and execute arbitrary code
in the context of NT AUTHORITY\SYSTEM, leading to full compromise of
the target server.

Fix Effectiveness
--------------------------------------------------------------------
The patched code removes the integer truncation, adds 64-bit bounds
checking, and re-checks the caller’s buffer length before copying.
No write occurs unless all size validations succeed, eliminating the
heap overflow condition described above.

