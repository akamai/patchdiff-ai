{'cve': 'CVE-2025-60723', 'patch_store_uid': 'ef35a2f2-7561-402f-9995-40a114a8900a', 'date': 1763412355.174791, 'file': 'dxgkrnl.sys', 'kb': 'KB5068861', 'confidence': 0.16, 'change_count': 67}
--------------------------------------------------------------------
CVE-2025-60723 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows DirectX Graphics Kernel  (dxgkrnl.sys).  The faulty
logic resides in the display-mode management and logical-allocator
helpers:  
 • SmmCreateLogicalAllocator()
 • DxgkpGetDisplayModeList()
 • CheckMultiPlaneOverlayInternal3()


Vulnerability Class
--------------------------------------------------------------------
CWE-362: Race Condition resulting in CWE-416: Use-After-Free.  Missing
synchronisation around shared adapter data lets two or more threads
free / reuse the same structures concurrently, leading to kernel
memory corruption and a system crash (DoS).


Detailed Root Cause Analysis
--------------------------------------------------------------------
1. Shared state
   All three routines operate on per-adapter global arrays that describe
   display modes, logical memory blocks and overlay planes.  The arrays
   are pointed to from adapter memory that is reachable from *any*
   graphics client running on the machine.

2. Missing lock (DxgkpGetDisplayModeList)
   Before the patch the function only held a COREADAPTERACCESS lock.
   While that lock is dropped the code recursively re-enters
   DxgkpGetDisplayModeList for other adapters, frees the current
   cached mode list and reallocates a new one, then later continues to
   dereference the stale pointer.  Concurrent threads can therefore
   UAF the cached list.

3. Use of uninitialised order (SmmCreateLogicalAllocator)
   The first call to
     SmmGetOrderBlockSizeInPages(v17)
   uses v17 before it is initialised, causing an incorrect decrement
   of the page counter.  The loop may over-iterate, write past the end
   of the newly allocated 1 328-byte structure and corrupt the linked
   list that is shared by other threads.

4. Cascade into CheckMultiPlaneOverlayInternal3
   The overlay helper consumes the same global lists without any
   additional serialisation.  A simultaneous free in the mode-list
   path can therefore leave dangling plane pointers that are walked
   later in the function, again crashing the kernel.

5. Result
   A user-mode process can race two threads that call the affected
   D3DKMT ioctls (GetDisplayModeList, CommitVidPn, overlay checks, …)
   and trigger a BSOD (KERNEL_MODE_EXCEPTION / BUGCHECK 0x3B or 0x50).
   No privileges beyond graphics-device access are needed.


Vulnerability Code Snippets
--------------------------------------------------------------------
Before (missing lock and uninitialised variable):
```c
// DxgkpGetDisplayModeList (excerpt)
CachedModeList = ADAPTER_DISPLAY::GetCachedModeList(a1[390], a4);
// no push-lock taken – other thread can free the list here
...
for ( i = v7; i; i -= SmmGetOrderBlockSizeInPages(v17) )
{                       // v17 is garbage on 1st iteration
    ...
}
```
After (fixed):
```c
// Take shared push-lock that covers the cached list
if (Feature_IsEnabledDeviceUsage_8()) {
    lock = AutoPushLock;
    lock->Address = Base + 1128;
    DXGAUTOPUSHLOCK::AcquireShared(lock);
}
...
while (v8) {
    Lower = SmmGetLowerOrderFromPageCount(v8);
    v8 -= SmmGetOrderBlockSizeInPages(Lower); // now valid
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User-mode calls D3DKMTGetDisplayModeList (win32k → dxgkrnl).
2. DxgkpGetDisplayModeList() allocates / frees the adapter’s cached
   mode list without holding a global push-lock.
3. A second thread enters the same ioctl and frees the list while the
   first thread still holds a pointer.
4. First thread proceeds, dereferences the freed memory in
   CheckMultiPlaneOverlayInternal3() or during list iteration and
   crashes the kernel.


Attack Vector
--------------------------------------------------------------------
An authenticated local user spawns two (or more) threads that
aggressively call the public D3DKMT* ioctls in parallel.  Timing the
calls forces the race and causes a system-wide denial of service.  No
special privileges are required beyond the ability to open a graphics
adapter handle (granted to ordinary users).


Patch Description
--------------------------------------------------------------------
• Introduced DXGAUTOPUSHLOCK in DxgkpGetDisplayModeList.  The lock is
  acquired in shared mode for reads and upgraded to exclusive before
  mode-list replacement, preventing concurrent frees.  
• Added feature-flag gates (IsEnabledDeviceUsage_xx) so the new locking
  is only active on patched systems.  
• Fixed uninitialised variable in SmmCreateLogicalAllocator and
  increased the allocation size from 1 328 to 1 336 bytes to match the
  extended structure.  
• Re-implemented CheckMultiPlaneOverlayInternal3 to use typed
  PagedPoolZeroedArray helpers, removing the complex manual allocation
  logic and guaranteeing single-owner freeing.  
• Added extra parameter validation (e.g., max address-space and page
  count checks) to refuse oversize requests early.


Security Impact
--------------------------------------------------------------------
Before the fix an attacker could reliably crash the kernel, leading to
local denial of service.  Because the bug is a classic UAF in kernel
context, elevation of privilege might also be possible, but no exploit
for that has been demonstrated.


Fix Effectiveness
--------------------------------------------------------------------
The added push-lock enforces single-threaded updates to the shared
mode-list, eliminating the double-free / UAF window.  The allocator
loop now uses a fully initialised order variable and correct page
count arithmetic, removing the out-of-bounds write.  Combined with the
new structured pool helpers and early-reject guards, the vulnerability
appears fully addressed.
