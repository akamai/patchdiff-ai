{'kb': 'KB5068861', 'cve': 'CVE-2025-60721', 'file': 'consent.exe', 'confidence': 0.27, 'change_count': 7, 'date': 1763409997.315364, 'patch_store_uid': '6e89b61c-bd67-4d2a-9782-fd415c123ea5'}
--------------------------------------------------------------------
CVE-2025-60721 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
consent.exe – Windows Administrator Protection (WAP) user-mode helper
that brokers elevation/UAC prompts.  All code shown is inside the
binary’s feature-gating helpers (wil::details::FeatureImpl<...>), its
ReportUsage telemetry helper and WinMain – the main entry point that
switches process context and applies mitigation policies.

Vulnerability Class
--------------------------------------------------------------------
CWE-270: Privilege Context Switching Error (local elevation of
privilege caused by wrong security-state decision logic).

Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  At process start WinMain determines whether the optional WAP
    security hardening (internally “Feature_ShadowAdmin” / feature id
    2578215227) must be applied.  In the vulnerable build the code:

        if (Feature_ShadowAdmin_IsEnabled())
            SetProcessMitigationPolicy(8, &ReturnLength, 4);

    executed unconditionally once the feature bit was set.  No further
    validation of the caller’s actual elevation state was performed.
    An attacker running inside an already elevated medium-IL process
    could therefore launch consent.exe with crafted command-line
    parameters that force WAP into an incorrect context-switch path
    later in WinMain.  Because the mitigation policy was enabled even
    when the process was started in the wrong elevation context,
    subsequent privilege checks relied on bad assumptions and the
    token handling code (ImpersonateLoggedOnUser / RevertToSelf
    blocks) was executed while the process still owned high-privilege
    handles, letting the attacker escape back to a SYSTEM / high-IL
    token that is written into the target process memory (NtWrite­
    VirtualMemory path around line 6100 in the original WinMain).

2.  Several wil::details::FeatureImpl<...>::GetCurrentFeatureEnabled­
    State helpers generated the per-feature state bitmask that drives
    the above decision.  Before the patch those helpers used a
    complicated flag-merge routine that left bit-0 (the final
    “valid/usable” flag) set even when the feature’s usage report could
    not be trusted (variable v10 remained zero, but v11 kept the value
    1).  The patched version rewrites the routine and explicitly
    forces bit-0 to be cleared unless both the 0x40 (valid) flag and a
    successful ReportUsage() call are present, closing the logic hole.

3.  wil::details::FeatureImpl<...>::ReportUsage previously accepted an
    attacker-controlled byte (a2) that was forwarded to
    ReportUsageToService as the ReportingKind parameter.  The patch
    turns that into a fixed constant (1) and changes the prototype so
    untrusted data can no longer steer the reporting path that feeds
    back into GetCurrentFeatureEnabledState.

4.  Finally, WinMain now performs two new validations before calling
    SetProcessMitigationPolicy:
      a. Feature_ShadowAdmin__private_IsEnabledDeviceUsageNoInline()
         must return true (device-specific gating).
      b. RtlQueryElevationFlags(&Flags) must succeed and the returned
         flags must indicate “ELEVATED_AND_NOT_VIRTUALIZED” (bit 0x10).

    Only when both hold will the mitigation be applied, preventing the
    confused-deputy scenario triggered by a low-privilege caller.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// WinMain (before)
if (Feature_ShadowAdmin_IsEnabled()) {
    ReturnLength = 1;
    SetProcessMitigationPolicy(8, &ReturnLength, 4); // no validation
}

// WinMain (after)
if (Feature_ShadowAdmin_IsEnabled()) {
    DWORD Flags = 0;
    if (Feature_ShadowAdmin_IsEnabledDeviceUsageNoInline() &&
        RtlQueryElevationFlags(&Flags) >= 0 && (Flags & 0x18) == 0x10)
    {
        ReturnLength = 1;
        SetProcessMitigationPolicy(8, &ReturnLength, 4);
    }
}

// ReportUsage (before)
__int64 ReportUsage(_DWORD *state, unsigned __int8 kind, ...)
{
    ...
    return ReportUsageToService(state+2, 54237988i64, bit10, bit11,
                                &v9, kind, 0);
}

// ReportUsage (after)
__int64 ReportUsage(unsigned int *state, __int64 /*unused*/, ...)
{
    ...
    return ReportUsageToService(state+2, 54237988i64, bit10, bit11,
                                &v8, 1, 0);
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker launches consent.exe with crafted command line that refers
   to a privileged target process and memory address (arguments are
   parsed around WinMain line 240).
2. Feature_ShadowAdmin is enabled; before the patch the process always
   calls SetProcessMitigationPolicy, putting consent.exe into an
   inconsistent state regardless of real elevation flags.
3. Later, NtDuplicateObject / NtWriteVirtualMemory writes an elevated
   token handle into the target process (lines 6100-6180).  Because
   the earlier context checks were bypassed, this succeeds and the
   attacker obtains a high-privilege token.

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker starts consent.exe with crafted
parameters while running under a medium-IL session that already has
some administrative privileges (e.g., via scheduled task).

Patch Description
--------------------------------------------------------------------
1. Strengthened feature state calculation – mandatory usage reporting
   must succeed before bit-0 (“state valid”) is set.
2. ReportUsage no longer accepts caller-supplied ReportingKind.
3. WinMain now checks both device-usage and elevation flags before
   invoking SetProcessMitigationPolicy, preventing the faulty context
   switch that kept elevated handles alive.
4. Numerous trace-guid and cosmetic renames; not security-relevant.

Security Impact
--------------------------------------------------------------------
Before the fix a standard user who could already run code in an
administrative context could coerce consent.exe into re-using elevated
handles after RevertToSelf(), allowing the write of an arbitrary token
handle into another process and ultimately elevating to SYSTEM / full
administrator locally.  No user interaction beyond launching the tool
was required.

Fix Effectiveness
--------------------------------------------------------------------
All introduced checks are performed in the same early code path that
previously mis-configured the process.  The additional elevation flag
validation, the hardened feature state logic, and the constant
ReportingKind together remove the incorrect privilege transition path.
Static review of the patched code shows no remaining way to reach the
unsafe NtWriteVirtualMemory block with an untrusted token.
