{'date': 1763409939.588911, 'change_count': 10, 'cve': 'CVE-2025-59506', 'kb': 'KB5068861', 'confidence': 0.28, 'file': 'dxgmms2.sys', 'patch_store_uid': '2793df05-f57c-4678-a179-38eeba1a9f17'}
--------------------------------------------------------------------
CVE-2025-59506 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows – DirectX Graphics Kernel (dxgmms2.sys)

Vulnerability Class
--------------------------------------------------------------------
Race condition leading to out-of-bounds (OOB) index/write in shared
flip-queue state (CWE-362 / CWE-787).

Detailed Root Cause Analysis
--------------------------------------------------------------------
Several flip-management routines share the VIDSCH_FLIP_QUEUE structure
without adequate synchronisation.  The key routine is
VidSchiRestartQueuedFlip():

1.  In the original code the current queue phase (parameter a5) is
    passed as signed int.  No range validation is performed before the
    value is used to index multiple per-source arrays that are sized
    for 0-63 entries only.

2.  When two execution contexts (e.g. the VSYNC DPC running
    VidSchiExecuteMmIoFlipAtPassiveLevel() and the scheduler thread
    running VidSchUnwaitFlipQueue()) update the same flip queue
    concurrently, a mismatch of *a4->Phase* (field 16) may occur.  One
    context can call VidSchiRestartQueuedFlip() with a negative or out
    of range phase value while the other still believes the phase is
    valid.

3.  The phase is used directly in arithmetic that computes array
    addresses such as:
        v13 = *(_QWORD *)( ... + 8 * v7 + 88 );
        _InterlockedAdd( (v5 + 8 * v7 + 6712) + 8, -v12 );
    Because the index is unchecked, a malicious or corrupted value
    points outside the intended per-adapter buffers and leads to kernel
    memory corruption.

4.  With carefully timed user-mode D3DKMT Present / Flip calls an
    attacker can win the race and make the scheduler use an invalid
    phase.  The resulting OOB write occurs in ring-0 and can be
    escalated to arbitrary privilege.

5.  Similar unsigned/synchronisation hardening was applied to
    VidSchiExecuteMmIoFlipAtPassiveLevel(), VidSchUnwaitFlipQueue(),
    VIDMM_GLOBAL::UpdateGpuVirtualAddressSystemCommand() and
    VidSchInitializeAdapter(), indicating the same shared state could
    be reached through multiple racing code paths.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
int __fastcall VidSchiRestartQueuedFlip(..., int a5) {
    ...
    if ( v10 != a5 ) {
        v12 = VidSchiCompleteFlipEntry(..., ((_BYTE)a5 - 1) & 0x3F, ...);
        // a5 used without validation
        _InterlockedAdd( (v5 + 8*v7 + 6712)+8, -v12 );
    }
    *((_DWORD *)a4 + 16) = a5;
}

// after
unsigned int __fastcall VidSchiRestartQueuedFlip(..., unsigned int a5) {
    ...
    if ( !*(_BYTE *)(v5 + 7072) ||
         ( (result = *((unsigned int *)a4 + 350*a5 + 293)) > 0xC ||
           (!_bittest(&v14,result)) ) &&
         result != 5 && result != 15 )
    {
        *((_DWORD *)a4 + 16) = a5;   // only if checks passed
        return VidSchiUpdateFlipQueueHistory(...);
    }
    return result;      // bail out on invalid phase
}
```
The patch converts the parameter to unsigned, adds a comprehensive
boundary/bitmap test against the flip-entry history and refuses the
update when the value is outside [0..63] or in invalid state.

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-mode Present / Flip → dxgkrnl!NtGdiDdDDIPresent →
VidMM/VIDS scheduler →
  ‑ thread A: VidSchiExecuteMmIoFlipAtPassiveLevel()
  ‑ thread B: VidSchUnwaitFlipQueue()
Both reference the same VIDSCH_FLIP_QUEUE object and may call
VidSchiRestartQueuedFlip() concurrently, racing on *Phase* field 16.

Attack Vector
--------------------------------------------------------------------
Local, low-privileged attacker submits a crafted sequence of Flip /
Present calls to the GPU while continuously toggling full-screen / MPO
state to maximise scheduler thread activity.  By stressing the race the
attacker injects an invalid phase that causes the OOB write inside the
kernel.

Patch Description
--------------------------------------------------------------------
1.   All affected functions now take the phase/index as *unsigned int*.
2.   Added explicit bounds and state validation before the index is
     written back or used for pointer arithmetic.
3.   Added adapter-wide flag (*v5+7072*) to short-circuit risky paths
     when debugging/validation is enabled.
4.   Replaced bespoke lock helpers with AcquireSpinLock wrappers to
     guarantee mutual exclusion.
5.   Increased size of adapter object (7088→7104) and extended
     feature-flag bytes (7068-7073) to gate new validation logic.

Security Impact
--------------------------------------------------------------------
Before the fix a winning race allowed kernel OOB writes from a
controllable value, leading to local privilege-escalation (SYSTEM) or
kernel crash.  The bug is reachable by any sandboxed process that can
use D3DKMT calls; no admin rights are required.

Fix Effectiveness
--------------------------------------------------------------------
The patch converts the critical parameter to unsigned and introduces
strict state/bound checks, preventing negative or oversized indices
from ever reaching the pointer arithmetic.  Additional locking reduces
window for concurrent corruption.  No remaining uncontrolled path was
observed in the patched diff, so the fix is considered effective.
