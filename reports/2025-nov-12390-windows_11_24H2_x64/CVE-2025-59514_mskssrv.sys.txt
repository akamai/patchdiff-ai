{'file': 'mskssrv.sys', 'cve': 'CVE-2025-59514', 'kb': 'KB5068861', 'date': 1763413968.4738345, 'change_count': 2, 'confidence': 0.29, 'patch_store_uid': '0449d30d-05d3-4f0a-a1ec-cd1730d9a493'}
--------------------------------------------------------------------
CVE-2025-59514 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Streaming Service Proxy driver (mskssrv.sys) – routine
FSRegObject::SetRegProcess and related registration logic.

Vulnerability Class
--------------------------------------------------------------------
Improper Privilege Management / Access Control (CWE-269).

Detailed Root Cause Analysis
--------------------------------------------------------------------
FSRegObject instances store two process pointers:
  +56h : Owning _KPROCESS (created when the kernel streaming filter is
         instantiated).
  +64h : "Registration" _EPROCESS supplied by user-mode clients through
         an IOCTL chain that ultimately calls
         FSRegObject::SetRegProcess.

Before the patch the routine performed the following logic:
 1. If the caller passed a non-NULL _EPROCESS pointer (a2):
      a. If a feature flag (Feature_H2E_WPA3SAE…) was enabled *and*
         (OwnerKproc == NULL || OwnerKproc->PID == a2->PID) it returned
         STATUS_ACCESS_DENIED.
      b. Else, if RegProcess was already set, it returned
         STATUS_OBJECT_NAME_EXISTS.
      c. Otherwise it called ObReferenceObjectByPointer(a2, 0, …) and
         blindly stored the pointer in RegProcess (+64h).
 2. If the caller passed NULL it simply dereferenced any previously
    stored RegProcess and cleared the field.

Key issues:
• The code accepted an arbitrary _EPROCESS pointer whenever the owner
  field (+56h) happened to be NULL – a normal condition for many filter
  objects created from user space.
• ObReferenceObjectByPointer was invoked with DesiredAccess == 0, so the
  caller did **not** need PROCESS_DUP_HANDLE or any other right to the
  target process.  Any low-privileged user could therefore register a
  privileged process such as the System process.
• Other parts of mskssrv.sys later attach to RegProcess and perform
  registry or object operations under that process context, giving the
  original caller SYSTEM-level capabilities.

Effect: a local, authenticated attacker can escalate privileges by
binding an elevated process to an FSRegObject they control and then
triggering subsequent operations that run with that process’s security
context.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// BEFORE
if (a2) {
    if (Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage() &&
        (*(KPROCESS **)(a1+56) == 0 ||
         PsGetProcessId(*(KPROCESS **)(a1+56)) == PsGetProcessId(a2)))
        return STATUS_ACCESS_DENIED;
    else if (*(void **)(a1+64))
        return STATUS_OBJECT_NAME_EXISTS;
    else {
        v7 = ObReferenceObjectByPointer(a2, 0, 0, 0);
        if (v7 >= 0)
            *(void **)(a1+64) = a2;   // arbitrary privileged process set
    }
}
```
```c
// AFTER (excerpt)
v5 = this->KProcess;
if (!v5)
    return STATUS_ACCESS_DENIED;     // new guard
if (PsGetProcessId(v5) == PsGetProcessId(a2))
    return STATUS_ACCESS_DENIED;
if (this->RegProcess)
    return STATUS_OBJECT_NAME_EXISTS;
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Low-privileged client opens \\Device\\Ks (mskssrv) via CreateFile.
2. Sends a KS property/IOCTL that reaches
   FSRegObject::SetRegProcess with a crafted _EPROCESS pointer to the
   System process.
3. Old code stores this pointer in object->RegProcess without access
   checks.
4. Client triggers another IOCTL that causes the driver to
   KeStackAttachProcess(RegProcess) or perform privileged registry
   writes, executing with SYSTEM rights and completing the privilege
   escalation.

Attack Vector
--------------------------------------------------------------------
Local – an authenticated user sends crafted IOCTLs to mskssrv.sys. No
administrator privileges or special capabilities are required.

Patch Description
--------------------------------------------------------------------
1. Rejects the call if the FSRegObject lacks a valid owner KPROCESS
   (this->+56) – the condition that previously allowed arbitrary
   registration.
2. Removes the irrelevant Feature_H2E_WPA3SAE flag gate; the checks are
   now always enforced.
3. Adds a PID comparison against the owner process and refuses when a
   caller tries to register the same PID, preventing context confusion.
4. Access to the RegProcess field is refactored to C++ member offsets
   but functional change is the new negative checks.

Security Impact
--------------------------------------------------------------------
Prior to the fix any standard user could bind an FSRegObject to an
arbitrary privileged process and later induce the driver to execute
inside that process context, resulting in full SYSTEM privilege
escalation.

Fix Effectiveness
--------------------------------------------------------------------
The added owner-existence and PID mismatch checks block the simple
privilege-escalation path because a user cannot create an FSRegObject
with a NULL KProcess and then register an elevated process. However, the
mitigation relies on the integrity of the owner pointer and PID
comparison; if other call paths allow NULLing or swapping the owner, the
issue could resurface. No further issues are visible in the supplied
diff.
