{'kb': 'KB5068861', 'file': 'bcastdvruserservice.dll', 'change_count': 9, 'date': 1763409893.511381, 'confidence': 0.29, 'cve': 'CVE-2025-59515', 'patch_store_uid': 'a5d1cc68-4205-440d-bca0-8dbbfd6959b5'}
--------------------------------------------------------------------
CVE-2025-59515 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Broadcast DVR User Service (bcastdvruserservice.dll).  All
changes are inside class
Windows::Media::Capture::Internal::BroadcastManager and related
AppBroadcast* helpers.


Vulnerability Class
--------------------------------------------------------------------
Use-After-Free caused by a race condition on reference–counted COM
pointers (CWE-416).


Detailed Root Cause Analysis
--------------------------------------------------------------------
BroadcastManager stores several COM interface pointers in its instance
memory:
  • +0x198 (field index 51) – OAuthRequestUri (IUriRuntimeClass*)
  • +0x1A0 (field index 52) – OAuthCallbackUri (IUriRuntimeClass*)
  • +0x1A8 (field index 53) – AuthenticationResult
      (IWebAuthenticationResult*)

Prior to the patch the getters and setters for those fields performed
these actions:
  1. Compare the incoming pointer with the cached one.
  2. If different, AddRef the new object, overwrite the field, and then
     Release the old object.

The code executed **without any mutual exclusion**.  Multiple service
threads could therefore run the following inter-leaving:
  T1:  GetOAuthCallbackUri() reads the field value into v5.
  T2:  SetOAuthCallbackUri() overwrites the field and Releases v5.
  T1:  continues and dereferences v5 (now freed) to AddRef → UAF.

A similar pattern existed between Set* / HandleExitBroadcastMode (which
asynchronously nulls the same fields while other threads are still
running).

Because the objects are COM interfaces, a successful UAF gives the
attacker a dangling vtable pointer under service privileges, enabling
a controlled write/execute primitive.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before – no locking
if (*((IWebAuthenticationResult**)this + 53) != a2) {
    (*(void(**)(IWebAuthenticationResult*))(*(_QWORD*)a2 + 8))(a2); // AddRef new
    v5 = *((_QWORD*)this + 53);
    *((_QWORD*)this + 53) = a2;
    if (v5)
        (*(void(**)(__int64))(*(_QWORD*)v5 + 16))(v5);           // Release old
}

// getter – also unlocked
v5 = *((_QWORD*)this + 53);
if (v5)
    (*(void(**)(__int64))(*(_QWORD*)v5 + 8))(v5); // AddRef after race → UAF
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker obtains two threads in the same low-priv context that can
   call the BroadcastManager WinRT interface.
2. Thread-A: repeatedly calls SetOAuthCallbackUri / SetAuthenticationResult
   with alternating objects.
3. Thread-B: simultaneously calls the matching Get* method in a tight
   loop.
4. Race window between overwrite and AddRef in getter produces a freed
   but reused interface pointer, leading to controlled memory
   corruption inside the Broadcast DVR User Service.


Attack Vector
--------------------------------------------------------------------
Any local user that can access the public WinRT "Game Bar / Broadcast"
APIs (e.g., a sandboxed UWP app) can trigger the race.  Successful
exploitation grants code execution in the Broadcast DVR User Service,
which runs with elevated privileges, resulting in local privilege
escalation.


Patch Description
--------------------------------------------------------------------
1. Introduced a dedicated CRITICAL_SECTION at offset +0x3C8 ("this+968")
   and wrapped all read/write operations on the vulnerable fields with
   EnterCriticalSection/LeaveCriticalSection.
2. Added feature-flag checks (wil::Feature … 75275577 / 2098154810) but
   both the "enabled" and the "disabled" paths are now protected—either
   by the new section or by an early critical-section taken in the
   calling helper.
3. HandleExitBroadcastMode now
   • converts the error-code parameter to unsigned, avoiding negative
     sign extension issues, and
   • clears +408/+416/+424 under the same critical sections.
4. BackgroundClientInternal::put_OAuthRequestUri was refactored to call
   BroadcastManager::SetOAuthRequestUri, guaranteeing it uses the new
   locking logic.


Security Impact
--------------------------------------------------------------------
The race could be exploited to execute attacker-controlled code inside
the Broadcast DVR User Service process, thereby elevating privileges to
SERVICE (and typically SYSTEM).  The patch eliminates the race and
therefore the UAF avenue for privilege escalation.


Fix Effectiveness
--------------------------------------------------------------------
The added critical sections make all pointer manipulations atomic with
respect to other threads, preventing concurrent Release/Use sequences.
No remaining unlocked code paths that touch the same fields are visible
in the diff.  The mitigation is effective provided the service always
initialises the CRITICAL_SECTION (true for class constructor – not in
diff).  Feature-flag fallback paths are also covered, so the fix appears
complete.
