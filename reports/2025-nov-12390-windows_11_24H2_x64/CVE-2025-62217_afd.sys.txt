{'cve': 'CVE-2025-62217', 'file': 'afd.sys', 'patch_store_uid': 'dd9c6721-2756-4ad6-92a0-850c704dd674', 'change_count': 5, 'kb': 'KB5068861', 'date': 1763409913.4688723, 'confidence': 0.24}
--------------------------------------------------------------------
CVE-2025-62217 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows kernel driver  
File: afd.sys (Ancillary Function Driver for WinSock)  
Affected routines:  
 * AfdSocketTransferBegin / AfdSocketTransferEnd  
 * AfdGetInformation  
 * AfdBind  
 * AfdConnect


Vulnerability Class
--------------------------------------------------------------------
Concurrent execution using shared resource with improper
synchronization (race condition) leading to use-after-free / dangling
pointer dereference inside kernel-mode socket endpoint objects.


Detailed Root Cause Analysis
--------------------------------------------------------------------
AFD endpoint structures can be *unbound* (logically detached and
released) at any time by user code that closes a handle or issues
IOCTL_AFD_UNBIND.  Prior to the patch a large family of handler
functions (Bind, Connect, SocketTransfer*, GetInformation) dereferenced
the endpoint, its connection, and its underlying TDI device pointers
without first guaranteeing that the endpoint cannot be un-bound in
parallel.

Execution flow:
1.  Thread-A starts one of the vulnerable IRP paths and obtains a raw
    pointer to the endpoint (e.g. `v4 = *(a2+48)->FileObject->FsContext`)
    and later to the connection object.
2.  Before the IRP finishes, Thread-B closes the same socket or calls
    the unbind IOCTL.  This drops the last reference and frees the
    endpoint / connection memory.
3.  Thread-A resumes and continues to access fields inside the now
    freed structures (`v4+248`, `v7+48`, `v5+264`, etc.).  This is a
    classic use-after-free that results in arbitrary kernel read/write
    and ultimately privilege escalation.

The race could be triggered reliably because none of the affected
functions raised the in-flight reference count that normally prevents
unbind (`AfdEndpoint->UnbindPreventCount`).


Vulnerability Code Snippets
--------------------------------------------------------------------
Before (AfdSocketTransferEnd):
```c
v4 = *(FileObject->FsContext);
...
if (!v8) {               // v8 = DeviceObject extracted from endpoint
    Status = STATUS_INVALID_PARAMETER;
    goto complete;
}
...
*(_WORD *)&v11[-1].MajorFunction = 21007;   // continues to use v4
```
After patch (excerpt):
```c
if (*(_WORD*)v5!=0xAFD1 && *(_WORD*)v5!=6909 &&
    ((*(_BYTE*)(v5+5)&0x10)==0 || (*(_BYTE*)(v5+6)&1)==0) &&
    (*(_DWORD*)(v5+8)&1)==0 && *(_BYTE*)(v5+2)!=4) {
    if (!(UINT8)AfdPreventUnbind(v5)) {
        Status = STATUS_PORT_DISCONNECTED;  // bail out
        goto cleanup;
    }
    v3 = 1;            // remember to re-allow later
}
...
cleanup:
if (FeatureEnabled && v3)
    AfdReallowUnbind(v5);        // release the hold
```
The same two-step *PreventUnbind / ReallowUnbind* sequence has been
added to all other touched routines.


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User process opens an AFD socket handle.
2. Thread-A issues IOCTL_AFD_BIND / CONNECT / TRANSFER / QUERY, placing
   the vulnerable routine on the stack.
3. Just after the routine reads the endpoint pointer, Thread-B closes the
   handle or issues IOCTL_AFD_UNBIND causing the endpoint to be freed.
4. Thread-A continues execution and touches freed memory, corrupting
   pool or executing attacker-controlled data.


Attack Vector
--------------------------------------------------------------------
Local, low-privilege user-mode code.  No special rights beyond the
ability to create and manipulate Winsock sockets are required.  The
race can be driven entirely from user space with two threads and normal
AFD IOCTLs.


Patch Description
--------------------------------------------------------------------
1. Introduces helper pair `AfdPreventUnbind()` / `AfdReallowUnbind()`
   that atomically increments / decrements the endpoint field that gates
   unbind operations.
2. Each vulnerable routine now:
   a. Detects whether the endpoint is susceptible to unbind (various
      fast-path exclusions remain for raw or already protected sockets).
   b. Calls `AfdPreventUnbind()` before dereferencing the endpoint.
   c. Stores a flag so that `AfdReallowUnbind()` is executed on every
      exit path (success, failure or early return).
3. Adds extra parameter and state validation to bail out early on
   malformed input.
4. Minor refactoring: renamed local variables, widened IRP status plane,
   and added feature-flag wrappers so the mitigation can be enabled /
   disabled via GFlags.


Security Impact
--------------------------------------------------------------------
Prior to the fix a local attacker could win the race to unbind and
convert the freed endpoint / connection memory into a controlled fake
object.  Subsequent kernel dereferences allow arbitrary kernel pointer
reads/writes, resulting in elevation to SYSTEM.  The bug therefore
constitutes a local Elevation of Privilege (EoP) vulnerability in the
Windows kernel.


Fix Effectiveness
--------------------------------------------------------------------
The added *PreventUnbind* reference guarantees that the endpoint remains
allocated while the routine is operating, closing the race window.  The
complementary *ReallowUnbind* in every exit path prevents leaks.
Additional sanity checks further reduce malformed input surfaces.  No
remaining unprotected dereference paths were observed in the patched
code, so the fix appears comprehensive.

