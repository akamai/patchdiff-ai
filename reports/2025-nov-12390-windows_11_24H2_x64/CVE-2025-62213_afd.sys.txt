{'cve': 'CVE-2025-62213', 'patch_store_uid': 'dd9c6721-2756-4ad6-92a0-850c704dd674', 'confidence': 0.34, 'kb': 'KB5068861', 'date': 1763412304.0701337, 'file': 'afd.sys', 'change_count': 5}
--------------------------------------------------------------------
CVE-2025-62213 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows kernel driver  afd.sys  (Ancillary Function Driver for WinSock)
versions prior to the April-2025 security update.

Vulnerability Class
--------------------------------------------------------------------
CWE-416  –  Use-After-Free / Dangling-pointer access leading to local
privilege escalation.

Detailed Root Cause Analysis
--------------------------------------------------------------------
AFD endpoint objects can be *un-bound* (freed) by a user process via
IOCTLs or closes.  Several code paths (SIO_SOCKET_TRANSFER_BEGIN / END,
AfdBind, AfdConnect and AfdGetInformation) accessed internal endpoint
fields after assuming the object would remain valid:

  • v5/v4   – pointer to the AFD_ENDPOINT structure
  • v9/v10  – cached DEVICE_OBJECT
  • v8      – cached connection pointer

Before the patch these routines:
  1. copied the DEVICE_OBJECT and FILE_OBJECT from the endpoint;
  2. queued an IRP to the transport with IofCallDriver();
  3. returned to user mode *without* holding any additional reference
     on the endpoint or connection.

If the caller (or another thread with a duplicated handle) closed or
unbind the socket before the IRP finished, AfdDereferenceEndpoint()
freed the object.  The completion routine, or later instructions in the
same function, then dereferenced the stale pointers, producing a
use-after-free in kernel context.

Because the freed memory is controlled by the attacker (it resides in
NonPagedPool) the dangling write/read can be exploited to overwrite
adjacent kernel objects and run arbitrary code with SYSTEM privileges.
No special capabilities are needed beyond a handle to a local socket.

The bug is reachable for:
  • Bluetooth RFCOMM endpoints ("\Device\BTHMS_RFCOMM")
  • regular TCP/UDP endpoints that are not yet bound
  • endpoints whose type is neither AFD_ENDPOINT_TYPE_V4(1) nor
    V6(6) (the extra checks added by the patch).

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Before
v8 = *(DEVICE_OBJECT **)(v4 + 40);
v9 = *(FILE_OBJECT   **)(v4 + 24);
_IofCallDriver(v8, Irp);      // endpoint can be freed right here
...

// After
if (!AfdPreventUnbind(v5))        // grab a "no-unbind" reference
    return STATUS_CONNECTION_ABORTED;
v3 = 1;                           // remember the lock
...
Status = IofCallDriver(v9, Irp);
...
if (v3)                           // release only after use
    AfdReallowUnbind(v5);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User opens an un-bound socket (CreateFileA on "\\Device\\Afd").
2. Issue IOCTL_AFD_SOCKET_TRANSFER_BEGIN / BEGIN_BIND / CONNECT.
3. Immediately close the handle or call IOCTL_AFD_UNBIND from another
   thread.
4. Endpoint memory is freed.
5. Transport IRP completes and AfdTdiSocketTransferComplete (or similar)
   touches the freed endpoint –> kernel UAF.

Attack Vector
--------------------------------------------------------------------
Local, authenticated user-mode code.  Requires only the ability to open
and close a Winsock socket; no administrator rights or special
privileges are needed.

Patch Description
--------------------------------------------------------------------
Microsoft inserted systematic lifetime-management around every code path
that accesses an un-bound endpoint:
  • New helpers AfdPreventUnbind() / AfdReallowUnbind() are called to
    raise a reference counter that blocks the unbind operation for the
    duration of the sensitive region.
  • Additional endpoint-type checks (family == 1/6, state flags, IRQL)
    cause early FAIL_FAST if the object is already in a dangerous
    state.
  • In AfdGetInformation/AfdBind/AfdConnect extra parameter validation
    prevents undersized sockaddr buffers and illegal combinations.

Security Impact
--------------------------------------------------------------------
Prior to the fix, a local attacker could dereference freed kernel memory
from ring-0, allowing information disclosure or, with pool spraying,
arbitrary kernel code execution.  Successful exploitation yields SYSTEM
privileges (Elevation-of-Privilege class).

Fix Effectiveness
--------------------------------------------------------------------
The added unbind-prevention reference guarantees that the endpoint
structure cannot be freed until after the IRP or helper routine has
finished, removing the dangling pointer window.  Combined with stricter
parameter validation, the patch completely eliminates the observed
use-after-free condition.

