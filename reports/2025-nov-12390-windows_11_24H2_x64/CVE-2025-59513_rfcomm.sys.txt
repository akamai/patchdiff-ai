{'cve': 'CVE-2025-59513', 'change_count': 4, 'kb': 'KB5068861', 'patch_store_uid': '07a0172b-918a-47d6-8168-c0699d64bde2', 'file': 'rfcomm.sys', 'date': 1763409788.9978082, 'confidence': 0.24}
--------------------------------------------------------------------
CVE-2025-59513 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Bluetooth RFCOMM protocol driver (rfcomm.sys) –
function TdiConnect (also touched: RfcommExpandSystemRoot).


Vulnerability Class
--------------------------------------------------------------------
Out-of-Bounds Read (CWE-125) leading to kernel information
leakage.


Detailed Root Cause Analysis
--------------------------------------------------------------------
The driver services a user-mode TDI_CONNECT request through the
routine TdiConnect( … ).  The IRP parameter block (a4) contains a
pointer at offset +0x08 that is expected to reference a
TDI_CONNECTION_INFORMATION structure supplied by the caller.

Layout (relevant fields):
  0x00  Next/Unused
  0x20  OptionsLength          (ULONG)
  0x24  RemoteAddressLength    (ULONG)
  0x28  Options                (PVOID)
  0x30  UserDataLength         (ULONG)   <-- length checked by patch
  0x38  UserData               (PVOID)   <-- pointer used by driver

Prior to the patch the driver performed **no** size validation before
using the embedded pointer:
    v8 = *(_QWORD *)(*(_QWORD *)(a4 + 8) + 40);
    *(_OWORD *)(a3 + 116) = *(_OWORD *)(v8 + 8);   // copy 32 bytes
    *(_QWORD *)(a3 + 132) = *(_QWORD *)(v8 + 24);
    *(_DWORD *)(a3 + 140) = *(_DWORD *)(v8 + 32);

If the attacker sets UserDataLength to a value < 36 (the driver later
uses offsets 0x08, 0x18 and 0x20) while pointing UserData to a buffer
that is exactly UserDataLength bytes long, the above copies access
memory outside the supplied buffer.  Because the access occurs in
kernel mode, the contents of adjacent kernel memory are read and
stored in the connection context.  Subsequent status or ioctl calls
can disclose these stale bytes back to user mode, providing an
information disclosure primitive.

The secondary routine RfcommExpandSystemRoot suffered from similar
unchecked length arithmetic when expanding symbolic links; the patch
adds equivalent boundary validation, but the CVE is satisfied by the
TdiConnect flaw alone.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// BEFORE
v8 = *(_QWORD *)(*(_QWORD *)(a4 + 8) + 40); // no size check
*(_OWORD *)(a3 + 116) = *(_OWORD *)(v8 + 8);
*(_QWORD *)(a3 + 132) = *(_QWORD *)(v8 + 24);
*(_DWORD *)(a3 + 140) = *(_DWORD *)(v8 + 32);

// AFTER
v4  = *(_QWORD *)(a4 + 8);
len = *(DWORD *)(v4 + 32);          // UserDataLength
if (len < 36) {                     // new validation
    WPP_RECORDER_SF_ddd(...);
    return STATUS_INVALID_PARAMETER;
}
v12 = *(_QWORD *)(v4 + 40);         // safe – structure large enough
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User opens the Bluetooth RFCOMM device (\\.\BthModem or higher
   layers).
2. User crafts and sends a TDI_CONNECT IRP where
      UserDataLength  < 0x24 (e.g. 4) and
      UserData        -> controlled buffer of that length.
3. rfcomm.sys::TdiConnect executes, acquires the spin-lock, and copies
   fixed-size structures from offsets +0x08, +0x18, +0x20 beyond the
   attacker buffer.
4. Kernel memory adjacent to the buffer is read and stored in the
   connection object; later queries can leak these bytes to the
   attacker.


Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker.  No special privileges are required
beyond the ability to open a Bluetooth RFCOMM socket and issue a
TDI_CONNECT request, something any normal user can do on systems with
Bluetooth support enabled.


Patch Description
--------------------------------------------------------------------
1. In TdiConnect the patch reads the UserDataLength field at offset
   +0x20 (v4 + 0x20 / displayed as +32) and aborts with
   STATUS_INVALID_PARAMETER (0xC000000D) if the size is < 36 bytes –
   the minimum needed for the subsequent fixed-offset reads.
2. Records the unexpected path through RtlLogUnexpectedCodepath for
   telemetry.
3. Adds similar 0xFFFF and size relationship checks to
   RfcommExpandSystemRoot and improves error logging.
4. No structural changes to allocation or copy operations; the fix is
   purely defensive length validation.


Security Impact
--------------------------------------------------------------------
Before the fix a non-privileged process could perform an arbitrary
kernel out-of-bounds read, leaking up to 24 bytes per request
(0x40-0x24) from the kernel heap or stack.  Leaked data may include
pointers and layout information that allow bypass of KASLR and other
mitigations, facilitating further exploitation chains.


Fix Effectiveness
--------------------------------------------------------------------
The added UserDataLength >= 36 test ensures that the driver only
accesses memory within the user-supplied buffer, preventing the
out-of-bounds read path that led to leakage.  No alternative entry
points to the same code path were observed in the diff, and additional
length checks were inserted in the secondary helper routine, making
the fix comprehensive for the reported issue.
