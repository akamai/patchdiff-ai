{'patch_store_uid': 'ac1e457b-c56f-4ee7-b47c-3c0a37f29444', 'file': 'speechruntime.exe', 'confidence': 0.31, 'cve': 'CVE-2025-59509', 'kb': 'KB5068861', 'date': 1763392680.4010856, 'change_count': 25}
--------------------------------------------------------------------
CVE-2025-59509 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows 10/11 speechruntime.exe – NLInternal::CVoiceActivationController
(Audio / Voice-activation subsystem, part of the Speech Runtime).

Vulnerability Class
--------------------------------------------------------------------
Information Disclosure – CWE-201: Insertion of Sensitive Information
Into Sent Data (leak via malformed COM property accessors).

Detailed Root Cause Analysis
--------------------------------------------------------------------
The COM interface that exposes speech-training state to user-mode apps
contains a set of property “get_” methods that must return a BOOL value
via an out-parameter:
    HRESULT get_IsVoiceActivationEnabled( BOOL *pValue );
    HRESULT get_IsTrainingEnabled(      BOOL *pValue );
    HRESULT get_IsTrained(              BOOL *pValue );
    HRESULT get_IsInTraining(           BOOL *pValue );

In the vulnerable build these routines were implemented with the wrong
prototype.  They received a single 8-bit value instead of a pointer:
    __int64 func( __int64 this, char value );

When a legitimate caller passed the **address** of a BOOL variable, the
implementation treated that 64-bit pointer as a scalar boolean and
forwarded it to lower layers (ISpAudioOrchestratorPolicy::SetProperty,
CVAEngineModelWrapper, etc.) as a configuration value.  This resulted
in two problems:

1.  The high 56 bits of the user-supplied pointer – which contain stack
    or heap addresses – were copied verbatim into the Speech Policy
    message that is propagated to other privileged components of the
    audio pipeline.
2.  Because any non-zero pointer is interpreted as TRUE, callers could
    silently force the speech engine to enable features such as Voice
    Activation and Speaker ID training, causing unintended collection
    and distribution of microphone data.

Thus an unprivileged local process that can obtain a reference to the
CVoiceActivationController object can disclose memory addresses (ASLR
bypass) **and** trigger continuous voice capture, leading to local
information disclosure of spoken content.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable (before)
__int64 __fastcall sub_14001B8E0(__int64 a1, char a2)
{
    ...
    v6 = (*(fn *)(*v9 + 48))(v9,
            L"SpeakerIDOn",          // property name
            a2 != 0);                // *pointer interpreted as value!
    ...
}

// fixed (after)
__int64 __fastcall CVoiceActivationController::get_IsVoiceActivationEnabled(
        LPVOID *this, bool *pOut)
{
    if (!pOut) return E_INVALIDARG;
    ...                                 // fetch real value
    *pOut = v18 != 0;                   // return via out parameter
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Low-privilege app activates the Speech COM object and calls
   get_IsVoiceActivationEnabled(&myBool).
2. Pointer value is mis-cast to bool ; internal SetProperty("SpeakerIDOn", 1)
   executes, copying the pointer bits into the property packet.
3. Packets are forwarded to the Audio Orchestrator service and can be
   read back by the attacker or cause continuous microphone capture.

Attack Vector
--------------------------------------------------------------------
Local – any sandboxed or normal desktop process able to create or
receive an interface pointer to NLInternal::CVoiceActivationController
can exploit the bug without needing additional privileges.

Patch Description
--------------------------------------------------------------------
• All affected “get_” methods were rewritten with the correct
  signature (LPVOID *this, BOOL *pOut).
• Added explicit nullptr checks and early E_INVALIDARG return paths.
• Replaced direct COM SetProperty calls with guarded reads using
  CAudioPolicyWrapper::GetDWORD / Feature gating.
• Introduced wil::Feature checks to restrict code paths and inserted
  proper critical-section handling.
• Any failure path now resets the Audio Orchestrator training mode
  to 0, preventing unintended audio capture.

Security Impact
--------------------------------------------------------------------
Prior to the patch a local attacker could:
1. Read process memory addresses (information useful for further
   exploits) because pointer bits were propagated into shared speech
   policy messages.
2. Force the Speech Engine into training / activation mode, enabling
   clandestine microphone recording and exposing the user’s spoken
   content.
Overall this yields a local Information Disclosure rated Important.

Fix Effectiveness
--------------------------------------------------------------------
The new binaries strictly treat the parameter as an OUT pointer, never
copy the pointer value itself, and validate all inputs.  Policy updates
are now based solely on trusted data read from the AudioPolicy wrapper.
As the faulty type-confusion path has been completely removed, the
original disclosure vector is closed.
