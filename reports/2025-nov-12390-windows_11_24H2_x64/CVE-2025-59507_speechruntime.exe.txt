{'cve': 'CVE-2025-59507', 'file': 'speechruntime.exe', 'patch_store_uid': 'ac1e457b-c56f-4ee7-b47c-3c0a37f29444', 'confidence': 0.27, 'kb': 'KB5068861', 'change_count': 25, 'date': 1763409756.411471}
--------------------------------------------------------------------
CVE-2025-59507 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Speech Runtime (speechruntime.exe) – Voice Activation
Controller (NLInternal::CVoiceActivationController)

Vulnerability Class
--------------------------------------------------------------------
Race condition / improper synchronization (CWE-362)

Detailed Root Cause Analysis
--------------------------------------------------------------------
Several controller entry points, all callable from user-mode COM
interfaces, access shared state inside
NLInternal::CVoiceActivationController without taking a lock in the
original code.  The affected members are

  + DWORD TrainingMode      @ offset +0x38 (old code uses +0x128)
  + COM ptr ISpAudioOrchestratorInput  @ offset +0x90
  + COM ptr ISpAudioOrchestratorPolicy @ offset +0xA0

Key routines:
  1. SetAudioOrchestratorTrainingMode()
  2. ProcessAudioForModelTraining()
  3. StartModelTraining_Old()

Before the patch SetAudioOrchestratorTrainingMode() simply compared and
updated TrainingMode, obtained the internal orchestrator object and
invoked its SetTrainingMode method – all without any critical section.
Because other public methods (ProcessAudioForModelTraining /
StartModelTraining_Old) can be executed on separate worker threads, two
threads can run the following inter-leaved sequence:

  T1: read TrainingMode == 0
  T2: read TrainingMode == 0
  T1: obtain orchestrator pointer
  T2: free / re-create orchestrator pointer
  T1: call vtable on stale pointer  → UAF / memory corruption

The orchestrator object lives in a privileged Audio Service process.
Triggering the use-after-free under the SpeechRuntime process context
lets an attacker execute code with service-level privileges, resulting
in a local elevation of privilege.

Patch 2025-04 adds an explicit RTL_CRITICAL_SECTION at offset +0xB8
(184) to serialize all accesses to TrainingMode and the two COM
pointers.  Every path that mutates or consumes those fields now enters
this critical section before touching them and leaves it on exit.

Vulnerability Code Snippets
--------------------------------------------------------------------
Before:
```c
if ( *(_DWORD *)(a1 + 128) == a2 )
    return 0;
...                          // no locking at all
*(_DWORD *)(a1 + 128) = a2;  // shared state update
```
After:
```c
EnterCriticalSection((LPCRITICAL_SECTION)((char *)this + 184));
if ( *((_DWORD *)this + 56) == a2 )
{
    LeaveCriticalSection((LPCRITICAL_SECTION)((char *)this + 184));
    return 0;
}
...
*((_DWORD *)this + 56) = a2;
LeaveCriticalSection((LPCRITICAL_SECTION)((char *)this + 184));
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Attacker thread A                 Attacker thread B
----------------------------------------------------------------
StartModelTraining_Old()          ProcessAudioForModelTraining()
  └─ SetAudioOrchestratorTrainingMode(1)   └─ SetAudioOrchestratorTrainingMode(0)
       (no lock)                             (no lock)
       – obtains ptr P1                      – frees / replaces ptr P1
       – later dereferences P1 → crash / RCE in service context

Attack Vector
--------------------------------------------------------------------
Local code that can load speechruntime.dll and obtain a
CVoiceActivationController COM object (available to normal user
sessions) launches two or more threads that invoke the public
training-related APIs concurrently to race the internal state.

Patch Description
--------------------------------------------------------------------
1. Introduced a dedicated critical section member at offset +0xB8.
2. Wrapped all shared resource manipulation in
   EnterCriticalSection/LeaveCriticalSection.
3. Unified the locking scheme across old and new feature-flag code
   paths so every access to TrainingMode or orchestrator COM objects is
   serialized.
4. Minor refactor: replaced ad-hoc logging with DoTraceMessage and
   updated offsets to use typed fields (56 rather than raw +128).

Security Impact
--------------------------------------------------------------------
Without the lock an unprivileged process can race the controller into a
use-after-free of a service-owned COM interface, leading to memory
corruption inside the Speech Runtime service and therefore elevation
of privilege (local EoP).

Fix Effectiveness
--------------------------------------------------------------------
All entry points now take the same critical section before touching the
shared members, eliminating concurrent unsynchronised access paths.
No remaining unprotected writes were observed in the diff, making the
patch logically sound for this specific race condition.
