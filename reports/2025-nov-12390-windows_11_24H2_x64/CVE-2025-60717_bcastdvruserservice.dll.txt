{'patch_store_uid': 'a5d1cc68-4205-440d-bca0-8dbbfd6959b5', 'kb': 'KB5068861', 'confidence': 0.15, 'cve': 'CVE-2025-60717', 'file': 'bcastdvruserservice.dll', 'change_count': 9, 'date': 1763412270.7896793}
--------------------------------------------------------------------
CVE-2025-60717 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Broadcast DVR User Service (bcastdvruserservice.dll), mainly
class Windows::Media::Capture::Internal::BroadcastManager and helper
client classes used by the Game DVR / App Broadcasting feature set.


Vulnerability Class
--------------------------------------------------------------------
CWE-416 – Use After Free caused by a missing synchronization (thread
safety / race condition) on reference-counted interface pointers that
are shared across multiple threads inside the service.


Detailed Root Cause Analysis
--------------------------------------------------------------------
The Broadcast Manager maintains several COM interface pointers that are
stored directly in class members:
  + offset +0x1A0 (member 52) – IUriRuntimeClass  (OAuth callback URI)
  + offset +0x1A8 (member 53) – IWebAuthenticationResult (OAuth result)
  + additional members at +0x198/+0x1A0 accessed during
    HandleExitBroadcastMode.

Prior to the patch the following code paths accessed these members
without any mutual exclusion:
  • SetOAuthCallbackUri(..) / SetAuthenticationResult(..) replaced the
    stored pointer and released the previous interface.
  • GetOAuthCallbackUri(..) / GetAuthenticationResult(..) returned the
    pointer to callers and performed AddRef after the load.
  • HandleExitBroadcastMode(..) asynchronously cleared the same members
    while other threads could still call the getters.

Because the load-AddRef sequence in the getters was not protected, the
following inter-thread race was possible:
  1. Thread A executes GetOAuthCallbackUri()
         ptr = m_pCallbackUri;            // load
  2. Thread B pre-empts, calls SetOAuthCallbackUri(newUri);
         Release(oldPtr);                 // decrements ref-count
         m_pCallbackUri = newUri;         // store
         if (oldPtr->ref == 0) free(oldPtr)
  3. Thread A resumes, executes AddRef(ptr) on the freed object.

The same pattern exists for IWebAuthenticationResult and for the
HandleExitBroadcastMode clean-up routine.  A stale pointer dereference
leads to heap use-after-free, memory corruption and ultimately privilege
escalation inside the SYSTEM service process.

Affected structures / parameters
  • BroadcastManager::m_pOAuthCallbackUri (member 52)
  • BroadcastManager::m_pAuthenticationResult (member 53)
  • Parameter a2 of setters / double-pointer a2 of getters
  • Critical section added at offset +0x3C8 (field starts at +968)


Vulnerability Code Snippets
--------------------------------------------------------------------
Pre-patch (no locking):
```c
// SetOAuthCallbackUri - before
if (a2) {
    if (this->m_pOAuthCallbackUri != a2) {
        a2->AddRef();
        auto old = this->m_pOAuthCallbackUri;
        this->m_pOAuthCallbackUri = a2;
        if (old) old->Release();          // releases while getters run
    }
}
```

Patch (critical section added):
```c
if (Feature2098154810_IsEnabled()) {
    EnterCriticalSection(this + 968);
    if (this->m_pOAuthCallbackUri != a2) {
        a2->AddRef();
        auto old = this->m_pOAuthCallbackUri;
        this->m_pOAuthCallbackUri = a2;
        if (old) old->Release();
    }
    LeaveCriticalSection(this + 968);
}
```

Similar changes were applied to GetOAuthCallbackUri / (Authentication
Result) and to HandleExitBroadcastMode, which now takes the same lock
before clearing the members.


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Low-privileged client rapidly issues
   BroadcastManager::SetOAuthCallbackUri() from one thread while
   simultaneously issuing GetOAuthCallbackUri() from another thread.
2. Race window between load and AddRef in the getter collides with the
   Release in the setter.
3. Freed COM object vtable is dereferenced inside the SYSTEM service.
4. Memory corruption → controlled code execution in the service → local
   elevation of privilege.


Attack Vector
--------------------------------------------------------------------
Local.  Any sandboxed or low-privileged Windows Store application that
has access to the public App Broadcasting APIs can interact with the
Broadcast DVR User Service and provoke concurrent setter / getter calls
needed for the race.


Patch Description
--------------------------------------------------------------------
1. Introduced two feature-flag guarded helper classes
   (Feature 2098154810 and Feature 75275577) whose
   GetCachedFeatureEnabledState() functions were added.
2. Added a dedicated critical section at offset +968 in
   BroadcastManager.  All accesses that load, store, or clear the
   vulnerable interface members are now wrapped with
   EnterCriticalSection / LeaveCriticalSection when either new feature
   is enabled.
3. HandleExitBroadcastMode was rewritten to take the same lock before it
   nulls the interface pointers, eliminating another unsynchronized
   Release path.
4. Minor type cleanup (a3 changed to unsigned) and additional defensive
   checks.


Security Impact
--------------------------------------------------------------------
Prior to the update a local attacker could reliably trigger a heap
use-after-free inside a SYSTEM service, leading to arbitrary code
execution in the service context and therefore elevation of privilege.


Fix Effectiveness
--------------------------------------------------------------------
The added critical section provides mutual exclusion, making the
load-AddRef and store-Release sequences atomic with respect to each
other; thus the stale pointer race is removed.  Because the lock is used
consistently in all getters, setters, and shutdown paths, no obvious
remaining UAF window was observed in the patched diff.  The mitigation
is however gated behind runtime feature flags; the fix is effective only
when the corresponding features are enabled on the target build.

