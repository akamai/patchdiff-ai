{'patch_store_uid': '8372ab7b-63c5-464e-9600-988f592dd1ca', 'change_count': 1, 'date': 1763409821.848465, 'cve': 'CVE-2025-60705', 'file': 'csc.sys', 'confidence': 0.17, 'kb': 'KB5068861'}
--------------------------------------------------------------------
CVE-2025-60705 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Client-Side Caching (CSC) kernel driver (csc.sys).
The vulnerable helper routine is CscRebootRenamepOpenKey(), which
creates/opens the registry key used to store reboot-time file rename
operations.

Vulnerability Class
--------------------------------------------------------------------
Improper Access Control / Insecure default permissions (CWE-284).

Detailed Root Cause Analysis
--------------------------------------------------------------------
CscRebootRenamepOpenKey() is responsible for returning a handle to the
registry location that the CSC driver uses for "reboot rename" state.
Prior to the patch the code built the OBJECT_ATTRIBUTES structure as
follows:

  ObjectAttributes.SecurityDescriptor = NULL
  ObjectAttributes.Attributes        = 0x240   ;
                                            ; OBJ_CASE_INSENSITIVE |
                                            ; OBJ_KERNEL_HANDLE

When the caller requested creation (a3 != 0) the function issued

  ZwCreateKey(KeyHandle, KEY_ALL_ACCESS, &ObjectAttributes, ...)

Because SecurityDescriptor was NULL, the newly-created key received the
default DACL inherited from its parent hive.  On typical Windows
installations the parent path of CSC's parameters is writable by the
local "Authenticated Users" group.  Consequently the new key was
created with a world-writable DACL even though it is later accessed by
the driver with KEY_ALL_ACCESS while executing in the SYSTEM security
context.

An unprivileged local attacker could therefore modify the content of
that key (or pre-create it with malicious data) and influence the
privileged reboot-rename mechanism, ultimately allowing modification or
replacement of arbitrary system files on next boot and escalating to
SYSTEM.

Key data structures / parameters affected
• OBJECT_ATTRIBUTES.SecurityDescriptor – left NULL before the fix.
• AccessMask: 0xF003F (KEY_ALL_ACCESS) – unchanged, but dangerous when
  combined with a weak DACL.
• Disposition – returned as 1 when the key is newly created, allowing
  the caller to detect first-time creation and potentially reset the
  *a4 flag.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Before
ObjectAttributes.Length = 48;
ObjectAttributes.RootDirectory = 0;
ObjectAttributes.Attributes = 576;          // OBJ_KERNEL_HANDLE | CASE_INSENSITIVE
ObjectAttributes.ObjectName = a2;
*(_OWORD *)&ObjectAttributes.SecurityDescriptor = 0; // <- NULL SD
...
return ZwCreateKey(a1, 0xF003F, &ObjectAttributes, 0, NULL, 0, &Disposition);
```

```c
// After (feature flag path)
PVOID Sd = NULL;
...
CscRebootRenamepCreateSecurityDescriptor(&Sd); // builds restricted SD
ObjectAttributes.SecurityDescriptor = Sd;      // secure DACL
...
NTSTATUS status = ZwCreateKey(KeyHandle, 0xF003F, &ObjectAttributes,
                              0, NULL, 0, &Disposition);
...
if (Sd)
    ExFreePoolWithTag(Sd, 'CrsR');
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User-mode API/IOCTL asks CSC to schedule a file rename at reboot.
2. CSC.sys calls CscRebootRenamepOpenKey(&hKey, Path, Create=TRUE, ...).
3. Old code creates the registry key with NULL security descriptor.
4. Key inherits permissive ACL; attacker can write arbitrary values.
5. On reboot CSC processes the registry values with SYSTEM rights and
   performs file operations specified by attacker, leading to
   privilege escalation.

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker.  By racing or predicting the moment the
CSC driver creates its reboot-rename registry key, or by pre-creating
it with a loose DACL, the attacker can freely modify the data the
kernel later interprets, enabling elevation of privilege.

Patch Description
--------------------------------------------------------------------
The patch introduces two changes:
1. When the internal feature gate
   Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage() is active and the
   caller requests creation (a3!=0), the driver now:
   • Builds a dedicated security descriptor via
     CscRebootRenamepCreateSecurityDescriptor().
   • Supplies the SD in OBJECT_ATTRIBUTES.SecurityDescriptor when
     calling ZwCreateKey().
   • Frees the SD after use with ExFreePoolWithTag().
2. All other logic remains identical, preserving behaviour for open vs
   create while ensuring the key receives a hardened DACL.

Security Impact
--------------------------------------------------------------------
Prior to the fix, any local user could gain write access to a registry
key later processed with SYSTEM privileges, allowing arbitrary file
writes or replacements during reboot and resulting in full elevation of
privilege.  The vulnerability is therefore classified as Local EoP.

Fix Effectiveness
--------------------------------------------------------------------
Providing an explicit, restrictive security descriptor on creation
eliminates inheritance of weak ACLs and prevents non-privileged writes.
The added free prevents a potential memory leak.  The mitigation is
robust as long as the feature gate is enabled on supported builds; if
the gate is disabled the legacy vulnerable path is still present.
Deploying the patch therefore fully addresses the issue for default
configurations.

