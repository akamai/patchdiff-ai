{'confidence': 0.25, 'file': 'mpssvc.dll', 'cve': 'CVE-2025-54915', 'kb': 'KB5065426', 'date': 1757853991.4943757, 'patch_store_uid': '55be8ad8-5a68-4e61-9274-e927d121c45f', 'change_count': 45}
--------------------------------------------------------------------
CVE-2025-54915 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Defender Firewall Service (mpssvc.dll).  Faulty
logic resides in the helper routines that compute the intersection of
user-supplied IP range lists with the local interface list:

  • FwIntersectV4RangesAndLocalIPs()
  • FwIntersectV6RangesAndLocalIPs()

These routines are called while the firewall engine (running as
NT\SYSTEM) validates and stores policy objects that can be provided
through documented, authenticated management APIs.


Vulnerability Class
--------------------------------------------------------------------
Type confusion / memory corruption (CWE-843).  An internal structure
is used as if it contained more elements than were actually written,
causing subsequent consumers to treat unrelated memory as struct
_fw_IPv[46]_RANGE objects.


Detailed Root Cause Analysis
--------------------------------------------------------------------
Both IPv4 and IPv6 helper functions receive two in-place editable
structures:

  struct _tag_FW_IPVx_RANGE_LIST
  {
      DWORD  Count;            // number of valid range entries
      <ranges>[Count]          // FW_IPVx_RANGE (8 or 32 bytes)
  };

Parameters:
  a1 – caller-supplied range list (policy object)
  a2 – list of local interface addresses

The algorithm copies every overlapping range into *both* buffers while
walking them in lock-step.  Because the write happens in the very same
memory area (no new allocation), two counters have to be updated so
that later code knows the real element count in each list.

Bug before patch
----------------
At the end of the loop only the first structure’s Count field was
updated:
    *(_DWORD *)a1 = v5;            // new count
    // ***  a2->Count left unchanged  ***

Moreover, the loop index that controlled writes into a2 (v6) was
incremented unconditionally, but the outer index (v4/i) –the value
finally stored back into a1– lagged behind when no overlap was found.
This produced two inconsistent views:

  • memory from a2 now contains up to v6 valid FW_IPVx_RANGE elements
    but a2->Count still advertises the original (bigger) value;
  • spare memory beyond the last valid element is uninitialised but
    will later be consumed as FW_IPVx_RANGE records.

Any later routine iterating over a2->Count therefore reads or writes
past the legitimate array and operates on attacker-controlled data of
an unexpected type.  Because the structures are embedded in larger
policy blobs, this turns into a classic type confusion and enables
arbitrary memory corruption inside the firewall service process.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// IPv6 – before patch
...
  for (...) {
      ...
      if (v8 == 1)
          ++v6;            // v6 is write-index for a2
  }
  *(_DWORD *)v2 = v6;      // a1->Count fixed
  // a2->Count never updated – stale value
```

```c
// IPv6 – after patch
  ...
  *(_DWORD *)v2 = v4;      // real count for a1
  *(_DWORD *)a2 = v6;      // real count for a2 (new line)
```

Analogous corrections were made for the IPv4 variant.
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Management client (administrator or service) submits a firewall
   rule that contains large, crafted IPv4/IPv6 address ranges.
2. Firewall engine calls FwIntersectVxRangesAndLocalIPs() while
   validating the rule.
3. Intersection routine corrupts a2->Count, leaving it larger than the
   real number of elements.
4. Subsequent code iterates over the stale count and treats out-of-
   bounds memory as FW_IPVx_RANGE objects (type confusion).
5. Controlled corruption of heap data structures running in the
   mpssvc.exe process leads to elevation of privilege.


Attack Vector
--------------------------------------------------------------------
Local attacker with permission to create or modify firewall rules
(e.g., a service with SERVICE_CHANGE_CONFIG, or an admin in a locked-
 down environment) submits a specially crafted rule containing address
ranges designed to mis-size the second list.  No code execution
primitives are needed in kernel mode; exploitation happens entirely in
the user-mode service but results in SYSTEM privileges.


Patch Description
--------------------------------------------------------------------
1. Added independent counters for the two range lists (v4/v6 vs
   v6/v7) and updated both Count fields at function exit.
2. Re-organised inner loops so that the write-index is incremented only
   when an actual overlap is recorded.
3. Similar fixes ported to IPv4 helper.
4. Ancillary hardening: assertions and feature-flagged clean-up in
   FwFreeBlobRepos() and FwLoadBlobsRepos(), preventing stale pointers
   and memory leaks uncovered during investigation.


Security Impact
--------------------------------------------------------------------
Before the patch, a non-privileged but authenticated user could cause
mpssvc.exe to perform out-of-bounds reads/writes on the heap, leading
to memory corruption.  Because the service runs as LocalSystem, a
successful attacker can execute arbitrary code with SYSTEM privileges
(local elevation of privilege).


Fix Effectiveness
--------------------------------------------------------------------
The corrected code guarantees that:
  • both list headers always contain the true element count;
  • loop indices never exceed the respective Count values;
  • callers can no longer be fooled into reading uninitialised memory.

The additional assertions and feature-gated frees ensure that related
blob-repository structures remain consistent, further reducing exploit
surface.  No residual path to the original mis-sized access remains
observable in the patched binary.
