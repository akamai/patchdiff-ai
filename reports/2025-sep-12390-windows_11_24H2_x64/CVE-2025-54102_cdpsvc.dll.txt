{'patch_store_uid': '54651f9d-0a4a-4127-94ff-0b67ec0d88ed', 'change_count': 45, 'date': 1757843375.730008, 'confidence': 0.13, 'cve': 'CVE-2025-54102', 'file': 'cdpsvc.dll', 'kb': 'KB5065426'}
--------------------------------------------------------------------
CVE-2025-54102 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Connected Devices Platform Service (cdpsvc.dll) – Boost
thread-specific-storage (TSS) helpers

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use After Free (UAF)

Detailed Root Cause Analysis
--------------------------------------------------------------------
cdpsvc is linked with a private copy of Boost.  When a worker thread
terminates, Boost calls
boost::_anonymous_namespace_::run_thread_exit_callbacks() to destroy all
per-thread TSS objects and free the owning structure ‘tss_data’.  The
routine performs the following actions:
1. obtains the current thread’s tss_data from TLS index dwTlsIndex
2. walks two intrusive lists (callbacks and map entries), invoking the
   registered destructors and HeapFree()-ing each element
3. once the lists are empty, the tss_data reference count is checked and
   the whole structure itself is freed with HeapFree()
4. finally it calls boost::call_once(&unk_1800D0F58,
   create_current_thread_tls_key)

The problem is the order of steps 3 and 4.  create_current_thread_tls_key
is responsible for allocating *another* TLS entry and registering the
very same run_thread_exit_callbacks as that entry’s destructor.  Because
call_once may execute the supplied function the *first* time it is seen,
it can run *after* the original tss_data has already been freed.  The
callback that is registered inside create_current_thread_tls_key now
holds a dangling pointer to the just-freed tss_data.  Any subsequent
thread-exit event (or even a re-entrancy in the same thread) will make
cdpsvc call into this invalid memory, leading to a classic UAF.

Parameters / structures involved
• volatile signed int *tss_data  – per-thread structure, freed with
  HeapFree()
• dwTlsIndex                     – global TLS index that stores
  tss_data
• once_flag unk_1800D0F58        – Boost one-time initialisation guard
• create_current_thread_tls_key  – allocates a new TLS slot and
  re-registers run_thread_exit_callbacks()

The fault is therefore a missing guard against executing
create_current_thread_tls_key while the owning tss_data is already being
or has been released.

Vulnerability Code Snippets
--------------------------------------------------------------------
Before patch
```c
boost::call_once(
    (struct boost::once_flag *)&unk_1800D0F58,
    boost::_anonymous_namespace_::create_current_thread_tls_key);
...
HeapFree(v6, 0, (LPVOID)Value); // frees tss_data
```
After patch
```c
boost::call_once(
    (struct boost::once_flag *)&unk_1800C8F58,
    boost::_anonymous_namespace_::create_current_thread_tls_key,
    a3);                     // new context argument
```
A new third argument (a3) is threaded down from the caller and a *new*
one-time flag is used.

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Service spawns a worker thread that uses Boost TSS.
2. Thread exits –> NtTerminateThread triggers on_thread_exit().
3. on_thread_exit() -> run_thread_exit_callbacks().
4. Function destroys all TSS objects and HeapFree()s the tss_data.
5. Still inside the same routine, boost::call_once executes
   create_current_thread_tls_key() for the *first* time.
6. That helper re-registers run_thread_exit_callbacks() using the
   pointer to the *already freed* tss_data structure -> UAF.
7. Next thread-exit or re-entrancy dereferences freed memory, yielding
   arbitrary code execution in the cdpsvc (SYSTEM) context.

Attack Vector
--------------------------------------------------------------------
local attacker induces the service to create and terminate threads that
use Boost TSS (for example via normal CDP APIs).  By controlling the
heap state between free and reuse the attacker can place malicious data
at the freed address and hijack control flow.

Patch Description
--------------------------------------------------------------------
1. run_thread_exit_callbacks() and its thunk on_thread_exit() now accept
   an additional context parameter (void *a3).
2. The once flag address changed from unk_1800D0F58 to unk_1800C8F58,
   indicating a distinct initialisation path for the new logic.
3. The extra parameter is forwarded to boost::call_once().  That version
   of call_once stores the context and *does not* attempt to create a
   new TLS key when invoked from inside thread-destructor context,
   eliminating the re-entrancy that produced the dangling pointer.
   No other behavioural changes were observed.

Security Impact
--------------------------------------------------------------------
Prior to the fix an attacker could trigger a use-after-free in a SYSTEM
service, allowing arbitrary code execution and therefore elevation of
privilege from an unprivileged account.

Fix Effectiveness
--------------------------------------------------------------------
The additional context parameter separates the initialisation path taken
while a thread is still alive from the path taken during its destructor.
Because create_current_thread_tls_key can now detect the destructor
context, it refrains from registering a second callback that references
freed memory.  The once flag was also replaced, ensuring that any legacy
state cannot be reused.  Combined, these changes fully block the
original UAF scenario and appear sufficient, assuming all other callers
supply the new parameter.
