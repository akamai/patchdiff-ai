{'cve': 'CVE-2025-54104', 'file': 'mpssvc.dll', 'patch_store_uid': '55be8ad8-5a68-4e61-9274-e927d121c45f', 'change_count': 45, 'kb': 'KB5065426', 'confidence': 0.11, 'date': 1757854094.416801}
--------------------------------------------------------------------
CVE-2025-54104 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Defender Firewall Service (mpssvc.dll)
BLOB repository / container management code that maintains the in-
memory rule databases (FwFreeStore, FwFreeBlobRepos, FwLoadBlobsRepos
and helper routines).

Vulnerability Class
--------------------------------------------------------------------
Type confusion (CWE-843) that results in controlled kernel-pool
corruption which can be leveraged to obtain local elevation of
privilege.

Detailed Root Cause Analysis
--------------------------------------------------------------------
Each firewall rule is stored in a _tag_FW_BLOB_RULE_CONTAINER object
which is threaded into a doubly-linked list headed by the
_tag_FW_BLOB_REPO structure.  The list links (Flink/Blink) live
inside the container **after** a 16-byte header.  Helper
FwFreeBlobRepos() understands this layout and frees a container by

 1. reading the list entry (*(repo+0) / *(repo+8)),
 2. computing the real container address (Entry – 0x10),
 3. passing *(Container) to FwFreeBlobs(),
 4. finally calling FwFree(Container).

FwFreeStore() originally re-implemented the same walk-and-free logic
four separate times (for different repos at offsets 0,24,48,72 inside
the store object).  That duplicate code contained a **layout
mismatch**:

    v6 = *(QWORD *)(Head+8);   // points to list entry
    v8 = v6 - 2;               // assumes entry is at +0x10
    ...
    FwFree(v8);                // free                    (1)

For some repository types the list entry *is already* at the start of
the container, therefore subtracting 0x10 converts the valid address
into the middle of a **different** object.  When the service later
invoked FwFree(v8) (1) the kernel freed the wrong allocation class
while the original container stayed reachable by other code paths.
Subsequent accesses operate on memory that might now belong to a
different pool allocation – classic type confusion / use-after-free.

Attackers able to load or modify a firewall store (e.g. via local
policy APIs) can craft a repository that leads FwFreeStore() down the
erroneous branch, giving them arbitrary kernel pool corruption under
SYSTEM context and therefore elevation of privilege.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// FwFreeStore – vulnerable fragment (before)
while (*(_QWORD*)a2 != a2) {
    v6 = *(_QWORD**)(a2 + 8);  // list entry
    ...
    v8 = v6 - 2;               // WRONG for some repos
    ...
    FwFree(v8);                // frees wrong object
}

// FwFreeStore – fixed fragment (after)
FwFreeBlobRepos((FW_BLOB_REPO*)a2,        1, 0);
FwFreeBlobRepos((FW_BLOB_REPO*)(a2 + 24), 1, 1);
FwFreeBlobRepos((FW_BLOB_REPO*)(a2 + 48), 1, 2);
FwFreeBlobRepos((FW_BLOB_REPO*)(a2 + 72), 1, 1);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Low-priv code injects / modifies a firewall store on disk.
2. Windows Defender Firewall Service loads the store and later calls
   FwFreeStore() (e.g. service restart or policy reload).
3. During clean-up the duplicated loop in FwFreeStore subtracts 0x10
   from the first list entry belonging to a crafted repository.
4. FwFree() is invoked on an address that is not the start of the
   allocation => kernel pool corruption.
5. Attacker-controlled data written into the reclaimed memory grants
   arbitrary code execution in the mpssvc service (SYSTEM).  A SYSTEM
   token can then be duplicated to fully elevate the local user.

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker who can call the documented firewall
configuration APIs (INetFwPolicy2 / WFP BFE APIs) or directly replace
policy files under %SystemRoot%\System32\wfp\.*. No administrator
rights are required – only the ability to add firewall rules for the
current profile.

Patch Description
--------------------------------------------------------------------
1. Removed all hand-rolled list-freeing loops from FwFreeStore() and
   replaced them with calls to the single, hardened
   FwFreeBlobRepos() helper.
2. In FwFreeBlobRepos():
   • Corrected structure-offset use (no blind –0x10 arithmetic when
     reading flags).
   • Added extra defensive assertion on offset +0x140 (320) instead
     of +0x150 (336).
   • When feature flag *Firewall_BugFixes_25D_Memory_leak_*
     is enabled the routine also frees the optional blob array at
     offset +0x118 (280).
3. In FwLoadBlobsRepos():
   • Fixed formal type of the repository parameter and updated all
     list manipulations to use explicit offsets rather than pointer
     aliasing.
   • Added optional early call to FwFreeBlobRepos() as a fall-back to
     ensure no containers are leaked.
4. Additional telemetry points were updated but have no functional
   security impact.

Security Impact
--------------------------------------------------------------------
Prior to the patch, incorrect pointer arithmetic caused FwFreeStore()
to pass an *incompatible* object type to FwFree().  A crafted rule set
could therefore:
 • free the wrong allocation
 • leave the legitimate container active
 • later let the service reuse the freed memory as a different type
This type confusion permits controlled kernel-pool corruption and
hence local elevation of privilege (SYSTEM).  Remote impact is not
possible because the vulnerable code runs only in local policy
contexts.

Fix Effectiveness
--------------------------------------------------------------------
By centralising all container disposal in FwFreeBlobRepos(), using
well-defined structure offsets, the patch removes the conflicting
assumptions that caused the confusion.  Additional asserts and the
optional memory-leak feature flag provide defence-in-depth.  No
remaining code paths subtract a hard-coded 0x10, therefore the root
cause is convincingly eliminated, although full protection depends on
all callers using the helper correctly – a dedicated regression suite
is recommended.
