{'patch_store_uid': '39e8eb88-5045-4fd8-bb20-53978eb2c087', 'change_count': 10, 'file': 'win32k.sys', 'kb': 'KB5065426', 'cve': 'CVE-2025-54919', 'date': 1757853829.0405438, 'confidence': 0.19}
--------------------------------------------------------------------
CVE-2025-54919 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows win32k.sys – Graphics / Session-management call-out
layer (W32SessionAttachAndCalloutDispatch, W32CalloutDispatchThunk and
helpers).

Vulnerability Class
--------------------------------------------------------------------
Race condition (CWE-362) that leads to use-after-free / stale function
pointer dereference and ultimately arbitrary kernel-mode code
execution.

Detailed Root Cause Analysis
--------------------------------------------------------------------
At the centre of win32k’s "call-out" infrastructure is the routine
W32SessionAttachAndCalloutDispatch().  For request code 44 it looked up
an arbitrary session, entered that session’s process, and executed a
function pointer that lives inside the per-session WIN32KSESSIONSTATE
table:

   state  = W32GetSessionStateForSession(SessionId);
   proc   = state->KernelCalloutTable->Dispatch;
   (*proc)(Arg1,Arg2,Arg3);

Prior to the patch the code performed this sequence without holding any
synchronisation primitive that guarantees the lifetime of either the
session state object or the target process :

1.  No push-lock was held while the process reference returned by
    W32GetReferencedSessionProcessWithTag() was being used.
2.  The function pointer was fetched and invoked outside any lock – the
    table could be freed or re-initialised concurrently.
3.  The helper W32GetReferencedSessionProcessWithTag() itself only
    returned a _KPROCESS pointer; it did **not** return/retain the
    corresponding session state, so the caller had no way to keep that
    memory alive.

Because gLock / gSessionProcessLifetimeLock were dropped between the
lookup and the dereference, a racing thread that terminates the session
(or re-initialises gSessionGlobalSlots after a logoff) can make the
pointer refer to freed pool memory.  A local attacker can then reclaim
this memory with controlled data and have win32k dereference it in
kernel context, achieving arbitrary-code execution.

The same missing-lock pattern existed in several helpers (e.g.
W32AttachToSessionAndExecute__lambda_3f4683…, NtUserBuildHwndList,
NtUserBuildHimcList, ApiSetpResolveHost) which all copied the same
unsafe session-state dereference logic.

Structures / fields affected:
  • gSessionGlobalSlots[] / gLowSessionGlobalSlots (pointer array)
  • _tagWIN32KSESSIONSTATE.KernelCalloutTable + 0x10 / 0x30 / …
  • gLock / gSessionProcessLifetimeLock (missing or dropped too early)
  • Argument structure at a3 for request 44 (mode 1 / 2 selector)

The bug is purely a time-of-check vs time-of-use gap – no bounds or type
checks were missing; the state simply went away while the pointer was
still in use.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – W32SessionAttachAndCalloutDispatch (mode 1 path)
v7  = GetCurrentProcessSessionId();
v8  = *(PFN)(*(_QWORD *)(*(_QWORD *)(
          W32GetSessionStateForSession(v7)+0x88) + 0x18) + 0x10);
if (v8)
    return v8(a1, a2, a3);   // <--- no lock, session may be gone
```
```c
// before patch – W32GetReferencedSessionProcessWithTag
ExAcquirePushLockSharedEx(&gLock,0);
state = W32GetUserGdiSessionStateForSession(id);
// 'state' is read, but the function returns only the KPROCESS pointer –
// caller loses the reference as soon as the lock is released.
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker thread calls a syscall that reaches
   W32CalloutDispatchThunk().
2. Thunk issues request code 44 -> W32SessionAttachAndCalloutDispatch().
3. Function fetches session state & call-out pointer without lock.
4. Second attacker thread triggers session logoff / destruction so that
   the session state is freed.
5. Original thread executes the now-dangling function pointer -> EoP /
   kernel RCE.

Attack Vector
--------------------------------------------------------------------
Local, authenticated user code.  Any process that can issue win32k
syscalls (e.g. via GDI/User APIs) can create the racing threads and
control the freed memory.

Patch Description
--------------------------------------------------------------------
1. W32SessionAttachAndCalloutDispatch fully rewritten:
   •  Introduces tight critical-region windows and shared push-locks
      (gLock) while walking gSessionGlobalSlots.
   •  Keeps the lock until after the target function pointer has been
      *called* or a reference is explicitly held.
   •  Adds rigorous NULL / session-existence tests and returns
      STATUS_PROCEDURE_NOT_FOUND when the pointer is absent.
   •  Iterates safely over all sessions when mode == 2.

2. W32GetReferencedSessionProcessWithTag gains a third parameter that
   returns a referenced pointer to the session state, ensuring the
   memory is retained as long as the caller needs it.

3. All helper lambdas (…_2da4d1…, …_6eea85…) now call the revised helper
   and keep the process attached only while the session lock is held.

4. High-level thunks (NtUserBuildHwndList, NtUserBuildHimcList,
   W32CalloutDispatchThunk, etc.) were updated to fetch the per-session
   function pointers only after validating that the corresponding slot
   exists.

5. Several code paths add feature-gating checks
   (RtlQueryFeatureConfiguration) and explicit STATUS_NOT_IMPLEMENTED
   fall-backs.

Security Impact
--------------------------------------------------------------------
Prior to the fix an attacker could reliably cause win32k to call a
function pointer that points into attacker-controlled pool memory,
leading to arbitrary execution in the kernel (privilege escalation or
remote code execution via a graphical session such as RDP).  The issue
is rated as "Remote Code Execution" because the vulnerable code is
reachable through graphics APIs exposed over Remote Desktop / Remote
App sessions.

Fix Effectiveness
--------------------------------------------------------------------
The new implementation keeps either a push-lock or an explicit object
reference for the entire lifetime of the session data being used, and
verifies the presence of every function pointer before invocation.
This removes the TOCTOU window and makes it infeasible to race the
pointer.  No remaining unprotected dereferences were observed in the
modified code paths, suggesting the fix is comprehensive, though other
untouched call-sites must still obey the new contract of
W32GetReferencedSessionProcessWithTag().
