{'change_count': 25, 'date': 1757843800.4766874, 'kb': 'KB5065426', 'cve': 'CVE-2025-53802', 'patch_store_uid': '6bbd1ebb-0832-4b00-aa09-70baf89db1ad', 'confidence': 0.52, 'file': 'bthserv.dll'}
--------------------------------------------------------------------
CVE-2025-53802 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Bluetooth Service (bthserv.dll) â€“ internal helper class
SdpStack used during SDP (Service Discovery Protocol) parsing.

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use After Free

Detailed Root Cause Analysis
--------------------------------------------------------------------
SdpStack is a grow-able LIFO container that keeps traversal state
(_tag, _SDP_NODE *, LIST_ENTRY *) in 24-byte records.  The object
layout (64-bit) is effectively:
   +0x00 QWORD  EntryCount      ; number of valid elements
   +0x08 QWORD  pTop            ; pointer to first free slot
   +0x10 QWORD  pBase           ; pointer to beginning of buffer
   +0x18 QWORD  pStaticBuffer   ; pointer to small static buffer
   +0x20 DWORD  Capacity        ; number of records that fit

When Push() detects that the stack is full it allocates a new buffer
(double size), copies existing entries, updates the object pointers
and frees the old heap buffer with MIDL_user_allocate_0().  The buggy
implementation (pre-patch) executed the free *before* eliminating all
other references to the old allocation:

1. pTop was copied into a local (this[1]) **before** reallocation.
2. New memory was allocated and pTop was advanced into the *new*
   buffer, but the local alias still pointed inside the *old* buffer.
3. The old buffer was freed.
4. The function continued to use the stale local alias when the record
   was written, resulting in a write into freed memory.

If an attacker could cause the heap to be reused between steps 3 and
4, controlled data would be written into an arbitrary kernel pool
object, giving a classic pool-based UAF.

The additional, cosmetic feature-flag gating in the old version masked
this behaviour for some configurations, so the bug manifested only
when Feature_1723606328 was *disabled* (the common production case).

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// pre-patch excerpt (simplified)
if (this[1] == (char*)this[2] + 24 * Capacity) {
    v9 = MIDL_user_allocate_1(24 * 2 * Capacity);
    memcpy(v9, this[2], 24 * Capacity);
    this[1] = &v9[24 * Capacity];     // pTop -> new buffer
    v11 = (size_t)this[2];            // old buffer ptr
    if ((void*)v11 != this[3])
        MIDL_user_allocate_0(v11);    // FREE OLD BUFFER
    this[2] = v9;                     // pBase -> new buffer
    ...
}
*(_DWORD*)this[1] = Tag;              // write via STALE this[1]
*((_QWORD*)this[1] + 1) = pNode;
*((_QWORD*)this[1] + 2) = pList;
```

```c
// patched excerpt
v6 = (char*)*((QWORD*)this + 1);      // take fresh pTop
...
MIDL_user_allocate_0(oldBase);        // free old buffer
v6 = (char*)*((QWORD*)this + 1);      // REFRESH POINTER
*(DWORD*)v6       = Tag;              // write into valid memory
*(QWORD*)(v6 + 8) = pNode;
*(QWORD*)(v6 +16) = pList;
*((QWORD*)this +1)+=24;
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User mode supplies a crafted SDP record -> bthserv parses it ->
BthQueryRemoteServices() -> internal parser creates SdpStack instance
-> repeated Push() calls while traversing attacker-controlled data
-> buffer grows -> reallocation path triggers UAF -> arbitrary pool
overwrite -> privilege escalation within bthserv (runs as LocalSystem).

Attack Vector
--------------------------------------------------------------------
Local attacker with the ability to issue Bluetooth SDP queries to the
host (for example by running in a standard user context with Bluetooth
access) sends specially crafted, deeply nested SDP data that forces the
service to grow the stack.

Patch Description
--------------------------------------------------------------------
The update fixes pointer lifetime management in SdpStack::Push():
1. Re-typed the object pointer so the compiler treats it as mutable.
2. Stores the new pTop in a temporary *after* the old buffer is
   released, ensuring no stale alias survives the free.
3. Removes dual code paths gated by Feature_1723606328, eliminating the
   configuration in which the stale pointer was used.
4. Minor clean-ups of variable types to 64-bit safe forms.

Security Impact
--------------------------------------------------------------------
Prior to the patch, a local attacker could reliably obtain an arbitrary
kernel pool write primitive from user mode, leading to elevation of
privilege to SYSTEM.  The bug is exploitable without crashing the OS
because the freed block is immediately re-used by subsequent kernel
allocations.

Fix Effectiveness
--------------------------------------------------------------------
The refreshed pointer after the free eliminates the dangling alias, so
no writes are performed on freed memory.  Independent code review of
all write sites in Push() shows they now reference the up-to-date pTop
value.  No remaining path frees the buffer while outstanding aliases
exist, so the UAF condition is closed.
