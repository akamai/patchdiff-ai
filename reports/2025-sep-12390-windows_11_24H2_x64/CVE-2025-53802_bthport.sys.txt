{'patch_store_uid': '756030a2-be7b-4bcc-b9d7-15668181f7d5', 'change_count': 11, 'cve': 'CVE-2025-53802', 'kb': 'KB5065426', 'confidence': 0.26, 'file': 'bthport.sys', 'date': 1757843768.2435308}
--------------------------------------------------------------------
CVE-2025-53802 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows kernel-mode Bluetooth driver (bthport.sys)
AdvertisingRequestControllerModule and related helper classes that
manage per-client advertising-request state.

Vulnerability Class
--------------------------------------------------------------------
Use-After-Free (CWE-416)

Detailed Root Cause Analysis
--------------------------------------------------------------------
•  Every user-mode handle to the Bluetooth device is represented in
   the kernel by a WDFFILEOBJECT structure.  Advertising requests are
   tracked per file object.

•  Prior to the patch the object at offset +816 in
   AdvertisingRequestControllerModule was uninitialised.  Several
   helper routines (utl::_HashTable<WDFFILEOBJECT* …>) expected this
   field to be a doubly-linked list / hash bucket that maps a
   WDFFILEOBJECT* to a vector<AdvertisingRequestProgrammer::
   IrkRefCountToken>.

•  Because the constructor did not initialise the spin-lock or list
   head, and OnFileObjectCleanup(FileObject const &) was entirely
   missing, entries associated with a closing file handle were never
   removed.  After the user closed the handle the corresponding
   WDFFILEOBJECT was freed by the framework, but pointers to that
   object remained inside the global hash table.

•  Later operations (e.g. generation of new advertising addresses in
   AdvertisingRequestProgrammer::GetNewAddress) iterate this table,
   dereference the stale WDFFILEOBJECT pointer and pass it further
   down the stack.  At this point the memory is already under control
   of the pool allocator, allowing an attacker to reuse it and obtain
   arbitrary kernel-memory access.

•  The access happens in an arbitrary context (often DPC) and runs in
   kernel mode, enabling escalation from normal user privileges to
   SYSTEM.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// old constructor – critical fields left uninitialised
*((_QWORD *)this + 97) = 0;        // spinlock never set
*((_QWORD *)this + 101) = 0;       // list head garbage
...

// new constructor – proper initialisation
KeInitializeSpinLock((PKSPIN_LOCK)this + 101);
*((_QWORD *)this + 102) = (char*)this + 816; // fwd link
*((_QWORD *)this + 103) = (char*)this + 816; // back link
*((_WORD *)this + 424) = 2048;               // hash flags
```

```c
// new OnFileObjectCleanup()
wil::acquire_kspin_lock(v8, this+808);
...
find(this+816, &v12, &m_Object);
if (v12 != this+816) {
   vector::operator=(local_copy, v12+32); // copy out
   erase(this+816, &m_Object, v12);       // unlink entry
}
release_lock();
_RangeDestroyApc(..., local_copy);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User opens handle to  "\\.\BthLEDevice" (or similar).
2. Sends IOCTL 0x4112D8 (4264680 – periodic advertising request) or
   the newer 0x4112EC (4264708 – generate advertising address).
3. Driver allocates entry in internal hash table that references the
   WDFFILEOBJECT.
4. User closes the handle; Framework frees the WDFFILEOBJECT.
5. Because old driver lacks cleanup, the pointer stays in the table.
6. Any later advertising operation traverses the table and touches the
   freed memory – use-after-free occurs in kernel context.

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker.  Requires opening a Bluetooth device
handle, sending specific IOCTLs, then closing the handle while
triggering a second Bluetooth action.  No special privileges are
needed beyond the ability to communicate with the Bluetooth device
interface.

Patch Description
--------------------------------------------------------------------
1. Constructor now initialises a spin lock and properly anchors the
   WDFFILEOBJECT->token hash list; flags set to 0x800 to mark list as
   circular.
2. Added fully-featured
   AdvertisingRequestControllerModule::OnFileObjectCleanup() which:
   • acquires module spin lock
   • finds the hash-table node matching the closing WDFFILEOBJECT
   • copies and destroys the associated vector while holding no lock
   • erases the node and releases the lock.
3. Destructor walks the remaining list under the same lock and frees
   any still-allocated nodes, preventing leaks and future UAF.
4. GetNewAddress() and RequestForNewRandomAddress() were rewritten to
   use IrkRefCountToken helpers that maintain their own lifetime,
   removing more raw pointer usage.

Security Impact
--------------------------------------------------------------------
The stale pointer dereference allowed controlled pool reuse leading to
arbitrary kernel memory access and ultimately elevation of privilege
from the caller to NT AUTHORITY\SYSTEM (ring-0).  The issue is
therefore an EoP in the Windows Bluetooth service.

Fix Effectiveness
--------------------------------------------------------------------
The patch: (a) guarantees that the per-fileobject entry is removed on
cleanup, (b) introduces proper locking and list initialisation, and
(c) frees any residual entries in the destructor.  These corrections
eliminate dangling references and make a post-close dereference
impossible, effectively fixing the UAF.

