{'file': 'win32kfull.sys', 'cve': 'CVE-2025-55224', 'change_count': 633, 'date': 1757843993.998181, 'kb': 'KB5065426', 'confidence': 0.13, 'patch_store_uid': 'b3952593-9f8c-45cf-b9b4-2e0e409c0bb2'}
--------------------------------------------------------------------
Unknown-CVE Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
win32kfull.sys –  several window-manager system-call handlers (e.g.
SfnINOUTLPPOINT5, SfnINOUTLPRECT, SfnINOUTLPWINDOWPOS, SfnINOUT
LPSCROLLINFO, SfnINLPDELETEITEMSTRUCT, NtUserfnTOUCHHITTESTING, etc.)

Vulnerability Class
--------------------------------------------------------------------
CWE-362  Race Condition (TOCTOU on user buffers)
CWE-416  Use-After-Free / invalid pointer dereference (derived)

Detailed Root Cause Analysis
--------------------------------------------------------------------
Prior to the patch a family of win32k system-call helpers copied
structures supplied from user mode by performing a single ProbeForRead
(or ProbeForWrite) and then dereferencing the user pointer *after the
probe*, very often outside the thread’s win32k critical section.  The
sequence was generally: 

 1. ProbeForRead/Write(struct, sizeof …)
 2. Leave crit / release locks
 3.  *dereference the same user pointer* to build internal objects or
    to return data to user mode

Because the memory is still owned by user mode, a racing thread in the
same process can re-map or free the page(s) between steps (1) and (3).
When step (3) executes, kernel code operates on attacker-controlled or
invalid memory, allowing information disclosure or arbitrary pointer
reads / writes that ultimately lead to privilege escalation or remote
code execution in the kernel.

Examples from the diff (old code):
   v12 = *(_OWORD **)(v17 + 16);
   if ( v12 + 2 < v12 || (unsigned __int64)(v12 + 2) > MmUserProbeAddress )
       v12 = (_OWORD *)MmUserProbeAddress; // range check only
   v13 = v12[1];                          // dereference user page

The patch introduces a new helper RtlCopyFromUser() that explicitly
copies the user buffer into a kernel stack buffer *before* the thread
releases the critical section.  All vulnerable call sites were
rewritten to:

  • allocate fixed stack storage
  • call RtlCopyFromUser(dst, user_ptr, size)
  • operate only on the kernel copy

Affected structures/parameters include:
  − tagPOINT / tagRECT
  − tagWINDOWPOS
  − SCROLLINFO
  − DELETEITEMSTRUCT
  − TOUCH_HIT_TESTING_INPUT
  − arbitrary 0x64-byte buffer in NtUserSetDesktopColorTransform

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before (SfnINOUTLPPOINT5)
v20 = (_QWORD *)(v28 + 16);
if ( v20 + 5 < v20 || (ULONG_PTR)(v20 + 5) > MmUserProbeAddress )
    v20 = (_QWORD *)MmUserProbeAddress;
*(_OWORD*)a4 = *(_OWORD*)v20;   // user memory still live
```

```c
// after
__int128 tmp = 0;
RtlCopyFromUser(&tmp, (void*)user_ptr, 0x20);
*(__int128*)a4 = tmp;           // safe – kernel copy
```
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker calls one of the affected win32k system calls supplying a
   pointer P inside a user-writable page.
2. Kernel probes P, returns to user mode (e.g. via KeUserModeCallback)
   or leaves the win32k crit-section.
3. Attacker replaces, frees or remaps the page backing P.
4. Kernel later dereferences P believing it is still trustworthy,
   leading to a controlled read/write or use-after-free → code exec.

Attack Vector
--------------------------------------------------------------------
Local, low-privileged code in a GUI session.  No special permissions are
needed beyond owning a window / thread able to invoke the affected
syscalls.

Patch Description
--------------------------------------------------------------------
1. Added a new wrapper RtlCopyFromUser() that combines ProbeForRead with
   an immediate memcpy into kernel storage.
2. Replaced all direct user-pointer dereferences with copies into
   fixed-size stack buffers.
3. Where nested pointers were returned from user mode (e.g. via
   KeUserModeCallback) the code now copies those secondary buffers with
   RtlCopyFromUser before use.
4. Several helper routines (ProbeForRead_0, PWInsertAfter, etc.) were
   rewritten to use safe helpers (HMValidateHandleNoSecure, etc.).

Security Impact
--------------------------------------------------------------------
Prior to the patch an attacker could win a race to point the kernel at
controlled memory, allowing:
  • Arbitrary kernel memory disclosure or modification
  • Use-after-free on kernel objects
  • Ultimately kernel-mode code execution and full OS compromise

Because many GUI syscalls are reachable from a sandbox, exploitation
can be chained for privilege-escalation or, in RDP / Hyper-V graphics
channels, remote code execution in the host.

Fix Effectiveness
--------------------------------------------------------------------
All affected paths now copy the entire user supplied structure under the
protection of the probe, before any locks are dropped.  No remaining
kernel dereferences of user memory were observed in the patched code.
The race window is thus closed and the vulnerability is fully
mitigated.
