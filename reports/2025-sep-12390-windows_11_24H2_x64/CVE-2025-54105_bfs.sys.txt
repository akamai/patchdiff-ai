{'change_count': 1, 'cve': 'CVE-2025-54105', 'date': 1757843282.4460008, 'file': 'bfs.sys', 'confidence': 0.27, 'patch_store_uid': 'c16f49f0-8062-4a21-8625-6d26d381f253', 'kb': 'KB5065426'}
--------------------------------------------------------------------
CVE-2025-54105 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Brokering File System kernel driver (bfs.sys), routine
BfsCheckAndReleaseIdlePolicy.

Vulnerability Class
--------------------------------------------------------------------
Race condition leading to use-after-free / linked-list corruption
(CWE-362, CWE-416).

Detailed Root Cause Analysis
--------------------------------------------------------------------
BfsCheckAndReleaseIdlePolicy walks the per-device idle-policy list that
begins at (a1 + 0x10).  The list elements are BFS_POLICY_ENTRY
structures whose reference count is stored at offset +0x50 (i + 20).
The list itself is protected by a push-lock located at the object base
(a1).  

Before the patch the routine acquired the lock only in SHARED mode.
While holding this shared lock it:
 1. Traversed each LIST_ENTRY.
 2. Incremented the entry's reference count using
    _InterlockedIncrement.
 3. If the count became 2, rewired the entry's LIST_ENTRY (i+2) so it
    is spliced into a temporary private list (v10).

Because the code modifies the doubly linked list while protected only
by a shared (reader) lock, another thread that simultaneously acquires
an EXCLUSIVE lock may concurrently delete or free the same entry.  The
window between the shared traversal and the subsequent switch to the
exclusive lock (which happens only *after* the shared lock is
released) allows the following interleaving:

 Thread A (vulnerable path)        Thread B (normal deleter)
 ----------------------------------------------------------------
 acquire shared lock
 splice EntryX into v10            acquire exclusive lock
 release shared lock               unlink & free EntryX
 reacquire exclusive lock          release exclusive lock
 dereference EntryX --> UAF

Once thread B frees the object, thread A continues to touch the stale
memory (e.g., second call to BfsDereferencePolicyEntryEx), resulting in
use-after-free, pool corruption, or arbitrary kernel write.  Because
the code path runs in kernel mode, exploitation yields local privilege
escalation.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch (reader lock)
KeEnterCriticalRegion();
ExAcquirePushLockSharedEx(a1, 0);
...
// modify list while only shared
i[3] = (INT64)v11;          // forward link
*(INT64 **)(i+2) = &v10;    // back link
...
ExReleasePushLockSharedEx(a1, 0);
...
KeEnterCriticalRegion();     // now request writer lock
ExAcquirePushLockExclusiveEx(a1, 0);
```
```c
// after patch (new path)
if (FeatureEnabled()) {
    KeEnterCriticalRegion();
    ExAcquirePushLockExclusiveEx(a1, 0);  // writer from the start
} else {
    KeEnterCriticalRegion();
    ExAcquirePushLockSharedEx(a1, 0);     // legacy reader path
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User-controlled workload causes BFS idle-timer to expire.
2. Kernel schedules BfsCheckAndReleaseIdlePolicy.
3. Multiple processors enter the function concurrently.
4. Concurrent list traversal and deletion corrupt shared LIST_ENTRY
   structures, leading to UAF.

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker repeatedly triggers BFS idle-policy
creation and deletion from multiple threads / cores, forcing the race.
No special privileges are required beyond the ability to open the BFS
device interface.

Patch Description
--------------------------------------------------------------------
The fix introduces a feature flag check
Feature_3434922298__private_IsEnabledDeviceUsageNoInline().  When the
flag is enabled the function now:
 1. Acquires the push-lock in EXCLUSIVE mode before the traversal.
 2. Holds that exclusive lock for the entire operation, including list
    modification and dereference phase.
 3. Releases the lock once, at function exit.

In the legacy path (feature disabled) the old behaviour is preserved.

Security Impact
--------------------------------------------------------------------
Prior to the patch a local attacker could obtain arbitrary kernel write
via pool-header reuse, allowing elevation to SYSTEM and possible
sandbox escape.  Stable reproduction leads to full kernel compromise.

Fix Effectiveness
--------------------------------------------------------------------
Using the writer lock from the outset eliminates concurrent mutation of
the LIST_ENTRY, closing the race window and preventing UAF.  The fix is
only active when the feature flag is on; if the flag is disabled the
vulnerable logic remains, so overall effectiveness depends on runtime
configuration (unknown).  No additional correctness issues were
observed in the patched path.
