{'cve': 'CVE-2025-53805', 'change_count': 77, 'confidence': 0.23, 'file': 'http.sys', 'patch_store_uid': 'b0281ae5-a0ca-45e6-8c4d-c6a4f9eace48', 'kb': 'KB5065426', 'date': 1757843504.5378437}
--------------------------------------------------------------------
CVE-2025-53805 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
HTTP.sys kernel driver – request-serialization routines
(UlCopyRequestToBuffer / UlpCopyRequestInformation)

Vulnerability Class
--------------------------------------------------------------------
Out-of-bounds Read caused by use of an uninitialised stack
variable (CWE-125)

Detailed Root Cause Analysis
--------------------------------------------------------------------
When user mode calls HttpReceiveHttpRequest /
HttpQueryRequestQueue the kernel builds a caller-supplied output
buffer that contains a variable number of sub-structures.  The
function chain is
    UlCopyRequestToBuffer() → UlpCopyRequestInformation().

UlpCopyRequestInformation first counts how many optional
sub-structures will be copied and puts that count in a local
variable.  In the fast path (when all *UxKir* feature flags are
cleared) the following incorrect sequence is taken:

  v14 = (v11 != 0) + 4;          // base count
  …                               
  v82 = UlChannelBindRequestInfoPresent(...);
  v19 = v18 + 1;                 // <-- uses v18
  if (!v82)
      v19 = v18;                 //    again uses v18

The stack variable v18 is never initialised before it is read.
The random stack contents propagate into the field counter (v19)
which is later stored in *FieldCount* and also multiplied while
computing the total request-buffer size (v21).  If the stale stack
value is large enough the calculated size exceeds the real caller
buffer.  A later memcpy performed by UlpCopy* helpers therefore
reads past the end of the output buffer into adjacent kernel
memory, crashes the HTTP.sys worker thread and brings down the
machine (Blue Screen / bugcheck 0x139).

The fault is reachable only when
  • UxKirDtHttpIdleConnectionTimeout == 0
  • UxKirHttpDscp                 == 0
  • UxKirBrHttpQuerySocketTtl     == 0
and when the request does not contain the optional chunks whose
presence would have taken the slower, patched code path.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
/* before patch – v18 never initialised */
v14 = (v11 != 0) + 4;
...
v82 = UlChannelBindRequestInfoPresent(a1, v17);
v19 = v18 + 1;          // uninitialised read
if (!v82)
    v19 = v18;
```
```c
/* after patch – variable properly initialised */
v18 = UlChannelBindRequestInfoPresent(a1, a2, v17);
v67 = v18 != 0;
v21 = v19 + 1;          // v19 is the running counter
if (!v18)
    v21 = v19;
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Remote client sends crafted HTTP request.
2. User-mode service calls HttpReceiveHttpRequest with a small
   output buffer.
3. Kernel enters UlCopyRequestToBuffer → UlpCopyRequestInformation.
4. All *UxKir* features disabled → fast path executed.
5. Uninitialised v18 contaminates size counter.
6. Later copy helper reads past end of caller buffer → bugcheck
   (KERNEL_SECURITY_CHECK_FAILURE / ATTEMPTED_EXECUTE_OF_NOEXECUTE).

Attack Vector
--------------------------------------------------------------------
Unauthenticated network attacker sends specially crafted HTTP
traffic to any IIS/HTTP.sys listener, then causes the application
(or self-written client) to call the affected IOCTL.  No local
privileges are required; the result is a remote denial of service.

Patch Description
--------------------------------------------------------------------
• Re-organises counting logic – introduces distinct, correctly
  initialised variables (v19/v21) and removes the stale *v18*.
• Changes several parameters from *int* to *char* to prevent type
  promotion errors.
• Adds consistent overflow/size checks before every copy.
The offending uninitialised read can no longer occur.

Security Impact
--------------------------------------------------------------------
Prior to the patch, a malformed request could crash the Windows
kernel (BSOD) leading to complete denial of service for the host
running IIS or any other HTTP.sys consumer.  No information leak
or code execution was observed, but the read is still a memory
safety issue.

Fix Effectiveness
--------------------------------------------------------------------
The only code path where the uninitialised variable was used has
been rewritten; the new variables are set deterministically before
use, and additional bounds checks were added.  A code review shows
no remaining reads of uninitialised data in these routines, so the
fix is considered effective.
