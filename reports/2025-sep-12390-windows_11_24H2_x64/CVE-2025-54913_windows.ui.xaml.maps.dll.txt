{'file': 'windows.ui.xaml.maps.dll', 'cve': 'CVE-2025-54913', 'kb': 'KB5065426', 'change_count': 6, 'patch_store_uid': '705159f2-96ae-4921-9077-d001134b9ae5', 'confidence': 0.18, 'date': 1757843376.186107}
--------------------------------------------------------------------
CVE-2025-54913 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows.UI.Xaml.Maps – specifically the global MapControlSettings
infrastructure located in windows.ui.xaml.maps.dll (functions such as
MapControl::EnsureMapControlSettings, iterator helpers in the
XWinRT/Collections templates).


Vulnerability Class
--------------------------------------------------------------------
CWE-362: Race Condition
CWE-416: Use-after-free (secondary effect of the race)


Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  Global singleton
    Windows::UI::Xaml::Controls::Maps::s_pMapControlAdapterSettings is
    lazily created the first time MapControl::EnsureMapControlSettings()
    is called.

2.  OLD behaviour (before patch)
    EnsureMapControlSettings() performed:
      a. if (ptr == NULL) {
             InternalRelease(ptr);          // may free old instance
             Create(...,&ptr);              // allocate new settings
         }
    The whole block executes with **no synchronisation**.  Two threads
    entering simultaneously can interleave so that one thread frees the
    settings object while the other still uses it, or two different
    objects are created and one leaked.  Because the pointer is shared
    process-wide this produces a classic TOCTOU race leading to memory
    corruption / UAF.

3.  Related template helpers (SimpleVectorIterator::MoveNext, GetMany,
    XWinRT::detail::*::AtomicUpdate / InvalidationChecker) also relied on
    ad-hoc compare-exchange loops that accessed shared version counters
    and out-parameters without guaranteeing a consistent view when the
    loop was retried.  The same thread-safety issue could surface while
    enumerating Map collections during the MapControl initialisation
    window, amplifying the chance of corrupting heap structures freed by
    the primary race.

4.  Privilege escalation path (design-time):  A low-privileged caller
    that can execute XAML code instantiates MapControl from different
    threads (e.g. UI thread + background thread).  By racing the
    initialisation it can force use-after-free of an IMapControlSettings
    COM object.  Because COM interface vtables reside in controllable
    memory after free, the attacker can redirect execution inside the
    host process, which may run with a higher integrity level (for
    example XAML Island inside a privileged UWP container), thus
    achieving elevation of privilege.

Affected data/fields:
  • Windows::UI::Xaml::Controls::Maps::s_pMapControlAdapterSettings
  • MapControl::s_mapControlSettingsInitOnce (added by fix)
  • Shared version counters at offset +40 / +48 / +56 in the various
    iterator structures.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// BEFORE (race window)
if (!s_pMapControlAdapterSettings) {
    Microsoft::WRL::ComPtr<IUnknown>::InternalRelease(
        (ComPtr<IUnknown>*)&s_pMapControlAdapterSettings);
    CreateMapControlSettingsForDesigner(&s_pMapControlAdapterSettings,
                                        v2);   // unsynchronised
}
```
```c
// AFTER (thread-safe)
if (InitOnceExecuteOnce(&MapControl::s_mapControlSettingsInitOnce,
        MapControl::InitializeMapControlSettingsOnce,
        0,
        &Context)) {
    // Settings pointer created exactly once
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker creates two (or more) threads in the same process.
2. Each thread calls MapControl().EnsureMapControlSettings().
3. Thread-interleave:
     T1  checks ptr==NULL  → true
     T2  checks ptr==NULL  → true
     T1  releases (NULL) safely
     T2  releases (still NULL)
     T1  creates object A, stores pointer
     T2  creates object B, overwrites pointer, then frees pointer to A
     T1  continues to use pointer to A → UAF
4. Corrupted vtable ⇒ arbitrary code execution inside host process.


Attack Vector
--------------------------------------------------------------------
Local attacker code running inside a sandboxed / low-integrity app that
is able to load the XAML Maps control.  The attacker spawns parallel
threads to hit the initialisation race and hijacks freed memory to gain
control of execution in the higher-privileged XAML host process.


Patch Description
--------------------------------------------------------------------
1. Added static  INIT_ONCE  MapControl::s_mapControlSettingsInitOnce and
   re-implemented EnsureMapControlSettings() to call
   InitOnceExecuteOnce(), guaranteeing that the settings object is
   created exactly once and that the pointer cannot be freed while other
   threads are still using it.

2. Introduced wil::Feature gating to allow early exit if the feature is
   disabled, reducing surface area.

3. Re-worked iterator helpers:
   • New AtomicUpdates::AtomicUpdate() replaces hand-rolled CAS loops.
   • Extra out-parameter passed to MoveNext() so error propagation no
     longer races on stack-allocated memory.
   • GetMany() now branches: if iterator already immutable it directly
     calls AtomicUpdate; otherwise it still uses single-threaded path.

4. Removed the unsynchronised InvalidationChecker path for these
   collections.


Security Impact
--------------------------------------------------------------------
Before the fix a local attacker could reliably trigger use-after-free or
heap corruption while MapControlSettings was constructed, leading to
arbitrary code execution inside a process that hosts XAML (e.g. a UWP
app running with UIAccess or a privileged service that renders XAML).
This yields a local Elevation of Privilege.

After the fix the singleton is initialised once, atomically; iterator
state changes are performed through a safe helper, eliminating the data
race and removing the UAF primitive.


Fix Effectiveness
--------------------------------------------------------------------
The use of InitOnceExecuteOnce() gives strong one-time semantics backed
by the OS; no further unsynchronised accesses to
s_pMapControlAdapterSettings remain.  The template refactor moves all
shared-state mutation behind a single _InterlockedCompareExchange loop
that is free from the original out-parameter race.  No residual race
windows are observable in the patched code; therefore the fix is
considered effective.

