{'patch_store_uid': '6f91c739-5c54-4375-9321-fa8ca7db437b', 'cve': 'CVE-2025-55228', 'file': 'win32kbase.sys', 'date': 1757843688.700195, 'change_count': 327, 'confidence': 0.2, 'kb': 'KB5065426'}
--------------------------------------------------------------------
CVE-2025-55228 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
win32kbase.sys – process life-cycle helpers (UserProcessDestroyCallout,
xxxUserProcessInitCallout) and Win32JobObject helpers (AddProcess,
Terminated) that manipulate per-session Win32K data structures.

Vulnerability Class
--------------------------------------------------------------------
CWE-362: Race condition due to missing locking
CWE-416: Use-after-free on session / job lists as a consequence

Detailed Root Cause Analysis
--------------------------------------------------------------------
Several callout helpers that run in the context of process creation,
process teardown and job-object bookkeeping were compiled into trivial
inline wrappers that only touched raw session pointers:

  * UserProcessDestroyCallout wrote a supplied pointer straight into the
    UserSessionState +0x00 without taking the session critical section.
  * xxxUserProcessInitCallout only compared a field at UserSessionState
    +0x10 without any serialisation.
  * Win32JobObject::AddProcess and …::Terminated simply read or wrote
    session fields (+0x00, +0x08) without protecting the shared lists
    that track W32PROCESS / W32JOB objects.

Because these helpers run on arbitrary kernel worker threads while the
GUI subsystem is still live, multiple threads could enter them in
parallel for the same session.  At the same time other paths (e.g.
NtUserCreateWindowStation, graphics IOCTLs, DComp) legitimately assumed
that the session-global lists are protected by the "User crit" lock.

The result is a classic TOCTOU race:

1. Thread A frees or re-initialises an entry in the session array
   (e.g., destroys a W32PROCESS record).
2. Before the pointer is cleared, Thread B dereferences it from the same
   array slot because no lock is held.
3. The freed memory can now be used as a dangling object and its vtable
   or function pointers are executed under kernel context, yielding
   arbitrary code execution (R0) within win32kbase.sys.

The window for the race is small but repeatable because an attacker can
create and destroy large numbers of GUI processes or job objects across
several CPUs, forcing overlap between the unsynchronised assignments and
other GUI operations.

Structures/fields involved (offsets inside UserSessionState):
  +0x00  gpresUser            – pointer to session user crit owner
  +0x08  gpresRender          – pointer to render crit owner
  +0x10  gpresMitRitHazard    – pointer used by RIT mitigation logic
  +0x4CE8 etc.  deferred unlock lists

All accesses above were performed without acquiring the corresponding
_FAS_RESOURCE * user critical section, breaking the contract expected by
core win32k code.

Vulnerability Code Snippets
--------------------------------------------------------------------
Before patch (UserProcessDestroyCallout prototype):
```c
__int64 *__fastcall SGCRITTYPEgpresUser<_FAST_ERESOURCE *>::operator=(
    __int64 a1, __int64 *a2)
{
  __int64 v2 = *a2;
  *(_QWORD *)W32GetUserSessionState(a1) = v2;   // unsynchronised write
  return a2;
}
```

After patch:
```c
void __fastcall UserProcessDestroyCallout(_W32PROCESS *proc)
{
  __int64 s = W32GetUserSessionState(proc);
  __int64 ctx = UserCritInternal::EnterCritInternal(s, 0);
  *(_QWORD *)(s + 0x18) = ctx;                  // owner tracking
  ...                                           // validate context
  DestroySharedUserCritDeferredUnlockList(s+0x4CE8);
  ...                                           // safe cleanup
  UserSessionSwitchLeaveCritWithNonPaged(0);
}
```
Similar locking and validation blocks were added to xxxUserProcessInit
and both Win32JobObject helpers.

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker spawns two or more threads.
2. Thread A repeatedly creates GUI processes and immediately exits them
   so that UserProcessDestroyCallout is invoked.
3. Thread B simultaneously issues win32k system calls that walk the
   session job / process lists (e.g., NtUserBuildSelectionArray or job
   UI restriction APIs).
4. Because the destroy path writes a freed pointer without a lock,
   Thread B dereferences freed memory, leading to control-flow hijack.

Attack Vector
--------------------------------------------------------------------
Local, authenticated.  Requires the ability to create GUI processes or
job objects inside the same session – achievable from any normal user
account.

Patch Description
--------------------------------------------------------------------
The patch converts the stubbed template operators into full
implementations that:
  • Call UserCritInternal::EnterCritInternal(Ex) to acquire the per
    session _FAST_ERESOURCE ("user crit") in exclusive mode.
  • Mark the resulting GUI context as owned (byte +0x6AC).
  • Validate IsValidGuiContext() and flush deferred unlock lists before
    proceeding.
  • Use AtomicExecutionCheck to defend against re-entrancy.
  • On exit call UserSessionSwitchLeaveCritWithNonPaged() to release the
    lock.
  • RAII helper CTempW32ThreadNonPaged guarantees correct IRQL.
No functional change beyond proper synchronisation is introduced.

Security Impact
--------------------------------------------------------------------
Prior to the patch, an attacker could win a race that dereferences a
freed W32PROCESS/W32JOB pointer, enabling:
  • Arbitrary kernel read/write via crafted fake objects.
  • Escalation to ring-0 or sandbox escape.
  • Potential system compromise when chained with a GUI-trigger delivered
    from remote vectors (RDP, browser, etc.).

Fix Effectiveness
--------------------------------------------------------------------
The updated code consistently acquires the session critical section
before touching shared state, closing the race window.  All subsequent
writes/reads occur while holding the lock, and deferred unlock lists are
flushed under the same protection.  No remaining unlocked accesses to
UserSessionState+[0,8,10] were found in the modified functions,
indicating the vulnerability is effectively remediated.
