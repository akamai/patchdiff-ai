{'file': 'microsoft.bluetooth.service.dll', 'confidence': 0.27, 'cve': 'CVE-2025-53802', 'change_count': 110, 'patch_store_uid': '67b1359b-3787-4b70-8a1b-2e864ed2399c', 'date': 1757843802.7197566, 'kb': 'KB5065426'}
--------------------------------------------------------------------
CVE-2025-53802 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Bluetooth Service (microsoft.bluetooth.service.dll),
class Microsoft::Bluetooth::Core::Interface::GapAdvertisementPublisherImpl


Vulnerability Class
--------------------------------------------------------------------
Use-After-Free caused by missing synchronization (race condition)
(CWE-416)


Detailed Root Cause Analysis
--------------------------------------------------------------------
GapAdvertisementPublisherImpl exposes multiple WinRT property
getters/setters (Anonymous, Connectable, Legacy, IncludeTxPower and
Priority).  Prior to the patch every accessor directly read or wrote
object fields:
  * byte flags at offsets +0x190, +0x191, +0x192, +0x193
  * enum GapAdvertisementPublisherPriority at +0x210
without acquiring the object’s internal SRW lock located at +0xA0
(object+160).  When two threads manipulated the same publisher
instance one thread could destroy/free the object (e.g. via Stop() or
Release()) while the other thread was still executing one of these
property functions.  Because the accessors performed raw pointer
arithmetic ( *((_BYTE*)this+402) etc. ) the code followed a dangling
pointer after the object memory had been returned to the heap.  Any
subsequent heap reuse turned the stale read/write into memory
corruption under the high-privilege Bluetooth service, providing a
reliable elevation-of-privilege primitive.

Impacted members and offsets
  Anonymous        : byte  *(this+0x192)
  Connectable      : byte  *(this+0x190)
  Legacy           : byte  *(this+0x191)
  IncludeTxPower   : byte  *(this+0x193)
  Priority         : dword *(this+0x210)
All five were reachable by an authenticated local user through public
WinRT Bluetooth APIs.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – no locking, raw access
__int64 put_Connectable(GapAdvertisementPublisherImpl *this, char v)
{
    *((_BYTE*)this + 400) = v != 0;   // write without lock
    return 0;
}

__int64 get_Connectable(GapAdvertisementPublisherImpl *this, UCHAR *out)
{
    if (!out) return E_POINTER;
    *out = *((_BYTE*)this + 400);     // read without lock
    return 0;
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Client app obtains GapAdvertisementPublisher object via WinRT API.
2. Thread A calls put_*/get_* repeatedly.
3. Thread B concurrently closes the same object, freeing memory.
4. Thread A continues execution in accessor, uses freed memory -> UAF.


Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker able to run user-mode code and access the
public Windows Bluetooth WinRT APIs.  No additional privileges are
required; exploitation occurs entirely in user-mode but within the
SYSTEM-level Bluetooth service process.


Patch Description
--------------------------------------------------------------------
Each accessor now:
1. Tests a feature flag (Feature_2578215227).
2. If enabled, acquires the object’s SRW lock:
     AcquireSRWLockExclusive   for setters
     AcquireSRWLockShared      for getters
3. Performs the field access while the lock is held.
4. Releases the lock via RAII wrapper.
If the feature flag is disabled the previous unsynchronized path is
retained.


Security Impact
--------------------------------------------------------------------
Unprivileged code could cause use-after-free in the SYSTEM Bluetooth
service, leading to memory corruption and elevation of privilege to
SYSTEM.  Reliability is high due to deterministic field offsets and
controllable heap layout.


Fix Effectiveness
--------------------------------------------------------------------
Locking all property accesses removes the race window that permitted
concurrent free/use, effectively preventing the UAF.  The mitigation
relies on a feature flag; if that flag could be disabled the original
vulnerability would re-appear, but no such control is documented.
Overall the patch is technically sound and blocks the previously
exploitable condition.
