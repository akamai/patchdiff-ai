{'kb': 'KB5065426', 'patch_store_uid': '23031498-cadb-4b62-90ee-f08123f9a90a', 'date': 1757843417.8235872, 'file': 'capabilityaccessmanager.dll', 'confidence': 0.27, 'cve': 'CVE-2025-54108', 'change_count': 80}
--------------------------------------------------------------------
CVE-2025-54108 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Capability Access Management Service (camsvc), specifically
capabilityaccessmanager.dll implementing the
CapabilityUsageSessionServer::get_DisplayMessage and
CapabilityUsageSessionServer::put_DisplayMessage methods.

Vulnerability Class
--------------------------------------------------------------------
CWE-362: Race Condition (concurrent access to a shared resource)
leading to CWE-416: Use-After-Free / memory corruption and local
Elevation of Privilege.

Detailed Root Cause Analysis
--------------------------------------------------------------------
Each CapabilityUsageSessionServer instance owns an internal pointer at
offset 0x28 (this[5].Ptr) to a
Windows::Internal::CapabilityAccess::Private::CapabilityUsageSession
object that stores a wstring "DisplayMessage".  Two public server-
side methods expose that field:
  • get_DisplayMessage(HSTRING **out)
  • put_DisplayMessage(HSTRING  in)

Prior to the patch both methods executed completely unsynchronised.
put_DisplayMessage built a temporary std::wstring, assigned it to the
session object and immediately deallocated the temporary via
std::wstring::_Tidy_deallocate.  get_DisplayMessage retrieved the
internal wstring, turned it into a HSTRING via WindowsDuplicateString
and returned it to the caller.

Because camsvc is multi-threaded and the interface is callable from
multiple client processes, two threads could enter these functions
simultaneously.  A typical interleaving is:
  1. Thread A executes put_DisplayMessage and publishes the new
     wstring pointer inside the session object.
  2. Thread B enters get_DisplayMessage and obtains that same pointer
     for duplication.
  3. Thread A continues, calls _Tidy_deallocate and frees the buffer.
  4. Thread B now operates on freed memory, resulting in a classic
     use-after-free.

By spraying controlled strings an attacker can corrupt camsvc’s memory
and eventually execute code with the service’s LocalSystem privileges,
thereby achieving Elevation of Privilege.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// BEFORE
v4 = (CapabilityUsageSession*)*((QWORD*)this + 5);
if (a2) {
    StringRawBuffer = WindowsGetStringRawBuffer(a2, 0);
    std::wstring::wstring(v7, StringRawBuffer);
    CapabilityUsageSession::put_DisplayMessage(v4);
} ...
std::wstring::_Tidy_deallocate(v7);   // buffer freed while readers run
```

```c
// AFTER – critical section added
AcquireSRWLockExclusive(this + 9);
Ptr = (CapabilityUsageSession*)this[5].Ptr;
... (same work) ...
std::wstring::_Tidy_deallocate(&v10);
ReleaseSRWLockExclusive(this + 9);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Client process -> camsvc COM interface ->
CapabilityUsageSessionServer::put_DisplayMessage (writer thread)
          races with
CapabilityUsageSessionServer::get_DisplayMessage (reader thread)
          on shared member session.DisplayMessage -> buffer freed while
          still in use -> memory corruption -> privilege escalation.

Attack Vector
--------------------------------------------------------------------
Any local authenticated attacker can create two or more threads (or
processes) and repeatedly invoke the ICapabilityUsageSessionServer
GetDisplayMessage and SetDisplayMessage methods at high frequency to
win the race and trigger use-after-free inside the camsvc service that
runs as LocalSystem.

Patch Description
--------------------------------------------------------------------
1. Function ‘this’ is re-typed to RTL_SRWLOCK* so the object now owns a
   Slim Reader/Writer Lock located at offset +9.
2. put_DisplayMessage now calls AcquireSRWLockExclusive / Release… to
   obtain an exclusive lock while writing.
3. get_DisplayMessage calls AcquireSRWLockShared / Release… to allow
   concurrent readers but block writers.
4. Lock releases are wrapped into wil::unique_storage RAII objects to
   guarantee unlock on all exit paths (success or error).
5. Code paths without the feature flag fall back to the old behaviour;
   the flag is enabled through
   wil::Feature<__WilFeatureTraits_Feature_3159936315>.

Security Impact
--------------------------------------------------------------------
Unsynchronised access allowed memory corruption inside a privileged
service.  Successful exploitation lets a local attacker run arbitrary
code in camsvc context, yielding SYSTEM privileges (Elevation of
Privilege).  A crash is also possible, causing a DoS for any component
that relies on capability access decisions.

Fix Effectiveness
--------------------------------------------------------------------
The added SRW lock provides proper writer/reader exclusion, removing
the race window and the associated use-after-free.  RAII ensures the
lock is always released.  The protection, however, is contingent on
the associated feature flag being enabled; systems where the flag is
disabled will still use the vulnerable path.  Assuming the feature is
rolled out broadly, the fix is effective.
