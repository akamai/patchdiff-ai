{'cve': 'CVE-2025-53800', 'patch_store_uid': 'ce779ff9-268d-4bc0-b7f2-70c9427854b5', 'kb': 'KB5065426', 'file': 'dxgi.dll', 'change_count': 94, 'confidence': 0.12, 'date': 1757843884.454682}
--------------------------------------------------------------------
CVE-2025-53800 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Graphics Component – user-mode DXGI library
(dxgi.dll).  Impacted routines are mainly:
 • AslpFileGetVersionBlock
 • CDXGISwapChain::OnSettingsChanged
 • CDXGISwapChain::RegisterPowerNotificationCallback
 • ATL::CComCachedTearOffObject<…>::Release
The vulnerable code was delivered in the public Windows graphics
stack and is reachable from several graphics and App-X processing
paths that run inside privileged processes such as dwm.exe or
services using dxgi.dll.

Vulnerability Class
--------------------------------------------------------------------
Incorrect initialization / use of an un-initialised resource
(CWE-1419) that results in a logic error and memory corruption which
can be leveraged for local privilege-escalation.

Detailed Root Cause Analysis
--------------------------------------------------------------------
The defect sits in AslpFileGetVersionBlock(), a helper that locates
and validates the VS_VERSION_INFO resource inside an image or data
file:

1.  The code maps the caller-supplied file and calls
    LdrResSearchResource() to obtain a pointer (Src[0]) to the
    version block.
2.  A range check then validates that this pointer belongs to the
    mapped view:
        if (Src[0] < Base || Src[0] > Base + Size)
            … error …
    The upper bound (  Base + Size  ) is calculated with the helper
    variable  v18 .
3.  In the pre-patch build v18 is declared as coming from RCX – the
    first function parameter – instead of R8 (the register that will
    later hold the mapped view-size).  Consequently v18 is left
    un-initialised *or* contains an unrelated pointer value before it
    is eventually overwritten in some, but **not all**, code paths.
4.  When the LdrResSearchResource() fast path succeeds, the pointer
    check executes while v18 still contains this stale value.  By
    crafting Src[0] so that it falls below  Base +  bogusSize  an
    attacker can bypass the range check and force the routine to
    treat an out-of-bounds buffer as a legitimate version block.
5.  The function later trusts that buffer and copies/parses
    controlled data, leading to memory corruption inside the caller’s
    process (often running with SYSTEM integrity in servicing or
    graphic-worker contexts).

Additional issues fixed in the same patch set (null pointer guards in
CDXGISwapChain::OnSettingsChanged, correct reference counting in
ATL::CComObjectNoLock::Release, simplified registration in
RegisterPowerNotificationCallback) were not strictly required for the
privilege escalation but hardened the affected code paths.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// pre-patch (dxgi.dll)
void *v18; // rcx  <- wrong register, never initialised
...
if (Src[0] < v10 || Src[0] > &v10[(size_t)v18])
    // supposed range check, can be bypassed
```
```c
// patched
void *v18; // r8  <- correct register (mapped view size)
...
if (Src[0] < v10 || Src[0] > &v10[(size_t)v18])
    // now operates on initialised length value
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Low-privileged attacker causes a privileged component (for example
   app-installer service or dwm.exe) to call AslpFileGetVersionBlock()
   on a file they control.
2. Crafted file arranges VS_VERSION_INFO so that Src[0] points outside
   the mapped image yet still passes the faulty upper-bound test.
3. Subsequent parsing operates on out-of-range memory, corrupting the
   process heap/image and enabling code-execution with the victim
   process privileges (SYSTEM or administrator SYSTEM-context).

Attack Vector
--------------------------------------------------------------------
Local – the attacker needs the ability to feed a malicious PE or
resource file that is later processed by a privileged dxgi.dll
consumer (e.g. graphics service, signed-package installer, or another
high-integrity process invoking graphics resource APIs).
No additional authentication is required once the file is picked up.

Patch Description
--------------------------------------------------------------------
Microsoft corrected the initialisation defect by:
1. Declaring  v18  as the correct R8-sourced variable so that it
   always contains the mapped view size before the pointer range check
   executes.
2. Adding new error-handling labels (LABEL_38/39) to ensure early exit
   paths free the mapping correctly.
3. Introducing Feature_EnsureVerBlockCanHoldFixedInfo() gated logging
   that makes the validation stricter.
4. Complementary hardening: null-pointer checks in
   CDXGISwapChain::OnSettingsChanged, SafeUnknownDecrementReference()
   usage in Release(), and a minimalistic implementation of
   RegisterPowerNotificationCallback.

Security Impact
--------------------------------------------------------------------
Because the range check could be bypassed the routine would operate on
attacker-controlled memory, enabling arbitrary memory read/write and
ultimately execution of attacker code in a privileged graphics
context.  Once code execution is achieved the attacker can elevate
from a standard user to SYSTEM, fulfilling the "Elevation of
Privilege" impact noted in CVE-2025-53800.

Fix Effectiveness
--------------------------------------------------------------------
The patch addresses the root cause by ensuring the size variable used
in the boundary calculation is always initialised with the correct
view length.  Pointer validation is therefore reliable and out-of-
range version blocks are rejected with STATUS_INVALID_IMAGE_FORMAT.
No alternate path that re-introduces the stale variable has been
observed, and additional guard code (Feature_EnsureVerBlock… and
extra logging) increases defence in depth.  The fix is considered
adequate.
