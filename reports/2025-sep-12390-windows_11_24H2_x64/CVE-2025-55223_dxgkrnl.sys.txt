{'patch_store_uid': 'd684b50b-6751-470f-a207-df1d66ac8df9', 'change_count': 233, 'kb': 'KB5065426', 'confidence': 0.25, 'date': 1757843864.1211956, 'file': 'dxgkrnl.sys', 'cve': 'CVE-2025-55223'}
--------------------------------------------------------------------
CVE-2025-55223 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows dxgkrnl.sys (DirectX Graphics Kernel), specifically
CompositionSurfaceObject list-management and token processing logic.


Vulnerability Class
--------------------------------------------------------------------
Primary: CWE-362  Race Condition
Secondary: CWE-416 Use-After-Free (triggered by the race)


Detailed Root Cause Analysis
--------------------------------------------------------------------
CompositionSurfaceObject::NotifyTokenInFrame originally performed its
own synchronization and list maintenance:

1. It took an exclusive pushlock located at this+0x30 (field offset
   0x48 in the disassembly) with ExAcquirePushLockExclusiveEx.
2. It walked a doubly-linked list anchored at this+0x78 (offset 0x120)
   looking for a child surface (node *i) whose stored tokenId matched
   the caller-supplied CToken ( *((QWORD*)i-1) == *((QWORD*)a2+7) ).
3. On a match it executed the child’s virtual method at vtable+0x80
   (*(i-3)+0x128) => ChildSurface::NotifyTokenInFrame().
4. IF the virtual call succeeded AND returned *a3 == TRUE, the parent
   removed every **subsequent** node in the list:
      v9 = i->Flink;
      while (v9 != Sentinel) { unlink(v9); dec(Count); Release(v9); }

The virtual call is fully under control of the child object.  Nothing
prevents that code from:
  • Re-entering the parent object;
  • Dropping the parent’s pushlock (it is public to children);
  • Destroying or unlinking list nodes, including the same nodes the
    caller will access immediately afterwards.

When control returns, NotifyTokenInFrame continues to trust that

  v9, v11 = v9->Flink  and  *((CompositionSurfaceObject**)v11 + 1)

still reference valid memory.  If the child thread has already freed or
re-used any of those nodes, the parent dereferences freed memory,
leading to a write-what-where or execution of a stale vtable pointer.
Because the code runs inside the graphics kernel, an attacker with
normal user-mode access to D3DKMT interfaces can exploit the race to
execute arbitrary code with kernel privileges.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch (excerpt)
for (i = this->ListHead.Flink; i != &this->ListHead; i = i->Flink) {
    if (*((UINT64*)i - 1) == *((UINT64*)token + 7)) {
        status = i->Vtbl->NotifyTokenInFrame(i, token, &found);
        if (NT_SUCCESS(status) && found) {
            v9 = i->Flink;                    // start after match
            while (v9 != &this->ListHead) {
                v11 = v9->Flink;             // NEXT
                unlink(v9);                  // manipulates list
                this->Count--;               // --entries
                v9->Vtbl->Release(v9, 1);    // may free object
                v9 = v11;                    // continue on stale ptrs
            }
        }
        break;
    }
}
```

```c
// after patch (excerpt)
status = CPushLock::AcquireLockExclusive(this + 0x48);
if (NT_SUCCESS(status)) {
    status = CCompositionSurface::NotifyTokenInFrame(this + 0x40,
                                                    token,
                                                    found,
                                                    flags);
    CPushLock::ReleaseLock(this + 0x48);
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User-mode code creates several surfaces that share a parent
   CompositionSurfaceObject and obtains handles to their CToken values.
2. Two or more threads concurrently call the KMT ioctl that reaches
   CompositionSurfaceObject::NotifyTokenInFrame.
3. Thread A matches a node, enters the virtual method, and the child
   releases or destroys later nodes in the list, dropping the lock.
4. Thread A returns; the parent continues to iterate over already freed
   nodes, causing a UAF.
5. Corrupted pointers are reused, giving the attacker arbitrary kernel
   read/write or EIP control.


Attack Vector
--------------------------------------------------------------------
Local, from an ordinary user account.  Requires access to D3DKMT /
DirectComposition APIs which are available in all standard sessions.
No admin or special privileges are needed to trigger the race.


Patch Description
--------------------------------------------------------------------
The patched build removes all ad-hoc list traversal and manual unlinking
from CompositionSurfaceObject::NotifyTokenInFrame.  The function now

1. Uses CPushLock::AcquireLockExclusive/ReleaseLock wrappers which
   guarantee balanced acquisition and release and return an NTSTATUS.
2. Delegates token processing to CCompositionSurface::NotifyTokenInFrame
   (this+0x40), passing through the caller’s parameters.
3. Does *not* touch the child list after the virtual call returns; all
   cleanup is handled inside the lower-level routine that owns the list.

By removing post-callback list manipulation the window for concurrent
modification and stale-pointer dereference is closed.


Security Impact
--------------------------------------------------------------------
A successful exploit yields kernel-mode execution in the graphics stack,
allowing full local elevation of privilege (ring-0 arbitrary code).
Secondary impact includes potential kernel crashes (DoS).


Fix Effectiveness
--------------------------------------------------------------------
The dangerous code paths that dereferenced list nodes after an
unbounded callback are gone, and locking is now abstracted.  No stale
pointer is accessed after the virtual call, eliminating the UAF.  No
additional race entry points are visible in the patched diff, so the
fix is considered effective barring undisclosed paths.
