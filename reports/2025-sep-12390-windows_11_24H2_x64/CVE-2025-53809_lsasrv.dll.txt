{'file': 'lsasrv.dll', 'cve': 'CVE-2025-53809', 'date': 1757853908.9347196, 'kb': 'KB5065426', 'patch_store_uid': '088c2266-2443-4e1a-9bb7-fdeb31b20e02', 'confidence': 0.26, 'change_count': 31}
--------------------------------------------------------------------
CVE-2025-53809 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Local Security Authority Sub-System Service (lsasrv.dll)
Function: NegpCaptureSuppliedCreds()

Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow / Improper input validation (CWE-20,
results in memory corruption and service crash)

Detailed Root Cause Analysis
--------------------------------------------------------------------
NegpCaptureSuppliedCreds() processes a user-supplied, comma-separated
list of authentication package names that arrives from user mode
through LsapCopyFromClient().  The function first counts the number of
comma separators (variable v48) to estimate how many packages may be
requested, then allocates an array of pointer slots:

    slots = LsapAllocate( 8 * NegPackageCount );      // v75 / v99

NegPackageCount is a global constant (the total number of registered
packages, e.g. 128).  After allocation the routine walks the caller’s
string twice:
  1. exact package names (loop over v65)
  2. wildcard/attribute matches in the global NegPackageList (loop
     over list entry "Flink")

For every match it performs

    index = v73++;
    slots[index] = found_package;

In the original code no check verifies that the running index v73
stays below NegPackageCount.  A malicious string that mentions more
than NegPackageCount distinct or wildcard-resolved packages therefore
causes v73 to exceed the allocated bound and write pointers beyond the
end of the heap buffer.  The overwrite corrupts adjacent heap metadata
and predictably terminates the LSASS process, resulting in a denial-of
service and system reboot because LSASS is a protected process.

Parameters/structures involved:
  • user buffer -> comma separated package list (ANSI or Unicode)
  • NegPackageCount (global upper bound for expected packages)
  • v75 / v99 : pointer array allocated with LsapAllocate()
  • v73        : running package counter used as write index

Vulnerability Code Snippets
--------------------------------------------------------------------
Old code (before patch)
```c
v75 = (struct _RTL_BALANCED_NODE *)LsapAllocate(8i64 * NegPackageCount);
...
if ((*(_DWORD *)(pkg + 40) & v74) == v74) {
    v83 = v73++;                         // no bounds check
    v99->Children[v83] = (struct _RTL_BALANCED_NODE *)pkg; // OOB write
}
```

Patched code
```c
if (wil::details::FeatureImpl<...>::__private_IsEnabled(...) &&
    j >= v91) {                         // v91 == NegPackageCount
    v12 = STATUS_INVALID_PARAMETER;
    goto fail;
}
index = j++;
v96->Children[index] = (struct _RTL_BALANCED_NODE *)pkg; // safe
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker sends Negotiate authentication request containing a crafted
   string with >NegPackageCount package names ("NTLM,Kerberos,...").
2. lsass!NegpCaptureSuppliedCreds copies the string from client.
3. Buffer length is validated only for size, not for number of
   packages.
4. Function allocates 8*NegPackageCount bytes.
5. Enumeration loops add more than NegPackageCount entries and write
   past the end of the buffer.
6. Heap metadata is corrupted; LSASS crashes soon afterwards,
   triggering Windows to reboot or log the user off (DoS).

Attack Vector
--------------------------------------------------------------------
Any authenticated network protocol that allows the caller to select
packages for the SPNEGO/Negotiate mechanism (e.g. SMB, RPC, HTTP, or
local LSA APIs).  The attacker needs only a valid session to supply a
long, comma-separated list of package names.

Patch Description
--------------------------------------------------------------------
1. Introduced explicit counter (j) that tracks how many package
   pointers have been stored.
2. Added upper-bound check:
      if (j >= NegPackageCount) return STATUS_INVALID_PARAMETER;
3. Same guard added to both enumeration loops (exact names and
   wildcard pass).
4. Re-typed several variables to unsigned to avoid sign issues and
   updated tracing GUIDs but these are cosmetic.

Security Impact
--------------------------------------------------------------------
Before the patch an authenticated attacker could reliably crash LSASS,
causing a system reboot and denial of service.  No code execution is
known but memory corruption makes it theoretically possible.

Fix Effectiveness
--------------------------------------------------------------------
The added boundary check prevents writing beyond the allocated buffer
and converts the out-of-range condition into a clean error return
(STATUS_INVALID_PARAMETER).  With the guard in place the overflow is
eliminated and LSASS no longer terminates when presented with an
oversized package list.
