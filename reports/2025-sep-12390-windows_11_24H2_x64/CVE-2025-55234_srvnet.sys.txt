{'kb': 'KB5065426', 'confidence': 0.17, 'date': 1757843360.7339995, 'file': 'srvnet.sys', 'patch_store_uid': '09a804f6-2a15-4428-99b8-410315cedbed', 'cve': 'CVE-2025-55234', 'change_count': 9}
--------------------------------------------------------------------
CVE-2025-55234 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft SMB server kernel driver (srvnet.sys), routines dealing with
Service-Principal-Name (SPN) validation during administrative session
setup:  
 • SrvAdminValidateSpn()  
 • SrvNetRefreshLanmanServerParameters()


Vulnerability Class
--------------------------------------------------------------------
Stack-based buffer overflow / improper parameter validation (CWE-787
/ overlaps CWE-287 because the overwrite lets an attacker bypass SPN
validation, ending in improper authentication).


Detailed Root Cause Analysis
--------------------------------------------------------------------
SrvAdminValidateSpn() is responsible for evaluating the negotiated
security context and determining whether the remote client supplied a
valid SPN when attempting privileged operations over SMB.  The helper
function SrvAdminCheckSpn() returns two flag values:
  • AdminSpnIsPresent  (1 byte)
  • ClientSpnIsPresent (3-byte array, index-0 used as a flag)

The original implementation called the helper with the last two
parameters swapped:
   SrvAdminCheckSpn( SpnString, FlagArray3, &Flag1Byte );
Here FlagArray3 points at a 3-byte local (char v23[3]) while &Flag1Byte
points at a single byte (unsigned char v22).

SrvAdminCheckSpn() actually expects the opposite order
   (SpnString, BYTE *OneByteFlag, CHAR[3] Buffer)
so it writes up to three bytes through the third argument.  Because the
function received a pointer to only **one** byte, two bytes of stack
memory directly following v22 were silently overwritten.  The smashed
bytes belong to other in-scope locals (including control/status values)
and can be influenced by an attacker through crafted authentication data
(the content of the SPN).

Corrupting those locals allows the caller to falsify the outcome of the
SPN checks (e.g., set v22 or v23[0] to zero/non-zero at will) and bypass
authentication hardening that protects against credential-relay
(elevation of privilege) attacks.  Although the overwrite is small (2
bytes), it targets security-critical flags living on a protected kernel
stack frame, thereby undermining the decision logic that ultimately sets
*out* parameters a5/a6 returned to higher layers.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable call – before patch
unsigned __int8 v22;      // 1-byte flag
char v23[3];              // 3-byte buffer
...
SrvAdminCheckSpn(v26, v23, &v22);   // parameters swapped
```

```c
// fixed call – after patch
unsigned __int8 v22;      // 1-byte flag
char v23[3];
...
SrvAdminCheckSpn(v26, &v22, v23);   // correct order
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Remote attacker performs SMB session setup that reaches the
   administrative pipe path.
2. SMB server enters SrvAdminValidateSpn() during authentication.
3. Crafted security context forces SrvAdminCheckSpn() to populate all
   three bytes of its third argument.
4. Because that third argument is actually a 1-byte variable, two bytes
   of the kernel stack are overwritten.
5. Overwritten bytes include decision flags; attacker can clear the
   "SPN required" indicators.
6. Function returns success even though no valid SPN was supplied,
   enabling relay-style elevation of privilege.


Attack Vector
--------------------------------------------------------------------
Any network attacker able to negotiate an SMB session to a vulnerable
Windows server can send manipulated authentication data (NTLM /
Negotiate) that drives the SPN-validation path.  No credentials are
required; only the ability to reach the SMB service.


Patch Description
--------------------------------------------------------------------
1. Corrected the parameter order in the SrvAdminCheckSpn() invocation,
   ensuring a 3-byte buffer is supplied where the callee expects it.  
2. Adjusted local types (v26 is now a _WORD* instead of an int64) to
   match the real data layout and avoid future mismatches.  
3. Added an extra argument to SrvAdminValidateSpn() and extensive ETW
   logging/auditing (AuditClientSpnSupport) so administrators can detect
   devices that would fail once strict SPN/EPA rules are enabled.  
4. SrvNetRefreshLanmanServerParameters() now parses the new registry key
   AuditClientSpnSupport and propagates the global boolean
   SrvNetAuditClientSpnSupport so that the auditing code can be turned
   on or off.


Security Impact
--------------------------------------------------------------------
Prior to the update an unauthenticated remote attacker could
programmatically corrupt kernel stack memory inside srvnet.sys and,
importantly, bypass SPN enforcement.  This allowed credential-relay and
other elevation-of-privilege scenarios against servers that had not yet
mandated SMB signing or EPA.  The attack requires only network access to
the SMB port (TCP/445).


Fix Effectiveness
--------------------------------------------------------------------
Supplying the correct buffer sizes removes the overwrite, thereby
restoring reliable SPN validation.  Additional auditing paths introduce
no new writable buffers.  Static inspection shows the 3-byte buffer now
points to v23 (size-correct) and the single-byte flag to v22, eliminating
stack corruption.  No alternative path still uses the old prototype, so
the patch fully addresses the described flaw.
