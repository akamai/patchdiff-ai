{'change_count': 712, 'date': 1757844066.365791, 'file': 'ntoskrnl.exe', 'kb': 'KB5065426', 'patch_store_uid': '8ceaf580-961a-430f-ad80-451621699df6', 'cve': 'CVE-2025-54110', 'confidence': 0.27}
--------------------------------------------------------------------
CVE-2025-54110 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Kernel – Processor-Power-Management (Ppm) thread-priority
synchronisation logic (function PpmReleaseLock in ntoskrnl.exe).


Vulnerability Class
--------------------------------------------------------------------
Integer underflow / wrap-around (CWE-190) leading to corrupted per-
thread priority-floor accounting and privilege escalation.


Detailed Root Cause Analysis
--------------------------------------------------------------------
Each thread owns an 8-bit reference counter array
  KTHREAD::PriorityFloorCounts[32]
that tracks how many independent “priority floor” requests are active
for a given class of locks.  Entry index 22 is reserved for Ppm locks.

Prior to the patch PpmReleaseLock executed the following sequence:
  1. Acquire the current thread’s lock at IRQL DPC.
  2. Call KiClearPriorityFloor( CurrentThread ).
     This **unconditionally zeroed** PriorityFloorCounts[22] and
     cleared bit 22 (0x400000) from PriorityFloorSummary.
  3. Drop the thread lock and return.

If the same thread owned *nested* Ppm locks, only the first call should
have decremented the counter.  Because the old code bluntly forced the
counter to zero, every subsequent release operated on a value that was
already zero.  The next internal decrement therefore wrapped the
unsigned byte to 0xFF, leaving the summary bit permanently set while
PriorityFloorCounts[22] appeared non-zero for the life-time of the
thread.

Effect of wrap-around:
• Scheduler permanently believes that a priority floor request is still
  active and keeps the thread at an artificially high priority.
• The thread now executes with Real-time / High priority irrespective
  of normal quota or job restrictions, effectively granting an
  unprivileged process scheduling dominance.  Combined with known
  techniques (e.g. CPU starvation of higher-integrity threads) this
  enables a local Elevation-of-Privilege.

Patch logic adds precise reference accounting:
  • Reads the current counter (v5).  If zero ⇒ bugcheck 0x157.
  • Decrements the byte safely.
  • Clears the summary bit only when the counter reaches zero.
  • Re-evaluates the thread’s base priority via KiComputeThreadPriority
    and lowers it if required.
Thus the integer underflow can no longer occur.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Before (simplified)
KiAcquireThreadLockRaiseToDpc(CurrentThread, &Local);
KiClearPriorityFloor((ULONG_PTR)CurrentThread);   // zeroes counter !
CurrentThread->ThreadLock = 0;
```

```c
// After
KiAcquireThreadLockRaiseToDpc(CurrentThread, &Local);
unsigned char cnt = CurrentThread->PriorityFloorCounts[22];
if (!cnt)
    KeBugCheckEx(0x157, CurrentThread, 0x16, 2, 0);
cnt--;
CurrentThread->PriorityFloorCounts[22] = cnt;
if (!cnt) {
    CurrentThread->PriorityFloorSummary ^= 0x400000;
    if (CurrentThread->Priority <= 31) {
        unsigned int newP = KiComputeThreadPriority(CurrentThread, 0);
        if ((int)newP < CurrentThread->Priority)
            KiSetPriorityThread(CurrentThread, &Local, newP);
    }
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Thread A acquires Ppm lock twice (nested) via kernel paths
   – PpmAcquireLock increments PriorityFloorCounts[22] to 2.
2. First PpmReleaseLock call – counter cleared to 0 by vulnerable code.
3. Second PpmReleaseLock call – internal decrement of now-zero counter
   wraps to 0xFF (integer underflow).
4. Summary bit never cleared; scheduler treats thread as permanently
   floor-boosted.


Attack Vector
--------------------------------------------------------------------
A local, already-running user-mode process triggers kernel code paths
that nest PpmAcquireLock / PpmReleaseLock (e.g. through repeated
NtPowerInformation calls or crafted ACPI/ power-policy IOCTLs).  After
the wrap-around the attacker’s thread keeps elevated scheduling
priority, giving it the ability to starve or manipulate higher-
integrity code and gain system privileges.


Patch Description
--------------------------------------------------------------------
• Added explicit reference count handling for PriorityFloorCounts[22].
• Introduced bugcheck safeguard when the counter is unexpectedly zero.
• Clears PriorityFloorSummary bit only when the counter reaches zero.
• Recomputes and lowers the thread’s base priority when the floor is
  removed.
These changes eliminate the unsigned-byte underflow and restore correct
scheduler state.


Security Impact
--------------------------------------------------------------------
Before the fix an attacker could cause PriorityFloorCounts[22] to wrap
from 0 → 255, leaving the thread in a perpetual high-priority state.
This breaks scheduler isolation and can be used to achieve local
Elevation of Privilege.  The bug operates entirely in kernel mode and
bypasses standard integrity-level checks; code-execution is not
required in kernel context, only the ability to invoke affected power
APIs.


Fix Effectiveness
--------------------------------------------------------------------
The patch introduces: 1) counter-underflow detection, 2) safe
post-decrement logic, and 3) recalculation of thread priority.  Because
any future attempt to release a non-owned lock now raises bugcheck
0x157 instead of wrapping, exploitation is effectively blocked.  No
remaining paths in PpmReleaseLock bypass the new checks, so the fix is
considered effective.
