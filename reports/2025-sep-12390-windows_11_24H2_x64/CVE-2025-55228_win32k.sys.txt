{'confidence': 0.11, 'cve': 'CVE-2025-55228', 'date': 1757843691.058951, 'change_count': 10, 'kb': 'KB5065426', 'patch_store_uid': '39e8eb88-5045-4fd8-bb20-53978eb2c087', 'file': 'win32k.sys'}
--------------------------------------------------------------------
CVE-2025-55228 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows kernel graphics subsystem (win32k.sys) – session-management and
call-out dispatch code paths that attach to an arbitrary session /
process (W32* family of helpers).

Vulnerability Class
--------------------------------------------------------------------
CWE-362: Race condition in combination with CWE-416: use-after-free.

Detailed Root Cause Analysis
--------------------------------------------------------------------
Several helper paths that execute graphics / USER call-outs inside an
arbitrary logon session rely on
   W32GetReferencedSessionProcessWithTag(sessionId , Tag)
 to obtain a referenced KPROCESS pointer for the target session.  In
the pre-patch implementation the function:
1.  Took gLock in SHARED mode,
2.  Retrieved a USER/GDI per-session structure by executing
      UserGdi = W32GetUserGdiSessionStateForSession(sessionId);
3.  Released gLock and, still holding only the separate
   gSessionProcessLifetimeLock, copied the process pointer located at
   UserGdi+0x28 (= offset 40) and conditionally referenced it with
   ObfReferenceObjectWithTag.

The function then returned that pointer to the caller
(W32SessionAttachAndCalloutDispatch and several *AttachToSession* code
paths).  The returned pointer is subsequently passed to
   PsAcquireProcessExitSynchronization()
   KeStackAttachProcess()
   KeUnstackDetachProcess()

Unfortunately, the USER/GDI session object that contains the process
pointer can be freed asynchronously as soon as the owning logon session
terminates.  The global gLock used in step (1) does not protect the
memory lifetime of the UserGdi structure once it has been returned – it
only guards the slot array.  Therefore a window exists between the
moment the address is taken and the moment the caller dereferences the
embedded KPROCESS pointer.  A racing thread that logs off / deletes the
session can free the same memory, so the caller works on freed memory
leading to a classic kernel use-after-free.  When the freed region is
re-allocated by attacker-controlled data, that data is treated as a
valid KPROCESS structure and is passed into
KeStackAttachProcess, giving the attacker arbitrary kernel-mode code
execution.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// win32k!W32GetReferencedSessionProcessWithTag   (before patch)
KeEnterCriticalRegion();
ExAcquirePushLockSharedEx(&gLock,0);
UserGdi = W32GetUserGdiSessionStateForSession(sessionId);
...
ExReleasePushLockSharedEx(&gLock,0);
KeLeaveCriticalRegion();     // lifetime of UserGdi no longer guarded

ExAcquirePushLockSharedEx(&gSessionProcessLifetimeLock,0);
proc = *(PVOID *)(UserGdi + 0x28);   // pointer taken from possibly
                                     // freed UserGdi structure
if (proc)
    ObfReferenceObjectWithTag(proc, Tag);
ExReleasePushLockSharedEx(&gSessionProcessLifetimeLock,0);
```
No additional reference is kept on the UserGdi structure itself, so the
window between the two locks enables the race.

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker thread A: rapidly logs off a session (frees UserGdi
   structure).
2. Attacker thread B:
   NtGdi/Dxg/USER system call
   -> W32CalloutDispatchThunk
   -> W32SessionAttachAndCalloutDispatch
   -> W32AttachToSessionAndExecute…
   -> W32GetReferencedSessionProcessWithTag (returns dangling
      KPROCESS pointer)
   -> KeStackAttachProcess( fake_pointer )  => kernel RIP control.

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker running code inside a user session can
start two racing threads: one that continuously terminates and creates
sessions, and another that repeatedly issues the affected graphics /
USER system call.  No special privileges are required beyond the
ability to create sessions (logon), making the issue viable for local
EoP or RCE in services that talk to win32k from a sandbox.

Patch Description
--------------------------------------------------------------------
1. Re-implemented W32GetReferencedSessionProcessWithTag:
   • Accepts an optional out-parameter to return the immutable
     SessionState pointer.
   • Uses W32GetSessionStateForSession (not the volatile UserGdi
     object).
   • Keeps both gLock *and* gSessionProcessLifetimeLock until after a
     reference to the KPROCESS object is safely taken, guaranteeing the
     backing memory cannot disappear.
2. Callers were rewritten to consume the new interface and to perform
   extra validation (session-id sanity checks, bugchecks on -1, NULL
   checks, additional error paths returning STATUS_INVALID_SESSION).
3. Many call-out thunks now bail out with STATUS_GRAPHICS_INVALID if
   the session state or function pointer is missing instead of blindly
   dereferencing.

Security Impact
--------------------------------------------------------------------
A successful race gives the attacker an arbitrary, attacker-supplied
pointer that win32k treats as a valid KPROCESS.  Subsequent
KeStackAttachProcess/KeUnstackDetachProcess operations execute in the
context of that fake process, allowing full kernel-mode arbitrary code
execution.  This yields local privilege escalation to NT AUTHORITY\SYSTEM
and, under specific circumstances (e.g. when the graphics call originates
in a remotely reachable service), remote code execution.

Fix Effectiveness
--------------------------------------------------------------------
The patch closes the lifetime gap by holding both relevant locks while
the KPROCESS is looked up and referenced, and by returning the stable
SessionState pointer to the caller so no subsequent unprotected access
is required.  Additional NULL/invalid-session checks convert what used
to be silent dereferences into controlled STATUS_*
failures.  No further exploitable path is observable in the updated
code; the fix appears effective against the previously described race.
