{'confidence': 0.12, 'change_count': 28, 'file': 'vmcompute.exe', 'date': 1757843834.3014128, 'cve': 'CVE-2025-54092', 'patch_store_uid': '6f7ffb58-b491-40b7-a354-a9c3029dbd45', 'kb': 'KB5065426'}
--------------------------------------------------------------------
CVE-2025-54092 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Hyper-V user-mode service (vmcompute.exe) – specifically the
ComputeServiceModule::PrepareToRunSelf start-up path and the
VmSingletonObject<DmGlobalMemoryBalancer> helper used to obtain the
process-wide DmGlobalMemoryBalancer instance.

Vulnerability Class
--------------------------------------------------------------------
CWE-362: Race Condition  /  CWE-416: Use After Free

Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  ComputeServiceModule::PrepareToRunSelf must obtain a pointer to the
    process-wide DmGlobalMemoryBalancer singleton.  The pre-patch code
    does this as follows:
    • EnterCriticalSection( gm_SingletonLock )
    • if (TryOpenSharedInternal(outPtr))      // stores raw pointer in
      caller-supplied variable
         balancer = *outPtr;
      else
         balancer = OpenSharedInternal();
    • LeaveCriticalSection( gm_SingletonLock )

2.  TryOpenSharedInternal simply returns the current singleton pointer
    without incrementing any reference count; the caller therefore owns
    only a transient reference that is valid **only while the lock is
    held**.

3.  The caller immediately leaves the critical section and stores the
    raw pointer in ComputeServiceModule ( *((_QWORD*)this+32) = balancer
    ).  From this point on there is **no synchronisation** protecting
    the object’s lifetime.

4.  Any concurrent thread that later calls CloseSharedInternal (for
    example when the last VM terminates) can free the singleton.  The
    pointer held by ComputeServiceModule then becomes dangling.  The
    very next line in PrepareToRunSelf –
        DmGlobalMemoryBalancer::Initialize(balancer);
    – dereferences freed memory, producing a classic use-after-free.

5.  Because vmcompute.exe runs as NT AUTHORITY\SYSTEM, a cooperating
    low-privilege process that can influence the VM life-cycle may race
    the singleton shutdown to reclaim the freed memory, inject
    controlled data, and obtain arbitrary code execution in the SYSTEM
    context.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Before
EnterCriticalSection(&VmSingletonLock);
*(_QWORD*)temp = 0;
if (VmSingleton::TryOpenSharedInternal(temp))
    balancer = *(DmGlobalMemoryBalancer**)temp;   // raw pointer
else
    balancer = VmSingleton::OpenSharedInternal();
LeaveCriticalSection(&VmSingletonLock);
...
DmGlobalMemoryBalancer::Initialize(balancer);     // UAF if freed
```
```c
// After
balancer = VmSingleton::OpenShared();  // returns ref-counted object
*((_QWORD*)this+32) = balancer;
...
DmGlobalMemoryBalancer::Initialize(balancer);     // safe
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
ComputeService start
  -> PrepareToRunSelf()
     -> Acquire singleton pointer via TryOpenSharedInternal
        (lock held)
     -> Release lock
     -> Concurrent thread frees singleton
     -> PrepareToRunSelf continues and calls
        DmGlobalMemoryBalancer::Initialize() on dangling pointer
        => use-after-free, attacker-controlled memory possible

Attack Vector
--------------------------------------------------------------------
An authenticated local attacker able to create and tear down virtual
machines or containers quickly can race the ComputeService start-up
sequence, forcing the singleton to be freed after PrepareToRunSelf has
obtained its raw pointer.  By re-allocating the freed memory with
attacker-controlled data, the attacker gains execution in vmcompute.exe
running as SYSTEM, resulting in elevation of privilege.

Patch Description
--------------------------------------------------------------------
1.  Replaced the fragile TryOpenSharedInternal/OpenSharedInternal
    pattern with a single call to VmSingletonObject::OpenShared(), which
    returns a **reference-counted** pointer whose lifetime is guaranteed
    for the caller.
2.  Removed the explicit critical-section block; lifetime is now handled
    internally by OpenShared().
3.  Down-stream code remains unchanged but now operates on a safe
    pointer.

Security Impact
--------------------------------------------------------------------
Prior to the patch, a local administrator or service account could race
ComputeService start-up to achieve a use-after-free inside a SYSTEM
process, leading to arbitrary code execution and full elevation of
privilege.  Because Hyper-V services run with high privileges and have
broad system access, compromise of vmcompute.exe effectively compromises
the host.

Fix Effectiveness
--------------------------------------------------------------------
The new OpenShared() API hides all synchronisation and reference
counting, guaranteeing that the returned DmGlobalMemoryBalancer instance
remains valid for the caller’s lifetime.  The critical section is no
longer needed, eliminating the race window entirely.  No further UAF
condition is observable in the patched code path, so the fix is judged
complete and effective.
