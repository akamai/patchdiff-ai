{'change_count': 32, 'cve': 'CVE-2025-54911', 'file': 'fvevol.sys', 'date': 1757853919.075565, 'patch_store_uid': '090f9405-7989-4bcd-ac06-e37b6069c85a', 'kb': 'KB5065426', 'confidence': 0.29}
--------------------------------------------------------------------
CVE-2025-54911 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows 10/11 kernel-mode driver  fvevol.sys (BitLocker
volume filter) – routine AcquireRequestResources().

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use-After-Free (caused by corrupted heap pointer).

Detailed Root Cause Analysis
--------------------------------------------------------------------
AcquireRequestResources() builds an internal request-context structure
(FVE_REQUEST_CTX in the text below, base held in rsi => v9).  The
structure contains, among other fields:
  offset 0x110 (272)  PVOID   DataBuffer
  offset 0x110 (272)  BYTE    Flags   (bit 4 == cached-pages)
In the pre-patch code those two fields occupied the same physical
bytes.  The pointer is stored with
    *((_DWORD*)v9+68) = 0;            // zero DataBuffer  (0x110)
while the flag is later manipulated via
    v20 = v12 + 272;                  // char * to same location
    *v20 |= 0x10;                     // set cached bit
    *v20 &= ~0x10;                    // clear cached bit
Because the flag logic operates on a single byte, every modification
clobbers the low byte of the 64-bit DataBuffer pointer.  When the
pointer is subsequently freed or dereferenced (e.g. in the error path
around LABEL_78 and the normal completion path in
FveReleaseRequest()), the driver uses a value that may already have
been:
  • overwritten with 0x00/0x10, or
  • previously released by ExFreePool/IoFreeMdl.
This produces a classic UAF window: the pool block can be reclaimed by
an attacker and later operated on by fvevol.sys with kernel privileges.

Key parameters/structures affected
  – FVE_REQUEST_CTX::DataBuffer        (offset 0x110)
  – FVE_REQUEST_CTX::Flags.cached      (same address pre-patch)
  – pool block allocated via ExAllocatePool2 / lookaside list.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// pre-patch – pointer and flag share the same byte(s)
*((_DWORD*)v9 + 68) = 0;      // zero pointer (offset 0x110)
v20 = v12 + 272;              // char * to same offset
*v20 |= 0x10u;                // set flag -> clobbers pointer LSB
...
// post-patch – fields separated
*((_QWORD*)v9 + 34) = 0i64;   // 8-byte pointer at 0x110
v12[276] = 1;                 // flag moved to 0x114 (no overlap)
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User code issues IOCTL / IRP that causes fvevol!AcquireRequestResources.
2. Function allocates FVE_REQUEST_CTX (ExAllocateFromNPagedLookasideList).
3. IoGetFsTrackOffsetState succeeds -> cached-pages path chosen.
4. Flag bit 0x10 is set/cleared on *(ctx+0x110).
5. Later, error or completion path frees DataBuffer using the now
   corrupted pointer, or continues to access it, producing UAF.

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker sends a crafted sequence of BitLocker
IOCTLs that force the cached-pages branch, trigger an error path that
frees the buffer, and then re-uses the freed request structure,
allowing controlled memory to be operated on at kernel IRQL.

Patch Description
--------------------------------------------------------------------
1. Split the overlapped field:
     • DataBuffer remains at 0x110 but expanded to 8-byte store
       (`*((_QWORD*)v9 + 34)`)
     • Flags.cached moved to 0x114 (`v12[276]`).
2. All flag operations changed to use the new offset – no more pointer
   modification via bitmask.
3. Auxiliary tidy-ups:   variable types widened, boolean tracking via
   int, early initialisation changes – all related to the same layout
   correction.

Security Impact
--------------------------------------------------------------------
By re-allocating the freed pool block, an attacker can gain arbitrary
kernel read/write, leading to local privilege escalation to SYSTEM
(confirmed by Microsoft: "Elevation of Privilege").

Fix Effectiveness
--------------------------------------------------------------------
The patch eliminates field overlap; flag writes can no longer corrupt
DataBuffer, thereby preventing misuse of freed memory. No further code
paths write to the pointer location after free, so the UAF condition
is fully addressed.
