{'patch_store_uid': 'db16e4dd-e112-4254-a2f9-acf951479205', 'cve': 'CVE-2025-54093', 'kb': 'KB5065426', 'file': 'tcpip.sys', 'date': 1757843800.5304034, 'change_count': 1153, 'confidence': 0.63}
--------------------------------------------------------------------
CVE-2025-54093 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows TCP/IP driver (tcpip.sys) – IPsec / WFP processing path.
The vulnerable routine was originally named IPsecInsertInSaList(); it
has been replaced in the update by the new helper
CheckConnectBypass().

Vulnerability Class
--------------------------------------------------------------------
Time-of-check Time-of-use (TOCTOU) race that leads to an arbitrary
kernel memory overwrite (linked-list corruption / elevation of
privilege).

Detailed Root Cause Analysis
--------------------------------------------------------------------
The former IPsecInsertInSaList() function is responsible for adding a
Security Association (SA) element into an internal doubly-linked list
located at (a1 + 32).  The routine first tries to obtain a 24-byte
buffer via:
    v6 = WfpPoolAllocNonPaged(24, TAG, a3);
The pointer is stored in v6/v7.  The subsequent branch, however, is
inverted:
    if (v6)            // allocation **succeeded**
        WfpReportErrorIPSec(v6, ...);  // treats it as failure
    else               // allocation **failed** (v6 == NULL)
        insert into list using *a3;

Because of this logic error, the function proceeds to manipulate the
linked list even when no kernel buffer was obtained.  Instead, it uses
the caller-supplied pointer *a3 as the list entry.  Nothing guarantees
that *a3 is a valid kernel address; a local attacker can supply a
pointer to user-controlled memory.

The following writes are then performed while holding the SA list
spin-lock:
    *(QWORD*)(*a3)      = a2;            // store context
    *(QWORD*)(*a3+16)   = v8;            // Blink
    *(QWORD*)(*a3+8)    = a1+32;         // Flink
    v8->Flink           = (*a3)+8;
    (a1+40)             = (*a3)+8;

Because both Flink and Blink fields are written with attacker-chosen
addresses, an arbitrary 16-byte kernel overwrite is achieved.  The
overwrite occurs after the initial pointer check (time-of-check) but
before the list lock is released (time-of-use), so a rapid change of
*a3 between user-mode and kernel-mode mappings turns the bug into a
classic TOCTOU scenario.

By arranging the overwritten pointers to target a token or callback
function, the attacker can elevate privileges to SYSTEM.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// simplified from the pre-patch routine
v6 = WfpPoolAllocNonPaged(24, 0x654C5349, a3);
if (v6)                                  // WRONG – success treated as error
{
    WfpReportErrorIPSec(v6, "IPsecInsertInSaList", 2153);
}
else                                      // v6 == NULL, no buffer!
{
    IPSecAcquireLockItomIf(a1, &lock);

    *(_QWORD*)*a3        = a2;            // arbitrary write #1
    v8                   = *(_QWORD**)(a1+40);
    v9                   = (_QWORD*)(*a3 + 8);

    *(_QWORD*)(*a3+16)   = v8;            // arbitrary write #2
    *v9                  = a1 + 32;       // arbitrary write #3
    *v8                  = v9;            // arbitrary write #4
    *(QWORD*)(a1+40)     = v9;

    IPSecReleaseLockItomIf(v9, &lock);
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Local attacker invokes a user-visible API that eventually inserts a
   new IPsec SA.
2. Attacker passes a crafted buffer where *a3 points to controlled
   user-space memory.
3. Allocation succeeds; v6 != NULL; function treats this as failure and
   returns – no issue.
4. Attacker races the call so allocation fails (v6 == NULL) – common
   under memory pressure.
5. Function proceeds to write Flink/Blink pointers into the supplied
   address, corrupting arbitrary kernel memory and gaining EoP.

Attack Vector
--------------------------------------------------------------------
Local, authenticated user.  Exploitation requires the ability to start
or modify an IPsec connection (available to ordinary users on most
editions).  No special privileges beyond local log-on are necessary.

Patch Description
--------------------------------------------------------------------
The vendor deleted IPsecInsertInSaList() altogether and introduced
CheckConnectBypass().  Key hardening steps:
1. All temporary storage is now allocated on the stack or obtained via
   trusted helpers; the caller no longer provides a raw list entry.
2. The success path is gated on explicit success codes; NULL allocations
   are never dereferenced.
3. WfpReportError() is called only on genuine failure paths.
4. The routine builds a temporary, fully validated structure and copies
   it to the caller buffer only after all checks pass, eliminating the
   TOCTOU window.
5. Any heap objects allocated during processing are freed on every exit
   path, preventing leaks.

Security Impact
--------------------------------------------------------------------
Prior to the fix, a local attacker could achieve an arbitrary 16-byte
kernel overwrite, leading to elevation of privilege to SYSTEM.  The
vulnerability is tracked as CVE-2025-54093 and is rated Important.

Fix Effectiveness
--------------------------------------------------------------------
The flawed allocation check no longer exists; the kernel never writes
into caller-supplied addresses.  All memory accesses are either to
stack buffers or to objects returned by kernel allocators and fully
validated before use.  No uncontrolled list manipulations remain, so
the original exploit vector is closed.

