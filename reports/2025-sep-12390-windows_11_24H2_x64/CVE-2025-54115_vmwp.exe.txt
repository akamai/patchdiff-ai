{'change_count': 30, 'kb': 'KB5065426', 'confidence': 0.11, 'date': 1757843691.4850814, 'cve': 'CVE-2025-54115', 'file': 'vmwp.exe', 'patch_store_uid': 'aa6cdbf6-89a6-44dd-b063-2bfd0d522b3b'}
--------------------------------------------------------------------
CVE-2025-54115 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Hyper-V worker process (vmwp.exe) – class GmoMigration, function
DoMemoryTransferPass().  Code runs in the host context and is executed
when a live-migration source VM begins a memory-transfer pass.


Vulnerability Class
--------------------------------------------------------------------
CWE-362: Concurrent execution using shared resource with improper
synchronisation (race condition) leading to memory corruption / pointer
confusion.


Detailed Root Cause Analysis
--------------------------------------------------------------------
GmoMigration keeps a large per-migration object whose members are
indexed by fixed offsets.  Several of these members are concurrently
accessed by the main migration thread and by a thread-pool timer
callback that periodically reports progress.

The vulnerable version mis-calculated the field indices when it
initialised the object at the start of every memory-transfer pass:

  * m_UpdateProgressTimer   was at QWORD offset 47,            but code
    used offset 48.
  * m_MigrationSource       was at QWORD offset 49,            but code
    stored the pointer in offset 50.
  * m_Statistics fields     were zeroed in the wrong order,     causing
    a transient overlap with the two pointers above.

As a consequence the following happened in real time:

1. Main thread passes *(this+48) – i.e. a future statistics slot – to
   SetThreadpoolTimer().  The thread-pool infrastructure believes this
   value is a valid PTP_TIMER pointer and will later dereference it on
   a worker thread.
2. A few instructions later the same memory location *(this+48) is
   cleared to zero or overwritten with other data by the same function
   or by another thread that legitimately updates statistics.
3. When the timer expires the worker thread dereferences the stale /
   corrupted pointer, leading to use-after-free or arbitrary pointer
   dereference inside the vmwp.exe process.

Because the corruptible field is attacker-controlled through the live
migration API (e.g. size-related statistics or the
WorkerTaskMigrationSource pointer), a user with the ability to start a
migration can race the two threads and supply a crafted value that is
later treated as a kernel-mode function pointer, resulting in
escalation to the privilege level of the Hyper-V host worker process.

No locks protect the shared fields; the bug is therefore a classic
race between the migration control path and the asynchronous timer
callback.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable initialisation sequence (simplified)
*((_QWORD*)this + 51) = 0;          // stats
*((_QWORD*)this + 52) = 0;          // stats
*((_QWORD*)this + 53) = 0;          // stats
*((_QWORD*)this + 46) = 0;          // stats
*((_QWORD*)this + 47) = 0;          // stats
*((_QWORD*)this + 50) = a3;         // SHOULD have been +49
SetThreadpoolTimer(*((PTP_TIMER*)this + 48), &Due, 0x1F4, 0);
```

```c
// corrected sequence
*((_QWORD*)this + 52) = 0;
*((_QWORD*)this + 53) = 0;
*((_QWORD*)this + 51) = 0;
*((_QWORD*)this + 50) = 0;          // zero statistics slot first
*((_QWORD*)this + 46) = 0;
*((_QWORD*)this + 49) = a3;         // correct destination
SetThreadpoolTimer(*((PTP_TIMER*)this + 47), &Due, 0x1F4, 0);
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker (tenant admin) initiates VM live migration.
2. Hyper-V worker executes GmoMigration::DoMemoryTransferPass().
3. Function calls SetThreadpoolTimer() with wrong field address.
4. Main thread or attacker-controlled data overwrites same location
   before timer fires.
5. Timer callback executes on pool thread, dereferences corrupted
   pointer and jumps to attacker-controlled address.


Attack Vector
--------------------------------------------------------------------
Local attacker with the ability to manage VMs (or code running inside a
privileged guest) triggers multiple fast consecutive migration passes,
forcing the mis-initialisation and racing the timer callback to gain
control of the corrupted field.


Patch Description
--------------------------------------------------------------------
The fix re-aligns all member-offset references:

1. Correct timer pointer index: +48  -> +47.
2. Correct migration-source pointer index: +50 -> +49.
3. Zeroes the old slot (+50) before reuse to eliminate stale data.
4. Reorders zeroing of statistics fields so no live pointer is ever
   overwritten after SetThreadpoolTimer is armed.

No additional locking was required once the structure layout was used
consistently.


Security Impact
--------------------------------------------------------------------
Prior to the patch a local authorised attacker could achieve elevation
of privilege on the Hyper-V host.  By racing the progress-timer thread
against the migration control thread the attacker could cause
vmwp.exe to execute with a corrupted function pointer, providing
arbitrary code execution in the system context.


Fix Effectiveness
--------------------------------------------------------------------
The fix removes the shared-memory overlap and therefore eliminates the
possibility of concurrently modifying the pointer used by the timer
callback.  Without an overlapping field there is no longer a race
window, so the described privilege-escalation path is closed.
--------------------------------------------------------------------