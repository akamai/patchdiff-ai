{'kb': 'KB5065426', 'change_count': 31, 'confidence': 0.21, 'date': 1757843558.1665506, 'file': 'lsasrv.dll', 'patch_store_uid': '088c2266-2443-4e1a-9bb7-fdeb31b20e02', 'cve': 'CVE-2025-54894'}
--------------------------------------------------------------------
CVE-2025-54894 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows – Local Security Authority Sub-System Service  
(lsasrv.dll).  The vulnerable logic resides in  
  • LsapWinRtCaptureClientAuthIdentity()  
  • NegpCaptureSuppliedCreds()  
  • SspiExAcquireCredentialsHandle()

Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow / out-of-bounds write (CWE-122).

Detailed Root Cause Analysis
--------------------------------------------------------------------
NegpCaptureSuppliedCreds() receives a comma-separated list of security
package names from an unprivileged caller (RPC/LSA LPC).  The routine
first counts the number of names (variable ‘v48’ in the original
listing) and allocates an array of 8-byte pointers with a size of
    8 * v48 bytes.

Later, while it iterates over the list, the code may insert additional
entries that were **not** included in the initial count:
  • names preceded by ‘!’ or ‘-’ cause a second pass that may add the
    same package again;  
  • packages having the 0x40 (NEG_PACKAGE_SKIPEXT) flag cause the
    function to enumerate the global NegPackageList and append further
    packages that satisfy the requested negotiation flags.

Because the allocation was based solely on the original token count,
writing these extra pointers overruns the heap buffer (`v99->Children`)
allocated for the pointer array.  The write primitive is reachable in
user mode and is performed in the LSASS process under SYSTEM, leading to
memory corruption and potential elevation of privilege.

Additional issues fixed in the same patch set:  
– LsapWinRtCaptureClientAuthIdentity lacked several size checks when it
  decrypted and re-marshalled supplied _SEC_WINNT_AUTH_IDENTITY_EX2
  blobs.  Incorrect size tracking could propagate malformed lengths into
  NegpCaptureSuppliedCreds, aggravating the overwrite window.  
– SspiExAcquireCredentialsHandle relied on the unsafe helper routines
  above and therefore inherited the overflow.

Key conditions that trigger the overflow:  
1. Caller supplies a credential buffer with ADT 512 (supplied creds).  
2. `v18 & 1` is set so that the caller-supplied string is treated as
   Unicode.  
3. The comma-separated list contains enough specially-prefixed entries
   to make the second enumeration loop add >NegPackageCount elements.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// original (simplified)
packageCount = v48;                       // number of parsed tokens
credArray = LsapAllocate(8 * packageCount);
...
for (each token) {
    if (needExtraPackage)
        credArray[cur++] = extraPkg;      // <- no bounds check
}
```

```c
// patched
if (wil::details::FeatureImpl<...>::IsEnabled() && j >= NegPackageCount)
{
    status = SEC_E_BUFFER_TOO_SMALL;      // -2146892963
    goto cleanup;
}
credArray[j++] = pkg;
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Unprivileged client calls LsaLogonUser / AcquireCredentialsHandle and
   provides a crafted buffer.  
2. SspiExAcquireCredentialsHandle() ➜ NegpCaptureSuppliedCreds().  
3. NegpCaptureSuppliedCreds() parses the comma list, allocates an
   undersized array, then appends additional packages (flags 0x40 / ‘!’
   / ‘-’).  
4. Out-of-bounds write corrupts LSASS heap memory ➜ code execution under
   SYSTEM.

Attack Vector
--------------------------------------------------------------------
Local attacker with the ability to call LSA APIs (e.g., via the SSPI /
LogonUser or S4U interfaces) sends a malicious credential buffer to
LSASS.  No administrative rights are required.

Patch Description
--------------------------------------------------------------------
1. Introduced a running index variable (‘j’) that is compared against
   the **actual capacity (NegPackageCount)** before every write to the
   array.  Exceeding the limit now returns SEC_E_BUFFER_TOO_SMALL.  
2. Added additional size/length validation in
   LsapWinRtCaptureClientAuthIdentity(): – verified offsets and lengths
   of embedded strings, – converted several signed variables to
   unsigned, – guarded allocations and frees with correct sizes.  
3. Updated SspiExAcquireCredentialsHandle() to use the safer helper
   routines and correctly propagate the new error codes.

Security Impact
--------------------------------------------------------------------
Prior to the patch an attacker could corrupt heap metadata or adjacent
objects inside the LSASS process, leading to elevation of privilege to
SYSTEM and possible escape of AppContainer / sandbox boundaries.

Fix Effectiveness
--------------------------------------------------------------------
The added capacity check prevents any write when the computed index
would exceed the allocated element count, fully neutralising the
overflow.  Additional validation in helper routines removes secondary
paths that could still inject malformed length fields.  No residual
unsafe writes were observed in the patched code.
