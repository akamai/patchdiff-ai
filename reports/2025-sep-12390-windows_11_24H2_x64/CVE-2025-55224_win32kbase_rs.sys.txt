{'confidence': 0.3, 'change_count': 6, 'cve': 'CVE-2025-55224', 'kb': 'KB5065426', 'file': 'win32kbase_rs.sys', 'patch_store_uid': 'bf8a92b5-8b0d-4ffa-9845-95aacec6031e', 'date': 1757843961.2844994}
--------------------------------------------------------------------
CVE-2025-55224 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Win32k (win32kbase_rs.sys) – Region (GDI region / rgncore) handling
routines:  
• rgncore::RegionCore::set_to_scans_from()  
• rgncore::RegionCore::subtract()  
• rgncore::fill_path::<impl RegionCore>::fill_path_with_outline_generic()  
• rgncore::RegionCore::combine()


Vulnerability Class
--------------------------------------------------------------------
• CWE-362 – Race Condition (concurrent access to shared RegionCore
  buffers)  
• CWE-416 – Use-After-Free / stale-pointer dereference after concurrent
  resize failure


Detailed Root Cause Analysis
--------------------------------------------------------------------
RegionCore objects keep an array of 32-bit scan descriptors allocated by
RawVecInner<T>::try_reserve().  When memory growth fails the allocator
returns the sentinel value 0x8000000000000001 to signal
STATUS_NO_MEMORY, **not** a usable pointer.

1. Old code (combine / subtract / fill_path) called
   RawVecInner::try_reserve() or finish_grow().
2. If the allocator returned the sentinel, the functions continued to
   treat the ‘new buffer’ fields as valid.  Typical pattern:
     if (try_reserve(...) != 0x8000000000000001) { ok } else {
         if (Feature_IsEnabled())
             set_to_scans_from_no_resize(dst, src);  // keeps pointer
         else
             set_to_scans_from(dst, src);           // may *free* & re-
   allocate the buffer
     }
3. While the current thread still holds **references taken before the
   failed grow**, set_to_scans_from() could free the old array and place
   it in the look-aside list.  Another CPU may subsequently reuse the
   pool item, so the stored RegionCore pointer becomes dangling.
4. Later loops ( e.g. subtract’s wall-copy loop or
   fill_path_with_outline_generic’s poly-line construction ) iterate
   through the stale pointer, reading or writing freed memory.  Because
   the memory can be re-assigned concurrently, crafted data can be
   pivoted into controlled code-execution gadgets.

Trigger parameters / structures
• RegionCore header: [size, capacity, ptr] at +0x08 .. +0x18  
• Scan tables referenced from +0x08  
• RawVecInner<Scan> sentinel: 0x8000000000000001

A small Region that deliberately exhausts the look-aside list forces
finish_grow() to fail, schedules a second thread that reuses the scan
pool entry, and re-enters the vulnerable loop – winning the race and
causing a write-primitive inside freed memory.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// combine (before)
if (try_reserve(dst, old_len, need, 4,4) == 0x8000000000000001ULL) {
    if (Feature_IsEnabled())
        set_to_scans_from_no_resize(dst, src);
    else if (set_to_scans_from(dst, src))      // may realloc & free
        return 1;                              // stale ptr left alive
}
```

```c
// set_to_scans_from (before)
alloc::finish_grow(..,&v36);
if (v36 == 1) {
    v15 = 0x8000000000000001;    // *error* kept in v15
    goto LABEL_29;               // later used as size/pointer
}
```

```c
// subtract (before)
if (alloc::finish_grow(..) == 1) {
    // growth failed, but code continues using v37 as new buffer
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
User → NtGdiCombineRgn / NtGdiFillPath / NtGdiExtCreateRegion  →  
win32k!RGNOBJ::bCombine → RegionCore::combine() →  
RawVecInner::try_reserve()  →  failure sentinel propagated  →  
set_to_scans_from(_no_resize) frees or reuses the same scan array  →  
loop in subtract/fill_path uses stale pointer → memory corruption / RCE.


Attack Vector
--------------------------------------------------------------------
Local, from a low-integrity or sandboxed process that can issue win32k
GDI region API calls.  No special privileges are required; a malicious
PDF/EMF rendered via GDI in a remote browsing context can exercise the
race.


Patch Description
--------------------------------------------------------------------
1. In set_to_scans_from() the grow-failure path now returns immediately
   (error 14) instead of continuing with the sentinel.  Additional upper
   bound checks ( v8 > 0x3FFFFFFFFFFFFFFF ) were added.
2. combine() reworked: on allocation failure it *always* calls
   set_to_scans_from_no_resize(); the branch that could reallocate while
   stale references exist was removed.
3. subtract() / fill_path_with_outline_generic() now abort on every
   alloc-failure; they no longer use the possibly invalid buffer.  Large
   blocks of defensive bounds-checks were inserted.
4. All touched functions validate index vs. capacity before every access
   (numerous panic_bounds_check insertions).


Security Impact
--------------------------------------------------------------------
Prior to the patch an attacker could:
• Obtain an arbitrary use-after-free of region-scan arrays shared across
  threads.  
• Race the look-aside allocator to re-fill the freed pool block with
  controlled data, leading to out-of-bounds reads/writes.  
• Escalate to kernel-mode RCE from a sandboxed process (confirmed by
  Microsoft: CVE-2025-55224, CVSS 8.8).


Fix Effectiveness
--------------------------------------------------------------------
The patched code propagates allocation errors instead of ignoring the
sentinel, removes the re-allocation race path, and enforces strict
bounds checks before every scan access.  No stale pointer is left after
failure, eliminating the UAF window.  The fix is effective assuming all
call-sites adopt the new early-return logic.
