{'file': 'vhdmp.sys', 'cve': 'CVE-2025-54112', 'date': 1757843498.1917422, 'change_count': 33, 'patch_store_uid': 'b9f0560e-8f82-438f-81bf-95574d46a204', 'kb': 'KB5065426', 'confidence': 0.18}
--------------------------------------------------------------------
CVE-2025-54112 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows kernel-mode driver vhdmp.sys (Virtual Hard Disk
(VHD) Mini-Port – Win32k storage stack) responsible for IO tracking
and surface management for virtual hard-disk files.

Vulnerability Class
--------------------------------------------------------------------
Race-condition–driven Use-After-Free (CWE-416).  A shared rundown
reference counter protecting the per-disk IO-tracking structure was
manipulated non-atomically, allowing the structure to be freed while
still referenced.

Detailed Root Cause Analysis
--------------------------------------------------------------------
The per-disk structure VHD_IO_TRACKER is protected through a kernel
rundown reference (EX_RUNDOWN_REF  RunRef = &VirtualDisk->IoTracker).
Two helper routines manage the lifetime of this tracker:

  • VhdmpiActivateIoTracking()   –  increments RunRef->Count and, on
    the first reference, initialises per-CPU state.

  • VhdmpiDeactivateIoTracking() –  decrements RunRef->Count and, once
    the last reference is released, re-initialises the rundown object
    so that ExWaitForRundownProtectionRelease() will succeed.

Before the patch both functions updated the 32-bit field
RunRef[3].Count with plain C operators:
    ++LODWORD(RunRef[3].Count);
    LODWORD(RunRef[3].Count)--;

Although the update is performed while holding a passive-level lock
(&RunRef[1]), other CPUs may still touch the same field when calling
ExAcquireRundownProtection(), because that fast-path is executed
without taking the passive lock.  Consequently the following race is
possible:

1. CPU-0            : enters DeactivateIoTracking() and executes
                      "RunRef[3].Count--", which brings the value to
                      zero and re-initialises the rundown object.
2. CPU-1 (almost
   simultaneous)    : executes ExAcquireRundownProtection().  Because
                      Count is now zero the rundown completes and
                      the memory occupied by VHD_IO_TRACKER (and the
                      underlying VHD_SURFACE) can be freed.
3. CPU-1 continues  : still holds a pointer to the freed object and
                      later dereferences it, leading to a classic
                      use-after-free in kernel mode.

An attacker able to trigger frequent Activate/Deactivate operations
(e.g. by opening/closing a diff-chain VHD from multiple threads) can
reliably hit the window and obtain arbitrary kernel-mode read/write
capabilities, escalating to SYSTEM.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – non-atomic manipulation
VhdmpiActivateIoTracking:
  if (++LODWORD(RunRef[3].Count) == 1) { ... }

VhdmpiDeactivateIoTracking:
  if (LODWORD(RunRef[3].Count)-- == 1)
      ExReInitializeRundownProtection(RunRef);

// after patch – atomic manipulation
  if (_InterlockedIncrement((volatile LONG*)&RunRef[3]) == 1) { ... }
  ...
  if (_InterlockedExchangeAdd((volatile LONG*)&RunRef[3], -1) == 1)
      ExReInitializeRundownProtection(RunRef);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User-mode code opens a VHD and issues IOCTLs that cause
   VhdmpiActivateIoTracking() / VhdmpiDeactivateIoTracking() to be
   called from multiple threads.
2. Two CPUs race on the non-atomic ++/-- instructions.
3. One CPU re-initialises the rundown object while the other still
   believes it owns a reference.
4. VHD_IO_TRACKER and child VHD_SURFACE are freed by the rundown
   completion path.
5. The stale pointer kept by the losing CPU is dereferenced inside a
   subsequent I/O path (e.g. VhdmpiProcessEventInsert), corrupting
   kernel memory.

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker.  No special privileges are required
beyond the ability to open a virtual hard-disk file (CreateFile on
.vhd / .vhdx), which is granted to standard users.  A stress program
can hammer opens/closes or snapshot operations on multiple cores to
hit the race.

Patch Description
--------------------------------------------------------------------
1. Both ++ and -- on RunRef[3] are replaced with the corresponding
   Interlocked* intrinsics, guaranteeing atomicity with respect to
   ExAcquireRundownProtection().
2. Additional synchronisation aids were added:
   – VhdmpiDecoupleVirtualDiskSurface now waits on a per-surface
     KEVENT to make sure no thread is inside the surface while it is
     being destroyed.
   – Several paths raise and lower reference counts with
     InterlockedAdd/InterlockedIncrement.
3. Defensive waits (KeWaitForSingleObject) are introduced for builds
   where Feature_H2E_WPA3SAE private flag is enabled.

Security Impact
--------------------------------------------------------------------
Prior to the patch the reference count could drop to zero while still
referenced, resulting in freed memory being reused and later
accessed.  An attacker could:
• Corrupt adjacent pool data structures, leading to arbitrary kernel
  read/write.
• Execute code in kernel context and elevate privileges to SYSTEM.
The issue is therefore classified as an Elevation-of-Privilege in the
Windows kernel.

Fix Effectiveness
--------------------------------------------------------------------
The updated driver converts all reference-count manipulations to
atomic interlocked operations, closing the race window between the
rundown fast-path and Activate/Deactivate routines.  Additional
synchronisation points (KEVENT waits) ensure surfaces cannot be
freed while still accessed.  No remaining non-atomic updates to
RunRef->Count were located, so the fix is considered effective.
