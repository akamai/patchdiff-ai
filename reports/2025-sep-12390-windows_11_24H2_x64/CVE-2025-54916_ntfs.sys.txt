{'file': 'ntfs.sys', 'cve': 'CVE-2025-54916', 'change_count': 149, 'date': 1757843784.2419298, 'confidence': 0.12, 'kb': 'KB5065426', 'patch_store_uid': '1dc2f3fb-6383-4814-a8d5-7d77b86b8669'}
--------------------------------------------------------------------
CVE-2025-54916 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
ntfs.sys – helper routine MoveAttributeToOwnRecord()


Vulnerability Class
--------------------------------------------------------------------
Stack-based buffer overflow (CWE-121)


Detailed Root Cause Analysis
--------------------------------------------------------------------
MoveAttributeToOwnRecord() moves an NTFS attribute list entry from one
MFT record to a newly cloned record.  While doing so the function must
copy the attribute’s name string.  The name length (bytes to copy) is
stored in variable “v11” and may be larger than 0x10 bytes. 

1.  The code declares a 16-byte stack buffer `v87` and initialises a
    pointer `PoolWithTag` to this buffer:
       PoolWithTag = v87;

2.  When the name is longer than 0x10 the code attempts to obtain
    dynamic memory:
       if (v11 > 0x10u)
           PoolWithTag = ExAllocatePoolWithTag(...);

3.  The return value of ExAllocatePoolWithTag() is **not checked**.  If
    the allocation fails the pointer remains NULL.  Immediately after
    the branch the following copy is performed, using the unvalidated
    pointer and the untrusted length:
       memmove(PoolWithTag, &Src[NameOffset], v11);

4.  Two failure scenarios therefore exist:
      • Allocation succeeds but the length is still >0x10 – copy writes
        beyond the fixed 16-byte fallback buffer.
      • Allocation fails – copy is performed to address 0x0 leading to
        an access violation.

Because the overflow is on the stack and the attacker fully controls
both the copied data and its length (via the on-disk $ATTRIBUTE_LIST
entry), arbitrary code can be executed in kernel context when the file
system processes the crafted record.

Affected structures / fields
  – ATTRIBUTE_LIST_ENTRY.NameLength
  – local stack buffer `v87[16]` in MoveAttributeToOwnRecord()
  – pointer `PoolWithTag`


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – MoveAttributeToOwnRecord
PoolWithTag = v87;               // 16-byte stack buffer
Srca[1]  = v87;
if (v11 > 0x10u) {
    PoolWithTag = ExAllocatePoolWithTag(PagedPool, v11, 'NtfA');
    Srca[1]     = PoolWithTag;   // may be NULL on failure
}
memmove(PoolWithTag,            // unchecked destination
        &Src[NameOffset],       // attacker-controlled source
        v11);                   // attacker-controlled length
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User supplies a crafted disk image / remote SMB share containing an
   MFT record whose $ATTRIBUTE_LIST entry has:
     – NameLength > 0x10
     – Data that overflows target buffer
2. NTFS mounts / accesses the record.
3. NtfsMoveFileRecord triggers MoveAttributeToOwnRecord().
4. ExAllocatePoolWithTag() returns NULL (or overflow length > 0x10).
5. memmove() overruns 16-byte stack buffer → corruption / RCE.


Attack Vector
--------------------------------------------------------------------
Local or remote attacker places a malicious NTFS image (e.g. VHD,
USB-stick, or network share) that is mounted by Windows.  No additional
privileges are required; code runs in kernel context once the crafted
record is parsed.


Patch Description
--------------------------------------------------------------------
The new version still allocates a temporary buffer but rewrites the
whole routine and propagates allocation failure back to the caller.
Key fixes:
 1. Result of ExAllocatePoolWithTag() is validated.  When the call
    fails the function aborts with STATUS_INSUFFICIENT_RESOURCES
    instead of copying.
 2. Copy length is now bounded by the size of the destination buffer –
    dynamic if allocation succeeded, 16 bytes otherwise.
 3. Many auxiliary pointer/size calculations were converted from
    16-bit to 32-bit to prevent inadvertent truncation.


Security Impact
--------------------------------------------------------------------
Prior to the patch an attacker could reliably achieve arbitrary kernel
memory corruption and thus execute arbitrary code (RCE) or trigger a
system crash (DoS).  Successful exploitation yields kernel-level
privileges and compromises the entire operating system.


Fix Effectiveness
--------------------------------------------------------------------
Code paths that copy the attribute name now bail out when the allocation
fails and never copy more than the buffer can accommodate.  No further
unchecked memmove() using attacker-controlled length remains.  The
stack overflow condition is therefore effectively removed.
