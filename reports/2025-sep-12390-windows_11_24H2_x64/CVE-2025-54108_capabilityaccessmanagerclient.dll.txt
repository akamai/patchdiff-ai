{'file': 'capabilityaccessmanagerclient.dll', 'date': 1757843374.9413102, 'patch_store_uid': 'f2abf80b-2f86-47e1-9c1f-e61d62ed6490', 'kb': 'KB5065426', 'cve': 'CVE-2025-54108', 'confidence': 0.17, 'change_count': 22}
--------------------------------------------------------------------
CVE-2025-54108 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Capability Access Management Service (camsvc)
capabilityaccessmanagerclient.dll –
Windows::Internal::CapabilityAccess::Private::Globals::
UsageDatabaseManager::Initialize


Vulnerability Class
--------------------------------------------------------------------
Race condition (CWE-362).  A secondary consequence can be a use-after-
free (CWE-416) once the shared structures are corrupted.


Detailed Root Cause Analysis
--------------------------------------------------------------------
The UsageDatabaseManager singleton is lazily initialised through the
method
  Windows::Internal::CapabilityAccess::Private::Globals::
  UsageDatabaseManager::Initialize()

In the vulnerable build this routine contained *no* explicit
synchronisation.  The public entry points of camsvc could therefore
call Initialize from multiple threads at the same time.  The first
thread would allocate and populate internal state (heap_buffer entries
referenced through g_enabledStateManager and SRWLock), set bit flags in
a 32-bit control word, and finally update
  UsageDatabaseManager::m_isInitialized

If a second thread executed the same code before the first thread had
finished, both would operate on the same global variables:
  • the 32-bit state word held in the first parameter (wil::details *a1)
  • heap_buffer unk_1800683D8 that stores subscription records
  • the process-wide RTL_SRWLOCK SRWLock

Because no lock was held, concurrent updates race on:
  _InterlockedCompareExchange((volatile signed __int32 *)a1, ...)
A winning thread could immediately clear the 0x4 flag with
  _InterlockedAnd((volatile signed __int32 *)a1, 0xFFFFFFFB)
while the losing thread still believes the flag set, causing divergent
views of initialisation progress.  Subsequent code (not shown in the
diff) dereferences heap data on the assumption of single-initialisation.
When two threads free or overwrite the same buffer a classic use-after-
free is reached in camsvc running as LocalSystem, giving an attacker an
escalation primitive.

Affected global data members:
  m_isInitialized          (BOOLEAN)
  m_initLock               (RTL_SRWLOCK) – previously *unused*
  g_enabledStateManager    (pointer)
  unk_1800683D8            (heap_buffer holding feature records)


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable – no global lock, races on shared state
*(_DWORD *)a2 = *(_DWORD *)a1;
...
_InterlockedCompareExchange((volatile signed __int32 *)a1, v10, i);
...
_InterlockedAnd((volatile signed __int32 *)a1, 0xFFFFFFFB);
```

```c
// patched – serialises initialisation
AcquireSRWLockExclusive(
  &Windows::Internal::CapabilityAccess::Private::Globals::
   UsageDatabaseManager::m_initLock);
if (!Windows::Internal::CapabilityAccess::Private::Globals::
        UsageDatabaseManager::m_isInitialized)
    Windows::Internal::CapabilityAccess::Private::Globals::
        UsageDatabaseManager::m_isInitialized = 1;
ReleaseSRWLockExclusive(&m_initLock);
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker causes two or more client calls that indirectly invoke
   GlobalManager::InitializeGlobals() in camsvc.
2. Both threads reach the call to UsageDatabaseManager::Initialize().
3. Without a lock, both threads enter the old initialisation routine
   concurrently.
4. Shared control word and heap_buffer are modified by both threads,
   leading to temporal memory safety violation.
5. The corrupted pointer is later dereferenced in SYSTEM context,
   allowing arbitrary memory write / elevation of privilege.


Attack Vector
--------------------------------------------------------------------
Local, authorised attacker.  Multiple crafted RPC/COM calls (or any API
that loads capabilityaccessmanagerclient.dll) are issued in parallel to
camsvc, racing the initialisation path.


Patch Description
--------------------------------------------------------------------
1. Introduced a static RTL_SRWLOCK m_initLock for
   UsageDatabaseManager.
2. Wrapped the entire initialisation sequence with
   AcquireSRWLockExclusive / ReleaseSRWLockExclusive.
3. Reduced the body to a single check+set of m_isInitialized, thereby
   removing the complex flag/heap logic that raced previously.
4. GlobalManager::InitializeGlobals() now conditionally calls the new,
   thread-safe UsageDatabaseManager::Initialize().


Security Impact
--------------------------------------------------------------------
Without the lock an attacker could reliably corrupt camsvc global
structures and achieve code execution in the LocalSystem security
context, resulting in a full local privilege escalation.


Fix Effectiveness
--------------------------------------------------------------------
The serialisation with SRWLock eliminates concurrent entry and thus
removes the race window.  The single atomic write to m_isInitialized is
performed while the exclusive lock is held, guaranteeing consistent
state visibility to all threads.  No remaining unsynchronised access to
shared resources is observable in the patched code, so the fix is
considered effective for this vulnerability.
