{'change_count': 54, 'patch_store_uid': 'b1a2e097-49e5-4833-9ad9-f12764389b5b', 'cve': 'CVE-2025-53800', 'kb': 'KB5065426', 'confidence': 0.16, 'date': 1757843797.467048, 'file': 'd2d1.dll'}
--------------------------------------------------------------------
CVE-2025-53800 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
D2D1.dll  (Windows Graphics Component)
Class CDImageContext, method
CDImageContext::Initialize(ID3D11Device3*, IDeviceInternal*, DebugSink*,
CTickCounter*, uint)

Vulnerability Class
--------------------------------------------------------------------
Incorrect initialization / logic error (CWE-1419)

Detailed Root Cause Analysis
--------------------------------------------------------------------
Prior to the patch the Initialize() routine pulls an internal device
parameter it calls the "max tile size" directly from an offset inside an
object returned by the caller–controlled IDeviceInternal interface.  The
sequence is:
  1. The attacker-supplied IDeviceInternal* (arg a3) is stored at
     this+0x1228 (v7).
  2. A virtual call through *(v7)->vtable[8] returns a pointer to an
     internal CD3DDeviceCommon object (call site: *(v7)+0x40).
  3. The code then reads a dword at offset +0x90 (decimal 144) of that
     object, assumes it is a valid "tile size", and truncates it to at
     most 0x1000:
        v17 = *(DWORD *)(deviceCommon + 0x90);
        v18 = v17 < 0x1000 ? v17 : 0x1000;   // stored in this+0xF0

No attempt is made to verify that the returned object is really a
CD3DDeviceCommon or that the offset contains an initialized value.  An
attacker that implements IDeviceInternal can therefore return a forged
object with arbitrary contents.  Because later parts of CDImageContext
use the field at this+0xF0 to size allocator buckets and tiling buffers,
setting the value to 0 or to an overly large number leads to:
  • Division-by-zero or integer-underflow paths.
  • Out-of-bounds memory accesses when buffer sizes are smaller than the
    amount of data copied.
  • Memory corruption inside a high-integrity process using D2D1.dll,
    which can be leveraged for local elevation of privilege.

Additional foot-fault: the code stored the incoming ID3D11Device3* (arg
 a2) into a CComPtr that was declared as ID2D1EffectContext*, leading to
mismatched vtables if the pointer was later dereferenced.

Patch changes:
  • Replaces the raw field read with the vetted helper
      MaxTileSize = CD3DDeviceCommon::GetMaxTileSize(deviceCommon);
    which returns a device-validated, clamped value.
  • Removes the constant 0x1000 truncation logic.
  • Corrects the mis-typed CComPtr assignment (now uses
    CComPtr<ID3D12Resource>).
  • Tightens error paths (LABEL_20 -> LABEL_18) but functional changes
    are limited to the two bullets above.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable code (before)
DWORD raw = *(_DWORD *)(deviceCommon + 0x90);   // untrusted read
DWORD max  = 4096;
if (raw < 0x1000)
    max = raw;
this->m_MaxTileSize = max;                      // no validation

// patched code (after)
CD3DDeviceCommon *dev = GetDeviceCommon(v7);
DWORD max = CD3DDeviceCommon::GetMaxTileSize(dev); // validated helper
this->m_MaxTileSize = max;
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker provides a fake IDeviceInternal object to a privileged
   component that eventually calls CDImageContext::Initialize().
2. Fake object returns an attacker-controlled pointer from its vtable[8].
3. Initialize() blindly reads DWORD at offset +0x90.
4. Value is propagated to this->m_MaxTileSize and later used for buffer
   allocation / copy sizes.
5. Crafted value causes memory corruption, leading to code execution in
   the context of the caller (high integrity or SYSTEM).

Attack Vector
--------------------------------------------------------------------
Local.  The attacker must be able to load or inject code into a process
that calls the Direct2D image pipeline with an attacker-controlled
IDeviceInternal implementation (e.g., via COM registration or a plug-in
surface).  No additional privileges are required beyond the ability to
start such a process.

Patch Description
--------------------------------------------------------------------
1. Replaces direct structure-member access with the accessor
   CD3DDeviceCommon::GetMaxTileSize(), guaranteeing that the returned
   value is initialized, range-checked, and device-appropriate.
2. Removes the hard-coded 0x1000 truncation logic.
3. Fixes an unrelated but unsafe CComPtr assignment that stored an
   ID3D11Device3* into a pointer typed as ID2D1EffectContext*.

Security Impact
--------------------------------------------------------------------
Exploitation yields arbitrary memory corruption in a privileged graphics
process, which can be converted to local elevation of privilege.
Microsoft rates the issue as an Elevation of Privilege vulnerability
(CVE-2025-53800).

Fix Effectiveness
--------------------------------------------------------------------
The new helper function abstracts and validates the tile-size value,
eliminating the direct read of possibly uninitialized or attacker-
controlled memory.  It also removes the faulty constant 0x1000 logic.
Given that all later uses consume the validated field, the immediate
root cause is addressed.  Remaining risk would stem only from other code
paths that may still dereference internal objects without validation; no
such occurrences were observed in the supplied diff.
