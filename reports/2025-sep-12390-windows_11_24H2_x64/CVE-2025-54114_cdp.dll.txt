{'kb': 'KB5065426', 'cve': 'CVE-2025-54114', 'patch_store_uid': '84bebcb6-0b80-441a-b89d-b2f711a3a440', 'date': 1757843898.708984, 'file': 'cdp.dll', 'change_count': 811, 'confidence': 0.27}
--------------------------------------------------------------------
CVE-2025-54114 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Connected Devices Platform Service (Cdpsvc), cdp.dll –
DeviceCollection::GetDeviceInfo


Vulnerability Class
--------------------------------------------------------------------
CWE-362: Race Condition leading to CWE-822: Untrusted Pointer
Dereference / potential use-after-free, resulting in local Denial of
Service.


Detailed Root Cause Analysis
--------------------------------------------------------------------
DeviceCollection keeps a std::map (offset +40) that stores pointers
(std::_Ref_count_base*) to ICDPDeviceInfo objects.  Prior to the patch
GetDeviceInfo(char const*) executed the following sequence:

1. Construct a std::string key from the incoming device-id.
2. Search the internal map for that key.
3. Copy the stored shared_ptr (Ref_count_base) into the caller-supplied
   out parameter.
4. Return without any synchronisation.

Because the routine referenced both the map container and the refcount
object without holding the collection mutex (offset +8) two or more
threads could simultaneously:
 • look up the same entry,
 • increment / decrement the shared reference count, or
 • erase the entry through another API path.

A losing thread could end up copying a pointer that has already been
freed or whose reference count is in the process of being decremented
past zero.  Subsequent dereference in user code or in Cdpsvc itself
causes an access violation, crashing the service and breaking all
applications that rely on Connected Devices Platform – a classic local
DoS.

In short, the shared resource (map + Ref_count_base) was accessed
without mutual exclusion, allowing an authorized local attacker to race
service threads and provoke invalid pointer use.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// BEFORE (decompiled, simplified)
std::_Ref_count_base* GetDeviceInfo(const char* id)
{
    std::string key(id);
    auto it = m_deviceMap.find(key);    // no lock
    if (it == m_deviceMap.end())
        return nullptr;
    return it->second;                  // races with other threads
}
```

```c
// AFTER (key excerpts)
std::_Mutex_base::lock(&this->m_mtx);   // acquire
std::string key(id);
_tree::find(...);
...
_Mtx_unlock(&this->m_mtx);              // release
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker spawns several threads or processes.
2. Each thread issues the public API that ultimately reaches
   DeviceCollection::GetDeviceInfo with the same device id.
3. One thread erases or releases the entry while another is copying it.
4. Freed pointer is dereferenced later in service context -> crash.


Attack Vector
--------------------------------------------------------------------
Local, authenticated user.  Any process able to open the Cdpsvc COM
interface and call the relevant method can race the service through
high-rate, parallel requests.  No special privileges are required
beyond local execution.


Patch Description
--------------------------------------------------------------------
The fix replaces the old, autogenerated stub with a hand-written
implementation that:
1. Introduces a member mutex (offset +8).
2. Calls std::_Mutex_base::lock / _Mtx_unlock around the map lookup and
   shared_ptr copy.
3. Properly tidies temporary std::string objects.
4. Adds error handling: on failure it zeroes the out parameter and
   decrements any transient refcounts.
These changes serialise access to the shared container and guarantee
that the reference count transitions are atomic with respect to lookup
and copy.


Security Impact
--------------------------------------------------------------------
Before the patch an attacker could crash Cdpsvc at will, causing
system-wide Connected Devices features (Bluetooth, wireless display,
etc.) to stop working until the service is restarted.  Elevation of
privilege is not indicated; the impact is Denial of Service.


Fix Effectiveness
--------------------------------------------------------------------
The added mutex fully protects the critical section in this function so
the specific race is resolved.  Other Cdpsvc entry points were not
changed, therefore the overall robustness depends on similar protection
elsewhere (unknown).  No bypass is evident for the addressed issue.
