{'kb': 'KB5065426', 'file': 'negoexts.dll', 'change_count': 21, 'date': 1757853797.2639103, 'confidence': 0.19, 'patch_store_uid': '9b734c10-a0d9-4e2b-95c7-7526e2061403', 'cve': 'CVE-2025-54895'}
--------------------------------------------------------------------
CVE-2025-54895 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft SSPI – SPNEGO Extended Negotiation (NEGOEX) Security
Support Provider, implemented in negoexts.dll.
All affected code lies in the class basessp::BaseSSP and helpers
exported from negoexts.dll that are reachable through standard SSPI
APIs used by LSA and network-authenticating services.

Vulnerability Class
--------------------------------------------------------------------
CWE-190: Integer Overflow / Wraparound (leading to heap buffer
overflow and memory corruption).

Detailed Root Cause Analysis
--------------------------------------------------------------------
1. The core allocator wrapper is
     void * BaseSSP::WSTAllocate(size_t cb)
   implemented at vtable slot 30/31 of a BaseSSP instance.

2. In the vulnerable build the routine casts the 64-bit parameter
   ‘a2’ to 32 bits before calling the real heap allocator:
     alloc_ptr((unsigned int)a2);
   No upper bound is verified.

3. If a caller supplies a value larger than 0xFFFFFFFF
   (e.g. 0x1_0000_0008), the high 32 bits are silently truncated.
   The heap manager therefore reserves only (cb & 0xFFFFFFFF) bytes,
   while the caller believes the full 64-bit request succeeded.

4. Immediately after the allocation the wrapper executes
     memset(ptr, 0, a2);            // uses full 64-bit length
   which zeroes past the end of the buffer and corrupts adjacent
   heap metadata / objects.

5. Multiple higher-level helpers (WSTDuplicateStringEx and
   WSTGetTargetHostName) rely on WSTAllocate for building UNICODE
   strings that are later copied into process-supplied buffers
   running in SYSTEM context.  Therefore the overflow is reliably
   reachable from user mode through standard SSPI InitiateSecurity
   Context / AcceptSecurityContext calls that load negoexts.dll in a
   privileged LSA process.

6. Once heap memory is corrupted the attacker can hijack control
   flow inside lsass.exe and run arbitrary code at LocalSystem
   integrity, resulting in a local Elevation of Privilege.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// negoexts.dll – vulnerable version
void * __fastcall BaseSSP::WSTAllocate(BaseSSP *this, size_t cb)
{
    if (*((DWORD*)this + 52) == 1)
        return ((ALLOC32)(*(QWORD*)this + 384))( (unsigned int)cb );
    void *p = ((ALLOC32)(*((QWORD*)this + 31)))( (unsigned int)cb );
    if (p)
        memset(p, 0, cb);   // cb is 64-bit, p size may be 32-bit
    return p;
}

// patched version
if (FeatureEnabled && cb > 0xFFFFFFFF)
    return 0;               // reject oversized request
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
SSPI client -> lsass.exe
  InitiateSecurityContext()/AcceptSecurityContext()
    NEGOEX package parses user-supplied token
      WSTGetTargetHostName() or WSTDuplicateStringEx()
        BaseSSP::WSTAllocate( userControlledLength )   <-- overflow
          heap corruption in lsass.exe

Attack Vector
--------------------------------------------------------------------
Local attacker supplies a crafted NEGOEX authentication token (e.g.
via the standard SSPI API from a low-privilege process) that embeds a
very large length field (>4 GB).  The token is processed inside the
privileged LSASS process, hitting the vulnerable allocation path and
corrupting the heap, which can then be exploited for code execution
as SYSTEM.

Patch Description
--------------------------------------------------------------------
1. A feature-flagged guard was inserted at the beginning of
   BaseSSP::WSTAllocate:
       if (cb > 0xFFFFFFFF) return 0;
   The function now returns a 64-bit pointer cast (__int64) to avoid
   accidental promotion/truncation.

2. All in-tree callers (WSTDuplicateStringEx, WSTGetTargetHostName)
   were refactored to call the fixed WSTAllocate instead of
   re-implementing their own allocation logic.

3. Legacy code paths that manually zeroed the buffer were removed –
   the allocation helper now performs any necessary initialization.

Security Impact
--------------------------------------------------------------------
Before the fix any user who could trigger NEGOEX negotiation could
force lsass.exe to write beyond the end of a heap buffer, enabling
reliable elevation of privilege to SYSTEM.  The attack requires no
special privileges other than the ability to start an authentication
sequence on the local machine.

Fix Effectiveness
--------------------------------------------------------------------
The added 64-bit length check eliminates the 32-bit truncation window;
requests larger than 0xFFFFFFFF are refused and no heap allocation is
performed, preventing the subsequent out-of-bounds memset/copy.  All
known entry points were updated to use the same safe helper.  No
remaining cast or unchecked arithmetic on allocation sizes was
observed in the patched code, indicating the vulnerability has been
fully neutralized.
