{'patch_store_uid': '8796b9a4-2f21-4dfb-9ac8-ac90635d192f', 'date': 1757843386.7100344, 'change_count': 16, 'confidence': 0.11, 'cve': 'CVE-2025-55234', 'kb': 'KB5065426', 'file': 'srv.sys'}
--------------------------------------------------------------------
CVE-2025-55234 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows kernel driver srv.sys (SMB server).  All affected logic is in
its legacy SMB-1 signing and HMAC helpers ( CngRsa32Compat_* / MD5* /
HMACMD5* ) and in code that verifies or generates SMB security
signatures during SessionSetup, read/write and pipe traffic.


Vulnerability Class
--------------------------------------------------------------------
Improper Authentication / Weak Cryptography (CWE-287, CWE-327).
A home-grown MD5/HMAC-MD5 implementation inside the kernel allowed
creation and verification of SMB signatures that are vulnerable to
collision and relay attacks, resulting in elevation of privilege.


Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  Signing context allocation
    •  For every connection the driver keeps a 0x68-byte structure at
       Connection+0xB8 ( see SrvInitializeSmbSecuritySignature ).
    •  Before patch the structure was filled by the driver’s own
       MD5Init / HMACMD5Init routines which merely wrote literal MD5
       IV constants (0x67452301, ‑0x10325477 …) and left the rest of
       the buffer uninitialised.

2.  Update / Final
    •  MD5Update() is a 140-line hand-rolled implementation that reads
       and writes through pointer arithmetic with no parameter
       validation.  When it is called from SrvAddSmbSecuritySignature
       or SrvCheckSmbSecuritySignature the packet length (a3) is taken
       directly from untrusted SMB headers.  An attacker can supply
       values that cause integer wrap-arounds in
          v4 = 8 * a3 + *a1;
       and later mem-copies, leading to out-of-bounds reads / writes
       in kernel memory and, more importantly, to a predictable hash
       state.

3.  Verification logic
    •  SrvCheckSmbSecuritySignature copied the whole internal state
       (7 * 0x10 bytes) from another connection object and continued
       hashing new network data with it, making signatures re-usable.
    •  Only the final 8 bytes of the MD5 digest were compared to the
       network value.  A single MD5 collision therefore lets an
       attacker forge a valid signature with negligible effort.

4.  Consequence
    •  With signing considered valid the server trusts the session
       setup, accepts any presented UID and treats the connection as
       authenticated.  The attacker can then relay NTLM credentials or
       mount IPC$ as an elevated user (EoP).


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
void __fastcall MD5Init(_DWORD *a1) {
    *a1=0; a1[1]=0; a1[2]=0x67452301; a1[3]=0xEFCDAB89;
    a1[4]=0x98BADCFE; a1[5]=0x10325476;      // no status returned
}
char __fastcall MD5Update(unsigned int *ctx,_QWORD *buf,__int64 len){
    v4 = 8*len + *ctx;           // may wrap -> wrong length
    ...                         // hundreds of unchecked mem-copies
}

// patched
NTSTATUS __fastcall CngRsa32Compat_MD5Init(BCRYPT_HASH_HANDLE *ph){
    NTSTATUS s = BCryptCreateHash(0x21,ph,0,0,0,0,0);
    if (s<0) __fastfail(7);
    return s;
}
NTSTATUS __fastcall CngRsa32Compat_SHA256Update(
                      BCRYPT_HASH_HANDLE *ph,UCHAR *p,ULONG cb){
    NTSTATUS s = BCryptHashData(*ph,p,cb,0);
    if (s<0) __fastfail(7);
    return s;                    // no manual maths any more
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker connects with SMB 1 dialect.
2. Sends crafted SessionSetupAndX (BlockingSessionSetupAndX):
   • sets Flags2 to disable signing requirements
   • supplies oversized ByteCount to MD5Update.
3. SrvAddSmbSecuritySignature copies foreign hash state,
   processes attacker-controlled data with vulnerable MD5Update and
   stores only 64 bits of the digest.
4. Comparison in SrvCheckSmbSecuritySignature succeeds; connection is
   marked as authenticated (Conn+0xB3 = 1).
5. Attacker now issues tree-connect / NT create requests under SYSTEM.


Attack Vector
--------------------------------------------------------------------
Remote, unauthenticated network access to TCP/445 (SMB 1 enabled).  No
local privilege is required; the attack works in default domain
configurations where signing is negotiated but not required.


Patch Description
--------------------------------------------------------------------
• All custom MD5 / HMAC-MD5 code paths removed and replaced by CNG
  primitives (BCryptCreateHash / BCryptHashData / BCryptFinishHash).
• Hash algorithm switched from MD5 to SHA-256.
• Every helper now returns NTSTATUS and terminates the kernel thread
  with FAST_FAIL on error.
• SrvAddSmbSecuritySignature & SrvCheckSmbSecuritySignature now use
  BCryptDuplicateHash instead of copying raw context memory.
• 8-byte comparison replaced by full SHA-256 comparison.
• WIL / feature-logging helpers updated so that audit events can be
  emitted (new CVE audit ID 0x0379C624).


Security Impact
--------------------------------------------------------------------
Before the patch an attacker could
1. Forge or bypass SMB 1 signatures,
2. Relay NTLM credentials, and
3. Obtain SYSTEM privileges on the target machine.
The issue therefore constitutes an Elevation of Privilege in the SMB
server and enables cross-machine relay attacks.


Fix Effectiveness
--------------------------------------------------------------------
The vulnerable MD5 code is completely removed; all operations are now
performed by vetted CNG providers that internally validate lengths and
states and use SHA-256, eliminating collision and length-overflow
issues.  State cloning is no longer possible because only opaque
BCrypt handles are stored.  FAST_FAIL guards ensure any unexpected
error crashes the offending thread instead of proceeding with an
insecure state.  The patch is therefore considered effective.
