{'patch_store_uid': '8ceaf580-961a-430f-ad80-451621699df6', 'cve': 'CVE-2025-53803', 'file': 'ntoskrnl.exe', 'kb': 'KB5065426', 'change_count': 712, 'confidence': 0.13, 'date': 1757854155.5281885}
--------------------------------------------------------------------
CVE-2025-53803 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows kernel – Event Tracing for Windows (ETW) core logic,
specifically the function EtwpIsEventNameFilterEnabled in ntoskrnl.exe.
The routine is queried by user-mode providers to decide whether a
provider-defined name filter is active.

Vulnerability Class
--------------------------------------------------------------------
Race condition / time-of-check-to-time-of-use (TOCTOU) leading to use
of freed memory and kernel information disclosure (CWE-362 + CWE-416,
manifesting as CWE-209).

Detailed Root Cause Analysis
--------------------------------------------------------------------
Prior to the patch EtwpIsEventNameFilterEnabled(…)
   1. Obtained the provider control block pointer:
        pcb = *(a1 + 0x180)    // a1 == WMI_LOGGER_CONTEXT
   2. Selected one of two filter pointers inside the 104-byte per-
      provider slot (offset +56 or +96) based on the caller-supplied
      flag ‘a5’.
   3. Immediately dereferenced that pointer in order to read:
        BYTE  NameCount  = *(filter + 1);
        QWORD AllowedMask = *(filter + 8);
        QWORD RequiredMask= *(filter +16);
   4. No lock was held and the current IRQL remained unchanged.  The
      provider block can be modified or freed at PASSIVE_LEVEL by
      another thread that is enabling/disabling the provider.

Because the memory could be reclaimed between step (1) and the later
reads, EtwpIsEventNameFilterEnabled could end up reading uninitialised
or freed kernel heap memory.  The values are returned to the caller as
part of the success/fail decision, permitting an authorized local
attacker to infer or disclose kernel heap contents and potentially
bypass KASLR or obtain other sensitive information.

Structures/fields involved:
  WMI_LOGGER_CONTEXT +0x180    : pointer to provider array
  ProviderSlot[104] +56 / +96  : NAME_FILTER structure pointer
  NAME_FILTER +1              : NameCount (BYTE)
  NAME_FILTER +8 / +16        : QWORD masks examined by caller

The absence of IRQL elevation or locking is therefore the fundamental
root cause.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
v5 = *(QWORD *)(a1 + 384);
...
if (a5)
    v9 = *(QWORD *)(v6 + v5 + 56);
else
    v9 = *(QWORD *)(v6 + v5 + 96);
...
BYTE nameCnt = *(BYTE *)(v9 + 1);   // use after potential free
```
```c
// after
if (a3 < 2) {
    oldIrql = KeGetCurrentIrql();   // raise to DISPATCH_LEVEL
    __writecr8(2);
    ...
}
// re-read pointers *after* raising IRQL
v16 = *(QWORD *)(a1 + 384);
...
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User-mode ETW provider repeatedly calls
   EventRegister()/EventUnregister() on one thread.
2. A second thread continuously queries the provider state through
   EtwEventWrite or another API that internally reaches
   EtwpIsEventNameFilterEnabled.
3. Window between provider disable (which frees filter memory) and the
   second thread’s dereference causes freed memory read.
4. Returned status depends on stale heap data, disclosing up to
   16 bytes of kernel memory per call.

Attack Vector
--------------------------------------------------------------------
Local, authorized user can run two cooperating processes or threads
with standard ETW provider privileges.  No elevated rights are needed
beyond the ability to start/stop an ETW session they control.

Patch Description
--------------------------------------------------------------------
1. Function signature changed (returns char, extra parameters).
2. If caller IRQL < DISPATCH_LEVEL and the fast path is chosen,
   raises IRQL to 2 and handles KiIrqlFlags, preventing concurrent
   frees that execute only at PASSIVE_LEVEL.
3. Re-reads the provider slot pointer and re-validates filter pointer
   after IRQL raise, closing the TOCTOU window.
4. Restores original IRQL before exit.
5. Consolidates success logic into a local variable ‘v7’.

Security Impact
--------------------------------------------------------------------
Pre-patch an attacker could disclose kernel heap contents, undermining
KASLR and possibly assisting further exploitation.  The issue is
classified as an information disclosure vulnerability with CVSS scope
limited to the local machine.

Fix Effectiveness
--------------------------------------------------------------------
The added IRQL elevation prevents provider filter memory from being
freed while it is being inspected, eliminating the race on supported
systems because memory management routines for provider blocks execute
only at PASSIVE_LEVEL.  Re-validation of the pointer after elevation
further assures correctness.  No residual uncontrolled dereferences
were observed in the patched code, so the fix appears effective.
