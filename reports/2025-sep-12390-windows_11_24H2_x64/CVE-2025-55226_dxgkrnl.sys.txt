{'confidence': 0.38, 'cve': 'CVE-2025-55226', 'file': 'dxgkrnl.sys', 'patch_store_uid': 'd684b50b-6751-470f-a207-df1d66ac8df9', 'kb': 'KB5065426', 'change_count': 233, 'date': 1757854128.569031}
--------------------------------------------------------------------
CVE-2025-55226 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows graphics kernel driver (dxgkrnl.sys).  Vulnerable
routine: CTDR_GDI_RESET_THREAD::IsTdrAdapterUsedInSessionCallback().


Vulnerability Class
--------------------------------------------------------------------
CWE-362: Improper synchronization / race condition that can lead to a
use-after-free of a session-owned adapter pointer.


Detailed Root Cause Analysis
--------------------------------------------------------------------
Prior to the patch the callback determines whether the calling session
is using the TDR (Timeout Detection & Recovery) adapter by walking
internal data structures without holding any lock or reference:

1. SessionData = DXGSESSIONMGR::GetSessionDataForSpecifiedSession(a3)
   returns a pointer to a DXGSESSIONDATA object.  No reference count is
   taken and no lock is held after the call returns.

2. The code immediately dereferences
      *(SessionData + 0x486C)   // offset 0x486C == 18508
   to obtain a DXGSESSIONDATA::pPairedRenderAdapter pointer, stores it
   in a register and then compares it with the adapter pointer kept in
      CTDR_GDI_RESET_THREAD::m_pAdapter   // *(this + 0x20)

3. A concurrent thread that tears down the remote session or switches
   the paired adapter can free or repurpose the same DXGSESSIONDATA
   object in the time window between step 1 and 2.  The callback then
   reads a dangling pointer.

4. The read value is further split into low/high DWORDs and compared.
   If the freed memory is re-allocated by an attacker-controlled
   buffer, the comparison operates on attacker data.

Consequence: a TOCTOU race can turn into a kernel use-after-free read,
potentially escalating to code execution when combined with typical
heap-spray techniques inside the kernel pool used by session manager
objects.

The exposure exists only for non-console sessions (a3 != ActiveConsole)
where IsTdrAdapterUsedInSessionCallback() is executed in the context of
an RDS/CSC session.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable fragment (before patch)
SessionDataForSpecifiedSession = DXGSESSIONMGR::GetSessionDataForSpecifiedSession(...);
if (!SessionDataForSpecifiedSession)
    return 0;

v7 = *(this + 0x20);                          // m_pAdapter
SessionDataForSpecifiedSession =
    *(DXGSESSIONDATA **)((char *)SessionDataForSpecifiedSession + 0x486C);

if (!v7) {
    if (!HIDWORD(SessionDataForSpecifiedSession))
        return (DWORD)SessionDataForSpecifiedSession != 0;
    return 1;
}
return SessionDataForSpecifiedSession == *(DXGSESSIONDATA **)(v7 + 0x19C);
```

```c
// safe fragment (after patch)
DXGSESSIONMGR::GetPairedRenderAdapterInRemoteSession(..., &LuidLow);
...
v8 = *(m_pAdapter + 0x19C);
if (LuidLow == LOWDWORD(v8)) {
    if (LuidHigh == HIGHDWORD(v8))
        return true;
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker runs in a remote desktop (or similar) session.
2. Attacker starts intensive create/destroy of remote sessions or fast
   adapter switching to force free/reuse of DXGSESSIONDATA.
3. Concurrently a TDR reset is initiated, invoking the vulnerable
   IsTdrAdapterUsedInSessionCallback() for that session.
4. Callback dereferences freed object, reading attacker-supplied data.
5. Corrupted data path can lead to arbitrary kernel memory access when
   later used, enabling code execution in kernel context.


Attack Vector
--------------------------------------------------------------------
Local, authenticated user.  Requires ability to log on to a non-console
session (RDP, RemoteFX, etc.) and perform rapid session tear-down or
adapter switching to win the race.


Patch Description
--------------------------------------------------------------------
1. Converts return type from char to bool for clarity.
2. Short-circuits the function for console sessions early.
3. Introduces a new, synchronised helper
      GetPairedRenderAdapterInRemoteSession()
   which safely returns the adapter LUID as two DWORDs while holding
   the session lock, eliminating the need to dereference
   DXGSESSIONDATA::pPairedRenderAdapter directly.
4. Performs all comparisons on the returned LUID values, avoiding any
   access to potentially freed memory.
5. Removes the convoluted pointer/byte casts, preventing accidental use
   of high DWORDs of stale pointers as boolean flags.


Security Impact
--------------------------------------------------------------------
Before the fix, a local attacker could win a race and cause the kernel
callback to read from freed memory, potentially leading to corruption of
internal adapter state and ultimately remote code execution within the
Windows kernel (SYSTEM privileges).  Successful exploitation breaks the
kernel driver sandbox and may crash the system or allow privilege
escalation.


Fix Effectiveness
--------------------------------------------------------------------
The updated code path that was vulnerable now relies exclusively on a
thread-safe helper which returns simple POD values; no object
pointers are dereferenced post-lookup.  This removes the UAF window and
aligns the comparisons with proper locking discipline.  No remaining
unsynchronised dereferences were observed for the remote-session path,
so the patch is considered effective against the reported issue.
