{'kb': 'KB5058411', 'change_count': 7, 'patch_store_uid': '15306ebf-302c-4cb5-8e6b-0e0aa4400221', 'cve': 'CVE-2025-29971', 'date': 1751759752.4639626, 'confidence': 0.17, 'file': 'wtd.sys'}
--------------------------------------------------------------------
CVE-2025-29971 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Web Threat Defense kernel driver (WTD.sys) – stream-callout routine
sub_1C0002CF0 (renamed to sub_1C0002D40 after patch) that handles
FWPS_STREAM_DATA0 indicated by the Windows Filtering Platform (WFP).

Vulnerability Class
--------------------------------------------------------------------
CWE-125: Out-of-Bounds Read (kernel-mode)

Detailed Root Cause Analysis
--------------------------------------------------------------------
The function builds an auxiliary parameter block that is passed to a
secondary parser (sub_1C0003EF4).  In the vulnerable build the driver
packs the TCP FIN flag (bit 0 of FWPS_STREAM_DATA0::flags) into the low
byte of a *pointer* before passing that pointer to the helper:

    v32 = &v50;               // v50 = SIZE_T consumedBytes
    LOBYTE(v32) = v30;        // overwrite least-significant byte with
                              // FIN flag (0/1)
    sub_1C0003EF4( (DWORD)v32,             // corrupted pointer
                   (DWORD)&v54, … );

Because x64 pointers are little-endian, the write to LOBYTE(v32)
alters the actual address value.  The helper subsequently dereferences
this pointer expecting a valid SIZE_T, but now points to an arbitrary
(nearly always non-owned) location in kernel address space.  Reading
that memory triggers an access violation that crashes the box
(BUGCHECK 0xD1), resulting in a denial of service.

Key data involved
  • &v50 – local SIZE_T that should hold the number of bytes consumed.
  • v30 – TCP FIN flag (bit 0 of stream flags).
  • sub_1C0003EF4 – downstream routine that dereferences the pointer.
  • Corrupted pointer lies outside the current stack frame, producing
    an OOB read.

Boundary condition
The corruption happens whenever the stream contains the FIN flag and
all other guards (buffer < 0x2000 bytes etc.) succeed, therefore it can
be triggered remotely with a single crafted TCP session.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable
v32 = &v50;            // correct pointer
LOBYTE(v32) = v30;     // corrupt address with FIN bit
v33 = sub_1C0003EF4(   // helper will deref bogus ptr
         (DWORD)v32,
         (unsigned int)&v54,
         v53,            // payload buffer
         v45,            // length
         a6 + 121,
         (__int64)&v50);

// fixed
v32 = sub_1C0003F74(   // new helper, flag passed separately
         v30,                 // FIN flag as its own arg
         (__int64 *)&v50,     // unmodified pointer
         v13, v42,
         (_BYTE *)(a6 + 121),
         &v48);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Remote attacker opens a TCP connection to a host running WTD.
2. Attacker sends a short data segment followed immediately by FIN.
3. WFP invokes the Stream layer call-out; sub_1C0002CF0 executes.
4. dataLength != 0, a6 != NULL, buffer < 0x2000 ⇒ vulnerable block
   reached.
5. FIN bit is copied into low byte of &v50, corrupting the pointer.
6. sub_1C0003EF4 reads through this pointer –> invalid address.
7. Kernel attempts to read unmapped memory –> bugcheck.

Attack Vector
--------------------------------------------------------------------
Unauthenticated network attacker sends a crafted TCP stream that forces
WTD to process a FIN-marked segment through the vulnerable routine.
No local privileges are required; the crash occurs in kernel context.

Patch Description
--------------------------------------------------------------------
The patch removes the pointer/flag overlay.
• Introduces new helper sub_1C0003F74 whose first argument is the FIN
  flag; the pointer to the SIZE_T variable is passed *unchanged*.
• All code that previously used the LOBYTE trick has been deleted.
• Minor refactoring: variable types switched to size_t/unsigned,
  telemetry identifiers updated, early-exit logic inverted, but these
  are incidental.

Security Impact
--------------------------------------------------------------------
Prior to the patch a remote attacker could trigger an out-of-bounds
read in kernel space leading to a system crash (denial of service).  No
information disclosure or code execution is known, but the crash is
fully reliable.

Fix Effectiveness
--------------------------------------------------------------------
The corrected code no longer mutates the pointer; the helper receives a
valid address and cannot read outside the intended stack variable.  A
review of the patched binary shows no remaining instances of
LOBYTE(pointer) manipulation, so the fix comprehensively addresses the
identified OOB read vector.
