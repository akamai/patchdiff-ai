{'change_count': 264, 'confidence': 0.23, 'patch_store_uid': '1556b61b-6e12-44f3-988f-2e5fbc78c3dd', 'file': 'win32kbase.sys', 'cve': 'CVE-2025-30388', 'date': 1751781048.5130446, 'kb': 'KB5058411'}
--------------------------------------------------------------------
CVE-2025-30388 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
win32kbase.sys  (Windows Graphics / GDI kernel driver)
Vulnerable routine: GdiHandleManager::AcquireEntryIndex()

Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow  –  CWE-122

Detailed Root Cause Analysis
--------------------------------------------------------------------
GdiHandleManager::AcquireEntryIndex() is responsible for handing out a
free GDI handle index from a per-session, non-paged handle table
hierarchy.  The function first walks the hierarchy to locate or create
a "sub-table" that still contains free entries, then calculates a
pointer to the chosen 24-byte GDI_HANDLE_ENTRY structure:

    v15 = *(_QWORD *)v14 + 24 * v12;

v12 is derived from the 16-bit low word of the final handle value
(v7).  The only boundary check applied is

    if ((unsigned int)v12 < *(DWORD *)(v14 + 0x14))

but when the test fails v15 is deliberately left at 0.  A later block
executes unconditionally once the outer loop terminates:

    *(BYTE *)(v15 + 0x0D) = 0;              // or
    *(BYTE *)(v15 + 0x0D) = WORD1(v7);

Because the code does not re-validate that v15 is non-NULL (and in the
non-NULL case does not verify that v12 is within the allocated
sub-table), two distinct uncontrolled writes are possible:

1. v15 == 0        -> write to NULL page (no longer user-mappable on
   modern Windows; exploitable on older builds with prior
   NULL-dereference barriers)  
2. v12 >= Capacity -> v15 points past the end of the allocated
   sub-table; the byte write at offset +0x0D lands in adjacent kernel
   heap memory, corrupting pool metadata or a neighbouring object.

Both conditions are fully attacker-controlled through user-mode GDI
API calls that repeatedly exhaust handle tables, forcing the
vulnerable fallback paths inside AcquireEntryIndex().  Once pool
metadata is corrupted, a local attacker can craft subsequent
allocations to obtain execution control in kernel context – turning
the bug into a full Remote/Local Code Execution primitive.

Affected data structures / fields
  * GDI_HANDLE_HEADER  (24-byte table element)
  * Per-session BaseGlobals::HandleIndexArray (256-KB, tag 'Ghmc')
  * Fields at offsets 0x08 / 0x0C / 0x10 of each sub-table header

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – unchecked pointer arithmetic & write
v15 = 0i64;
if ((unsigned int)v12 < *(DWORD *)(v14 + 0x14))
    v15 = *(_QWORD *)v14 + 24 * v12; // <= may run past buffer
...
*(BYTE *)(v15 + 0x0D) = 0;           // overwrite out-of-bounds
```
```c
// after patch – vulnerable function removed, new safe init path
v2 = (BaseGlobalsNonPaged *)
     Win32AllocPoolImpl(0x40ui64, 0x788ui64, 'Gesm');
if (v2)
    BaseGlobalsNonPaged::BaseGlobalsNonPaged(v2);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-mode code
  -> GDI API loop (e.g., CreateBitmap) exhausts per-table quota
  -> kernel transitions to win32kbase!GdiHandleManager::AcquireEntryIndex
  -> path where all existing sub-tables are full is taken
  -> new sub-table allocation fails or v12 is outside size
  -> boundary check fails, v15 remains NULL / out-of-range
  -> *(BYTE *)(v15+0x0D) write corrupts kernel heap

Attack Vector
--------------------------------------------------------------------
Local attacker running in a low-privilege desktop session issues
thousands of GDI object creation calls, manipulating the internal free
list until AcquireEntryIndex() executes the unsafe path.  No special
privileges are required; the bug is reachable from a sandbox or
browser renderer process.

Patch Description
--------------------------------------------------------------------
Microsoft entirely removed the legacy AcquireEntryIndex() code path and
re-architected handle-table initialisation.  The replacement routine
(Gre::Base::InitNonPagedGlobals) allocates a fixed-size (0x788-byte)
non-paged structure and calls a constructor that no longer performs
pointer arithmetic based on attacker controlled indices.  All previous
calculations of 24*index and byte writes at +0x0D are gone, thereby
eliminating the overflow primitive.

Security Impact
--------------------------------------------------------------------
Prior to the patch a user-mode process could corrupt non-paged pool and
achieve arbitrary code execution in kernel mode, leading to full
system compromise and sandbox escapes.  The issue is rated Remote Code
Execution because many graphics attack surfaces (e.g., RDP, Hyper-V
vGPU) can reach the vulnerable code from outside the victim session.

Fix Effectiveness
--------------------------------------------------------------------
Diff analysis shows the vulnerable function has been removed; the new
initialisation routine performs constant-size allocations and does not
use attacker-controlled indices for pointer or size calculations.  No
path writes beyond the bounds of the newly allocated buffer.  The
specific overflow primitives are therefore completely neutralised.
