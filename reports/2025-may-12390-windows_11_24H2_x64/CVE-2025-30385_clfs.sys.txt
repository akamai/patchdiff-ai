{'date': 1751781063.067751, 'confidence': 0.11, 'change_count': 34, 'cve': 'CVE-2025-30385', 'patch_store_uid': '50b75c18-3545-4611-ba2f-9638129745a0', 'kb': 'KB5058411', 'file': 'clfs.sys'}
--------------------------------------------------------------------
CVE-2025-30385 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
clfs.sys – Common Log File System (CLFS) kernel-mode driver. Affected
objects are CClfsLogCcb (per-handle control block) and associated
lifetime-listener infrastructure.

Vulnerability Class
--------------------------------------------------------------------
Use-After-Free / Dangling Pointer (CWE-416)

Detailed Root Cause Analysis
--------------------------------------------------------------------
Each open handle to a CLFS log file owns a CClfsLogCcb structure.  A
pointer to that CCB is stored in FILE_OBJECT->FsContext2 and is shared
by multiple asynchronous paths (read/write/flush, archival, restart
I/O, etc.).  Prior to the patch the following sequence was possible:

1. Thread A initiates handle teardown.  In
   CClfsLogCcb::~CClfsLogCcb() the code tested the “linked” flag
   0x80, unlinked the CCB from the global list and immediately
   dropped the last reference (ObfDereferenceObject) **without** first
   serialising against racing users.
2. Thread B, already inside one of many request helpers
   (ReadLogBlock, ReadRestart, Flush, AdvanceLogBase, etc.) still
   held the stale pointer stored in the IRP/CCB and accessed object
   fields (e.g. Flags, Archive counters, ILifetimeListener pointer)
   after the memory had been freed by Thread A.
3. Because the freed pool is attacker-controlled, subsequent field
   dereferences or bit operations cause arbitrary kernel memory reads
   or writes, allowing local elevation of privilege.

Contributing factors
• No acquisition of the CCB’s per-handle ERESOURCE at offset 0x98
  ("+152" in the diff) when clearing flags, unlinking, or touching the
  lifetime listener.
• Missing reference counting for ILifetimeListener objects
  (pointer at CCB+0x100 / field index 32).
• Flag 0x80 (“linked”) was cleared with a plain AND, not atomically.

Patch behaviour (core changes)
• CClfsLogCcb::~CClfsLogCcb() now:
  – Acquires the handle resource before calling Unlink().
  – Uses InterlockedAnd() to clear 0x80.
• CClfsLogCcb::Unlink() changed the list-manipulation sanity checks
  and also uses InterlockedAnd() for the flag.
• New resource acquisition paths were added to
  UninstallLifetimeListener(), Add/ReleaseArchiveRef(), Cleanup(),
  Request Read/Write/Flush helpers, etc., protecting all updates to
  shared CCB state.
• CClfsLogCcb::UninstallLifetimeListener() now validates/clears the
  pointer while the same resource is held, preventing a second thread
  from observing a half-initialised listener or from re-using the CCB
  after it was freed.
• CClfsManagedLogClientUser::Initialize() now installs the lifetime
  listener through CClfsLogCcb::InstallLifetimeListener(), which
  bumps the CCB reference count.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before – UninstallLifetimeListener, no locking, straight free
if ( this[32] != a2 ) return STATUS_INVALID_PARAMETER;
this[32] = NULL;
(*a2->vtable->Release)(a2);   // UAF window
```
```c
// after – lock then validate, pointer cleared while held
ExAcquireResourceExclusiveLite(&this->Res, TRUE);
if (!(this->Flags & CCB_STATE_CLOSED) && this->Listener == a2) {
    this->Listener = NULL;
}
ExReleaseResourceLite(&this->Res);
(*a2->Release)(a2);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Open file -> CLFS returns handle and CClfsLogCcb.
2. Issue asynchronous IRP that keeps a pointer to CCB.
3. Close handle from another thread –> object is unlinked and freed.
4. First IRP completes and accesses freed CCB (e.g. marks
   flag 0x08, dereferences Listener) –> kernel UAF.

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker.  Any user able to open a CLFS log file
and trigger concurrent I/O can race close vs. read/write to gain
arbitrary-kernel-write and elevate privileges.

Patch Description
--------------------------------------------------------------------
• Systematically acquires the CCB ERESOURCE around every mutation or
  query of shared members (flags, counters, Listener).
• Adds atomic flag manipulation (InterlockedAnd) for 0x80.
• Introduces CClfsLogCcb::InstallLifetimeListener() and uses reference
  counting for ILifetimeListener objects.
• Destructor now performs Unlink() only while the resource is held and
  after asserting that no outstanding references remain.
• Many request paths (ReadLog*, Flush, AdvanceLogBase, etc.) call
  CClfsLogCcb::MarkAccessed() instead of directly setting Flags, again
  under protection of the lock or a retained reference.

Security Impact
--------------------------------------------------------------------
Before patch: race allowed reuse of freed CClfsLogCcb memory leading to
arbitrary kernel read/write and Local Privilege Escalation (EoP).
After patch: CCB lifetime is reference-counted and protected by an
exclusive resource; concurrent access now sees either a valid object
or NULL, eliminating the UAF.

Fix Effectiveness
--------------------------------------------------------------------
The added locking and reference-counting remove the window where a
pointer to freed memory can be dereferenced.  No remaining unlocked
paths to CClfsLogCcb fields were observed in the patched diff.  The
fix is therefore assessed as effective.
