{'kb': 'KB5058411', 'file': 'securekernel.exe', 'change_count': 1, 'date': 1751781007.8450472, 'confidence': 0.19, 'patch_store_uid': 'ec1df4e1-d7ec-4e0f-b057-94ea15e23c66', 'cve': 'CVE-2025-27468'}
--------------------------------------------------------------------
CVE-2025-27468 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Secure Kernel (securekernel.exe) – routine IumCopyEnclaveMemory
at RVA 0x4FFE0.  The helper is responsible for copying data between an
enclave page and a non-enclave page on behalf of kernel callers.

Vulnerability Class
--------------------------------------------------------------------
Improper bounds check / out-of-bounds write leading to privileged memory
corruption (CWE-120 style defect, mapped to CWE-269 privilege
escalation).

Detailed Root Cause Analysis
--------------------------------------------------------------------
IumCopyEnclaveMemory copies at most a page at a time.  For every
iteration it derives the number of bytes that may be copied without
crossing the current source page boundary:

    v28 = 4096 - (srcPtr & 0xFFF);
    if (v28 > RemainingLen) v28 = RemainingLen;

The routine then **tries** to ensure that the copy also fits inside the
destination page by testing

    if (v28 + (dstPtr & 0xFFF) > 0x1000)
        v28 = 4096 - (srcPtr & 0xFFF);

This is wrong – when the test is true the code rewrites the length with
the size of the *source* page tail instead of the space left in the
*destination* page.  A typical mis-case is:

    src offset  =   0
    dst offset  = 3500
    Remaining   = 600

v28 becomes 600, the test triggers (3500+600>4096) and v28 is reset to
4096, so **Size > RemainingLen** and certainly crosses the destination
page that has never been validated by SkmiGetValidEnclaveContainerPte.

The subsequent

    memmove(dst, src, Size)

is executed inside Secure-Kernel context with full privilege, causing an
out-of-bounds write into the following page.  Because the second page may
belong to arbitrary kernel or secure-kernel data, an enclave process can
corrupt privileged memory and obtain execution at secure-kernel IRQL.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// BEFORE – wrong adjustment
v28 = 4096 - (src & 0xFFF);
if (v28 > remaining) v28 = remaining;
if (v28 + (dst & 0xFFF) > 0x1000)
    v28 = 4096 - (src & 0xFFF);   // resets to wrong limit
Size = v28;
...
memmove(dst, src, Size);

// AFTER – fixed computation
v28 = 4096 - (src & 0xFFF);
if (v28 > remaining) v28 = remaining;
unsigned dstOff = dst & 0xFFF;
unsigned limit  = 4096 - dstOff;
Size = (dstOff + v28 <= 0x1000) ? v28 : limit;
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker invokes a kernel interface that eventually calls
   IumCopyEnclaveMemory(src, dst, len, DirectionFlag).
2. Chooses dst so that (dst & 0xFFF) is near 0x1000 and len smaller than
   the space to the end of the *source* page but larger than the space
   to the end of the destination page.
3. Function mis-computes Size and memmove crosses into an unvalidated
   page.
4. Memory corruption in secure kernel occurs; attacker gains arbitrary
   write inside secure-kernel address space.

Attack Vector
--------------------------------------------------------------------
Local attacker with the ability to allocate an enclave and to request
IumCopyEnclaveMemory (through a documented or undocumented system
service) supplies crafted source/destination addresses that straddle a
page boundary.  No special privileges beyond enclave ownership are
needed.

Patch Description
--------------------------------------------------------------------
The update rewrites the length calculation:
• Introduces variables v29/v30 (= dstOffset, dstRoom).
• Size is now the minimum of remaining length and **destination** page
  room when dstOffset+v28 would overflow.
• Renames bookkeeping variables so the source/destination pointers are
  not swapped later in the loop.
• No other logic is changed.

Security Impact
--------------------------------------------------------------------
Prior to the patch a local attacker could perform an out-of-bounds write
in secure-kernel memory, escaping the enclave boundary and achieving
arbitrary code execution in Secure Kernel Mode.  That directly leads to
full system compromise (Elevation of Privilege).

Fix Effectiveness
--------------------------------------------------------------------
The new calculation explicitly limits the copy length to the smaller of
(source room, destination room, remaining length).  Therefore the copy
can no longer cross into an unchecked page.  No additional vulnerable
paths were observed in the diff; the fix appears comprehensive for this
routine, but similar helpers should be reviewed for the same pattern.
