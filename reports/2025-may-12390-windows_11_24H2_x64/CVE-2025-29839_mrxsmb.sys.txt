{'change_count': 4, 'patch_store_uid': 'c0e5b152-c728-43e8-bacc-5805c283b07a', 'file': 'mrxsmb.sys', 'kb': 'KB5058411', 'date': 1751781009.9834957, 'confidence': 0.16, 'cve': 'CVE-2025-29839'}
--------------------------------------------------------------------
CVE-2025-29839 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows kernel FsRtl (File-system Runtime Library) as used by the
Multiple UNC Provider (mrxsmb.sys).  Affected routine is
FsRtlValidateChangeNotifyBuffer(), reached by directory-change
notification paths such as NtNotifyChangeDirectoryFile and SMB2
CHANGE_NOTIFY.


Vulnerability Class
--------------------------------------------------------------------
Out-of-bounds read / information disclosure (CWE-125).


Detailed Root Cause Analysis
--------------------------------------------------------------------
FsRtlValidateChangeNotifyBuffer() is tasked with sanity-checking a
caller-supplied buffer that supposedly contains one or more chained
FILE_NOTIFY_INFORMATION structures:

  struct FILE_NOTIFY_INFORMATION {
      ULONG NextEntryOffset;   // a1[0]
      ULONG Action;            // a1[1]
      ULONG FileNameLength;    // a1[2]
      WCHAR FileName[...];
  };

The routine iterates through the buffer, advancing by
NextEntryOffset (v7) for every record and performing basic range
checks.

In the vulnerable build the loop looked like this (simplified):

  while (TotalLen >= Offset + 4) {
      Next = *a1;                  // safe (needs 4 bytes)
      FileNameLength = a1[2];      // REQUIRES 12 bytes     <== BUG
      if (Offset + 12 > TotalLen) break;       // check too late
      ...
  }

The code fetches a1[2] (8 bytes past the start of the current record)
*before* it has verified that there are at least 12 bytes remaining in
the buffer.  If the caller supplies a buffer whose tail contains only
4–11 bytes, the read of a1[2] accesses up to 8 bytes beyond the caller
buffer.  Because the access happens in kernel mode it can succeed and
will pull arbitrary kernel memory into the caller-controlled buffer.
Subsequent IRP completion copies that buffer back to user space,
allowing disclosure of uninitialized or adjacent kernel data.

Additional limits (TotalLen < 0x7FFFFFFF, alignment checks, etc.) do
not prevent this under-read.

The MRxSmbSetInstanceConfig() changes in the same patch are cosmetic
and unrelated to the root cause.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch
while (v3 >= v5 + 4) {          // only confirms 4 bytes remain
    v7 = *a1;                   // read NextEntryOffset (4 bytes)
    if (v5 + 12 > v3) break;    // <-- length check is AFTER access
    v8 = a1[2];                 // read FileNameLength (requires 12)
    ...
}

// after patch
if (v2 >= 4) {
    do {
        v6 = *a1;               // read 4 bytes (still safe)
        if (v5 + 12 > v2) break;// ensure 12 bytes BEFORE next read
        v7 = a1[2];             // now guaranteed in-bounds
        ...
    } while (v2 >= v5 + 4);
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-mode           ->  kernel I/O manager
NtNotifyChangeDirectoryFile
    -> FsRtlNotifyInitializeSync
    -> FsRtlNotifyFilterChangeDirectory
    -> FsRtlValidateChangeNotifyBuffer (vulnerable)
         parses user buffer and may over-read
    -> completion routine copies data back to caller

Exact higher-level path may vary (SMB redirector, third-party FS,
etc.); only the vulnerable routine is certain.


Attack Vector
--------------------------------------------------------------------
A local, unprivileged attacker allocates a page-aligned buffer and
fills it with any value followed by 4–11 valid bytes, then calls
NtNotifyChangeDirectoryFile (or any IOCTL that internally invokes the
FsRtl notify logic) passing that buffer and its reported length.  When
the kernel validates the buffer it reads 8 bytes past the end and then
copies the full buffer back to user space, disclosing kernel memory
located immediately after the supplied allocation.


Patch Description
--------------------------------------------------------------------
1. Re-ordered field accesses so that *all* 12-byte header data are only
   read after confirming at least 12 bytes remain.
2. Added an explicit outer length check (v2 >= 4) before entering the
   loop.
3. Introduced optional call to FsRtlValidateChangeNotifyBufferEx() for
   builds where Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage() is
   enabled, providing a hardened validation path.

No structural changes were made to the FILE_NOTIFY_INFORMATION parser;
the fix is purely defensive bounds checking.


Security Impact
--------------------------------------------------------------------
Prior to the patch a malicious caller could force the kernel to read up
to 8 bytes past the end of a user-supplied buffer, and that stale
kernel memory would then be returned to user space.  This constitutes
an information disclosure vulnerability that can be chained with other
issues (e.g. KASLR or heap grooming) to facilitate elevation of
privilege exploits.


Fix Effectiveness
--------------------------------------------------------------------
The added length test guarantees that no field beyond the first 4
bytes is read until the routine has verified at least 12 bytes are
still available, fully eliminating the described out-of-bounds read.
The early outer guard and optional call to the extended validator
provide additional safety nets.  No residual paths that bypass these
checks are observable in the patched code, so the fix appears
complete.
