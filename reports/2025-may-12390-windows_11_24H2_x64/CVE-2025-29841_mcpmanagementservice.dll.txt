{'change_count': 2, 'patch_store_uid': '5e8145b8-149f-4e94-963a-302ceda9ad09', 'file': 'mcpmanagementservice.dll', 'confidence': 0.42, 'date': 1751781012.2216809, 'kb': 'KB5058411', 'cve': 'CVE-2025-29841'}
--------------------------------------------------------------------
CVE-2025-29841 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Universal Print Management Service (mcpmanagementservice.dll)
McpOperationHandler::CreateOperationThread and
McpOperationHandler::McpOperationThreadProc

Vulnerability Class
--------------------------------------------------------------------
CWE-362: Race Condition leading to CWE-416: Use-After-Free

Detailed Root Cause Analysis
--------------------------------------------------------------------
The parameter handed to McpOperationHandler::CreateOperationThread
contains two fields:
  DWORD  OperationType        // *(DWORD*)lpParameter
  IUnknown* pOperationObject  // *((void**)lpParameter + 1)

Before the patch the code started the worker thread first and only
inside McpOperationHandler::McpOperationThreadProc performed

  pOperationObject->AddRef();

This produced a race window:
  1. Main thread calls CreateThread.
  2. Main thread resumes and may immediately Release() or even free the
     whole McpOperationHandlerThreadParams structure.
  3. The new thread has not yet executed AddRef(); when it finally
     runs, pOperationObject might already be freed or recycled.

Dereferencing the dangling pointer inside the thread first to perform
AddRef() and later to execute virtual methods (Execute()) results in a
use-after-free.  Because the object is polymorphic, the attacker can
overwrite the vtable pointer and obtain arbitrary code execution in the
service context (LOCAL SYSTEM).

A second failure path existed when CreateThread itself returned NULL.
No AddRef() had been taken, yet the caller still assumed ownership had
been transferred, so the object leaked.  While not an immediate
security issue, the missing Release() shows the same lack of ownership
tracking.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Before
bool CreateOperationThread(void *lpParameter) {
    HANDLE h = CreateThread(..., McpOperationThreadProc, lpParameter,...);
    return (((uint64_t)h + 1) & ~1) != 0;
}

__int64 McpOperationThreadProc(_QWORD *Parameter) {
    IUnknown *pObj = (IUnknown*)Parameter[1];
    if (pObj)
        pObj->AddRef();           // first touch of pObj (race!)
    switch (*(DWORD*)Parameter) { /* ... */ }
    pObj->Release();
}
```
```c
// After (feature gate omitted for clarity)
char CreateOperationThread(unsigned int *lpParameter) {
    IUnknown *pObj = (IUnknown*)lpParameter[1];
    pObj->AddRef();              // ownership taken BEFORE thread start
    HANDLE h = CreateThread(...);
    if (!h) {
        pObj->Release();         // balanced if thread creation failed
        return 0;
    }
    return 1;
}

__int64 McpOperationThreadProc(_QWORD *Parameter) {
    IUnknown *pObj = (IUnknown*)Parameter[1];
    pObj->AddRef();
    pObj->Release();             // neutralise extra ref; keeps balance
    /* execute operation */
    pObj->Release();             // final Release on completion
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
McpService::* -> McpOperationHandler::CreateOperationThread
    (passes McpOperationHandlerThreadParams)
CreateThread returns, caller continues and may destroy params
Worker thread picks up and dereferences freed pOperationObject => UAF

Attack Vector
--------------------------------------------------------------------
A local, authenticated attacker able to interact with Universal Print
Management Service can deliberately race the destruction of the
operation object (or substitute it with crafted memory) after calling a
method that internally invokes CreateOperationThread.  When the worker
thread later executes, the service dereferences attacker-controlled
memory, allowing code execution at SYSTEM integrity.

Patch Description
--------------------------------------------------------------------
1. Pre-thread AddRef(): the service now increments the reference count
   on the operation object before CreateThread, closing the race.
2. Balanced Release(): if CreateThread fails the extra reference is
   released immediately.
3. Thread proc has a compensating early Release() so that the reference
   count taken in the parent is handed back as soon as the thread owns
   the pointer, keeping lifetime balanced.
4. Additional parameter-null validation and telemetry have been added
   but are ancillary.

Security Impact
--------------------------------------------------------------------
Prior to the fix an attacker could achieve a reliable use-after-free in
a SYSTEM service, leading to elevation of privilege and possibly
arbitrary code execution in kernel/user mode depending on further
exploitation.  Exploitation requires only local access; no additional
privileges are needed beyond the ability to trigger Universal Print
operations.

Fix Effectiveness
--------------------------------------------------------------------
The added AddRef()/Release() sequence removes the lifetime gap entirely
and guarantees that the object remains valid for the duration of the
race window.  Failure paths are handled and input validation was added.
No residual code paths lacking reference tracking were observed in the
provided diff, indicating the fix is complete for the affected
functions.
