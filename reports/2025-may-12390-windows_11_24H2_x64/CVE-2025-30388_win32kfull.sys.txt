{'date': 1751781042.0378962, 'patch_store_uid': '62dac484-f3bc-4d07-9dfd-85240e9d509e', 'confidence': 0.19, 'cve': 'CVE-2025-30388', 'change_count': 158, 'kb': 'KB5058411', 'file': 'win32kfull.sys'}
--------------------------------------------------------------------
CVE-2025-30388 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows kernel graphics subsystem (win32kfull.sys) – DrawStream
command parser executed through the NtGdiDrawStream system call.

Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow – CWE-122.

Detailed Root Cause Analysis
--------------------------------------------------------------------
GreDrawStream<XDCOBJ_NoCtor,0>() is the in-kernel dispatcher that
parses a DRAWSTREAM byte-buffer supplied from user-mode and issues
drawing primitives on behalf of the caller.

Each record in the buffer begins with a 32-bit opcode followed by an
opcode-specific payload whose length is also taken from the stream
itself.  While walking the buffer the original code only verified that
at least four bytes (the opcode) remained:

  if (v15 < 4) { v41 = 1; goto exit; }

Once the opcode had been read the implementation immediately deref-
erenced further fields (e.g. dimensions, colour key, rectangles) and
advanced the stream pointer without first checking that the remaining
buffer length (v15) was large enough for the full record.  For example
for opcode 9 (transparent-blt) the code assumed 0x3C bytes were
authorized and blindly accessed them:

  if (*v14 != 9) goto exit;
  if (v15 < 0x3C) goto exit;            // <-- missing
  ... use v14[13] ...

If the attacker provides a buffer where v15 < 0x3C, v14[13] and other
fields point outside the allocated region.  Subsequent calls to
NtGdiDrawStreamInternal() copy those out-of-bounds bytes into heap
buffers located inside win32k, overflowing the heap and giving the
attacker controlled data that is later interpreted as XLATEOBJ,
EXLATEOBJ or palette structures.  Because win32k operates in kernel
context, successful exploitation leads to arbitrary kernel code
execution.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before – no size validation for opcode 9
if (*v14 != 9)
    goto EXIT;
LODWORD(v36) = 60;            // expected record size
if (v15 < 0x3C)               // <-- missing check (patched code adds)
    goto EXIT;
...                          // uses v14[1..14] unconditionally
```
```c
// after – record size is validated before use
if (*v14 != 9)
    goto EXIT;
LODWORD(v36) = 60;
if (v15 < 0x3C)
    goto EXIT;                // newly added
...
```
Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker calls NtGdiDrawStream(hdc, len, userBuffer).
2. Kernel enters GreDrawStream<XDCOBJ_NoCtor,0>().
3. Crafted stream sets opcode = 9 and length < 0x3C.
4. Original code accesses v14[13] past end of userBuffer.
5. NtGdiDrawStreamInternal() receives pointers to attacker-controlled
   memory living beyond the allocated buffer and copies it into heap
   objects ⇒ overflow.

Attack Vector
--------------------------------------------------------------------
Any sandboxed or low-integrity process can invoke NtGdiDrawStream with
a malicious buffer.  Remote attackers can reach the primitive via RDP
or any vector that allows GDI calls (e.g. malicious document rendered
in a browser sandbox).

Patch Description
--------------------------------------------------------------------
Microsoft rewrote the record parser:
* Added per-opcode minimum-size checks (v15 < requiredSize ⇒ abort).
* Restructured control flow to centralised error handling (LABEL_80 /
  LABEL_81) ensuring the parser exits on any size mismatch.
* Introduced XDCOBJ::vUnlockFast() paths to correctly balance object
  references, eliminating associated UAF side effects.
* Refactored parameter types and renamed variables for clarity but the
  functional security fix is the added length validation.

Security Impact
--------------------------------------------------------------------
Without the fix, a local or remote attacker can overflow heap buffers
inside win32k, corrupting adjacent pool metadata and achieving
arbitrary code execution in the Windows kernel (RCE / LPE).  Successful
exploitation compromises the entire operating system.

Fix Effectiveness
--------------------------------------------------------------------
The patched function aborts parsing as soon as the remaining byte count
is smaller than the opcode-specific payload length, so no out-of-bounds
reads or writes are possible.  With the added clean-up paths the object
reference counts are also correctly balanced.  No further overflow
conditions were observed in the updated code, making the fix
comprehensive for the reported issue.
