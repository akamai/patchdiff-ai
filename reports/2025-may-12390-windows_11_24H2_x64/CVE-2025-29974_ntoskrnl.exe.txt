{'cve': 'CVE-2025-29974', 'patch_store_uid': '200b84b3-2d89-4157-885c-37e85aa79c41', 'confidence': 0.2, 'kb': 'KB5058411', 'change_count': 3791, 'date': 1751789070.8200648, 'file': 'ntoskrnl.exe'}
--------------------------------------------------------------------
CVE-2025-29974 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows kernel (ntoskrnl.exe) routine formerly exported as
sub_1408FAD58 and now rebuilt as sub_1408E6D3C.  The code is part of
the memory-management helper that validates a user-supplied buffer
before forwarding the request to other memory query helpers.

Vulnerability Class
--------------------------------------------------------------------
CWE-191: Integer Underflow / Wraparound leading to
CWE-125: Out-of-bounds Read (information disclosure).

Detailed Root Cause Analysis
--------------------------------------------------------------------
The pre-patch implementation receives three user-controlled values:
  BaseAddress   – start of a user buffer to be examined
  a2            – length of that buffer (unsigned int)
  a3            – flag that tells the function to perform the
                  in-depth MemoryBasicInformation test.

No upper bound is enforced on a2.  The only range check is:

    if (BaseAddress + a2 > RegionBase + RegionSize)
            FAIL;

Because the addition occurs before the comparison, a2 values larger
than (2^64 – BaseAddress) cause a 64-bit wraparound.  After the
wrap, the resulting pointer is smaller than RegionBase and therefore
passes the check.  When the function later copies data from the
validated area (not shown in the diff but required by the higher
level caller), it will read past the end of the real allocation and
return kernel memory to user mode.

Even without an actual wraparound, supplying an overly large a2 lets
an attacker extend the permitted read beyond the MEM_COMMIT range
returned by ZwQueryVirtualMemory because the code fails to compare
against MEM_RELEASE/MEM_RESERVE except for the single DWORD1(v13) ==
32 test.  Integer wrapping therefore converts the logical check into
an underflow that opens an arbitrary sized window on kernel address
space.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// pre-patch – no size limit and susceptible to wraparound
v3 = a2;                                // attacker-supplied length
...
if ((unsigned __int64)BaseAddress < v11 ||
    (unsigned __int64)BaseAddress + v3 > *((_QWORD *)&v12 + 1) + v11)
        return STATUS_INVALID_PARAMETER; // supposed guard
```
```c
// post-patch – first line in function
if (a2 > 0x10000)                      // hard cap at 64 KiB
{
    v8 = STATUS_INVALID_PARAMETER;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User calls the IOCTL or internal API that eventually invokes
   sub_1408FAD58 with arbitrary BaseAddress and a2.
2. Function queries VAD information via ZwQueryVirtualMemory.
3. Length check adds a2 to BaseAddress; if the math wraps, the value
   is now lower than the region end and validation succeeds.
4. Subsequent helper (not shown) copies (a2) bytes from kernel memory
   to user space, disclosing uninitialized or sensitive data.

Attack Vector
--------------------------------------------------------------------
An unprivileged local attacker opens a handle to the affected device
or subsystem and requests memory validation with a2 set to a very
large length (>= 2^63).  No special privileges are required beyond
local code execution.

Patch Description
--------------------------------------------------------------------
Microsoft rewrote the helper:
1. Introduced an explicit length ceiling:  if (a2 > 0x10000) fail.
2. Restructured the code to use guarded sections and push-locks; all
   address arithmetic is now done after the size is known to be
   small, eliminating 64-bit wrap risk.
3. Added additional bookkeeping (array walk, ref-counts) ensuring the
   returned pointer is one of the tracked regions before any data is
   exposed.

Security Impact
--------------------------------------------------------------------
Before the fix, a local attacker could read up to 2^64 bytes minus one
page of arbitrary kernel memory, bypassing KASLR and leaking secrets
such as credential material or code pointers.  The flaw does not
provide write primitives but constitutes a high-quality information
leak that can be chained with other bugs for full elevation.

Fix Effectiveness
--------------------------------------------------------------------
Capping a2 to 64 KiB removes the possibility of 64-bit wraparound and
limits any accidental over-read to a single, benign page.  The
additional consistency checks and locked list membership tests make
it highly unlikely that an untracked region can be validated.  Given
the diff, the patch appears complete and effective against the
original underflow vector.
