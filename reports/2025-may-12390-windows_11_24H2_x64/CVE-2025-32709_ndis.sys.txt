{'file': 'ndis.sys', 'kb': 'KB5058411', 'cve': 'CVE-2025-32709', 'date': 1751781061.094339, 'confidence': 0.33, 'patch_store_uid': '58f43ca8-b3c2-47e5-ab47-dc07c9b90bad', 'change_count': 7}
--------------------------------------------------------------------
CVE-2025-32709 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows network stack – NDIS (ndis.sys) compartment
management code that backs the Ancillary Function Driver for
WinSock (AFD) and the Network-Store-Interface (NSI) user APIs.

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use After Free (dangling pointer inside asynchronous
notification path).

Detailed Root Cause Analysis
--------------------------------------------------------------------
Every network compartment is represented by an
NDIS_IF_COMPARTMENT_BLOCK structure that is reference-counted and
kept in a global doubly-linked list.  Deleting a compartment is
performed by ndisIfDeleteCompartment(); creation is handled by
ndisIfCreateCompartment()/ndisIfCreateCompartmentBlock().

OLD BEHAVIOUR
1.  While still holding the global WPP_MAIN_CB.DeviceObjectExtension
    spin-lock, the delete routine marked the object as “pending
    delete” by setting bit 2 in field Flags (offset +0x28):
       Flags |= 2
2.  It immediately queued an asynchronous NSI worker by calling
    ndisNsiScheduleCompartmentBlockChangeNotification(Block).
    No extra reference was taken – the only protection was the
    object’s own refcount that the routine then proceeded to
    decrement.
3.  If the refcount reached 0 the block was unlinked from the global
    list, the internal list heads at offsets 0x6D0/0x6D8 were torn
    down and finally the pool memory was released with
    ExFreePoolWithTag().
4.  As soon as the queued worker executed, it dereferenced the
    pointer it had been given earlier.  Because the memory could
    already have been returned to the pool, the worker touched
    freed memory – classic use-after-free, leading to kernel pool
    corruption and privilege-escalation.

A parallel problem existed during creation: the block was always
initialised with self-referential list heads (entries 218/219).  When
an experimental code path guarded by
Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage_4() was enabled,
other parts of the driver expected these fields to stay NULL.  The
mismatch produced dangling links once the block got destroyed.

PATCHED BEHAVIOUR
•  If the H2E_WPA3SAE feature is ON the delete routine no longer
   queues the asynchronous worker while the spin-lock is held.  It
   sets a local flag (v4) and, after releasing the lock, invokes the
   synchronous helper ndisNsiNotifyClientCompartmentChange() which
   does not outlive the caller; therefore the pointer is never used
   after the block is freed.
•  A KEVENT previously embedded inside the block (offset +0x6E0) is
   replaced by a stack-allocated event when the feature is OFF; when
   the feature is ON no event is stored in the block at all.
•  Creation code now skips initialising the 218/219 list heads when
   the feature is ON and inserts the block into a new global list
   head (qword_1C0125AF0) with its own counter
   (dword_1C01265B4).  Delete code decrements the matching counter.
   This guarantees that removal happens from the same list into
   which the object was inserted.

Together these changes ensure that no outstanding reference to the
block survives pool deallocation, eliminating the UaF condition.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// ndisIfDeleteCompartment() – old code
*((DWORD *)Block + 10) = flags | 2;          // mark PENDING_DELETE
ndisNsiScheduleCompartmentBlockChangeNotification(Block); // queue worker
...
KeReleaseSpinLock(...);
...
ExFreePoolWithTag(Block, 0);                  // block freed while
                                              // worker still pending
```
```c
// ndisIfDeleteCompartment() – new code (feature ON)
*((DWORD *)Block + 10) = flags | 2;
// No worker queued here; remember we need to notify later
v4 = 1;
...
KeReleaseSpinLock(...);
if (FeatureEnabled && v4)
    ndisNsiNotifyClientCompartmentChange(Block, 2);
```
```c
// ndisIfCreateCompartmentBlock() – list head initialisation
if (!FeatureEnabled)
{
    Block->List218.Flink = &Block->List218;
    Block->List218.Blink = &Block->List218;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Local attacker calls an NSI / AFD IOCTL that ultimately executes
   NsiSetAllParametersEx() to delete a compartment.
2. ndisIfDeleteCompartment() runs, schedules the asynchronous
   notification while still holding the spin-lock and releases the
   object.
3. Memory is freed; kernel pool can be re-allocated by attacker.
4. Worker thread later executes and touches the stale block pointer,
   corrupting pool data chosen by the attacker – resulting in
   elevation of privilege.

Attack Vector
--------------------------------------------------------------------
Local, authenticated.  Any account able to create and delete network
compartments via the Winsock/NSI APIs (e.g., standard Users group)
can trigger the flaw without admin rights.

Patch Description
--------------------------------------------------------------------
• Introduced feature-flag aware path that converts asynchronous NSI
  change notification into a synchronous call executed *after* the
  global spin-lock is released.
• Stopped embedding KEVENT objects and internal list heads inside
  the block when not needed (feature ON).
• Switched to a new dedicated compartment list head/counter to avoid
  list corruption.
• Added multiple fastfail checks and updated WPP tracing IDs.

Security Impact
--------------------------------------------------------------------
Prior to the fix a low-privileged user could trigger kernel pool
use-after-free, leading to arbitrary code execution in kernel mode
and therefore full local privilege escalation.

Fix Effectiveness
--------------------------------------------------------------------
The patched functions ensure that:
1.  No queued worker keeps an un-referenced pointer alive after the
    block’s memory is freed.
2.  Compartment blocks created and deleted under the new feature flag
    are linked and unlinked from the same list, preventing dangling
    list entries.
3.  The absence of embedded KEVENTs eliminates the last remaining
    access path into freed memory.

Static review of the modified paths confirms that all previously
unsafe asynchronous accesses now happen either while an elevated
reference is held or synchronously before the object is freed, fully
mitigating the original UaF condition.
