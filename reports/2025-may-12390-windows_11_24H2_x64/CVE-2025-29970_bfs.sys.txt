{'file': 'bfs.sys', 'patch_store_uid': '7ce2abc4-66a3-422e-be49-839e17d7c181', 'kb': 'KB5058411', 'date': 1751759662.259331, 'confidence': 0.23, 'cve': 'CVE-2025-29970', 'change_count': 1}
--------------------------------------------------------------------
CVE-2025-29970 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Brokering File System (bfs.sys) kernel driver –
function BfsCloseStorage, invoked when a storage object belonging to a
BFS instance is torn down.

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use After Free (dangling pointer dereference on a doubly
linked list head).

Detailed Root Cause Analysis
--------------------------------------------------------------------
BfsCloseStorage receives a per-storage context pointer P.  P[8]
(pointers are 8-byte slots in the context) is the head of a doubly
linked LIST_ENTRY that chains directory objects allocated from
NonPagedPool.  Before the patch the routine freed this list with a C-
style for-loop that re-used the list head variable "i" as both the
iterator and the object being freed:

    for (i = (void **)P[8]; ; ExFreePoolWithTag(i, 0)) { ... }

Execution order in each iteration was:

 1. Dereference *i to fetch the next entry (v5 = *i).
 2. If the list is not empty, unlink the first real node and free its
    embedded buffer(s).
 3. Execute the update expression ExFreePoolWithTag(i,0).

Step 3 releases the storage occupied by the LIST_ENTRY head itself,
leaving the variable "i" pointing at freed memory.  The loop then
returns to its top, immediately dereferences the dangling pointer
(*i) in step 1 of the next iteration.  An attacker who can reclaim the
just-freed pool chunk can control the contents of *i, steering the
kernel into arbitrary memory writes during the unlink sequence or into
an arbitrary address dereference, leading to elevation of privilege in
kernel context.

The bug is purely intra-thread; no race is needed.  Triggering only
requires that the list contains at least one element so that the loop
performs more than one iteration.

Structures/parameters affected:
  • P[8] – LIST_ENTRY head of root directory objects.
  • The freed entry’s private buffer ( *((PVOID*)v5 + 2) ) is also
    freed, but its content can be reused while the driver still trusts
    it.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Vulnerable loop (before patch)
for ( i = (void **)P[8];               // i == list head
      ;                                // no condition
      ExFreePoolWithTag(i, 0) )        // FREE list head *here*
{
    v5 = *i;                           // 1st deref of freed memory on
                                       // next iteration
    if ( *i == i )                     // empty?
        break;
    ...                                // unlink + frees
}
```
```c
// Patched version
BfsCloseRootDirectory(P);              // helper safely disposes list
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-mode operation creating/closing a BFS storage ->
  BfsPostCreateOperation / BfsDereferencePolicyEntryEx ->
    BfsCloseStorage(P) ->
      vulnerable loop frees list head while still in use ->
      dangling pointer dereferenced -> memory corruption.

Attack Vector
--------------------------------------------------------------------
A local, sandboxed or otherwise low-privileged process that can mount
or open a BFS storage object (e.g., via CreateFile on a brokered path)
causes the driver to eventually call BfsCloseStorage.  By ensuring the
root directory list contains multiple entries, the attacker provokes
the use-after-free and places controlled data in the reclaimed pool to
achieve arbitrary kernel write/execute, escalating privileges.

Patch Description
--------------------------------------------------------------------
The loop that manually manipulated and freed the LIST_ENTRY head was
removed.  A new helper, BfsCloseRootDirectory(P), now disposes of the
root directory list.  This helper presumably walks the list without
freeing the head until enumeration finishes, eliminating the dangling
pointer.  No other semantic changes were made; variable renaming only.

Security Impact
--------------------------------------------------------------------
Prior to the patch, local attackers could attain kernel arbitrary
memory write or execute via pool spraying, leading to elevation of
privilege (ring-0).  Reliability is high because the dangling pointer
is used deterministically in the same thread context.

Fix Effectiveness
--------------------------------------------------------------------
The vulnerable code path has been completely removed; enumeration and
freeing are now encapsulated in BfsCloseRootDirectory.  Assuming the
helper is implemented correctly and is not inlined back to the same
pattern, the specific UAF is fully mitigated.  No residual reference
to the freed list head remains in BfsCloseStorage.
