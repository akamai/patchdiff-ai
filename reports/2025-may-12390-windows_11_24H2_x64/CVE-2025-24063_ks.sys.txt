{'kb': 'KB5058411', 'date': 1751754788.523614, 'confidence': 0.11, 'file': 'ks.sys', 'patch_store_uid': 'e0e128b9-e29b-43e3-bc0f-a3d588c7804a', 'cve': 'CVE-2025-24063', 'change_count': 5}
--------------------------------------------------------------------
CVE-2025-24063 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Kernel Streaming (ks.sys) – CKsMdlcache::
MdlCacheHandleThunkBufferIrp()

Vulnerability Class
--------------------------------------------------------------------
CWE-122: Heap-based Buffer Overflow (manifesting through a dangling
pointer/use-after-free that leads to pool memory corruption)

Detailed Root Cause Analysis
--------------------------------------------------------------------
The helper CKsMdlcache::MdlCacheHandleThunkBufferIrp() prepares an IRP
for zero-copy (MDL-based) data transfer.  It walks a user-supplied
“thunk buffer” that consists of one or more 0x38-byte stream headers
and, for every header that has KSSTREAM_HEADER_OPTIONSF_TYPECHANGED
(bit 0x8000) set, it builds an MDL chain and attaches it to
Irp->MdlAddress.

If any consistency check fails, the routine jumps to an error label
(LABEL_25 in the old build).  The error path:
  • Iterates over the MDL chain
  • Unlocks pages if necessary
  • Frees every MDL with IoFreeMdl()

Crucially, in the original code Irp->MdlAddress is *not* cleared on the
common path.  It is only nulled when an obscure, feature-flagged helper
Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage_8() is enabled.  In
stock configurations the pointer therefore remains non-NULL while
already freed.

When execution returns to the I/O manager, subsequent code (for
example IoCompleteRequest(), IoFreeIrp() or driver-supplied Cancel/Clean-
up handlers) treats Irp->MdlAddress as valid and will touch, unlock or
free the same memory again.  Because pool blocks are reused, the stale
pointer now aliases attacker-controlled data.  Typical secondary
operations (MmUnlockPages, IoFreeMdl, memcpy, memset, etc.) will then
read or write past the bounds of the re-allocated object, corrupting
adjacent heap data in kernel space.

Attacker-controlled layout of the look-aside / NonPagedPool enables
reliable pool-overflow style exploitation and ultimately arbitrary code
execution in kernel mode (local EoP).

Key data items involved:
  IRP            → Irp->MdlAddress (dangling)
  MDL            → _MDL structure allocated from NonPagedPool
  Stream header  → user buffer that drives the state machine

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Old – LABEL_25: free without NULLing
MdlAddress = a2->MdlAddress;
if (MdlAddress) {
    do {
        Next = MdlAddress->Next;
        if (MdlAddress->MdlFlags & 2)
            MmUnlockPages(MdlAddress);
        IoFreeMdl(MdlAddress);
        MdlAddress = Next;
    } while (Next);
    /* pointer left dangling unless obscure flag 8 is set */
}
```

```c
// New – pointer is always cleared
MdlAddress = a2->MdlAddress;
while (MdlAddress) {
    Next = MdlAddress->Next;
    if (MdlAddress->MdlFlags & 2)
        MmUnlockPages(MdlAddress);
    IoFreeMdl(MdlAddress);
    MdlAddress = Next;
}
a2->MdlAddress = 0;      // <-- unconditional NULL
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User process opens a KS filter pin (CreateFile on ks.sys exposed
   device).
2. Sends IRP_MJ_READ / IRP_MJ_DEVICE_CONTROL with a crafted user buffer
   that:
   • Is at least 0x38 bytes long
   • Sets OPTIONSF_TYPECHANGED (0x8000) to steer the MDL path
   • Forces an early error (e.g. by omitting the data pointer)
3. CKsMdlcache::MdlCacheHandleThunkBufferIrp() allocates and attaches
   one or more MDLs, then hits the error condition and frees them but
   forgets to clear Irp->MdlAddress.
4. I/O manager or another driver path later re-uses the dangling
   pointer, leading to heap corruption in kernel mode.

Attack Vector
--------------------------------------------------------------------
Local, authenticated user with the ability to send IOCTL/Read requests
to a KS pin (multimedia subsystem).  No special privileges are needed
beyond DEVICE_READ/WRITE access.

Patch Description
--------------------------------------------------------------------
The update makes two relevant changes:
1. After freeing the MDL list in *all* exit paths, the code now
   unconditionally sets Irp->MdlAddress = NULL.
2. Additional refactoring adds Boolean guards (v5/v31) and a feature
   flag (DeviceUsage_5) that routes most callers through a rewritten,
   safer code path, but the decisive fix is the NULL assignment.

Security Impact
--------------------------------------------------------------------
A dangling MDL pointer let attackers induce a second free or cause
kernel routines to operate on attacker-controlled pool data.  By
spraying memory, this can be turned into an arbitrary kernel heap
overflow, allowing elevation to SYSTEM.

Fix Effectiveness
--------------------------------------------------------------------
Clearing the pointer removes the stale reference, converting all later
checks into benign NULL tests and preventing double-free/re-use.  No
further data paths reference freed memory, so the patch fully
neutralises the vulnerability.
