{'confidence': 0.19, 'change_count': 3, 'cve': 'CVE-2025-32709', 'kb': 'KB5058411', 'patch_store_uid': '5dd3b557-7452-4b29-9752-52189a241097', 'file': 'afd.sys', 'date': 1751781051.2551763}
--------------------------------------------------------------------
CVE-2025-32709 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Ancillary Function Driver for WinSock (afd.sys).  The issue is
in the kernel-mode IOCTL handlers AfdSuperAccept (IOCTL_AFD_SUPER_ACCEPT)
and AfdSuperConnect (IOCTL_AFD_SUPER_CONNECT).

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use-After-Free (concurrent access to connection / endpoint
objects that have already been returned to their look-aside list).

Detailed Root Cause Analysis
--------------------------------------------------------------------
AfdSuperAccept and AfdSuperConnect both manipulate AFD_CONNECTION and
AFD_ENDPOINT structures that are reference–counted through
   ENDPOINT->ReferenceCount         (offset +0x38)
   ENDPOINT->State                  (offset +0x168, bitfield, 0==idle)
   ENDPOINT->BusyFlag              *(offset +0x168+0x1c) == 4 while
                                     a “super” call is in progress
and are linked through:
   ENDPOINT->FreeConnectionSList    (offset +0xA0)
   ENDPOINT->OutstandingIrpList     (offset +0x60)

In the pre-patch code a connection entry is removed from the free list,
passed to AfdServiceSuperAccept / AfdTdi* helpers and, when these
helpers fail, immediately re-inserted into the list *after the spinlock
has been released* and *without having taken a reference*.  The same
pointer (v23 / FreeConnection) is meanwhile still accessible to other
threads, allowing the object to be freed and reused while the current
thread continues to touch its fields (re-insert, queue IRP, complete
IRP, etc.).  The identical pattern exists in AfdSuperConnect when it
constructs a connection, queues IRP completion callbacks, and then
invokes the transport-layer dispatch routine without retaining a safe
reference.

Race window
1. Thread A dequeues a connection from FreeConnectionSList.
2. Thread A releases the socket spinlock and invokes
   AfdServiceSuperAccept(), which fails.
3. Before Thread A re-queues the connection, Thread B wins the race
   (e.g. Cancel IRP / close socket) and frees the object back to the
   AFD look-aside list.
4. Thread A now operates on freed memory, dereferences embedded list
   pointers, and ultimately allows an attacker-controlled write/exec in
   kernel context.

Trigger pre-conditions
• (*ENDPOINT->State & 0x400000) == 0  (direct-accept path)
• DepthSList() > 0x7FFF  OR   AfdGetFreeConnection() != 0
• Failure in AfdServiceSuperAccept()  or transport dispatch path.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// pre-patch (AfdSuperAccept, simplified)
FreeConnection = AfdGetFreeConnection(ep);
...
if (!AfdServiceSuperAccept(ep, FreeConnection, &Lock, ListHead)) {
    // < no reference held, spinlock already dropped >
    *FreeConnection = ListHead->Flink;   // UAF when other CPU freed it
    ...                                   // re-insert into list
}
```

```c
// post-patch
// – holds rundown protection while list is walked
// – keeps spinlock across error-path reinsertion
// – adds AfdNotifySockIndicateEventsUnlock(), removes window
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User –> NtDeviceIoControlFile( socket, IOCTL_AFD_SUPER_ACCEPT / _CONNECT )
     –> afd.sys::AfdDispatchDeviceControl()
     –> AfdSuperAccept() / AfdSuperConnect()
     –> race in error path –> freed connection reused –> kernel crash or
        controlled write / EoP.

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker.  Any user that can create a Winsock
socket (AF_INET/AF_INET6) can send crafted IOCTLs and use thread
cancellation / handle-close races to provoke the UAF and execute code in
kernel mode, thereby escalating privileges.

Patch Description
--------------------------------------------------------------------
1. Added explicit feature/state gating:
     if (Feature_IsEnabled && (Endpoint->Flags & AFD_FLAG_XXX))
      return STATUS_INVALID_PARAMETER;
2. Introduced auxiliary pointer (v48) so the original referenced
   FileObject is retained for clean-up even if local variable is
   overwritten.
3. Took an additional reference / rundown protection on endpoint before
   manipulating lists (ExAcquireRundownProtection, AfdRefTLBaseEndpoint)
   and releases it in all exit paths.
4. Holds socket spinlock while reinserting failed connection, thereby
   eliminating the race window.
5. Uses new helper AfdNotifySockIndicateEventsUnlock() that releases the
   spinlock *after* notification has completed.
6. Added consistent error-path that dereferences objects, unlocks MDLs
   and completes IRP exactly once.

Security Impact
--------------------------------------------------------------------
Prior to the fix, a local attacker could reliably cause a kernel use-
after-free leading to arbitrary code execution in kernel context and
full privilege escalation (SYSTEM).  The race is in socket-level code
reachable from user mode without special privileges.

Fix Effectiveness
--------------------------------------------------------------------
The patch removes the dangerous window by (a) holding references/rundown
protection, (b) not releasing the spinlock until the object is safely
re-linked, and (c) rejecting invalid endpoint types up-front.  All exit
paths now balance references, making the stale-pointer scenario
unreachable.  No residual UAF condition was observed in the patched
handlers.
