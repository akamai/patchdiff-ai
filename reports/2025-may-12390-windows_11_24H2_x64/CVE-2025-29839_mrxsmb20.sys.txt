{'date': 1751780999.4937491, 'change_count': 2, 'file': 'mrxsmb20.sys', 'cve': 'CVE-2025-29839', 'kb': 'KB5058411', 'confidence': 0.64, 'patch_store_uid': '1b7cdb19-0eb8-4933-85cf-f3206501b6ce'}
--------------------------------------------------------------------
CVE-2025-29839 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows UNC Provider / SMB2 redirector driver (mrxsmb20.sys) –
client-side processing of SMB2 CHANGE_NOTIFY responses and file ABE
status name-cache handling.

Vulnerability Class
--------------------------------------------------------------------
Out-of-bounds read (information disclosure) – CWE-125.

Detailed Root Cause Analysis
--------------------------------------------------------------------
The buggy path sits in Smb2ChangeNotify_Finalize().  Before the patch
the routine retrieves the buffer-context that holds the raw
FILE_NOTIFY_INFORMATION list returned by the SMB2 CHANGE_NOTIFY
response:

    v9 = *(_QWORD *)(a1 + 160) - 8      ; ctx = BUFFER_CONTEXT
    v4 = *(DWORD *)(v9 + 48)            ; Status of request
    Length = *(DWORD *)(v9 + 300)       ; Size of notify payload

If the I/O status (v4) is success, the code unconditionally trusts the
length field, stores it in RxContext->Information (offset 184), then
continues execution in other layers that iterate through the
FILE_NOTIFY_INFORMATION chain.  No attempt is made to verify that

  • the buffer length is non-zero and properly aligned, or
  • every NextEntryOffset keeps the walk inside <Buffer + Length>.

Therefore a malicious SMB2 server can craft a payload whose internal
offsets run past the end of the allocated MDL, causing subsequent
parsers in kernel mode to read from adjacent memory.  Because the data
are later copied back to user space (and may even traverse the
network), arbitrary kernel information can be disclosed.

Patch analysis shows two protection measures:

1.  Microsoft inserted a call to FsRtlValidateChangeNotifyBufferEx().
    The helper walks the list and guarantees that the buffer is
    self-consistent and fully contained in the declared length.

2.  When validation fails the code now forces STATUS_INVALID_PARAMETER
    (0xC000000D / –1073741629) and still finalises the buffer context,
    preventing the earlier dereference.

The validation is gated behind
Feature_1397499194__private_IsEnabledDeviceUsageNoInline() but the
feature is enabled for all supported builds that contain the patch.

The second diff (Smb2InsertFileAbeStatusCacheEntry) is unrelated to the
leak; it only simplifies name-cache activation and removes a separate
feature flag.

Affected structures / parameters
  a1 + 160     – list entry that links to SMB2_CSE_BUFFER_CONTEXT
  ctx+48       – NTSTATUS result of on-wire command
  ctx+264      – pointer to notify buffer
  ctx+300      – length of notify buffer (supplied by server)

Failure to validate ctx+264..ctx+299 against ctx+300 allowed an OOB
read starting at ctx+264 + crafted NextEntryOffset.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Old (simplified)
if (v4 >= 0)                 // success path
    v4 = *(DWORD *)(ctx+48); // unchanged
if ((v4 & 0xC0000000) != 0xC0000000)
    RxCtx->Information = *(DWORD *)(ctx+300);   // trust length
SmbCseFinalizeBufferContext();                   // done – no check

// New core fix
if (v4 >= 0) {
    length = *(DWORD *)(ctx+300);
    if (length) {
        status = FsRtlValidateChangeNotifyBufferEx(&Entries,
                        NULL, v4, *(QWORD *)(ctx+264), length,
                        (*(_BYTE *)(a1+2066) & 1));
        if (status < 0) {
            v4 = STATUS_INVALID_PARAMETER;      // 0xC000000D
            goto Finalise;
        }
    }
}
...
Finalise:
SmbCseFinalizeBufferContext(ctx);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User process  -> CreateFile / ReadDirectoryChangesW
              -> I/O stack sends SMB2 CHANGE_NOTIFY request
Malicious SMB server returns crafted FILE_NOTIFY_INFORMATION chain
mrxsmb20.sys  -> Smb2ChangeNotify_Indication()
              -> Smb2ChangeNotify_Finalize() (buggy path)
              -> Subsequent path enumeration reads past buffer -> leak

Attack Vector
--------------------------------------------------------------------
Any local user that can force the Windows client to access a malicious
SMB share (UNC path, WebDAV over SMB, etc.) can supply the crafted
CHANGE_NOTIFY response.  No special privileges are required; the
attacker only needs control over the remote server or the network path.

Patch Description
--------------------------------------------------------------------
• Added explicit call to FsRtlValidateChangeNotifyBufferEx() to verify
  the integrity of FILE_NOTIFY_INFORMATION buffers.
• On validation failure, forces STATUS_INVALID_PARAMETER and skips
  further processing.
• Ensures SmbCseFinalizeBufferContext() is invoked with the correct
  context pointer in both success and failure cases.
• Replaced in-line directory cache invalidation with
  Smb2InvalidateDirInfoCacheEx() (defence-in-depth, not part of fix).

Security Impact
--------------------------------------------------------------------
Before the fix an attacker could read arbitrary uninitialised kernel
memory that sits after the MDL containing the server-supplied buffer
and have it returned to user mode or over the network, leading to
information disclosure and potential ASLR bypass.

Fix Effectiveness
--------------------------------------------------------------------
The new validation covers both buffer length and internal offsets; any
malformed buffer now results in STATUS_INVALID_PARAMETER before the
pointer walk occurs.  Because the context is still finalised no other
cleanup paths are skipped.  The fix fully addresses the described OOB
read.
