{'file': 'clfs.sys', 'date': 1751781009.636464, 'kb': 'KB5058411', 'cve': 'CVE-2025-32706', 'confidence': 0.26, 'change_count': 34, 'patch_store_uid': '50b75c18-3545-4611-ba2f-9638129745a0'}
--------------------------------------------------------------------
CVE-2025-32706 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Common Log File System (CLFS) kernel driver
clfs.sys – routine
CClfsBaseFilePersisted::ExtendMetadataBlockDescriptor()

Vulnerability Class
--------------------------------------------------------------------
Heap-memory double free / pool corruption due to improper state
validation (CWE-415, manifests as CWE-20 – improper input validation)

Detailed Root Cause Analysis
--------------------------------------------------------------------
The CLFS routine ExtendMetadataBlockDescriptor() is responsible for
increasing the size of one of the three in-memory metadata blocks that
back a CLFS log.  Every block is referenced through a descriptor array
located at  this->m_pMetadataDesc ("*(this+0x30)").  Each descriptor is
24 bytes: {PVOID pBlock; ULONG cbBlock; ULONG Flags}.

1.  When the incoming request indicates that block i must be replaced by
the contents of block i+1 (the "shadow block" case), the function first
retrieves the pointer stored in descriptor[i] (variable v6) and, if it
is different from the pointer stored in descriptor[i+1], frees it:
       ExFreePoolWithTag(v6);
   The descriptor entry is then overwritten with the content of
descriptor[i+1].

2.  Before returning, the routine tries to free the *old* buffer once
again unless that buffer is still marked as a shadow block:
       if (v6 && !IsShadowBlock((CClfsBaseFilePersisted*)v21, i, i-1))
           ExFreePoolWithTag(v6);

3.  The intention is that v21 should hold the address of the descriptor
array so that IsShadowBlock() can inspect the current pointer value in
 descriptor[i].  Unfortunately, the same register-backed local variable
(v21) is reused for unrelated arithmetic later in the function
(modulus, alignment, etc.).  By the time the epilogue executes, v21 no
longer contains a valid pointer – it holds a small integer.
IsShadowBlock therefore operates on an invalid address, always returns
FALSE, and the already-freed buffer referenced by v6 is freed a second
time.

4.  A local attacker that can reach this code path (e.g. via the public
CLFS APIs NtCreateLogFile/NtSetInformationFile → SetEndOfLog →
ExtendMetadataBlockDescriptor) controls the lifetime of the metadata
blocks and can reliably trigger the double free.  Subsequent pool
allocations allow re-occupation of the freed chunk, leading to pool
corruption and ultimately arbitrary kernel-mode code execution.

Affected parameters/structures
  • a2 – index of the metadata block (0-2) that is being extended.
  • Descriptor array *(this+0x30) – 24-byte records per block.
  • Local variables  v6  (old buffer) and  v21  (descriptor pointer)
    whose lifetime overlap incorrectly.

Vulnerability Code Snippets
--------------------------------------------------------------------
Before patch (epilogue)
```c
if ( v6 &&
     !CClfsBaseFilePersisted::IsShadowBlock((CClfsBaseFilePersisted *)v21,
                                            v3, v3-1) )
{
    ExFreePoolWithTag(v6, 0);          // second free – corruption
}
```
After patch
```c
if ( v6 &&
     !CClfsBaseFilePersisted::IsShadowBlock((CClfsBaseFilePersisted *)v20,
                                            v3, v3-1) )
{
    ExFreePoolWithTag(v6, 0);          // executes only when safe
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-mode ⇒ NtSetInformationFile(SetEndOfLog) ⇒
  CClfsLogFcbPhysical::SetEndOfLog ⇒
  CClfsBaseFilePersisted::ExtendMetadataBlock() ⇒
  CClfsBaseFilePersisted::ProcessCurrentBlockForExtend() ⇒
  CClfsBaseFilePersisted::ExtendMetadataBlockDescriptor(index,size)
    ↳ shadow-block branch followed by function epilogue
    ↳ double free on same pool chunk

Attack Vector
--------------------------------------------------------------------
A local, low-privileged attacker opens or creates a CLFS log file and
issues crafted SetEndOfLog/CLFS_RECORD_TYPE operations so that:
  • block i is a shadow of block i+1, and
  • the requested extension size triggers the early reuse branch.
The attacker then performs heap grooming in the kernel pool between the
first and second free to reclaim the chunk with controlled data,
leading to arbitrary kernel write and elevation of privilege.
No special privileges are required beyond the ability to create and
write to a CLFS log.

Patch Description
--------------------------------------------------------------------
The update performs defensive refactoring:
  • Introduces dedicated variables (v20, v22) so the pointer to the
    descriptor array is preserved throughout the function lifetime.
  • Replaces the IsShadowBlock() epilogue argument from the clobbered
    variable v21 to the preserved pointer v20, preventing an invalid
    memory reference and ensuring the second free is executed only when
    the buffer is not already freed.
  • Minor cosmetic changes (layout, trace GUIDs, type corrections) that
    do not affect security.

Security Impact
--------------------------------------------------------------------
Before the patch the routine could free the same pool allocation twice.
By reclaiming the freed chunk, an attacker gains the ability to corrupt
pool metadata or object contents, leading to arbitrary kernel memory
write and full local elevation of privilege (ring-0 code execution).
System integrity and confidentiality are fully compromised.

Fix Effectiveness
--------------------------------------------------------------------
By ensuring IsShadowBlock() receives a valid, unaltered pointer, the
second free is skipped for buffers already released, eliminating the
double-free condition.  No other variable aliasing capable of reviving
the bug is observable in the new code, so the fix is considered
effective for this specific flaw.
