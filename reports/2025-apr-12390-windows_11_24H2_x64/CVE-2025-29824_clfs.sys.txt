{'file': 'clfs.sys', 'change_count': 11, 'patch_store_uid': 'ae2d10cf-f612-4183-9fbb-bd006dba2545', 'cve': 'CVE-2025-29824', 'kb': 'KB5055523', 'date': 1751822629.1332388, 'confidence': 0.23}
--------------------------------------------------------------------
CVE-2025-29824 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Common Log File System (CLFS) kernel driver – clfs.sys
(CClfsRequest, CClfsLogCcb, CClfsLogFcb* and related structures).

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use After Free (stale pointer retained in FILE_OBJECT
contexts leading to dangling-reference access in kernel mode).

Detailed Root Cause Analysis
--------------------------------------------------------------------
Each FILE_OBJECT opened on a CLFS log keeps two opaque context
pointers:
    Fo->FsContext  → CClfsLogFcbCommon (FCB)
    Fo->FsContext2 → CClfsLogCcb       (CCB)

When an IRP_MJ_CLOSE arrives, the original implementation of
CClfsRequest::Close():
  1. Retrieved Fo->FsContext2 (CCB).
  2. Called CClfsLogFcbCommon::Close(), which internally decrements
     the CCB reference count and may free the object.
  3. Returned to caller **without**
       • clearing Fo->FsContext/FsContext2, or
       • holding an extra reference while the routine executed.

If any other kernel path still owned a reference to the FILE_OBJECT –
for example a pending asynchronous read or a racing thread that called
NtQueryInformationFile immediately after Close – it would consult the
still-populated FsContext2 field and access the CCB that had just been
freed.  The freed slab could be re-allocated under attacker control,
turning the dangling reference into an arbitrary-write primitive in
kernel space.

An additional bug in CClfsLogCcb::Cleanup() caused the CCB to be
released twice in some edge cases, amplifying the UAF window.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before (1C0068F70)
v3 = (CClfsLogFcbCommon *)*(Fo->FsContext + 15);
CClfsLogFcbCommon::Close(v3, v4);   // may free CCB
// FsContext/FsContext2 left intact – stale pointers
```
```c
// after (patched)
FsContext2 = Fo->FsContext2;
if (FsContext2) CClfsLogCcb::AddRef(FsContext2);
...
CClfsLogFcbCommon::Close(v5, v7);
...
Fo->FsContext  = 0;
Fo->FsContext2 = 0;          // clear stale pointers
if (FsContext2) CClfsLogCcb::Release(FsContext2);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User mode:
  1. CreateFileA("\\.\Clfs") → obtains HANDLE-1.
  2. DuplicateHandle(HANDLE-1, …) → HANDLE-2.
  3. Thread-A closes HANDLE-1 → IRP_MJ_CLOSE processed, frees CCB.
  4. Thread-B immediately issues DeviceIoControl on HANDLE-2.
Kernel mode:
  • Ioctl handler dereferences Fo->FsContext2, now pointing to freed
    memory ⇒ use-after-free and controlled memory corruption.

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker.  No special privileges are needed – only
ability to open a log stream handled by clfs.sys.  By racing Close vs.
any other CLFS I/O the attacker can obtain arbitrary kernel-mode write
access and elevate privileges.

Patch Description
--------------------------------------------------------------------
• CClfsRequest::Close()
    – Takes an extra reference on the CCB at function entry.
    – After the Close path finishes, explicitly sets
      FILE_OBJECT.FsContext/FsContext2 to NULL.
    – Drops the extra reference only after the pointers are cleared.
• CClfsLogCcb::Cleanup()
    – Guards the final CClfsLogCcb::Release() to avoid double-free when
      called from the new Close path.
• CClfsLogFcbPhysical::ReleaseInternal()
    – Re-orders list removal vs. table unlink to prevent stale list
      entries and adjusts fail-fast conditions.

Security Impact
--------------------------------------------------------------------
Prior to the fix a local attacker could reliably trigger a kernel
use-after-free, resulting in elevation of privilege or, at minimum,
local denial of service (bug check 0xC1F5).  Exploitation requires only
normal user permissions and is therefore classified as an EoP.

Fix Effectiveness
--------------------------------------------------------------------
The added AddRef/Release pair guarantees the CCB remains alive for the
entire Close routine, and NULL-ing the FILE_OBJECT fields removes the
remaining dangling reference.  Complementary changes in Cleanup and
ReleaseInternal close secondary free paths.  With these corrections the
observed UAF condition can no longer be reproduced, indicating the
patch fully addresses the vulnerability path described above.
