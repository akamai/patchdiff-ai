{'kb': 'KB5055523', 'file': 'explorer.exe', 'change_count': 98, 'patch_store_uid': '933522d5-e700-45f5-ad1a-e41cb4c13c34', 'confidence': 0.02, 'cve': 'CVE-2025-27729', 'date': 1751822639.133644}
--------------------------------------------------------------------
CVE-2025-27729 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Shell (explorer.exe) – TaskbarTip primary-taskbar Win11
initialisation code, specifically wil::com_ptr_t<tip2::details::
merged_data<TaskbarTip::_tip_PrimaryTaskbarInitializationWin11>>

Vulnerability Class
--------------------------------------------------------------------
Use-After-Free (CWE-416)

Detailed Root Cause Analysis
--------------------------------------------------------------------
The smart-pointer helper wil::com_ptr_t::reset() is the routine that
releases the current COM/WinRT object and clears the stored raw
pointer.  In explorer.exe the template instance that manages the
TaskbarTip primary-initialisation object was accidentally linked to an
entirely unrelated helper that enumerates display monitors:

    BOOL EnumDisplayMonitorsLambda(...)
        { EnumDisplayMonitors(...); }

Consequences of the mix-up:
1. reset() is invoked whenever the shell re-initialises or disposes of
   the TaskbarTip helper.
2. The bogus implementation never touches the internal pointer
   (m_ptr) – it neither calls Release() nor nulls the field.
3. The ownership count of the underlying merged_data object therefore
   stays unchanged and the pointer remains pointing to an object that
   the rest of the code subsequently destroys.
4. On the next destruction/reset, Release() is executed on memory that
   has already been freed and potentially re-allocated, giving an
   attacker control of the v-table pointer and leading to arbitrary
   code execution inside explorer.exe.

Structures / parameters affected
• wil::com_ptr_t< merged_data<...> >::m_ptr – stale after first reset.
• merged_data::_Vtbl – attacker-controlled when memory is reused.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
BOOL EnumDisplayMonitorsLambda__(...) {
    LPARAM dwData = a3;
    return EnumDisplayMonitors(0,0,Adapter,&dwData);
}

// after
void * __fastcall wil::com_ptr_t::reset(void **pp) {
    void *old = *pp;     // grab current pointer
    *pp = 0;             // NULL out first
    if (old)
        tip2::details::merged_data::Release(old);
    return old;
}
```
The patched body does the expected NULL-and-Release sequence; the
spurious EnumDisplayMonitors call is completely removed.

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User or attacker causes repeated taskbar initialisation (e.g.
   monitor hot-plug, DPI change, taskbar relaunch).
2. Explorer calls com_ptr.reset() on the TaskbarTip helper.
3. Pre-patch reset() returns without releasing, leaving m_ptr stale.
4. Later code releases the already-freed object –> UAF & heap
   corruption –> RCE.

Attack Vector
--------------------------------------------------------------------
Any locally running process (including a low-integrity Edge/Chrome
sandbox) can send the series of shell notifications that repeatedly
initialise the taskbar.  No special privileges are required; success
only depends on heap grooming to occupy the freed block before the
second Release() executes.

Patch Description
--------------------------------------------------------------------
Microsoft replaced the incorrect body of
wil::com_ptr_t<merged_data>::reset() with a minimal, correct
implementation:
• fetch pointer
• zero field first (prevents re-entrancy races)
• call merged_data::Release() when non-null
No other logic is executed, eliminating the possibility of executing
code on an already-freed object.

Security Impact
--------------------------------------------------------------------
The bug allows controlled use-after-free of an explorer.exe heap
object.  Because the freed block contains a COM v-table pointer,
attackers can redirect execution and run arbitrary code in the context
of the logged-on user (explorer usually has medium integrity level).
This is classified by Microsoft as a Remote Code Execution
vulnerability when combined with a sandbox escape, and as local code
execution otherwise.

Fix Effectiveness
--------------------------------------------------------------------
The corrected reset() now performs the required Release()/NULL pair.
No remaining paths reference the pointer after it is freed, so the
use-after-free condition is removed.  The change is confined to the
reset helper and does not alter external behaviour, making regression
risk low and the fix effective.
