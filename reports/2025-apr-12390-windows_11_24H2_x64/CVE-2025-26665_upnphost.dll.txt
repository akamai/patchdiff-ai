{'kb': 'KB5055523', 'file': 'upnphost.dll', 'patch_store_uid': 'db294493-e719-4193-9502-b097e10eee9b', 'confidence': 0.34, 'cve': 'CVE-2025-26665', 'date': 1751822653.5252056, 'change_count': 16}
--------------------------------------------------------------------
CVE-2025-26665 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows UPnP Device Host service (upnphost.dll).  Affected routines
include CRegistrarSingleton::SetICSInterfaces, 
CUPnPInterfaceList::HrSetICSOff / HrShutdown, 
BaseHttpListener::DoReceiveRequestHeaders, and the helper routines
StringVPrintfWorkerW_*.

Vulnerability Class
--------------------------------------------------------------------
Race condition / use-after-free caused by missing synchronisation of
handle-bearing fields.  In practice this translates into CWE-591
(Sensitive data stored in memory that is not properly locked) and a
local Elevation of Privilege.

Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  COM entry point
    CRegistrarSingleton::SetICSInterfaces() is callable by any local
    client through the IUPnPRegistrar interface.  Before the patch the
    function manipulated the **global** thread handle `hObject` and the
    per-instance handle stored at offset +26 of
    CUPnPInterfaceList::s_instance **without acquiring any lock**.

2.  Handle life-cycle before the patch
    a.  If `hObject` was non-NULL the code performed
        WaitForSingleObject(hObject,INFINITE) followed by CloseHandle.
    b.  Immediately afterwards CreateThread is invoked and the returned
        handle is written back to `hObject` (+26 in the object).
    c.  Nothing prevents a second caller from executing the same code
        path concurrently.  Two threads therefore can interleave so
        that one thread frees a handle that the other still expects to
        be valid (classic use-after-free).

3.  Memory/handle reuse window
    Because the service runs as LocalService/SYSTEM, an attacker can
    deliberately create kernel objects until the just-freed handle
    value is re-allocated for an attacker-controlled object.  When the
    service later calls WaitForSingleObject or CloseHandle it will
    operate on the attacker’s object, enabling privilege-escalation
    primitives (e.g. signalling an event in a higher privilege
    namespace or closing a handle that should stay open).

4.  Related secondary issues
    * CUPnPInterfaceList::HrShutdown() used the same unguarded fields
      during service stop, producing an identical race.
    * BaseHttpListener::DoReceiveRequestHeaders() relied on an
      uninitialised NumberOfBytesTransferred when ERROR_MORE_DATA was
      returned – potentially copying stale memory into a heap buffer.
    * The two internal StringVPrintfWorkerW_* helpers returned wrong
      length information when the buffer was exactly full, causing the
      caller to treat uninitialised memory as valid.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – no locking, shared field +26
DWORD ThreadId = 0;
void *v2 = *((void **)this + 26);
if (v2) {
    WaitForSingleObject(v2, INFINITE);
    CloseHandle(v2);
    *((void **)this + 26) = NULL;
}
*((void **)this + 26) = CreateThread(NULL,0,ExecIcsChangeInterfaces,
                                     this,0,&ThreadId);
```
```c
// after patch – serialised with critical section and new slot +31
EnterCriticalSection((LPCRITICAL_SECTION)this + 2);
...
*((void **)this + 31) = CreateThread(...);
LeaveCriticalSection((LPCRITICAL_SECTION)this + 2);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Low-privileged client obtains IUPnPRegistrar via COM.
2. Client spams SetICSInterfaces() from multiple threads.
3. Races in HrSetICSOff/HrShutdown close and recreate the same handle.
4. Attacker reallocates the freed handle for a controlled object.
5. Service operates on attacker’s handle with LocalService/SYSTEM
   privilege, enabling EoP.

Attack Vector
--------------------------------------------------------------------
Local.  Any authenticated user capable of activating the UPnP Registrar
COM object can trigger the race condition; no additional service
configuration is required.

Patch Description
--------------------------------------------------------------------
* Introduces a dedicated critical section (offset +2 in the object) and
  wraps all handle manipulation (CloseHandle / CreateThread / Wait*) in
  Enter/LeaveCriticalSection pairs.
* Moves the thread-handle field from index +26 to +31, preventing legacy
  code paths from touching the new handle unintentionally.
* CUPnPInterfaceList::HrShutdown now serialises shutdown-time handle
  cleanup in the same way.
* DoReceiveRequestHeaders now optionally supplies
  NumberOfBytesTransferred to HttpReceiveHttpRequest when the new
  feature flag is active, preventing use of uninitialised stack memory.
* StringVPrintfWorkerW_* were swapped/fixed so that pcchNewDestLength is
  updated correctly and the overflow path no longer leaks stack data.

Security Impact
--------------------------------------------------------------------
Without the lock an attacker could:
1. Cause the service to act on a hijacked handle (signal, duplicate or
   close), achieving Local Privilege Escalation.
2. Read or corrupt sensitive in-process state because stale pointers
   remained accessible.
3. Indirectly disclose memory through the uninitialised-length bug in
   DoReceiveRequestHeaders / StringVPrintfWorkerW.

Fix Effectiveness
--------------------------------------------------------------------
Serialising all handle operations removes the race window, making
hijacking impossible.  Additional hardening (correct buffer length
handling) prevents auxiliary memory-safety problems.  The protection is
conditionally compiled behind FeatureId 2578215227; effectiveness
therefore depends on that feature being enabled on the target build, but
it is enabled by default in the shipping patch level.
