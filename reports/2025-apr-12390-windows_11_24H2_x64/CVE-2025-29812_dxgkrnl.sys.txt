{'date': 1751820824.2360735, 'confidence': 0.38, 'kb': 'KB5055523', 'file': 'dxgkrnl.sys', 'cve': 'CVE-2025-29812', 'change_count': 54, 'patch_store_uid': 'b37e521c-417a-4885-aabb-f65dc66218e0'}
--------------------------------------------------------------------
CVE-2025-29812 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows DirectX Graphics Kernel (dxgkrnl.sys) – class
CIFlipPresentHistoryToken and related list-management code.

Vulnerability Class
--------------------------------------------------------------------
Untrusted pointer dereference / doubly-linked list unlink leading to
arbitrary kernel memory write (CWE-822).

Detailed Root Cause Analysis
--------------------------------------------------------------------
CIFlipPresentHistoryToken objects keep a LIST_ENTRY-style doubly linked
list of auxiliary structures.  Prior to the patch, the class destructor
(~CIFlipPresentHistoryToken) reduced to a single virtual call:

    vtable(this, 1);

The vtable routine performed list removal without verifying that the
Flink/Blink fields inside each entry were trustworthy.  Because parts of
the list could be influenced by user-mode controlled present history
tokens, an attacker could supply crafted list pointers.  During
uninitialisation the kernel executed the classic unlink primitive:

    Flink->Blink = Blink;
    Blink->Flink = Flink;

If either Flink or Blink was attacker-controlled, the write turned into
an arbitrary 8-byte store to an attacker-chosen kernel address, giving
full read-write primitives and therefore SYSTEM-level privilege.

The patch replaces the destructor with an inline lambda that walks the
list while explicitly validating both forward and backward links before
performing the unlink:

    if (*(next->Flink+8) != next || *(next->Blink) != next)
        FAST_FAIL(3);

If the integrity check fails the kernel terminates the process via
fastfail, preventing the write.  Only after both links are proven self-
consistent are the list pointers relinked and the object-specific
cleanup routines invoked.

Affected structures / parameters:
  • CIFlipPresentHistoryToken
      – LIST_ENTRY at offset +8 (assumed)
  • attacker-controlled Flink / Blink pointers used during unlink

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable behaviour (pre-patch)
void __fastcall CIFlipPresentHistoryToken::~CIFlipPresentHistoryToken(
        CIFlipPresentHistoryToken *this)
{
    if (this)
        (**(void (__fastcall ***)(CIFlipPresentHistoryToken *,
                                  __int64))this)(this, 1i64);
}

// patched routine (excerpt)
while (1) {
    entry = *head;
    next  = *(entry);
    if (next == *head)
        break;                 // list empty
    if (*(QWORD*)(*next + 8) != next || *(QWORD*)(next[1]) != next)
        __fastfail(3);         // integrity check
    *next[1] = *next;          // safe unlink
    *(QWORD*)(*next + 8) = next[1];
    (*(fn*)(obj-1)[7])(obj-1); // object cleanup
    (*(fn*)(obj-1)[0])(obj-1,1);// final release
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User-mode code opens a Direct3D/DirectComposition device.
2. Sends crafted flip-model present requests that cause
   CIFlipPresentHistoryToken objects to be created with controlled list
   link fields.
3. When the device or process is closed the kernel calls the destructor
   for CIFlipPresentHistoryToken.
4. The destructor unlinks the corrupted entry, writing to arbitrary
   kernel memory and elevating attacker privileges.

Attack Vector
--------------------------------------------------------------------
Local, from a sandboxed or standard user account able to create a D3D
context.  No special privileges required; only graphics hardware access
is needed.

Patch Description
--------------------------------------------------------------------
Replaced the former one-line destructor with a hardened lambda that:
  • Iterates through every entry in the internal list.
  • Verifies that next->Flink->Blink == next AND next->Blink->Flink ==
    next before unlinking.
  • Invokes fastfail (FAST_FAIL 3) if the links are not mutually
    consistent.
  • Performs the unlink and normal cleanup only after successful
    validation.
This change prevents an attacker from directing writes to arbitrary
kernel addresses via corrupted list pointers.

Security Impact
--------------------------------------------------------------------
Before the fix, successful exploitation yielded arbitrary kernel memory
write, enabling escalation from local user to SYSTEM and potential full
OS compromise.  Confidentiality, integrity, and availability were all
impacted.

Fix Effectiveness
--------------------------------------------------------------------
The added integrity checks convert the primitive into a fail-stop
condition, eliminating the ability to forge Flink/Blink pointers.  No
bypass is evident from the diff; however, effectiveness depends on all
entry points using the new destructor.  Residual risk: unknown if other
list operations elsewhere remain unchecked.
