{'file': 'http.sys', 'kb': 'KB5055523', 'patch_store_uid': '39ce3636-1b36-4b14-a9ae-92b4f2079b73', 'date': 1751820812.912801, 'cve': 'CVE-2025-27473', 'confidence': 0.23, 'change_count': 28}
--------------------------------------------------------------------
CVE-2025-27473 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows kernel HTTP protocol stack      
(http.sys), function ParseChunkLength,  
responsible for decoding the length     
of an incoming chunked-encoding header. 

Vulnerability Class
--------------------------------------------------------------------
CWE-400: Uncontrolled Resource          
Consumption (Denial-of-Service) due to  
missing length/boundary validation and  
resulting arithmetic underflow.

Detailed Root Cause Analysis
--------------------------------------------------------------------
ParseChunkLength receives:              
  a3 – pointer to current buffer start  
  a4 – number of valid bytes remaining  
It first optionally skips a preceding   
CRLF, then tries to locate the first    
hexadecimal digit of the chunk length.  
                                          
In the vulnerable build the search is   
performed by                           
    HexToken = FindHexToken(v8, v11,&v25)
where                                    
  v8   = current buffer pointer         
  v11  = remaining byte count (a4)      
  v25  = OUT: length of hex run         
The helper does **not** verify that     
"HexToken + v25" still lies inside the  
[a3 , a3 + a4) receive buffer. An       
attacker can therefore send a segment   
ending in the middle of the hex digit   
sequence.  Example:                     
   0000000D...<half of next digit>      
FindHexToken returns a valid pointer    
inside the buffer but reports v25 that  
extends past its end.                   
                                          
ParseChunkLength subsequently computes  
   remaining = v11 + v8 - HexToken - v25
When v25 exceeds the actual data size   
`remaining` underflows to a very large  
unsigned value (≈4 GB). This inflated   
length is passed to                    
   FindChunkHeaderEnd(…, remaining, …); 
which performs a linear scan, locking   
the parser in a CPU-bound loop that may 
span gigabytes of address space. In     
error paths a negative byte-count can   
also be returned through *a7, causing   
IIS/WinRM to re-enter the routine over  
and over, further amplifying the DoS.   
No memory corruption occurs, but the    
kernel thread spins until timed out,    
starving http.sys worker threads and    
rending the service unavailable.        

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable
HexToken = FindHexToken(v8, v11, &v25);
...
remaining = v11 + v8 - HexToken - v25; // may underflow
ChunkHeaderEnd = FindChunkHeaderEnd(a1,
        (int)HexToken + v25, remaining,
        (unsigned int)&v23, (__int64)&v26);
```
```c
// patched
HexTokenBounded = FindHexTokenBounded(
        v9, v8, a3, (unsigned int)&v23,
        (__int64)&v25);
if (HexTokenBounded < 0)  // boundary   
    error;                              
... // same math now guaranteed safe
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Remote client opens HTTP connection. 
2. Sends chunked request body.          
3. Splits chunk length field so last    
   packet ends inside the hex token.    
4. http.sys receives partial buffer and 
   calls ParseChunkLength.              
5. ParseChunkLength mis-calculates      
   remaining length, FindChunkHeaderEnd 
   loops through large region.          
6. Worker thread is pinned; service     
   eventually exhausts worker pool or   
   watchdogs, causing DoS.              

Attack Vector
--------------------------------------------------------------------
Unauthenticated network attacker sends  
a specially fragmented chunked HTTP     
request to any Windows service backed   
by http.sys (IIS, WinRM, WebDAV, etc.). 
No credentials or local access needed.  

Patch Description
--------------------------------------------------------------------
• Introduced global flag                 
  UxKirSeHttpChunkLengthFix.            
• Replaced unbounded FindHexToken()     
  call with new FindHexTokenBounded()   
  that receives the original buffer     
  base (a3) and available length (a4).  
  The helper ensures                     
     HexToken >= a3                     
     HexToken + v25 <= a3 + a4          
  and returns STATUS_INVALID_PARAMETER  
  if the boundaries are violated.       
• Updated book-keeping variables so the 
  byte-count returned to caller is      
  always non-negative.                  
• Added extra tracing for failure paths.

Security Impact
--------------------------------------------------------------------
Before the fix an unauthenticated       
attacker could reliably trigger a       
kernel-mode busy loop, exhausting CPU   
and worker threads and denying service  
to all HTTP.sys consumers. No code      
execution or information disclosure,    
but full denial of service of the host. 

Fix Effectiveness
--------------------------------------------------------------------
The new bounded helper closes the only  
path by which an out-of-range token size
reached FindChunkHeaderEnd. Arithmetic  
no longer underflows, and CPU usage is  
bounded by supplied data size, fully    
mitigating the reported DoS condition.  
No residual variant was identified in   
this code path.                         
