{'file': 'windows.media.playback.mediaplayer.dll', 'cve': 'CVE-2025-26674', 'patch_store_uid': 'dde755f3-6cfd-4bb7-86ec-3f14fa2eea1c', 'date': 1751829083.0720763, 'confidence': 0.38, 'change_count': 1, 'kb': 'KB5055523'}
--------------------------------------------------------------------
Unknown-CVE Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Media Player implementation inside windows.media.playback.
mediaplayer.dll, function MediaPlayerImpl::WaitForVBlankLoop().  The
code synchronises video frame presentation with the monitor V-Blank by
periodically calling IDXGIOutput::WaitForVBlank().

Vulnerability Class
--------------------------------------------------------------------
Heap-based Buffer Overflow / NULL-pointer function-pointer dereference
(CWE-122).  Absence of a NULL check on a COM interface pointer allows
indirect calls through address 0, which can be steered into a heap
controlled area.

Detailed Root Cause Analysis
--------------------------------------------------------------------
The loop keeps a cached IDXGIOutput* in local variable v6.  When the
pointer is NULL the helper GetDefaultDXGIOutput(&v6) is supposed to
populate it.  The unpatched logic performs the following sequence:

  1. v4 = v6;                         // copy cached pointer
  2. if (!v6) {                       // attempt to refresh
         InternalRelease(&v6);        // no-op when v6==NULL
         GetDefaultDXGIOutput(&v6);   // may fail and leave v6==NULL
         v4 = v6;                     // copy again (may still be NULL)
     }
  3. ((IDXGIOutput*)v4)->lpVtbl->     // unconditional indirect call
         WaitForVBlank(v4);

When GetDefaultDXGIOutput fails, v4 remains NULL but the indirect call
is still executed.  The first CPU read dereferences address 0 to obtain
the v-table pointer, and the second read fetches the function pointer.
If an attacker is able to allocate heap memory at or near address 0, or
otherwise map controlled data there, the call dispatches to an
attacker-supplied address, achieving arbitrary code execution inside the
Media Player process.  Even without exploiting the control-flow hijack,
this causes a write to or read from unmapped memory, leading to a heap
buffer overflow and process crash.

Key parameters / structures affected
  • v6 : local IDXGIOutput* (cached DXGI output)
  • v4 : transient copy of v6 used for the virtual call
  • GetDefaultDXGIOutput() : helper that may legitimately fail, e.g.
    when no physical display is present or the last monitor is
    disconnected.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// unpatched excerpt
v4 = v6;
if ( !v6 ) {
    InternalRelease(&v6);
    GetDefaultDXGIOutput(&v6);
    v4 = v6;
}
if ( ((int (__fastcall *)(IDXGIOutput *))v4->lpVtbl->WaitForVBlank)(v4)
     < 0 ) {
    InternalRelease(&v6);
    Sleep(0x10);
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker detaches all monitors or otherwise forces
   GetDefaultDXGIOutput() to fail.
2. MediaPlayerImpl::WaitForVBlankLoop executes; v6 is NULL.
3. Function still issues v4->lpVtbl->WaitForVBlank(v4) with v4==NULL.
4. Dereference of address 0 results in control-flow through attacker
   controlled data located at the NULL page or nearby heap memory.
5. Arbitrary code executes in the context of the calling process, or
   the process crashes.

Attack Vector
--------------------------------------------------------------------
Local attacker running with the ability to start Media Player and adjust
the display topology.  No special privileges are required.  Exploitation
is fully local but can be used as a post-exploitation primitive to gain
code execution in another, possibly more privileged, process hosting the
MediaPlayerImpl component.

Patch Description
--------------------------------------------------------------------
The fix wraps the pointer acquisition and the virtual call in a single
composite conditional:

  if ( !v6 && (reacquire failed || v4==NULL) ||
       WaitForVBlank(v4) < 0 )

If GetDefaultDXGIOutput fails and v4 is still NULL, the code now skips
the virtual call and falls back to the error path (release + sleep),
thereby eliminating the unsafe dereference.

Security Impact
--------------------------------------------------------------------
Prior to the fix an attacker could induce an indirect call via a NULL
COM interface pointer and thus redirect execution to controlled heap
memory, achieving arbitrary code execution in the context of
windows.media.playback.mediaplayer.dll.  At minimum this led to a
reliable denial-of-service.  With additional heap manipulation it can be
converted into a full local RCE.

Fix Effectiveness
--------------------------------------------------------------------
The added NULL test guarantees that WaitForVBlank is never invoked on a
NULL IDXGIOutput pointer.  As long as GetDefaultDXGIOutput cannot return
an object whose lifetime is shorter than the current iteration (not
observed in the diff), the use-after-free and NULL dereference avenues
are closed.  No further issues are evident in the patched logic.
