{'change_count': 13, 'cve': 'CVE-2025-26663', 'confidence': 0.26, 'patch_store_uid': 'ca230859-d37d-4894-8880-e7425bdefdb2', 'file': 'wldap32.dll', 'date': 1751828826.5121112, 'kb': 'KB5055523'}
--------------------------------------------------------------------
CVE-2025-26663 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft wldap32.dll – CryptStream TLS/SSL helper that wraps SChannel
APIs for LDAP over SSL (LDAPS).  All affected routines live inside the
client-side CryptStream class (DecryptLdapReceive, LdapSendSsl,
NegotiateSecureConnection, SSPI negotiate loop, TearDownSecureConnection
and the class dtor).

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use-After-Free caused by missing synchronisation around the
SChannel security context that lives inside every CryptStream object.

Detailed Root Cause Analysis
--------------------------------------------------------------------
Each CryptStream instance owns an SChannel context handle pair stored at
offsets +64/+72 (now +72/+80 after refactor).  The handle is destroyed in
TearDownSecureConnection(), CryptStream::~CryptStream() or during
renegotiation, but the same pointer is dereferenced by worker paths that
process network data – e.g. DecryptLdapReceive() and LdapSendSsl().

Before the patch all these paths accessed *(this+64) without any locking
or reference counting:
  • DecryptLdapReceive → this[1] (DecryptMessage)
  • LdapSendSsl        → this[1] (EncryptMessage)
  • Negotiate / Tear-down → DeleteSecurityContext
Because LDAP traffic can be serviced by multiple worker threads (async
I/O completion or parallel calls issued by the upper LDAP runtime), a
thread that is still inside DecryptMessage can race with another thread
tearing the context down.  Once DeleteSecurityContext frees the kernel
objects the first thread continues to use freed memory, yielding a UAF
that an attacker controlling the network stream can shape.

Key data affected
  offset +48  : CredHandle (creds)
  offset +64  : CtxtHandle Lower
  offset +72  : CtxtHandle Upper
  offset +35* : negotiated stream buffers
  SRW lock    : newly inserted at (this+6)

Exploitability stems from the fact that the freed CtxtHandle structure is
heap allocated inside schannel, so an attacker can provoke a predictable
layout and gain EIP/RIP control when the later DecryptMessage() walks the
already-freed structure.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// pre-patch DecryptLdapReceive excerpt
v18 = this[1]( (char*)this+64, (char*)this+192, 0, 0 );
// no locking, may run concurrently with DeleteSecurityContext

// pre-patch destructor
if (*((_OWORD*)this+4)!=0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)
    (*(void(**)(void))(*((_QWORD*)this+3)+72))(); // frees context
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Thread-A processes network data → DecryptLdapReceive() → uses context.
2. Thread-B handles LDAP disconnect / renegotiation →
   TearDownSecureConnection() → DeleteSecurityContext().
3. Context memory freed while Thread-A still inside schannel → UAF →
   memory corruption / RCE.

Attack Vector
--------------------------------------------------------------------
A remote LDAP server (or a MiTM attacker) sends crafted packets that
force frequent renegotiation or connection tear-down while the client is
still decoding previous records.  With asynchronous receives the two
code paths can execute in parallel, triggering the race and ultimately
use-after-free inside the client process (e.g. LSASS or any process that
uses wldap32).

Patch Description
--------------------------------------------------------------------
1. A per-instance SRWLOCK is added and initialised in the constructor.
2. New helpers:
   • CryptStream::AcquireSslContextLockExclusive
   • CryptStream::ReleaseSslContextLockExclusive
   • DecryptLdapReceive/LdapSendSsl/SSPINegotiateLoop acquire the lock in
     shared mode while _using_ the context.
   • All functions that mutate or free the context (TearDown, dtor,
     NegotiateSecureConnection, etc.) acquire the lock in exclusive mode.
3. Old WIL helper code is removed; the Feature flag gates the lock calls
   so the change is flight-controlled.

Security Impact
--------------------------------------------------------------------
Without the lock a race allows use-after-free of an SChannel context
object, leading to heap memory corruption in a high-privilege process
that speaks LDAP over SSL.  An unauthenticated network attacker can
craft traffic to obtain remote code execution in that process context
(typically SYSTEM).

Fix Effectiveness
--------------------------------------------------------------------
The SRW lock serialises all operations that access the CtxtHandle:
exclusive writers (delete/renew) cannot run while readers are in
Decrypt/Encrypt, and vice-versa.  The handle cannot be freed until the
last shared holder exits, removing the UAF window.  No remaining code
paths dereference the context without holding either the shared or
exclusive lock, so the vulnerability is fully mitigated.
