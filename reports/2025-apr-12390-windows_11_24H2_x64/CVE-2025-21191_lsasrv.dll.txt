{'cve': 'CVE-2025-21191', 'file': 'lsasrv.dll', 'confidence': 0.24, 'date': 1751820816.6472502, 'patch_store_uid': 'd385f223-ad66-4d9c-b311-8df147a53b99', 'kb': 'KB5055523', 'change_count': 33}
--------------------------------------------------------------------
CVE-2025-21191 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Local Security Authority Sub-system (lsasrv.dll) – session
context-handle table management and helper routines
(ReferenceContextHandle, DerefContextHandle, LsaIContextToHandleNoRef).

Vulnerability Class
--------------------------------------------------------------------
CWE-367: Time-of-check Time-of-use (TOCTOU) race condition that can be
escalated into a use-after-free / double-free, allowing local privilege
escalation.

Detailed Root Cause Analysis
--------------------------------------------------------------------
Every security package loaded into LSASS is assigned a _Session object.
Each session owns a handle table that maps (upper,lower) 64-bit values
(SecHandle) to in-memory context structures.  Access to the table is
supposed to be synchronised with the RTL_RESOURCE embedded at
Session+0x30 (pointer passed as (session+48) in the decompiled code).

Prior to the patch, three helper routines tried to take that lock
manually, but they suppressed locking when Session->Flags bit 0x800 was
set:

  if ((Session->Flags & 0x800) == 0)
      RtlAcquireResourceShared(&Session->Resource, TRUE);

0x800 is set for so-called *trusted* sessions that run entirely inside
LSASS (e.g. the default Local System session).  Because those sessions
are shared by *all* callers, omitting the lock left the handle table
unprotected against concurrent threads.  A typical execution sequence
was:

1. Thread A calls ReferenceContextHandle() on a trusted session.
   No lock is taken, a pointer to the context (ctxA) is returned.
2. Thread B simultaneously calls DerefContextHandle() for the *same*
   SecHandle.  Again no lock; the reference count drops to zero and the
   package’s free routine releases ctxA.
3. Thread A continues to use ctxA, now pointing to freed memory that an
   attacker controls.  A vtable entry or structure field can be
   overwritten to execute arbitrary code in the LSASS process, yielding
   SYSTEM-level privileges.

A second race existed inside LsaIContextToHandleNoRef():  the function
looked up the context, *released* the lock, then reacquired it to
perform DerefContextHandle().  The unlock/relock window allowed another
thread to free or replace the context before the reference count was
balanced, producing the same stale-pointer scenario.

Because all user processes may call into LSA via the public SSPI /
SChannel / Negotiate APIs, any authenticated local user could spawn two
or more threads and reliably win the race.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// ReferenceContextHandle – before
if ((Session->Flags & 0x800) == 0)
    RtlAcquireResourceShared((PRTL_RESOURCE)((char*)Session + 48), TRUE);
ctx = VTBL(Session)[1].RefFunc(Session, HandleIn, HandleOut);
if ((Session->Flags & 0x800) == 0)
    RtlReleaseResource((PRTL_RESOURCE)((char*)Session + 48));
```

```c
// LsaIContextToHandleNoRef – before (simplified)
RtlAcquireResourceShared(Res, TRUE);
ctx = VTBL(Session)[2].NoRefFunc(...);
RtlReleaseResource(Res);
if (ctx) {
    RtlAcquireResourceShared(Res, TRUE);   // TOCTOU gap starts here
    VTBL(Session)[4].DerefFunc(ctx);
    RtlReleaseResource(Res);
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
LSA client -> SSPI / Auth package -> lsasrv!LsaIContextToHandleNoRef()
  -> *no lock* lookup in trusted session
  -> context pointer returned to caller
Race thread -> lsasrv!DerefContextHandle() on same handle
  -> reference count hits zero, package frees context
Winning attacker thread regains control of freed memory
Original caller resumes, uses dangling pointer inside LSASS.

Attack Vector
--------------------------------------------------------------------
Local authenticated attacker starts two (or more) threads that call
LSA/SSPI APIs against the default session in tight loops – one thread
continuously references a context handle while another dereferences it.
Because the trusted session took no lock, the attacker wins the race and
achieves code execution in LSASS, thus elevating privileges to SYSTEM.

Patch Description
--------------------------------------------------------------------
1. Introduced helper macros ReadLockSession() / ReadUnlockSession() that
   *always* acquire the session’s RTL_RESOURCE, regardless of flag
   0x800.
2. Replaced all open-coded conditional acquisition/release blocks with
   those helpers in ReferenceContextHandle() and DerefContextHandle().
3. Added DerefContextHandleNoLock() and updated
   LsaIContextToHandleNoRef() so that the dereference is performed while
   the original shared lock is still held, completely removing the
   unlock/relock gap.
4. Minor telemetry / WPP changes and optional feature-flagged tracing –
   unrelated to the vulnerability but present in the diff.

Security Impact
--------------------------------------------------------------------
Before the fix, any local user could corrupt or control freed context
memory inside LSASS, leading to arbitrary code execution in the LSASS
process and a full elevation of privilege to NT AUTHORITY\SYSTEM.

Fix Effectiveness
--------------------------------------------------------------------
All handle-table operations are now protected by ReadLockSession(), and
LsaIContextToHandleNoRef() no longer releases the lock before the handle
is dereferenced.  This eliminates the observable race windows.  No other
paths skipping the new helpers are visible in the supplied diffs, so the
patch appears complete for the affected code region.  Effectiveness for
other, unpatched call sites is unknown.
