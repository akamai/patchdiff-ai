{'file': 'samsrv.dll', 'kb': 'KB5055523', 'change_count': 1, 'cve': 'CVE-2025-26673', 'patch_store_uid': '34c965b4-c42b-4851-b6ce-cb58c31d6c36', 'date': 1751828833.257583, 'confidence': 0.2}
--------------------------------------------------------------------
CVE-2025-26673 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows SAM server (samsrv.dll) – function
wil_details_FeatureReporting_RecordUsageInCache()

Vulnerability Class
--------------------------------------------------------------------
Improper input validation leading to uncontrolled resource
consumption (CWE-400)

Detailed Root Cause Analysis
--------------------------------------------------------------------
RecordUsageInCache maintains a 64-bit bit-set that tracks whether a
particular “feature id” (parameter a3) has already been reported.  A
feature id in range 320-383 is mapped to bit positions 0-63 by

    v7 = a3 - 320;          // wanted: 0 <= v7 < 64

The pre-patch code checked only

    if ((int)(a3 - 320) < 64)

This expression is true both for the intended positive values and for
any negative result (e.g. a3 == 8 gives -312 < 64).  Because v7 is
unsigned, negative values are converted to very large numbers
(0xFFFFFEC8, …).  Those bogus indices are then folded to 16 bits and
mixed into the shared bit-field by a CAS loop:

    new = v8 ^ ((uint16)v8 ^ (uint16)(32 * v7)) & 0x7E0 | 0x10;

With an out-of-range v7 the loop never observes the expected value and
spins indefinitely, saturating one CPU core.  Every client request that
passes an attacker-controlled feature id < 320 but still routed through
the “6+” branch can therefore pin a worker thread, exhausting CPU and
thread pool resources in LSASS and resulting in an LDAP service denial.

Additional problem: even for legal IDs, the routine unconditionally
creates a new usage record, allowing unbounded growth of the in-memory
cache when the same feature is reported repeatedly.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// pre-patch
v7 = a3 - 320;
if ((int)(a3 - 320) < 64)             // negative values also pass!
{
    v8 = *((DWORD*)a2 + 1);
    do {
        v9  = (v8 & 0x10) && (((v8 >> 5) & 0x3F) == v7);
        v6[4] = v9;
        v10 = v8;
        v8 = _InterlockedCompareExchange(a2+1,
                v8 ^ ((uint16)v8 ^ (uint16)(32 * v7)) & 0x7E0 | 0x10,
                v8);
    } while (v10 != v8);
}
```
```c
// post-patch
if ((int)(a3 - 320) >= 64)            // bail out on invalid index
    goto LABEL_16;
...
if (!v6[4]) {                          // only if not already set
    v6[2] = a3;
    v6[1] = 1;
    v6[3] = a4;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Remote LDAP call reaches SAM through LSASS.
2. SamrIsShadowAdminAccount()
3. Feature_Adminless_..._IsEnabledDeviceUsageNoInline()
4. wil_details_FeatureReporting_ReportUsageToService()
5. wil_details_FeatureReporting_ReportUsageToServiceDirect()
6. wil_details_FeatureReporting_RecordUsageInCache(a1,a2,a3,a4)
   – faulty bounds check executed.

Attack Vector
--------------------------------------------------------------------
An unauthenticated attacker sends a crafted LDAP request that causes LSASS
to call RecordUsageInCache with a feature id below 320 but still routed
through the “opportunity/usage” path (a3 >= 8).  Each request forces the
CAS retry loop to spin, monopolising CPU and threads and finally causing
LSASS/LDAP to stop responding.

Patch Description
--------------------------------------------------------------------
1. Validates the computed bit index: if (a3-320) is not in 0-63 the code
   skips the compare-exchange loop (prevents endless spinning).
2. After a successful update the code creates a new cache record only
   when the bit was previously clear (prevents cache bloat).

Security Impact
--------------------------------------------------------------------
Before the patch, a remote attacker could repeatedly trigger the inner
spin loop, leading to sustained 100% CPU utilisation in LSASS, thread
starvation, and denial of LDAP and other directory-related services.
No privileges are required and no memory corruption occurs, but service
availability is lost.

Fix Effectiveness
--------------------------------------------------------------------
The added signed range check guarantees that only indices 0-63 reach the
CAS loop, eliminating the uncontrolled CPU consumption path.  The
additional duplication guard stops unbounded cache growth.  Assuming no
other entry points bypass the same function, the fix appears complete.
