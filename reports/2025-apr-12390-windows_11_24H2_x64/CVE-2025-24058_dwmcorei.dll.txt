{'patch_store_uid': '0ce0ff63-a825-42bc-aede-2a80530f3a4d', 'confidence': 0.22, 'date': 1751807959.648873, 'cve': 'CVE-2025-24058', 'file': 'dwmcorei.dll', 'change_count': 1, 'kb': 'KB5055523'}
--------------------------------------------------------------------
CVE-2025-24058 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Desktop Window Manager (dwmcorei.dll) – routine
CLocalAppRenderTarget::EnsureRenderSurface()

Vulnerability Class
--------------------------------------------------------------------
Use-after-free / Type-confusion resulting from passing a freed object
pointer as the implicit this-pointer (CWE-416, CWE-843)

Detailed Root Cause Analysis
--------------------------------------------------------------------
EnsureRenderSurface() builds or re-uses a D3D device that backs a local
application render target.  When no dedicated device is present, the
routine must obtain a “default” device through
CDeviceManager::GetDefaultDevice().

Before the patch the following sequence executed (numbers are local
variables in the decompiled listing):

1. v32 holds an ID3DDevice* freshly returned from
   CDeviceManager::GetDevice().
2. v5  <- v32               (copy the pointer)
3. v32 <- NULL              (clear global storage)
4. if (v5) CD3DDevice::Release(v5);         // **frees object**
5. DefaultDevice = CDeviceManager::GetDefaultDevice(v5, &v32);

The first parameter of GetDefaultDevice **must be a CDeviceManager***,
not a CD3DDevice*.  The code therefore supplies a pointer that

  • no longer points to a live object (it has just been Released), and
  • is of the wrong dynamic type.

GetDefaultDevice is a C++ member and immediately interprets the first
parameter as a ‘this’ pointer, reading its vtable and internal state.
Because the memory is unallocated (or can be re-allocated by an
attacker) this becomes a classic use-after-free that allows the caller
to steer execution through attacker-controlled data.

Key parameters / structures affected
  • v5   – freed CD3DDevice object reused as CDeviceManager
  • GetDefaultDevice() – dereferences vtable at offset [v5]
  • Global g_DeviceManager remains unused in the faulty path, masking
    the bug during normal testing.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable path (before)
v5  = v32;              // copy current device
v32 = 0;
if (v5)
    CD3DDevice::Release(v5);   // free
DefaultDevice = CDeviceManager::GetDefaultDevice(v5, &v32);
// v5 is now dangling + wrong type -> UAF / type confusion
```
```c
// fixed path (after)
CD3DDevice **ppDev = TSmartPointer<...>::operator&(&v39);
DefaultDevice = CDeviceManager::GetDefaultDevice(&g_DeviceManager,
                                                ppDev);
// correct object, pointer never freed beforehand
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
CheckOcclusionState() or other callers → EnsureRenderSurface()
  → Branch where no render surface & feature level >= 9_3
    → CDeviceManager::GetDevice() succeeds (v32 != NULL)
    → Path tries default device (original code)
      → releases v32, calls GetDefaultDevice(v5)
      → UAF executed inside GetDefaultDevice()

Attack Vector
--------------------------------------------------------------------
A local, low-privileged process that can repeatedly force DWM to create
and destroy D3D render targets (e.g., by creating and resizing windows
with specific DPI / composition flags) can reliably land user-controlled
heap data at the address of the freed CD3DDevice object.  When
GetDefaultDevice() is invoked, the crafted memory is treated as a
CDeviceManager vtable, leading to arbitrary code execution in the DWM
process, which runs as NT AUTHORITY\SYSTEM, thus providing an elevation
of privilege.

Patch Description
--------------------------------------------------------------------
• Re-architected the logic around device acquisition to use
  TSmartPointer wrappers (v39) instead of raw pointers.
• Removed the erroneous Release() + reused pointer pattern.
• All calls to CDeviceManager::GetDefaultDevice() now pass an explicit
  CDeviceManager* (v7 / v13) – normally &g_DeviceManager.
• Added extra containment gate (IsChangeEnabled_55369411_) and updated
  failfast instrumentation offsets.

Security Impact
--------------------------------------------------------------------
Before the fix an attacker could obtain arbitrary code execution inside
DWM, achieving SYSTEM-level privilege escalation.  The defect is
triggerable from a normal desktop session without special entitlements.

Fix Effectiveness
--------------------------------------------------------------------
The dangerous use-after-free path is removed: the freed CD3DDevice
pointer is never reused, and the correct object type is supplied to
GetDefaultDevice().  Smart-pointer usage also reduces the chance of
similar lifetime mistakes in adjacent code.  No residual variant of the
same bug is observable in the patched diff.
