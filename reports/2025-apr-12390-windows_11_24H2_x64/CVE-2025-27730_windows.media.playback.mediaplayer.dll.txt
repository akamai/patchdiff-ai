{'change_count': 1, 'patch_store_uid': 'dde755f3-6cfd-4bb7-86ec-3f14fa2eea1c', 'kb': 'KB5055523', 'confidence': 0.29, 'date': 1751820807.7268493, 'file': 'windows.media.playback.mediaplayer.dll', 'cve': 'CVE-2025-27730'}
--------------------------------------------------------------------
CVE-2025-27730 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
windows.media.playback.mediaplayer.dll – user-mode Media Foundation
helper that drives the render clock for Windows MediaPlayer via the
WaitForVBlankLoop worker thread.

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use After Free (related double–free/NULL deref conditions were
also present – CWE-415).

Detailed Root Cause Analysis
--------------------------------------------------------------------
The worker routine
   MediaPlayerImpl::WaitForVBlankLoop(MediaPlayerImpl*,WRL::WeakRef)
executes in a tight loop and is supposed to:
 1. Resolve the caller’s WeakRef back to IMediaPlayer (v7)
 2. Ensure an IDXGIOutput object is available in v6
 3. Call IDXGIOutput::WaitForVBlank each iteration
 4. Drop the reference and sleep on error

Lifetime of v6 is managed manually with
Microsoft::WRL::ComPtr<IUnknown>::InternalRelease(&v6), yet the code
handles v6 only as a raw pointer.  In the original version the logic
was:
    v4 = v6;
    if (!v6) {
        InternalRelease(&v6);        // unconditional
        GetDefaultDXGIOutput(&v6);   // may fail and leave v6==NULL
        v4 = v6;                    // mirror to local alias
    }
    v4->lpVtbl->WaitForVBlank(v4);   // ALWAYS executed

Two related bugs arise:
  • If GetDefaultDXGIOutput fails, v6 remains NULL but v4 is still
    dereferenced, yielding an invalid call through a NULL / stale
    pointer.
  • When WaitForVBlank previously returned <0, the object held in v6
    is released.  Any subsequent iteration that enters the !v6 block
    performs another InternalRelease(&v6) even though v6 was already
    cleared, creating a second Release() call on the same interface
    (double free).  The local alias v4 taken **before** the release is
    still live and can be used after the underlying object was freed –
    a classic use-after-free.

Because the freed IDXGIOutput vtable pointer is later executed, an
attacker who is able to influence heap layout (e.g. by repeatedly
opening/closing video windows) can reclaim the freed memory with a
controlled fake object and achieve arbitrary code execution in the
media-playback service context, therefore escalating privileges.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable logic (simplified)
v4 = v6;
if (!v6) {
    InternalRelease(&v6);          // second Release, v6 already null
    GetDefaultDXGIOutput(&v6);
    v4 = v6;                       // may still be NULL
}
// use after free / NULL deref
if (((int (__fastcall *)(IDXGIOutput*))v4->lpVtbl->WaitForVBlank)(v4) < 0) {
    InternalRelease(&v6);
    Sleep(0x10);
}
```
Fixed version gates the dereference with a single compound test:
```c
if ((!v6 && (InternalRelease(&v6), GetDefaultDXGIOutput(&v6),
             (v4 = v6) == 0)) ||
    v4->lpVtbl->WaitForVBlank(v4) < 0) {
    InternalRelease(&v6);
    Sleep(0x10);
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User starts/continues video playback -> MediaPlayerImpl schedules
WaitForVBlankLoop on a work-item thread -> loop attempts to acquire a
DXGI output -> GetDefaultDXGIOutput fails (e.g. headless RDP session)
-> v6 stays NULL -> old code dereferences NULL/stale v4 -> Release()
may already have freed the object -> attacker-controlled heap memory is
invoked.

Attack Vector
--------------------------------------------------------------------
Local, low-privileged user running crafted multimedia content or
headless sessions.  By repeatedly starting/stopping playback while
forcing GetDefaultDXGIOutput to fail (disconnect monitors, RDP shadow
session, etc.) the vulnerable path is hit in a predictable way.
Heap-grooming via ordinary COM allocations can then place attacker data
at the freed IDXGIOutput address.

Patch Description
--------------------------------------------------------------------
The update rewrites the conditional to ensure IDXGIOutput::WaitForVBlank
is only executed when a valid interface pointer is present.  Key
changes:
  • Single compound if-statement combines the null-check, acquisition
    of a fresh IDXGIOutput, and the WaitForVBlank call.
  • WaitForVBlank is short-circuited when GetDefaultDXGIOutput returns
    NULL, thereby eliminating the dereference of a freed/NULL pointer.
  • InternalRelease is no longer executed twice on the same pointer in
    the !v6 path, preventing double free.
No other functional behaviour is modified.

Security Impact
--------------------------------------------------------------------
Prior to the patch a local attacker could reliably trigger a use-after-
free on an IDXGIOutput COM object inside a privileged media playback
process.  Successful exploitation yields arbitrary code execution with
the privileges of the hosting application (commonly SYSTEM for media
services), resulting in local privilege escalation.

Fix Effectiveness
--------------------------------------------------------------------
The added compound condition removes both the double free and the
subsequent stale/NULL pointer dereference.  WaitForVBlank is now only
called on a verified, freshly acquired interface.  No further reference
counting anomalies are observable in the patched routine, so the fix is
considered complete for the identified defect.
