{'confidence': 0.41, 'date': 1751822609.120437, 'kb': 'KB5055523', 'change_count': 1, 'patch_store_uid': '04512c00-bf9f-4db3-a983-d024e8d8de85', 'file': 'udhisapi.dll', 'cve': 'CVE-2025-27484'}
--------------------------------------------------------------------
CVE-2025-27484 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows UPnP Device Host (udhisapi.dll) – routine
wil_details_FeatureReporting_RecordUsageInCache.
The function maintains an in-process cache that records per-feature
usage statistics by updating a pair of 32-bit bitfields that are
shared by multiple threads.

Vulnerability Class
--------------------------------------------------------------------
CWE-591: Sensitive Data Storage in Improperly Locked Memory
(Logical race/initialisation error that leaves attacker-supplied data
in shared memory without holding the intended lock bit.)

Detailed Root Cause Analysis
--------------------------------------------------------------------
The function receives four parameters:
  a1 – pointer to a WIL_CACHE_RECORD structure (24 bytes)
  a2 – pointer to two volatile INT32s that form the thread-shared
       feature cache (bits 0–31 and 32–63)
  a3 – feature identifier (untrusted)
  a4 – opaque value that is copied into the record when a miss occurs

Execution reaches the default path when the feature id is *not* one of
0-7.  The code then derives an index inside the secondary cache word:
    v7 = a3 – 320               // desired bit position set 0-63

BEFORE the patch the following sequence was used:
    if (v7 < 64)                // only true for legal indices
        acquire+update bit, set *(a1+16)=hit/miss
    *(a1+8)  = a3               // ALWAYS executed
    *(a1+4)  = 1
    *(a1+12) = a4               // ALWAYS executed

If v7 >= 64 the atomic update is skipped, leaving *(a1+16) untouched
(the earlier prologue zeroes it).  Nevertheless the function still
copies a3 and, crucially, a4 into the caller-supplied structure *even
though the cache line was never locked*.  On a cache hit (v9==true)
inside the update loop the write also happens a second time, needlessly
exposing data after the feature had already been recorded.

Because the cache record is subsequently processed by other service
threads without additional synchronisation, an attacker can:
  • Supply an out-of-range feature id (>383, i.e. v7≥64) so that no
    lock bit is taken at all, or
  • Rapid-fire legitimate ids to cause repeated, unlocked overwrites.
Either way attacker-controlled *a4* is stored in shared memory that is
expected to be protected by the bitfield lock, violating the intended
access discipline and potentially leaking or corrupting privileged
service state.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable fragment (before)
if ((unsigned int)(a3 - 6) >= 2) {
    v7 = a3 - 320;
    if (v7 < 64) {               // lock only if in range
        ... _InterlockedCompareExchange(...);
    }
    *(DWORD *)(a1 + 8)  = a3;    // <- always executed
    *(DWORD *)(a1 + 4)  = 1;
    *(DWORD *)(a1 + 12) = a4;    // <- attacker-supplied
    return a1;
}

// fixed fragment (after)
if ((unsigned int)(a3 - 6) >= 2) {
    v7 = a3 - 320;
    if (v7 >= 64)
        goto LABEL_16;           // bail-out, treat as generic path
    ...  // same CAS loop
    if (!*(DWORD *)(a1 + 16)) {  // write only on real miss
LABEL_16:
        *(DWORD *)(a1 + 8)  = a3;
        *(DWORD *)(a1 + 4)  = 1;
        *(DWORD *)(a1 + 12) = a4;
    }
    return a1;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Remote or local attacker reaches UPnP Device Host code path that
   calls wil_details_FeatureReporting_RecordUsageInCache with
   attacker-controlled feature id (a3) and payload (a4).
2. Choose a3 >= 384 so that v7 >= 64.
3. Before patch: function skips the interlocked update and directly
   stores a4 into the shared record while *(a1+16) == 0 (no lock).
4. Another thread processing the cache reads or acts upon the stale
   value, leaking sensitive data or operating on attacker-controlled
   content, enabling privilege escalation.

Attack Vector
--------------------------------------------------------------------
Any context that can talk to the UPnP Device Host (e.g. network
requests that the service translates into feature-id reporting calls)
may pass crafted identifiers >= 384 together with arbitrary data in
parameter a4.  Because the service runs with elevated privileges,
reading or corrupting its shared memory can lead to elevation.

Patch Description
--------------------------------------------------------------------
1. Added upper-bound check: if calculated bit index v7 is >= 64 the
   code now jumps to the generic path that never touches the shared
   cache word.
2. Added conditional store: a3/a4 are now copied into the output record
   only when *(a1+16)==0, i.e. on a genuine cache miss after the lock
   bit has been set.  Duplicate writes are suppressed.
3. Cosmetic: label renumbering to accommodate the new logic.

Security Impact
--------------------------------------------------------------------
Pre-patch, attacker-supplied data could be written into a structure that
other high-privilege threads treat as authoritative without the
expected locking.  This constitutes sensitive data storage in
improperly locked memory (CWE-591) and can be abused to leak
information or corrupt service state, resulting in elevation of
privilege within the UPnP Device Host service context.

Fix Effectiveness
--------------------------------------------------------------------
The added bounds check prevents out-of-range feature ids from reaching
unlocked code paths, and the conditional store guarantees that no data
is written unless the cache line has been atomically claimed.  No other
writes to the shared record occur without holding the lock bit, so the
vulnerability is effectively removed.
