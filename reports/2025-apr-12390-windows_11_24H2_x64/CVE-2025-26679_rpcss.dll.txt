{'patch_store_uid': 'fbc8b878-8b09-4675-b50b-b286c5732325', 'cve': 'CVE-2025-26679', 'change_count': 100, 'kb': 'KB5055523', 'file': 'rpcss.dll', 'date': 1751829079.747125, 'confidence': 0.26}
--------------------------------------------------------------------
Unknown-CVE Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft RPCSS (Rpc Endpoint Mapper) – function
GetInstalledPackageFullNameFromPackageFamilyName() in rpcss.dll.
The routine is reachable through several COM/RPC entry points that
allow normal user-level callers to ask the service for the full
package name that belongs to a package family.

Vulnerability Class
--------------------------------------------------------------------
Use After Free / Double Free (CWE-416, CWE-415).

Detailed Root Cause Analysis
--------------------------------------------------------------------
The function first asks an IUserTokenInternal object (parameter a1)
for an impersonation token via vtbl[96].  The returned kernel handle
is stored in local variable v30.  A second vtbl entry (index 104) is
used to release that handle later.

Old code kept a copy of the token handle only as a raw DWORD and
called the release method manually on *many* exit paths:
  – after an early failure to obtain the token
  – after each FindPackagesByPackageFamily() error
  – again after the happy path just before returning success

Because each branch performed its own clean-up it was possible to hit
logic that released the same handle twice:
  1. The first free happened when an error branch was taken that
     called vtbl[104] and then executed the common LABEL_8 code.
  2. LABEL_8 itself also called vtbl[104] unconditionally, causing a
     second free of the same token handle.

A second CloseHandle() on the same kernel handle makes the value
available for re-use by the system.  A local attacker who holds a
handle to a chosen object can win the race and re-allocate the same
handle value before rpcss uses it again, gaining a handle with higher
privileges inside the SYSTEM service – a classical use-after-free
leading to elevation of privilege.

The defect exists only when a1 is non-NULL and the first
vtbl[96] call succeeded; otherwise no duplicate free occurs.  The bug
is fully inside the service process; no special kernel primitives are
needed.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// pre-patch (simplified)
if (a1) {
    hr = a1->GetToken(0, &hTok);      // vtbl[96]
    if (hr < 0) {
        a1->CloseToken(hTok);          // vtbl[104] 1st free
        return hr;
    }
}
...
err:
if (a1)
    a1->CloseToken(hTok);              // 2nd free – same value!
```
```c
// after patch (simplified)
wil::scope_exit cleanup([&]{
    if (tokenObtained && pUser)
        pUser->CloseToken(hTok);       // executed exactly once
});
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Client process -> RPC to Endpoint Mapper ->
GetInstalledPackageFullNameFromPackageFamilyName()
  1. Provide any package family string that forces
     FindPackagesByPackageFamily() to fail with ERROR_INSUFFICIENT_BUFFER
     (122) or any unexpected Win32 error.
  2. The function enters the 122/15701 branch, frees the token, then
     jumps to LABEL_8 which frees it again.
  3. Attacker immediately re-opens a chosen handle value equal to the
     freed one.
  4. Subsequent rpcss code operates on the attacker-controlled handle
     under SYSTEM privileges.

Attack Vector
--------------------------------------------------------------------
Any authenticated local user can repeatedly call the public RPC
interfaces that end up in this helper routine.  No special rights are
required beyond the capability to connect to the RPC Endpoint Mapper.
A precise timing attack allows the user to re-cycle the just-freed
handle value and obtain privileged access.

Patch Description
--------------------------------------------------------------------
The patch entirely removes the ad-hoc cleanup code and replaces it with
an automatic WIL scope-exit guard:
  • Introduces a wil::scope_exit lambda (lambda_09c4ab…) capturing the
    IUserTokenInternal pointer and the token handle.
  • All explicit calls to vtbl[104] are deleted.
  • Error reporting helpers changed from Return_Win32Msg() to
    Return_HrMsg() but that is cosmetic.

The guarded cleanup guarantees that the token handle is closed exactly
once – on whichever path the function returns – eliminating both
double-free and use-after-free conditions.

Security Impact
--------------------------------------------------------------------
Before the fix a local attacker could execute code in the context of
the RpcSs service (NT AUTHORITY\SYSTEM).  Because RpcSs is a trusted
broker for all local RPC, this provides full privilege escalation on
the machine.

Fix Effectiveness
--------------------------------------------------------------------
The single-point scope-exit destructor ensures exactly-once release
semantics.  No branches now contain manual frees, so double-free/UAF
is structurally impossible unless future modifications bypass the
scope-exit block.  Static review of the patched function confirms that
hTok is never accessed after the destructor runs.  The fix is therefore
considered complete for this code path.
