{'cve': 'CVE-2025-26679', 'confidence': 0.24, 'file': 'rpcrtremote.dll', 'date': 1751829076.7962718, 'kb': 'KB5055523', 'change_count': 1, 'patch_store_uid': '31390f6c-4cc9-424e-ade5-abe4b652e560'}
--------------------------------------------------------------------
CVE-2025-26679 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows RPC Endpoint Mapper service (rpcrtremote.dll)
Function: wil_details_FeatureReporting_RecordUsageInCache

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use After Free (caused by erroneous reference counting /
out-of-range cache indexing)

Detailed Root Cause Analysis
--------------------------------------------------------------------
The routine wil_details_FeatureReporting_RecordUsageInCache() maintains a
small two-DWORD cache that tracks whether a given feature identifier has
already been recorded.  The second DWORD ( *(a2+1) ) contains a 1-bit
"present" flag (0x10) plus a 6-bit slot index (bits 5-10).  The fast
path is intended to be used only when FeatureId (a3) is in the compact
range 320-383, so that the slot index (v6) is 0-63.

Bug 1 – Missing upper bound / negative index
-------------------------------------------
Original code:
    v6 = a3 - 320;
    if ((int)a3 - 320 < 64) {  // signed comparison
        ...fast path...
    }
Because the comparison is signed, every id < 384 satisfies the test,
including the entire range 8-319 where v6 becomes *negative*.  The value
v6 is then multiplied by 32 and merged into *(a2+1), corrupting the slot
index field and possibly the 0x10 present bit for an unrelated feature.

Bug 2 – Unconditional fallback increment
---------------------------------------
After the (possibly bogus) fast path the function always executed
    *(_DWORD *)(a1+8)  = a3;
    *(_DWORD *)(a1+4)  = 1;
    *(_DWORD *)(a1+12) = a4;
and returned.  These assignments drive the slower
wil_details_FeatureReporting_* routines that bump the global reference
counter.  Because the fallback ran even when the slot was already marked
"present", the reference count was incremented repeatedly, letting it
later reach zero too early.  Concurrent cleanup code then freed the
backing structure while other threads still held pointers, producing a
classic use-after-free in the Endpoint Mapper process (SYSTEM-level).

Combined result
---------------
Out-of-range feature ids (8-319) or repeated legitimate ids (320-383)
allowed an attacker to poison the cache and desynchronize the reference
counter, eventually causing a free of a still-referenced object and
subsequent kernel-mode dereference.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Original
v6 = a3 - 320;
if ((int)a3 - 320 < 64) {          // accepts negative values
    v7 = *((_DWORD *)a2 + 1);
    do {
        v8 = (v7 & 0x10) != 0 && ((v7 >> 5) & 0x3F) == v6;
        *(_DWORD *)(a1 + 16) = v8; // present flag
        v9 = v7;
        v7 = _InterlockedCompareExchange(
                 a2 + 1,
                 v7 ^ ((unsigned __int16)v7 ^ (unsigned __int16)(32 * v6)) & 0x7E0 | 0x10,
                 v7);
    } while (v9 != v7);
}
*(_DWORD *)(a1 + 4) = 1;           // fallback runs unconditionally
```
```c
// Patched
if ((int)a3 - 320 >= 64)
    goto LABEL_16;                 // reject out-of-range ids
...
if (!*(_DWORD *)(a1 + 16)) {       // run fallback only on first hit
LABEL_16:
    *(_DWORD *)(a1 + 8)  = a3;
    *(_DWORD *)(a1 + 4)  = 1;
    *(_DWORD *)(a1 + 12) = a4;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User process -> RPC call to Endpoint Mapper ->
Feature_Servicing_RPCFirewallManager_... ->
wil_details_FeatureReporting_RecordUsageInCache ->
cache corruption / refcount inflation ->
later cleanup frees still-referenced object ->
service dereferences freed memory (SYSTEM EoP).

Attack Vector
--------------------------------------------------------------------
A local, authenticated attacker able to invoke the Endpoint Mapper RPC
interface can supply crafted feature identifiers (8-319) or flood the
service with repeated identifiers in the 320-383 range.  This poisons
the cache, drives the reference counter to zero prematurely, and triggers
a use-after-free inside the service’s process running as SYSTEM.

Patch Description
--------------------------------------------------------------------
1. Added a strict range check: the fast path is taken only when
   0 <= a3-320 < 64.  Any other value falls back to the safe slow path.
2. Added a guard so the slow path executes only when the slot was not yet
   present, preventing multiple increments of the same reference count.

Security Impact
--------------------------------------------------------------------
The vulnerability allowed a local attacker to elevate privileges to
SYSTEM by inducing a use-after-free in the Endpoint Mapper service.  The
exploitability is high because only user-mode data is required and the
service runs with full system privileges.

Fix Effectiveness
--------------------------------------------------------------------
The additional bounds check eliminates the out-of-range write, and the
conditional fallback prevents reference-count inflation.  Together these
changes remove the inconsistency that led to premature frees, fully
mitigating the reported UAF condition.
