{'patch_store_uid': '44c5ade3-f6e4-4e14-b4ef-aa3168ae6c31', 'date': 1751911061.4548528, 'cve': 'CVE-2025-26640', 'confidence': 0.19, 'file': 'windows.media.mediacontrol.dll', 'kb': 'KB5055523', 'change_count': 8}
--------------------------------------------------------------------
CVE-2025-26640 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
windows.media.mediacontrol.dll – specifically the wil::AsyncEventSourceT
RaiseEvent helpers for SystemMediaTransportControls event sources and
ConvertToInMemoryRandomAccessStream().  All are part of the Windows
Digital Media (SMTC) stack.

Vulnerability Class
--------------------------------------------------------------------
CWE-416 Use-After-Free (primary)
CWE-415 Double-Free (secondary)

Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  Event-source work-item helpers
    wil::AsyncEventSourceT<…>::AsyncEventWorkItem::RaiseEvent() is
    generated for every SMTC typed-handler.  The pre-patch routine
    implements complex subscriber-list fix-up logic when a handler
    returns specific HRESULT values (RPC_S_SERVER_UNAVAILABLE,
    RPC_E_DISCONNECTED, or RPC_E_SERVER_DIED ‑> 0x8001010D / 0x800706BA
    etc.).

    Old algorithm:
      • Take SRW lock #2 (exclusive) on internal structure pointed to by
        a1[2] (RTL_SRWLOCK *v1).
      • Allocate a new Microsoft::WRL::Details::EventTargetArray (ptr
        v13) and partially populate it from the current list (v1->Ptr).
      • Perform multiple Release() calls on v13 while the object is still
        reachable through v1->Ptr and other local aliases.
      • Swap the new array into v1->Ptr under SRW lock #1, then unlock
        both SRW regions, leaving previous array(s) with a reference
        count that may already have reached zero.
      • Control-flow paths (LABEL_16/LABEL_35/LABEL_40) cause
        RuntimeClassImpl::Release(v13) to be executed twice or after the
        pointer has been detached, producing double-free; on concurrent
        RaiseEvent threads a dangling pointer can be dereferenced
        (classic UAF).

    The race is trivial to hit by repeatedly subscribing/unsubscribing a
    handler while simultaneously firing e.g. ShuffleEnabledChange or
    PropertyChanged events.

2.  ConvertToInMemoryRandomAccessStream()
    The helper used a raw buffer (pv) obtained from
    ReadStreamIntoByteArray().  Error unwind paths both invoked
    CoTaskMemFree(pv) and the StateRepository::Cache::Manager_NoThrow
    destructor, freeing the same allocation twice.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
Microsoft::WRL::Details::RuntimeClassImpl<…>::Release(v13);
v25 = v1->Ptr;                     // v13 may reach refcount 0 here
v22 = (_QWORD *)*((_QWORD *)v1->Ptr + 4);
...
if (v1 != (RTL_SRWLOCK *)-16i64)
    ReleaseSRWLockExclusive(v1 + 2);
// later LABEL_40 executes a second Release(v13) -> double free / UAF
```
```c
// after
for (i = *(QWORD **)(list+16); i != end; ++i) {
    rc = InvokeHandler(...);
    if (FAILED(rc) && rc is one of the 3 errors)
        EventSource::Remove(list, *i);   // simple, no new array
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Client code
  -> SystemMediaTransportControls::ShuffleEnabled property changed
  -> SMTC raises internal async work item
  -> wil::AsyncEventWorkItem::RaiseEvent()
  -> Handler A returns RPC_E_DISCONNECTED
  -> Old logic reallocates list, mis-manages refcounts
  -> Second thread (or same thread later) dereferences freed
     EventTargetArray -> UAF

Attack Vector
--------------------------------------------------------------------
Any low-privilege local process that can register SMTC event handlers
(e.g., UWP or Win32 media apps) and stimulate rapid subscribe/unsubscribe
cycles can provoke the race.  If the vulnerable code executes inside a
higher-privilege service (such as Audio Service) the attacker gains code
execution in that context, leading to EoP.

Patch Description
--------------------------------------------------------------------
• Re-implemented RaiseEvent() helpers: now
  – Acquire *no* write lock; simply iterate over existing stable list.
  – On failure remove the offending handler through
    EventSource::Remove().
  – All allocation, swap, and multi-Release logic deleted ( > 150 lines
    removed).
• ConvertToInMemoryRandomAccessStream()
  – Added early null-length check, feature-flag gating, and single exit
    funnel that always frees the byte-array via
    StateRepository::Cache::Manager_NoThrow destructor.  Direct
    CoTaskMemFree() call removed.

Security Impact
--------------------------------------------------------------------
Before the patch a local attacker could
  • Dereference freed memory -> arbitrary code execution in the hosting
    process;
  • Cause double-free leading to heap corruption;
  • Escalate privileges if the host process runs under SYSTEM or another
    elevated account (documented as EoP).
Crash-in-place was also trivial, enabling DoS.

Fix Effectiveness
--------------------------------------------------------------------
Patch removes the faulty ownership transfer and ref-count juggling, so
no path can Release the same EventTargetArray twice.  All exits funnel
through a single cleanup, making double-free impossible.  Iteration uses
stable snapshot, eliminating dangling pointers.  ConvertTo… now owns the
buffer via one code path only.  Therefore the UAF/double-free condition
is fully closed.
