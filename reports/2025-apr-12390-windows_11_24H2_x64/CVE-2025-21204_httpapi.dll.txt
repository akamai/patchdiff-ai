{'patch_store_uid': '126d59cd-ac9c-49d2-9eba-7a7b5e778af9', 'change_count': 4, 'kb': 'KB5055523', 'cve': 'CVE-2025-21204', 'confidence': 0.2, 'date': 1751911082.7144983, 'file': 'httpapi.dll'}
--------------------------------------------------------------------
CVE-2025-21204 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
httpapi.dll (user-mode helper for HTTP.SYS).  Vulnerable routine is
wil_details_FeatureReporting_RecordUsageInCache(), a helper that
maintains the per-process WIL feature-usage cache.

Vulnerability Class
--------------------------------------------------------------------
Improper input validation / integer under-flow leading to out-of-range
bit-field update (logic-error memory corruption).

Detailed Root Cause Analysis
--------------------------------------------------------------------
RecordUsageInCache() is handed                
  a1 – pointer to 6-DWORD scratch struct that is returned to caller   
  a2 – pointer to two shared DWORDs holding per-process cache state   
  a3 – Feature identifier                                             
  a4 – Call-site specific flags                                       

For feature Ids outside the simple 0-5 range the code tries to store a
6-bit index (bits 5-10, mask 0x7E0) together with a "present" bit
(0x10) into *(a2+1):

    v7 = a3 - 320;           // desired index (0-63)
    v8 = *((DWORD*)a2 + 1);  // current cache word
    new = (v8 ^ ((v8 ^ (32*v7)) & 0x7E0)) | 0x10;
    _InterlockedCompareExchange(a2+1, new, v8);

The algorithm ASSUMES 0 <= v7 < 64.  The entry-condition meant to
guarantee this is:

    if (a3-6 >= 2) {               // i.e. a3 >= 8
        if ((int)(a3-320) < 64)    // range check – BUG!
            ...update loop...
    }

Because the subtraction is performed *before* the comparison is signed
(for example a3 == 200 gives v7 == -120), negative values also satisfy
"< 64" and enter the CAS loop.  Once inside, 32*v7 is negative, is
truncated to unsigned __int16, and the masked result no longer matches
v7.  The loop continually rewrites the shared word with undefined
indices, corrupting the cache word that is read by other threads.

In addition, element v6[4] ("already-seen" flag) is written **only**
inside the range-checked loop.  If v7 is out of range the function
returns with that flag uninitialised although the upper part of the
scratch structure is reported as valid, leaking stack contents to the
caller.

Consequences:
1. Corruption of the shared cache word used by all threads in the
   calling process (including SYSTEM services that host httpapi.dll).
2. Disclosure of four bytes of uninitialised stack memory to any caller
   that can pass an out-of-range feature id.
3. Because the cache word is later interpreted as a list head, its
   corruption can be turned into an arbitrary linked-list write in
   privileged processes, yielding elevation of privilege.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
if (a3 - 6 >= 2) {
    v7 = a3 - 320;
    if ((int)(a3 - 320) < 64) {
        ... update loop using v7 ...
    }
    v6[2] = a3;   // out even when v7 was invalid
    ...
}

// after
if (a3 - 6 >= 2) {
    v7 = a3 - 320;
    if ((int)(a3 - 320) >= 64)
        goto LABEL_16;          // bypass update for bad index
    ... update loop ...
    if (!v6[4]) {               // only when first seen
LABEL_16:
        v6[2] = a3;
        ...
    }
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker loads httpapi.dll (any low-privilege process can).          
2. Calls exported WIL helper that eventually invokes                    
   wil_details_FeatureReporting_RecordUsageInCache(), passing           
   a crafted feature id 8 <= a3 < 320 (e.g. 200).                       
3. Function computes negative v7 and corrupts the shared cache word.    
4. Privileged thread (e.g. Windows Update service) later uses the same
   library; the corrupted list head is dereferenced, leading to a
   controlled write or to use of leaked stack data.                     

Attack Vector
--------------------------------------------------------------------
Local – any process that is able to load httpapi.dll can supply an
out-of-range feature id to the public WIL recording helpers.

Patch Description
--------------------------------------------------------------------
• Added upper-bound check: if (a3-320) >= 64 the fast-path is skipped.  
• Removed negative values by branching before v7 is used.               
• Added secondary guard: the costly bookkeeping path now executes only
  when v6[4] (already-recorded flag) is zero.                           
• Zero-initialised structure is therefore always consistent and never
  leaks uninitialised bytes.

Security Impact
--------------------------------------------------------------------
Before the fix an unprivileged caller could:                          
• Corrupt the per-process feature-cache word shared with higher         
  privilege threads in the same process, enabling an elevation of      
  privilege via arbitrary pointer overwrite, or                       
• Obtain four bytes of uninitialised stack data (information leak).    
Combined, these issues map to CWE-59 and permit a local Elevation of
Privilege (CVE-2025-21204).

Fix Effectiveness
--------------------------------------------------------------------
The added boundary test excludes both negative and >=64 indices, thus
eliminating the malformed-index path.  v6[4] is now always
initialised before it is consulted, closing the information leak.
No remaining code path allows an attacker-controlled out-of-range index
to reach the CAS loop, so the vulnerability is fully remediated.
