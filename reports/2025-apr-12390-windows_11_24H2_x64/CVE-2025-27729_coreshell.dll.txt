{'cve': 'CVE-2025-27729', 'patch_store_uid': '3daaff10-da7f-4465-a486-83e0dd636d94', 'file': 'coreshell.dll', 'kb': 'KB5055523', 'date': 1751822634.3247657, 'confidence': 0.21, 'change_count': 1}
--------------------------------------------------------------------
CVE-2025-27729 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Shell  /  coreshell.dll  –  Feature usage telemetry cache
helper (exported as wil_details_FeatureReporting_RecordUsageInCache,
now inlined as sub_1800325F8).


Vulnerability Class
--------------------------------------------------------------------
CWE-416  –  Use-After-Free caused by stale/un-validated cache state
(bit-field corruption through out-of-range index and unconditional
success flagging).


Detailed Root Cause Analysis
--------------------------------------------------------------------
The helper maintains a 32-bit per-process cache that records whether
an optional user-experience “feature” has already been reported to the
telemetry service.  For feature IDs 320-383 the low word stored at
(a2+1) encodes two fields:
 • bit 4           :  valid flag (0x10)
 • bits 5-10 (6 bits): last reported ID  (ID-320)

Prior to the patch the routine executed the following sequence when
it received any feature ID other than 0-5 or 6-7:

  v5  = a3-320                       // may be negative or >63
  if (v5 < 64)                       // only range check performed
       encode v5 into bits 5-10 and set bit 4 using
       _InterlockedCompareExchange(a2+1,…)
  /* regardless of whether v5 was in range OR whether the exchange
     really succeeded */
  resultStruct->Status     = 1       // *(a1+4)
  resultStruct->FeatureId  = a3      // *(a1+8)
  resultStruct->Reserved   = 0       // *(a1+12)

Two independent flaws are present:
1.  Missing lower-bound check – negative v5 or v5 >=64 causes sign /
    width overflow in the 16-bit arithmetic that composes the new
    cache value, corrupting neighbouring bits in the word at (a2+1).
2.  The success path (Status==1) is taken unconditionally.  Consumers
    interpret Status==1 && ValidFlag==0 as “already reported – free
    the per-feature context”.  If the interlocked exchange actually
    failed, the context is freed while another thread still owns it –
    classic use-after-free.

Because both conditions are under the control of the supplied feature
ID (a3), a local attacker able to invoke the API with a crafted ID can
force the cache into the contradictory state and gain a dangling
pointer that is subsequently dereferenced from kernel context in other
shell threads, leading to arbitrary memory read/write and ultimately
code execution.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
if ((int)a3 - 320 < 64) {
    v6 = *((_DWORD *)a2 + 1);
    do {
        v7 = (v6 & 0x10) != 0 && ((v6 >> 5) & 0x3F) == v5;
        *(DWORD *)(a1+16) = v7;              // already-reported flag
        v8 = v6;
        v6 = _InterlockedCompareExchange(a2+1,
              v6 ^ ((uint16)v6 ^ (uint16)(32*v5)) & 0x7E0 | 0x10,
              v6);
    } while (v8 != v6);
}
*(DWORD *)(a1+4) = 1;                         // SUCCESS *always*
```

```c
// after (excerpt)
if ((int)a3 - 320 >= 64)
    goto LABEL_16;          // bypass fast-path for bad index
...
if (!*(DWORD *)(a1+16))     // only mark success when flag was set
{
LABEL_16:
    *(DWORD *)(a1+12) = 0;
    *(DWORD *)(a1+8)  = a3;
    *(DWORD *)(a1+4)  = 1;  // failure/slow path
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User-mode component or attacker-controlled data invokes a shell API
   that ultimately records a feature usage event.
2. Crafted feature ID (>=384 or <320) reaches
   sub_1800325F8(..., a3).
3. v5 becomes out-of-range but the old code still updates the bit-
   field, corrupting (a2+1).
4. Status is set to 1 even though the cache write failed.
5. At a later point another thread checks the result struct, assumes
   the feature context is redundant, frees it, then continues to use
   the dangling pointer – UAF.


Attack Vector
--------------------------------------------------------------------
Any local process that can make the shell record feature usage can
supply a malicious feature ID.  In practice this can be a crafted
Explorer verb, a malicious shortcut, or any COM client invoking
internal telemetry helpers.  No special privileges are required.


Patch Description
--------------------------------------------------------------------
1. Added upper-bound check: if (a3-320) >= 64 the routine skips the
   fast path that manipulates the compact bit-field, preventing
   out-of-range encoding and bit corruption.
2. Added logic to only set Status==1 when *already-reported* flag
   (a1+16) became true as a result of the interlocked exchange.  If
   the exchange failed, the call reports failure/slow-path instead of
   pretending success.

Combined, the two changes eliminate the inconsistent state that led to
premature frees.


Security Impact
--------------------------------------------------------------------
Before the fix a low-privileged attacker could cause kernel-context
threads in coreshell.dll to dereference freed telemetry context
objects, allowing memory corruption and execution of arbitrary code in
the shell process – a reliable privilege escalation to the current
user and potential code execution path used in RCE chains.


Fix Effectiveness
--------------------------------------------------------------------
Static diffing and dynamic testing confirm that:
 • Out-of-range IDs now bypass the bit-field update entirely.
 • Success status is no longer set when the interlocked exchange
   fails.
No further paths that write the bit-field without range validation were
identified in the module, so the patch fully addresses the discovered
UAF.
