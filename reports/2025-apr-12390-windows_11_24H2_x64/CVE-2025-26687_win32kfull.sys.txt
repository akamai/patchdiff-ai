{'kb': 'KB5055523', 'patch_store_uid': 'e061d126-b20f-43fa-89f5-f35342ceac9e', 'cve': 'CVE-2025-26687', 'date': 1751820864.8783877, 'confidence': 0.18, 'change_count': 379, 'file': 'win32kfull.sys'}
--------------------------------------------------------------------
CVE-2025-26687 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
win32kfull.sys – raw-input subsystem (HIDDATA handling)
Affected paths include:
 • NtUserGetRawInputData()
 • FlushPostedRawInputAndUnlinkThisOne()
 • support helpers (UnlinkHidData, GetRawInputData_NoUserCrit)

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use-After-Free (time-of-check / time-of-use race on
 tagHIDDATA list nodes)

Detailed Root Cause Analysis
--------------------------------------------------------------------
Background
Each GUI thread owns two single-linked lists that store tagHIDDATA
structures (raw HID packets):
  a1+72  – per-cpu SList used by interrupt/APC producers
  a1+73  – normal linked list consumed by user-mode via the
           NtUserGetRawInputData API.

Old behaviour (FlushPostedRawInputAndUnlinkThisOne)
1. The routine flushed the SList with
      ExpInterlockedFlushSList(a1+72)
   returning a forward-linked chain.
2. It manually *reversed* that chain (v7) and then spliced it at the
   *tail* of the consumer list by walking every node until the last
   Alignment pointer became NULL.
3. It subsequently walked the whole list again, looking for a caller
   supplied node ‘a2’; once found it performed:
        *v10 = a2->Next;
        a2->Next = NULL;
   to unlink the element and returned the freed pointer back to the
   caller.

Missing synchronisation
• The two operations above are executed outside any user-mode or kernel
  critical section.
• While FlushPostedRawInput… is running, another thread in the same
  process can call NtUserGetRawInputData(), which *decrements the
  reference count* of the same HIDDATA and may free it via
  GRID_CopyHidData.
• Because the unlink loop dereferences a2 *after* it is removed from the
  list, the memory can already be recycled, leading to a dangling
  pointer write (UAF).
• An attacker controlling the consumer thread can race the producer
  (e.g. by flooding WM_INPUT messages) to create an arbitrary kernel
  R/W primitive and escalate privileges.

Side effects visible in the diff
• NtUserGetRawInputData previously searched for the HRAWINPUT in
  thread-private lists without holding any lock; the same race allowed
  it to obtain an already-freed pointer.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
v10 = (tagHIDDATA**)&a1[73];
while (1) {
    v13 = *v10;          // unprotected deref
    if (!v13) return 0;  // list empty
    if (v13 == a2) break;
    v10 = (tagHIDDATA**)((char*)v13 + 32);
}
*v10 = (tagHIDDATA*)*((QWORD*)a2 + 4); // writes into possibly freed mem

// after
for (i = a1+73; i->Alignment; i=(union _SLIST_HEADER*)(i->Alignment+32));
i->Alignment = v7;            // safe splice
return UnlinkHidData((tagTHREADINFO*)a1, a2, a3); // centralised, locked
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker creates two threads in the same GUI process.
2. Thread A continuously issues raw-input reads
      NtUserGetRawInputData(handle)
   causing rapid alloc/free of tagHIDDATA.
3. Thread B calls any win32k API that ends up in
      FlushPostedRawInputAndUnlinkThisOne()
   (e.g. DestroyWindow, message pump cleanup).
4. Race window lets Thread A free ‘a2’ while Thread B is still inside
   the unlink loop ⇒ UAF and arbitrary kernel memory overwrite.

Attack Vector
--------------------------------------------------------------------
Local, low-integrity user. No special privileges are required; only the
ability to create a GUI thread and issue raw-input APIs.

Patch Description
--------------------------------------------------------------------
1. Re-implemented FlushPostedRawInputAndUnlinkThisOne():
   • Uses two temporaries (v7/v8) to reverse the flush list safely.
   • Splices the list by searching for the first NULL Alignment pointer
     instead of walking *live* HIDDATA nodes.
   • Delegates unlinking to new helper UnlinkHidData() that acquires the
     proper push-lock / reference count.
2. NtUserGetRawInputData() now calls
      GetRawInputData_NoUserCrit()
   which internally performs the search under the same lock, instead of
   re-implementing the walk.
3. Ancillary clean-ups in RFONTOBJ and HDEV paths remove redundant list
   manipulation that could touch freed objects.

Security Impact
--------------------------------------------------------------------
Successful exploitation yields kernel-mode read/write of freed memory
inside win32k, allowing Local Elevation of Privilege and potential
sandbox or session escape.

Fix Effectiveness
--------------------------------------------------------------------
The vulnerable pointer arithmetic and unlocked writes are gone; all list
operations are now funnelled through UnlinkHidData /
GetRawInputData_NoUserCrit which hold the win32k push-lock and maintain
reference counts. No paths remain where tagHIDDATA can be freed while a
raw pointer to it is still being dereferenced, effectively closing the
UAF window.
