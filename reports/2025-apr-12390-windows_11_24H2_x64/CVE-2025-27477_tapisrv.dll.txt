{'file': 'tapisrv.dll', 'change_count': 2, 'kb': 'KB5055523', 'cve': 'CVE-2025-27477', 'confidence': 0.38, 'date': 1751822580.891847, 'patch_store_uid': '38b57009-9f8e-4426-8142-2d7f8db5f6f2'}
--------------------------------------------------------------------
CVE-2025-27477 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Telephony Service (TAPISRV) – tapisrv.dll, routine
LGetAddressStatus().  The function post-processes a LINE_ADDRESSSTATUS
structure returned from a TSP (Telephony Service Provider) and
returns the data to the caller through the RPC interface.

Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow / out-of-bounds write (CWE-122).

Detailed Root Cause Analysis
--------------------------------------------------------------------
LGetAddressStatus() allocates an output buffer "a4" large enough to
hold the user-supplied size (a2[4]) and passes it to the TSP callback.
After the driver fills the structure the function sanitises the list
of LINEFORWARD entries that begins at:
    BYTE *list = (BYTE *)a4 + a4[11];   // dwForwardOffset
    DWORD cnt  = a4[9];                 // dwForwardNumEntries
Each entry is 32 bytes; the loop walks the list and clears specific
flag bits:
    for (i = 0; i < cnt; i++)
        list[i].dwForwardMode &= 0xFFFCFFFE | 1;
Prior to the patch no bounds check verified that
    (dwForwardOffset + 32*dwForwardNumEntries) <= dwTotalSize
(stored at a4[0]).  A malicious TSP or attacker-controlled reply can
set dwForwardOffset and/or dwForwardNumEntries so that the computed
pointer lies outside the  heap allocation.  The subsequent masked
store writes past the end of the buffer, corrupting heap metadata or
adjacent objects under the telephony service’s SYSTEM account.

The patch introduces an explicit check that detects:
  • 32*cnt overflows 32-bit arithmetic
  • offset + (32*cnt) overflows
  • offset + (32*cnt) exceeds dwTotalSize
If any test fails the code logs an error, zeroes dwForwardNumEntries
and returns 0x8000000D (ERROR_INVALID_DATA).

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// pre-patch (simplified)
listCnt = a4[9];                     // dwForwardNumEntries
listPtr = (DWORD *)((BYTE*)a4 + a4[11]); // dwForwardOffset
for (i = 0; i < listCnt; i++)        // NO SIZE CHECK!
{
    if (*listPtr & 0x30000)
        *listPtr = (*listPtr & 0xFFFCFFFE) | 1;
    listPtr += 8;                   // 32-byte stride
}

// post-patch validation
sizeNeeded = 32ULL * a4[9];
if (sizeNeeded > 0xFFFFFFFF ||
    sizeNeeded + a4[11] < a4[11] ||
    sizeNeeded + a4[11] > a4[0])
{
    TRACE("invalid forward list");
    a4[9] = 0;
    *a2 = 0x8000000D;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Remote/RPC client invokes lineGetAddressStatus().
2. TAPISRV allocates buffer and calls the provider’s
   LINE_GETADDRESSSTATUS handler (function pointer in v19).
3. Provider returns a LINE_ADDRESSSTATUS structure with crafted
   dwForwardOffset/dwForwardNumEntries.
4. LGetAddressStatus() loops over the list without validating its
   bounds (pre-patch) and writes beyond the heap allocation.

Attack Vector
--------------------------------------------------------------------
An unauthenticated attacker controlling a network-reachable TSP or
able to induce TAPISRV to process attacker-supplied telephony data can
return a malicious LINE_ADDRESSSTATUS structure containing oversized
(dwForwardNumEntries, dwForwardOffset) values, triggering the heap
overflow in the service process.

Patch Description
--------------------------------------------------------------------
Added integer-overflow-safe validation of the forward list:
  • Calculates 32 * dwForwardNumEntries using 64-bit math.
  • Verifies the sum with dwForwardOffset does not wrap and is within
    the total structure size.
  • On failure zeros the count and returns ERROR_INVALID_DATA.
The fix is guarded by an internal feature flag
Feature_3235131707__private_IsEnabledDeviceUsageNoInline().

Security Impact
--------------------------------------------------------------------
Prior to the fix an attacker could write controlled 32-bit values past
heap buffers inside the SYSTEM-privileged TAPISRV service, enabling
remote code execution or service compromise.

Fix Effectiveness
--------------------------------------------------------------------
The new bounds checks eliminate the reachable out-of-bounds write so
long as the Feature flag is enabled.  If the flag is disabled by
policy or future regression the original flaw would resurface.
Otherwise the patch fully mitigates the overflow condition.
