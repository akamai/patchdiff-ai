{'confidence': 0.12, 'patch_store_uid': '2f2abc8b-e3d1-4cbb-8b39-7aa68abb7731', 'change_count': 1, 'file': 'winbio.dll', 'kb': 'KB5055523', 'cve': 'CVE-2025-26644', 'date': 1751822554.807231}
--------------------------------------------------------------------
CVE-2025-26644 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
winbio.dll – internal Windows Hello feature-usage reporting cache
routine wil_details_FeatureReporting_RecordUsageInCache

Vulnerability Class
--------------------------------------------------------------------
Logic flaw / state-management error that leads to spoofing (CWE-1039)

Detailed Root Cause Analysis
--------------------------------------------------------------------
The routine builds a 20-byte record that tells higher-level code
whether the current usage of a Windows Hello feature should be sent to
the telemetry service.  It receives
  a1 – pointer to output record
  a2 – pointer to a volatile 2-DWORD per-session cache
  a3 – feature-specific usage opcode

For opcodes 320-383 the second DWORD of the cache is used as a compact
bitfield:
  bit 4           – “usage already logged” flag
  bits 5-10 (6 bits) – index 0-63 of the opcode actually logged

Correct behaviour is:
  if (bit4==1 && bits5-10==index)  => already logged, do NOT report
  else                            => atomically set bit4+index and
                                      report once

Pre-patch code computed the boolean v7 = alreadyLogged but *ignored* it
when filling the output record.  The field at a1+4 ("ShouldReport") was
unconditionally set to 1, so callers always proceeded to send a usage
report even when the identical opcode had already been recorded.  An
attacker able to invoke the API repeatedly could therefore inflate
usage counters or skew opportunity/usage ratios that Windows Hello’s
anti-spoofing heuristics rely on, ultimately lowering the decision
threshold and enabling spoofing.

Additionally, the range guard only verified
    (int)a3 - 320 < 64
before touching the bitfield, but the surrounding logic that fills the
output record executed even when the opcode was *outside* that range,
leading to inconsistent state.

Patch changes:
1. Reverses the range test so that out-of-range opcodes bypass the
   bitfield manipulation entirely.
2. After the atomic compare-exchange it now checks
      if (!alreadyLogged)
   before marking the record as reportable, ensuring a single report
   per opcode per session.
3. The record is no longer populated when alreadyLogged==1, eliminating
   duplicate reporting.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
if ((int)a3 - 320 < 64) {
    ... alreadyLogged = ...;
}
*(_DWORD *)(a1 + 4) = 1;          // always report
```
```c
// after
if ((int)a3 - 320 >= 64)
    goto LABEL_16;                // skip out-of-range
...
*(_DWORD *)(a1 + 16) = alreadyLogged;
if (!*(_DWORD *)(a1 + 16))        // only first time
{
LABEL_16:
    *(_DWORD *)(a1 + 4) = 1;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-mode component makes repeated Windows Hello API calls ->
wil::details::ReportUsageToService* ->
wil_details_FeatureReporting_RecordUsageInCache ->
uncoditionally returns ShouldReport=1 (pre-patch) ->
service accepts endless identical usage records.

Attack Vector
--------------------------------------------------------------------
A local, unauthenticated attacker can repeatedly invoke any code path
that ends in ReportUsageInCache with an opcode in the 320-383 range.
Because caching fails, each call is treated as a fresh, legitimate
usage event.  By manipulating usage/opportunity ratios the attacker can
train the recognition model into accepting spoofed biometric data.

Patch Description
--------------------------------------------------------------------
• Added early bail-out for opcodes whose index is >=64.
• Suppresses population of the outgoing record when the
  alreadyLogged condition is true.
• Logic now guarantees exactly one report per opcode per session.

Security Impact
--------------------------------------------------------------------
Pre-patch, Windows Hello’s heuristic counters could be arbitrarily
manipulated, leading to a reduction in spoof-detection sensitivity and
a possible biometric spoofing of the local user.

Fix Effectiveness
--------------------------------------------------------------------
The added alreadyLogged gate removes the repeat-report condition and
restores one-time logging semantics.  Range validation prevents
inconsistent cache state.  No remaining path appears to re-enable the
bug, but the protection is limited to the specific opcode range; any
future code that writes to the same cache word must replicate the same
check.
