{'change_count': 28, 'kb': 'KB5055523', 'patch_store_uid': 'e857eb2b-d0be-4f78-a03e-cf11a128a490', 'file': 'dxgmms2.sys', 'confidence': 0.34, 'date': 1751820848.8265457, 'cve': 'CVE-2025-29812'}
--------------------------------------------------------------------
CVE-2025-29812 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
DirectX Graphics Kernel  (dxgmms2.sys) scheduler routine
VidSchCancelPresentAtFlips.

Vulnerability Class
--------------------------------------------------------------------
CWE-822: Untrusted Pointer Dereference (kernel write-what-where).

Detailed Root Cause Analysis
--------------------------------------------------------------------
Before the patch VidSchCancelPresentAtFlips received parameter a3 as a
64-bit value originating from user mode.  When the present type flag
(a5) equalled 2 the function treated this value as a pointer to a
KEVENT object.  It forwarded the raw pointer to
VidSchiFlushCompletedPresentsForCompSurf and afterwards executed

    KeSetEvent((PRKEVENT)a3, 1, 0);

without any attempt to verify that a3 actually mapped to a valid
kernel event object, belonged to the caller, or was even a valid
address.  Because the code runs in kernel mode the KEVENT structure is
blindly dereferenced and its internal list entries are written, giving
a local attacker an arbitrary kernel write primitive.

The bug is reachable from user mode through the standard D3DKMT
present-cancellation path: the caller supplies the pointer via the
KM escape structure; the scheduler later executes the above code when
flushing/completing the flip.  No kernel-mode validation is involved.

Patch Analysis
--------------
The patched routine introduces a new HANDLE parameter (Handle) that is
expected to reference the user-supplied event.  For the vulnerable
code path (Feature_H2E_WPA3SAE && a5==2) the function now

 1. Initialises Object = NULL;
 2. Calls ObReferenceObjectByHandle(Handle, 0x1F0003,
    ExEventObjectType, KernelMode, &Object, NULL);
 3. Uses the returned, type-safe Object pointer.
 4. Signals the event with KeSetEvent(Object,1,0) and then
    ObfDereferenceObject(Object).

If the handle conversion fails the function returns the NTSTATUS error
code without touching the caller-supplied address.  All other logic
remains unchanged, so functional behaviour is preserved while the
unsafe pointer dereference is removed.

Affected Structures / Parameters
--------------------------------
 a3   – user-controlled 64-bit value interpreted as _KEVENT *.
 Handle – new, validated event handle replacing a3 for dereference.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
if (a5 == 2) {
    VidSchiFlushCompletedPresentsForCompSurf(dev, Luid,
                                            (struct _KEVENT **)a3);
    if (a3)
        KeSetEvent((PRKEVENT)a3, 1, 0);   // untrusted ptr deref
}

// after
PVOID Object = NULL;
status = ObReferenceObjectByHandle(Handle, 0x1F0003,
                                   ExEventObjectType, KernelMode,
                                   &Object, NULL);
if (NT_SUCCESS(status)) {
    VidSchiFlushCompletedPresentsForCompSurf(dev, Luid,
                                            (struct _KEVENT **)&Object);
    if (Object) {
        KeSetEvent((PRKEVENT)Object, 1, 0);
        ObfDereferenceObject(Object);
    }
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Low-privileged process opens adapter and issues D3DKMT present
   cancellation with flag 2 and supplies arbitrary 64-bit value.
2. Call chain inside dxgkrnl → dxgmms2 leads to
   VidSchCancelPresentAtFlips.
3. Pre-patch: function enters a5==2 path and calls KeSetEvent on the
   raw pointer, writing into attacker-chosen kernel address space.

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker executing crafted D3DKMT ioctl can pass
an arbitrary 64-bit value in place of the event pointer and cause an
arbitrary kernel write, leading to privilege escalation or system
crash.

Patch Description
--------------------------------------------------------------------
• Signature changed: added HANDLE parameter.
• Replaced raw pointer use with ObReferenceObjectByHandle to obtain a
  verified, reference-counted kernel pointer of type ExEventObjectType.
• Added proper dereference (ObfDereferenceObject) after signalling.
• Old unsafe path is bypassed when the feature flag is enabled and
  a5==2; other paths are untouched.

Security Impact
--------------------------------------------------------------------
Arbitrary kernel memory write allows elevation of privilege to SYSTEM
and potential kernel corruption/DoS.  Exploitation requires only a
valid graphics device handle and no additional privileges.

Fix Effectiveness
--------------------------------------------------------------------
The patch enforces object-type verification and access checks through
ObReferenceObjectByHandle and removes all direct dereferences of
user-supplied pointers.  Because KeSetEvent is now called only on a
validated kernel object, the original arbitrary write primitive is
eliminated.  No bypass is apparent with the available evidence.
