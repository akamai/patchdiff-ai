{'date': 1751822603.8228416, 'cve': 'CVE-2025-26668', 'patch_store_uid': 'df5c96ae-bf56-4fc6-929b-b0a727fc0bc8', 'confidence': 0.26, 'file': 'mprapi.dll', 'change_count': 4, 'kb': 'KB5055523'}
--------------------------------------------------------------------
CVE-2025-26668 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Routing and Remote Access Service (RRAS) user-mode helper
library mprapi.dll.  The same code is linked into the RRAS service
process (svchost.exe –netsvcs), so the flaw is reachable in both the
client API and the server-side RPC handlers.

Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow caused by integer-truncation/size-validation
errors (CWE-122 + CWE-190).

Detailed Root Cause Analysis
--------------------------------------------------------------------
Several exported helper routines allocate an output buffer whose length
is computed as  <record_size> * <count_returned_by_RPC>.  Before the
patch the product was cast to 32-bit and supplied to LocalAlloc as an
unsigned int, while all subsequent memory operations (memset, memcpy,
or structure field access) used the full 64-bit value.  If the 64-bit
product exceeds 0xFFFFFFFF the cast silently truncates, causing an
allocation that is much smaller than the space later written.  The
result is an unconstrained heap overwrite in the RRAS process running
as NT AUTHORITY\SYSTEM.

Affected helper functions and record sizes:
  • MprAdminInterfaceEnumEx      – record 1280 bytes (0x500)
  • MprAdminRoutingDomainsEnumEx – record  540 bytes (0x21C)
  • MprAdminConnectionEnumEx     – record 1672 bytes (0x688)

The function MprAdminInterfaceDeviceGetInfo contains a second, related
issue: the routine dereferences a pointer at offset 0x228 (552) inside
the structure returned by the RPC call without first validating that
the buffer is large enough.  A short buffer therefore allows the
attacker to redirect subsequent pointer writes anywhere on the heap.

In all cases the attacker controls the record count and/or buffer size
via crafted RPC replies to procedure numbers 0x26, 0x37, 0x3E and 0x2D
in the \PIPE\ROUTER endpoint.  No authentication is required when RRAS
is configured for remote access.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// MprAdminInterfaceEnumEx – BEFORE
v16 = (char *)LocalAlloc(0x40u, (unsigned int)(1280 * *v11));
memset_0(v16, 0, 1280i64 * (unsigned int)*v11);
for ( i = 0; i < *v11; ++i )
    Pointer = ConvertMpriToMprStructureInternal(...);
```

```c
// MprAdminRoutingDomainsEnumEx – BEFORE
v6 = (char *)LocalAlloc(0x40u, (unsigned int)(540 * *a3));
while (v9 < *a3)
    Pointer = ConvertMpriToMprStructureInternal(...);
```

```c
// MprAdminInterfaceDeviceGetInfo – BEFORE
if (dwLevel == 1 && *((QWORD*)&v7+1))
    *(QWORD*)(*((QWORD*)&v7+1) + 552) = *((QWORD*)&v7+1) + 560;
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Remote attacker sends crafted RPC request to RRAS procedure 0x37
   (e.g. RouterInterfaceEnumEx).
2. RRAS server unmarshals and calls MprAdminInterfaceEnumEx.
3. RPC stub fills *Entries with a large value (>= 0x10000000) and
   returns variable-length data blob in *hMem.
4. Function multiplies 0x500 * Entries, truncates to 32-bit, allocates
   a tiny buffer, then copies the full data, overflowing the heap.
5. Overwritten heap metadata or function pointers are later used,
   leading to code execution under SYSTEM.

Attack Vector
--------------------------------------------------------------------
Unauthenticated network attacker communicates with the vulnerable RRAS
named-pipe/RPC interface and returns a maliciously large entry count or
short structure in the RPC response.  No credentials are required when
RRAS is exposed to the network.

Patch Description
--------------------------------------------------------------------
1. All allocation sizes are now tracked in 64-bit variables.  Before
   calling LocalAlloc the code checks
      if (product > 0xFFFFFFFF) { return ERROR_INVALID_PARAMETER; }
   thereby preventing truncation.
2. MprAdminInterfaceDeviceGetInfo verifies that the returned level-1
   structure is at least 0x230 bytes.  Short buffers are freed and
   ERROR_INVALID_PARAMETER (87) is returned.
3. New validation is gated by Feature_986203450__private_...
   but the default state enables the checks.

Security Impact
--------------------------------------------------------------------
Prior to the patch a remote attacker could overflow the process heap in
the RRAS service and achieve arbitrary code execution with SYSTEM
privileges, leading to complete server compromise.

Fix Effectiveness
--------------------------------------------------------------------
Code inspection shows that all previously unguarded multiplications are
now size-checked and the minimum structure length is enforced before
any pointer dereference.  Provided the feature flag is not disabled via
configuration, the original attack paths are blocked.  No alternative
unchecked allocation paths were observed in the diff, but full binary
review is required to rule out other occurrences.
