{'confidence': 0.31, 'patch_store_uid': 'c22bb7ef-b7b4-46df-ab3e-d621aaee2fe5', 'kb': 'KB5055523', 'cve': 'CVE-2025-24062', 'file': 'dwmcore.dll', 'change_count': 45, 'date': 1751808101.4773192}
--------------------------------------------------------------------
CVE-2025-24062 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Desktop Window Manager core library (dwmcore.dll)
Functions affected:
  • CCompositionSurfaceBitmap::AddOcclusionInformation
  • CSurfaceBrush::AddOcclusionInformation

Vulnerability Class
--------------------------------------------------------------------
Pointer-truncation / improper input validation leading to use-after-
free / elevation of privilege (CWE-20, related to CWE-704)

Detailed Root Cause Analysis
--------------------------------------------------------------------
Both AddOcclusionInformation call helpers in COcclusionContext to
register overlay candidates.  The helper is an instance method and
expects the full 64-bit this-pointer.  In the vulnerable builds the
pointer and several object references are force-cast to 32-bit values
before the call:

  (_DWORD)a2              // COcclusionContext * this
  (unsigned int)this[12]  // CGlobalCompositionSurfaceInfo *
  (unsigned int)v57       // CMILMatrix *

On a 64-bit OS any object allocated above the 4-GB boundary has its
upper 32 bits cleared during the cast.  COcclusionContext::
CheckAndRecordOverlayCandidate therefore receives a corrupt this
pointer and subsequently dereferences attacker-controlled memory.
Because these helpers run inside the DWM process (running as
"DWM-1" under Session-0 and highly trusted), the erroneous write/read
occurs with elevated privileges, opening a path to arbitrary code
execution or token manipulation.

The old code also determined whether overlay candidate collection is
enabled by comparing two internal counters at fixed offsets
(+0x580/+0x588):

  if ( *(a2+0x580) != *(a2+0x588) )

An attacker able to influence those fields could trick the routine
into reaching the vulnerable cast path even when overlay collection
should be disabled.

In summary the defect is a 64-to-32 bit truncation of object
pointers combined with ad-hoc access to internal state; together they
allow memory corruption and privilege escalation from a GUI client
context into the privileged DWM service.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
v37 = COcclusionContext::CheckAndRecordOverlayCandidate(
          (_DWORD)a2,                     // <--- truncation
          *((_QWORD *)a2 + 144),
          (unsigned int)this[12],         // <--- truncation
          (unsigned int)v57,              // <--- truncation
          0i64, 0);

// after
v37 = COcclusionContext::CheckAndRecordOverlayCandidate(
          (__int64)a2,                    // 64-bit safe
          *((_QWORD *)a2 + 144),
          (__int64)this[12],              // 64-bit safe
          (__int64)v57,                   // 64-bit safe
          0i64, 0);
```
```c
// guard condition before
if ( *((_QWORD *)a2 + 177) != *((_QWORD *)a2 + 176) )

// guard condition after
if ( COcclusionContext::IsOverlayCandidateCollectionEnabled(a2) )
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Caller supplies a DComp surface or brush ->
 AddOcclusionInformation() builds layout data ->
 CheckAndRecordOverlayCandidate() invoked with truncated this-pointer
 -> inside the helper, corrupted "this" dereference -> arbitrary memory
 access in DWM process.

Attack Vector
--------------------------------------------------------------------
A locally authenticated attacker creates or controls DComp content that
causes the COcclusionContext object (or related objects) to be
allocated above 0x100000000.  When DWM processes the content it calls
the vulnerable AddOcclusionInformation path, leading to pointer
truncation and memory corruption inside the privileged DWM session.
This can be converted into SYSTEM-level code execution or token
substitution.

Patch Description
--------------------------------------------------------------------
1. Replaced all 32-bit casts with explicit 64-bit (__int64) arguments
   when calling COcclusionContext helpers.
2. Introduced COcclusionContext::IsOverlayCandidateCollectionEnabled()
   instead of reading raw struct fields.
3. Updated function-pointer typedefs so that compilers flag width
   mismatches going forward.
4. Cosmetic: unified MilInstrumentationCheckHR parameter style.

Security Impact
--------------------------------------------------------------------
Prior to the patch a non-privileged user could reliably gain code
execution in the highly privileged DWM process, thereby elevating
local privileges to SYSTEM.  The flaw also allowed potential kernel
exposure through malformed DXGI overlay paths.

Fix Effectiveness
--------------------------------------------------------------------
The cast sites identified by the vendor have been corrected and the
feature-enable check is now encapsulated, removing the known EoP path.
No additional truncations are visible in the patched diff, but full
binary review is required to rule out other callers that still pass
(_DWORD) pointers.
