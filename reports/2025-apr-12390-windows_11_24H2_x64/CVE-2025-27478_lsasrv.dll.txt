{'cve': 'CVE-2025-27478', 'date': 1751822625.0685337, 'kb': 'KB5055523', 'change_count': 33, 'file': 'lsasrv.dll', 'patch_store_uid': 'd385f223-ad66-4d9c-b311-8df147a53b99', 'confidence': 0.27}
--------------------------------------------------------------------
CVE-2025-27478 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
lsasrv.dll – Local Security Authority Sub-System Service (LSASS) memory
marshalling helpers LsapCopyFromClient() and LsapCopyToClient().

Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow caused by missing pointer validation /
improper address classification (CWE-122).

Detailed Root Cause Analysis
--------------------------------------------------------------------
Both helpers are used by the LSASS RPC layer to copy caller-supplied
buffers between the untrusted client process and the privileged LSASS
process.

PRE-PATCH behaviour
1.  The requested length is truncated to 32 bits  (v3 = (UINT)Size).
2.  For outbound copies (LSASS -> client) LsapCopyToClient decides
    whether to use NtWriteVirtualMemory (safe, copies into the *caller
    process*) or a plain memcpy() executed in LSASS itself.
3.  The decision is based only on the session id and two per-call flags
    (0x80000 / 0x100000).  There is **no test that the destination
    pointer really belongs to the caller’s address space**.
4.  If the client maps a view of LSASS heap (e.g. via a SEC_IMAGE or
    section handle) at the same virtual address inside its own process
    and then passes this pointer as the output buffer, the test falls
    through the following path:
        if (same-session)
            memcpy(outBuf, inBuf, length);   // executes in LSASS
   Because the address is valid in LSASS, the copy is performed *inside*
   LSASS, not into the caller.  Length is entirely attacker-controlled
   and is not checked against the real size of the heap block that
   starts at outBuf -> classic heap overflow in lsass.exe.
5.  The counterpart LsapCopyFromClient() suffers from the symmetric
    issue for inbound copies, allowing reads or writes beyond the
    intended heap allocation when the attacker makes Src point inside
    LSASS.

Structures / parameters involved
  Src   – client supplied pointer.
  a2    – LSASS buffer (CopyFromClient) or client buffer (CopyToClient).
  Size  – user-controlled length, truncated to 32 bits.
  Session.FFlags (bit 0x80000 / 0x100000) – controls copy direction.
  CallInfo->MarshalledBase/Limit (v9[48]/[49]) – original, insufficient
  address check.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch (LsapCopyToClient)
if ( *((DWORD *)Value + 4) == *((DWORD *)pDefaultSession + 4) ) {
    memcpy_0(a2, Src, v3);          // <-- Unsafe: no ownership check
    v10 = 0;
}
```
```c
// after patch
if (wil::Feature2578215227::IsEnabled()) {
    int cls = LsapClassifyClientAddress(a2);
    if (cls == 1) {                 // remote client address
        v15 = NtWriteVirtualMemory(hProc, a2, Src, v3, 0);
    } else if (cls == 2) {
        // fast path using callbacks
        ...
    } else {
        MicrosoftTelemetryAssertTriggeredNoArgs(...);
        v15 = STATUS_INVALID_PARAMETER;
    }
} else {
    ...      // old logic kept behind feature-flag for rollback
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Client process -> any LSA RPC API that returns data -> marshalling layer
-> LsapCopyToClient()
   1. Client maps a view of LSASS heap inside its own process at the
      same VA (Section / DuplicateHandle).
   2. Supplies that VA as the output buffer pointer.
   3. Function chooses memcpy() path, overwriting LSASS heap with
      attacker-controlled length.

Attack Vector
--------------------------------------------------------------------
Local, authenticated user.  Requires the ability to call standard LSA
APIs (e.g. LsaEnumerateLogonSessions) which is permitted to low-privilege
processes after LsaConnectUntrusted().  No additional privileges are
needed.

Patch Description
--------------------------------------------------------------------
• Introduces new helper LsapClassifyClientAddress() that positively
  determines whether a supplied pointer belongs to the remote caller,
  to LSASS itself, or is otherwise invalid.
• Based on that classification, selects one of three copy mechanisms:
    – Nt(Read|Write)VirtualMemory for cross-process copies.
    – Callback marshalling for WOW or cross-bitness copies.
    – memcpy() only when the pointer is guaranteed to be inside the
      caller’s address space.
• Adds telemetry asserts and converts silent fall-through cases into
  STATUS_INVALID_PARAMETER when classification fails.
• Keeps original code behind a WIL feature flag for fast rollback.

Security Impact
--------------------------------------------------------------------
Successful exploitation gives the attacker arbitrary, in-process writes
to LSASS heap memory, enabling code execution as SYSTEM and thus full
local privilege escalation.  Crashability / information disclosure are
also possible.

Fix Effectiveness
--------------------------------------------------------------------
The new address-classification gate completely removes the unsafe
memcpy() path for attacker-controlled addresses, eliminating the direct
heap-overflow primitive.  The remaining code paths rely on NtRead/
NtWriteVirtualMemory, which enforce process-boundary checks in the
kernel.  No residual overflow condition is observable in the patched
functions.

