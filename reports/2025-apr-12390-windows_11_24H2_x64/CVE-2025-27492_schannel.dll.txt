{'change_count': 34, 'patch_store_uid': '7dcbd1d8-ea00-4048-b511-5ff09787d90f', 'cve': 'CVE-2025-27492', 'kb': 'KB5055523', 'file': 'schannel.dll', 'date': 1751820788.6734123, 'confidence': 0.21}
--------------------------------------------------------------------
CVE-2025-27492 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Secure Channel (schannel.dll) – handling of
CSslParentContext objects in the SSPI public entry-points
  * SpLsaQueryContextAttributes
  * SpSetContextAttributes
  * SpApplyControlToken
  * SslFreeCustomBuffer

Vulnerability Class
--------------------------------------------------------------------
CWE-362: Race Condition leading to CWE-416: Use-After-Free

Detailed Root Cause Analysis
--------------------------------------------------------------------
Each SSL security context (CSslParentContext) owns a per-connection
"scratch" buffer (pointer stored at offset +0x20 / 4th QWORD).
Functions that query or mutate the context (Sp* APIs) dereference this
pointer, while SslFreeCustomBuffer() can free it and set the field to
NULL.  Prior to the patch no **mutual exclusion** existed between those
call paths:

  • SpLsaQueryContextAttributes / SpSetContextAttributes /
    SpApplyControlToken read context->Scratch (v7[13] / v10[13]).
  • SslFreeCustomBuffer directly invoked
    ((vtable)->Free)(context->Scratch) and zeroed the field.
  • Synchronisation relied only on a reference counter at *(this+0x8),
    incremented/decremented with Interlocked* but **never checked**
    before the scratch buffer was freed.

If one thread entered SslFreeCustomBuffer while another thread was
still inside a Sp* API, the scratch buffer could be released out from
under the reader.  The reader then dereferenced a freed allocation
(v8 / v11), resulting in a classic use-after-free in the LSASS process
(which hosts Schannel SSP).  Because LSASS runs as SYSTEM, a local
attacker able to control the freed memory can execute code in a SYSTEM
context, achieving elevation of privilege.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// SslFreeCustomBuffer (before)
if (a2 != g_dwPackageId || !a1) return 0;
ptr = *(QWORD *)(a1 + 0x18);     // scratch buffer
if (ptr) {
    (*(fn**)ptr)->Free(ptr, a3); // frees memory
    *(QWORD *)(a1 + 0x18) = 0;   // zero field with no lock
}

// SpLsaQueryContextAttributes (before)
v7 = *(_QWORD **)(a1 + 8);
v8 = v7[13];                     // same scratch pointer
... dereference v8 while another thread may have freed it ...
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Thread A                 Thread B
2.                            SpLsaQueryContextAttributes(ctx,..)
3. SslFreeCustomBuffer(ctx,..)   - reads ctx->Scratch (v8)
4.  - frees ctx->Scratch         - uses v8 after free
5.  - zeros ctx->Scratch
6. Result: UAF in LSASS

Attack Vector
--------------------------------------------------------------------
Any local user that can obtain a handle to its own Schannel security
context (e.g., by calling InitializeSecurityContext/AcceptSecurityConte
xt via SSPI) can run two parallel threads that call the public SSPI
APIs in the sequence shown above, racing free vs. attribute query to
achieve memory corruption inside LSASS and elevate privileges.

Patch Description
--------------------------------------------------------------------
The fix introduces a per-context exclusive lock:

  • New helper  CSslParentContext::AcceptCall() tries to acquire an
    SRW exclusive lock (RtlTryAcquireSRWLockExclusive(this)).
  • CSslParentContext::ReleaseCall() releases the lock.
  • All vulnerable entry-points (SslFreeCustomBuffer, SpApplyControlToke
    n, SpLsaQueryContextAttributes, SpSetContextAttributes) now call
    AcceptCall at entry and ReleaseCall on exit.
  • If the lock cannot be taken, the function returns STATUS_RETRY (120)
    rather than touching shared memory.
  • On down-level systems where the new feature flag is disabled, the
    code falls back to the former InterlockedIncrement/Decrement scheme
    but now **tests** the counter and aborts if concurrent use is
    detected.

Security Impact
--------------------------------------------------------------------
Pre-patch, an attacker could provoke a race that freed memory still in
use, enabling arbitrary code execution in LSASS and therefore local
privilege escalation to SYSTEM.  The issue is tracked as
CVE-2025-27492 and classified as EoP.

Fix Effectiveness
--------------------------------------------------------------------
Introducing a real critical section (SRW lock) around all accesses to
context-owned buffers eliminates the time-of-check/time-of-use window.
Returning STATUS_RETRY when contention is detected prevents the old
silent data corruption.  The fallback path still relies on the legacy
counter but now enforces mutual exclusion; however, if the feature flag
is ever disabled the protection reverts to best-effort.  Assuming the
feature is enabled on supported builds, the patch effectively removes
exploitable races.
