{'change_count': 2, 'file': 'fvevol.sys', 'cve': 'CVE-2025-26637', 'confidence': 0.71, 'kb': 'KB5055523', 'date': 1751822596.9328103, 'patch_store_uid': '569edcbc-13ef-4c44-a747-02b552810300'}
--------------------------------------------------------------------
CVE-2025-26637 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows BitLocker volume driver (fvevol.sys) – routine
BlCdoFilterIoctl(), which services DeviceIoControl requests on a Bit-
Locker Child Device Object (CDO).

Vulnerability Class
--------------------------------------------------------------------
Improper access control / protection-mechanism failure (CWE-693).

Detailed Root Cause Analysis
--------------------------------------------------------------------
BlCdoFilterIoctl() must verify that the caller is authorised to issue
specific IOCTLs (e.g. QUERY_CHILD_INFO_LIST, GET_NAMESPACE_REF, newly
added CLEAR_KEYS_FROM_KEYRING).  The driver stores the access flags for
a given FileObject in the two low bits of FileObject->FsContext.  When
an IRP_MJ_DEVICE_CONTROL arrives, the routine should compare those bits
to the access bits embedded in the IOCTL code (bits 14–15 of the
IOCTL).

Prior to the patch the code retrieved the comparison value from an
entirely different field:

    v7 = (UCHAR)HIBYTE(CurrentStackLocation->Parameters.Create.
                       FileAttributes) >> 6;   // WRONG SOURCE

FileAttributes is only defined for IRP_MJ_CREATE.  When the same handle
later sends DeviceIoControl, this byte is unrelated or zero.  As a
result the check often collapses to 0 == (0 & FsContext), which is
always true and the privileged IOCTL is executed even if the handle was
opened with FILE_ANY_ACCESS.

Patch change:

    v8 = (USHORT)IoControlCode >> 14;           // CORRECT SOURCE
    if ((DWORD)v8 != ((UINT)v8 & FsContext)) …   // proper test

Thus the root cause is an authorisation decision made using the wrong
input parameter, allowing access checks to be bypassed.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// BEFORE
v7 = (BYTE)HIBYTE(Stack->Parameters.Create.FileAttributes) >> 6;
if (v7 != (v7 & (INT64)FileObject->FsContext)) {
    Status = STATUS_INVALID_DEVICE_REQUEST;     // -0x3fffff12
    …
}

// AFTER
v8 = (USHORT)IoControlCode >> 14;               // bits 14–15
if ((DWORD)v8 != ((UINT)v8 & (INT64)FileObject->FsContext)) {
    Status = STATUS_INVALID_DEVICE_REQUEST;
    …
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker opens the BitLocker CDO with minimal access
   (CreateFile(…, FILE_ANY_ACCESS,…)).
2. Attacker issues a privileged IOCTL that normally requires
   FILE_READ_ACCESS/FILE_WRITE_ACCESS.
3. BlCdoFilterIoctl() extracts wrong access bits (from CREATE
   FileAttributes) and authorises the request.
4. The driver executes the privileged sub-routine, e.g.
   BlIoctlGetNamespaceRef(), exposing protected BitLocker material.

Attack Vector
--------------------------------------------------------------------
Local or physical attacker who can obtain a handle to the BitLocker
volume device can send crafted DeviceIoControl() requests to bypass
BitLocker protections.  No elevated token is needed because the faulty
check accepts handles opened with FILE_ANY_ACCESS.

Patch Description
--------------------------------------------------------------------
• Replaced use of Create.FileAttributes with the proper access field
  extracted from IoControlCode (bits 14–15).
• Consolidated failure handling into one early exit path (LABEL_14).
• Added explicit routing for new IOCTL 0x4C44189C
  (BlIoctlClearKeysFromKeyring).
• No structural changes to FsContext flag layout; only access-check
  logic was corrected.

Security Impact
--------------------------------------------------------------------
The flaw allows unauthorised callers to execute BitLocker-specific
IOCTLs that can enumerate child volumes, obtain namespace references,
or clear keys.  In practice this can lead to a complete bypass of
BitLocker’s protection of data at rest, satisfying Microsoft’s
classification as a Security Feature Bypass.

Fix Effectiveness
--------------------------------------------------------------------
The patched routine now derives required access directly from the IOCTL
code, matching Windows IOCTL specification.  The comparison is made
before any privileged operation is dispatched.  No obvious alternate
path remains that preserves the old behaviour, so the fix appears
logically sound.  Runtime testing unknown.
