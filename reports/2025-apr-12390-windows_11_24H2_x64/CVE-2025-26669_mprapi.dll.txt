{'patch_store_uid': 'df5c96ae-bf56-4fc6-929b-b0a727fc0bc8', 'kb': 'KB5055523', 'change_count': 4, 'confidence': 0.28, 'cve': 'CVE-2025-26669', 'file': 'mprapi.dll', 'date': 1751829055.6001742}
--------------------------------------------------------------------
CVE-2025-26669 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Routing and Remote Access Service (RRAS) user-mode RPC client
library, mprapi.dll.  Affected exported APIs:
  • MprAdminInterfaceDeviceGetInfo
  • MprAdminInterfaceEnumEx
  • MprAdminRoutingDomainsEnumEx
  • MprAdminConnectionEnumEx
All four wrappers are executed inside the calling process and parse the
network data returned by the RRAS server.

Vulnerability Class
--------------------------------------------------------------------
CWE-125: Out-of-bounds Read (triggered by integer-truncation that leads
to an undersized heap allocation and subsequent out-of-bounds memory
access; some paths can also over-write, but Microsoft classifies as
information disclosure).

Detailed Root Cause Analysis
--------------------------------------------------------------------
The four helper functions retrieve variable-length arrays or structures
from the remote RRAS server via the auto-generated RPC stub
NdrClientCall3().

Returned parameters that remain fully controlled by the server are:
  • entry count (for *EnumEx helpers)  ->  DWORD  *a5 / *a3 / v17
  • structure size (for *DeviceGetInfo) -> DWORD  LOWORD(v7)

PRE-PATCH logic
1. NdrClientCall3() returns success and fills the count / size as
   32-bit values.
2. The wrapper multiplies the count with a fixed element size to obtain
   the required buffer length:
        bytes = (unsigned int)(STRUCT_SIZE * Count);
3. The product is explicitly cast to unsigned int and supplied to
   LocalAlloc().
4. If Count is large enough ( >= 0x100000000 / STRUCT_SIZE ), the 64-bit
   product is truncated to 32 bits.  LocalAlloc therefore returns a
   buffer that is far smaller than needed.
5. A for-loop copies every element that the server claimed to return
   into the undersized buffer using memcpy() / manual field copies:
        memcpy(Buffer + i*STRUCT_SIZE , Remote + i*STRUCT_SIZE , ...);
6. When i exceeds bytes/STRUCT_SIZE the code walks past the allocation
   boundary and reads (and partly writes) adjacent process memory,
   leaking it back to the caller or potentially corrupting heap
   metadata.

The same pattern exists in three enumeration helpers with element sizes
  • 1280 (MprAdminInterfaceEnumEx)
  •  540 (MprAdminRoutingDomainsEnumEx)
  • 1672 (MprAdminConnectionEnumEx)

For MprAdminInterfaceDeviceGetInfo the defect is slightly different: the
code blindly dereferences offset 0x230 and 0x238 inside the returned
LEVEL-1 structure without verifying that the server allocated that many
bytes.  A size field smaller than 0x230 results in an out-of-bounds read
from heap memory.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// InterfaceEnumEx  – before patch
Pointer = (unsigned int)NdrClientCall3(...).Pointer;
if (!Pointer) {
    char *buf = LocalAlloc(0x40u, (unsigned int)(1280 * *a5));
    ...
    for (i=0; i < *a5; i++)
        memcpy(buf + 1280*i, (char*)hMem + 1280*i, 1280);
}

// DeviceGetInfo – before patch
if (dwLevel == 1) {
    if (*((QWORD*)&v7 + 1) && *(QWORD*)(*((QWORD*)&v7 + 1)+552))
         *(QWORD*)(*((QWORD*)&v7 + 1)+552) = *((QWORD*)&v7 + 1)+560;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker controls a malicious RRAS server.
2. Victim calls any affected *EnumEx / *GetInfo API to that server.
3. Server crafts RPC reply with:
     Count = 0xFFFFFFFF  (or any value causing overflow)
     OR size < 0x230 for GetInfo(Level1)
4. Client-side mprapi.dll allocates a truncated heap buffer.
5. Copy loop (or pointer fix-up) accesses beyond the buffer.
6. Out-of-bounds data is disclosed to the caller or can corrupt heap
   memory leading to further exploitation.

Attack Vector
--------------------------------------------------------------------
Network.  A non-privileged attacker who can impersonate or operate a
RRAS server that the victim queries can send specially crafted RPC
responses to trigger the flaw in the client process.

Patch Description
--------------------------------------------------------------------
Microsoft added strict size validation guarded by the internal runtime
flag Feature_986203450__private_IsEnabledDeviceUsageNoInline():
  • For each EnumEx helper the 64-bit product is computed first and
    compared against 0xFFFFFFFF.  If it would overflow, the function now
    aborts with ERROR_INVALID_PARAMETER (87) before allocation.
  • DeviceGetInfo now validates that the returned structure length is
    >= 0x230 bytes.  If not, the buffer is freed and the same error 87
    is returned.
  • All functions free any partially allocated memory on early exit to
    avoid leaks.

Security Impact
--------------------------------------------------------------------
Prior to the patch, a malicious RRAS server could force the caller to
read past the end of a heap allocation, disclosing up to several
kilobytes of process memory per request (information disclosure).  In
some cases the overwrite could corrupt adjacent heap data and be
leveraged for code execution, but only information disclosure is
acknowledged in CVE-2025-26669.

Fix Effectiveness
--------------------------------------------------------------------
The added 64-bit multiplication and upper-bound check eliminates the
integer truncation, making it impossible to obtain an undersized buffer
through a crafted count.  The Level-1 structure length check prevents
pointer fix-up on an undersized buffer.  No residual code paths
reachable from the same APIs perform unchecked size calculations, so
the patch fully mitigates the identified out-of-bounds read.
