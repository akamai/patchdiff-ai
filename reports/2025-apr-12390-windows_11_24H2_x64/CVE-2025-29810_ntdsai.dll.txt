{'cve': 'CVE-2025-29810', 'file': 'ntdsai.dll', 'patch_store_uid': 'a85e12c7-310f-4444-a434-b5b808f3b783', 'confidence': 0.22, 'kb': 'KB5055523', 'change_count': 21, 'date': 1751822661.2959154}
--------------------------------------------------------------------
CVE-2025-29810 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Active Directory Domain Services – LDAP server code in ntdsai.dll
( functions LDAP_CONN::BindRequest and LDAP_REQUEST::Authenticate )

Vulnerability Class
--------------------------------------------------------------------
Improper Access Control / Type-confusion leading to controlled memory
overwrite (logical privilege-escalation)

Detailed Root Cause Analysis
--------------------------------------------------------------------
Prior to the patch the LDAP server exported

    LDAP_CONN::BindRequest( … , _WORD *a5, _QWORD *a7 )

The last parameter ( a7 ) is treated as an output buffer that the
routine unconditionally fills with a 128-bit ‘BindType’ constant, for
example

    *(OWORD*)a7 = BindTypeNtlm;           // 16-byte store

Nothing in the function checks where a7 points.  The caller supplies
this pointer and, because the declared prototype does not match the
real data flow further up the call-stack, a7 can reference unrelated
process memory.  When NTLM / Digest / External or other bind paths are
executed the 16-byte store blindly overwrites that memory.

A network client is able to trigger BindRequest through the LDAP bind
operation and can influence the memory layout so that a7 references
server-side structures that control the security context of the
connection.  By overwriting those words the attacker can flip
authentication flags and elevate the privileges granted to the
connection.

A similar unchecked pointer ( a5 ) was used to zero a single WORD.

The subsequent routine LDAP_REQUEST::Authenticate used the same
mismatched prototypes and performed pointer arithmetic on the buffers
returned by BindRequest.  Because the returned buffer could have been
corrupted, the authentication routine operated on attacker-controlled
values, compounding the privilege escalation.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
*(_DWORD *)a7 = 0;          // caller buffer
a7[1]      = 0i64;
* a5        = 0;            // zero WORD at caller pointer
...
*(OWORD *)a7 = BindTypeNtlm;   // 16-byte blind write

// after
LDAP_SECURITY_CONTEXT *a5;
WCHAR *a7;                   // corrected types
...
// no more BindType writes through caller pointer – value is now
// stored inside the connection object itself (StringSid alias).
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Remote client issues LDAP BIND.
2. dsasrv!ReceiveLdapRequest -> LDAP_CONN::BindRequest.
3. Malformed packet arranges for pointer a7 to reference sensitive
   memory.
4. BindRequest writes 16 bytes of attacker-chosen BindType constant to
   that location.
5. LDAP_REQUEST::Authenticate later trusts the overwritten memory and
   installs a security context with elevated flags.

Attack Vector
--------------------------------------------------------------------
Any authenticated network user who can reach the DC’s LDAP port (389 /
636) can send a crafted BIND request that steers the a7 pointer and
gains higher privileges on the same connection.

Patch Description
--------------------------------------------------------------------
• Function signature changed: ‘_WORD *a5, _QWORD *a7’ replaced by
  ‘LDAP_SECURITY_CONTEXT *a5, WCHAR *a7’.  Both are now strictly
  internal – caller can no longer pass arbitrary pointers.
• All direct stores through a7 were removed; BindType is saved inside
the connection structure instead.
• Added extra      SetChannelBindings(…, &outFlags, &internalBuf)
  variants that receive an internal buffer pointer, never a caller
  pointer.
• Wrapped sensitive AcceptSecurityContext calls with a critical section
  to prevent concurrent pointer reuse.

Security Impact
--------------------------------------------------------------------
The uncontrolled 16-byte write allowed an attacker to tamper with
security-critical state and force the DC to treat the connection as
NTLM / Negotiate / Digest etc.  This bypasses normal authentication
policy and results in elevation of privilege in the directory service.

Fix Effectiveness
--------------------------------------------------------------------
The vulnerable caller-supplied pointers are no longer used; all writes
now target memory that belongs to the connection object and is under
full control of the LDAP server.  No remaining code paths perform
unchecked stores through external pointers, so the issue is considered
fully remediated.
