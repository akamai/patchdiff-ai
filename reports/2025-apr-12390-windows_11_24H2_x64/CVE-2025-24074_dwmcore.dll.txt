{'kb': 'KB5055523', 'change_count': 45, 'confidence': 0.18, 'file': 'dwmcore.dll', 'patch_store_uid': 'c22bb7ef-b7b4-46df-ab3e-d621aaee2fe5', 'date': 1751807568.05906, 'cve': 'CVE-2025-24074'}
--------------------------------------------------------------------
CVE-2025-24074 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Desktop Window Manager (dwmcore.dll)
Affected routines:
 • COcclusionContext::PreSubgraph()
 • CDDisplaySwapChain::PresentMPO()
 • CLegacySwapChain::Present()

Vulnerability Class
--------------------------------------------------------------------
Heap-based memory corruption caused by improper input validation /
integer-overflow during dynamic array growth (CWE-20, leads to CWE-787).

Detailed Root Cause Analysis
--------------------------------------------------------------------
1. Occlusion list growth
   In PreSubgraph() the occlusion pointer list for a tree-data object
   lives between offsets 0xB0+ ( v4+176 … v4+192 ).  When the caller’s
   visual-tree has no entry, code block “LABEL_33” allocates a new
   COcclusionInfo* and appends it:
      v65 = *(policy**)(v4+184);
      needed = currentCount + 1;           // v33 + 1
      newCap = liberal_expansion_policy::expand(..);
      buf  = operator new[](newCap*8);

   Copy-back loop
      while (oldBegin != oldEnd) { *dst++ = *old++; }
   uses v68 (count) but later performs
      v436 = (dst - newBegin) >> 3;
   without validating that (v68 – v33) is positive.  If the original
   size is close to 0x20000000 the arithmetic in ‘expand()’ wraps, the
   allocator returns a too-small buffer and the copy loop overruns it
   – corrupting the heap controlled by the DWM service (SYSTEM).

2. Missing state initialisation in Present* paths
   • PresentMPO() previously called CopyFrontToBackBuffer() only when
     (flags&2)==0, but never executed PrePresent().  The swap-chain’s
     internal state (scan-out cache / HDR metadata) therefore contained
     stale pointers.  Subsequent SetPerPresentDisplayScanoutOptions()
     dereferenced them and could be forced into a use-after-free.
   • LegacySwapChain::Present() showed the same pattern and additionally
     handled the HDR-metadata parameter as a raw 32-bit value, allowing
     out-of-range ids to propagate down the driver stack.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// PreSubgraph – before
if (!((v63-(__int64)v65)>>3) ) {
    if (v33+1 < v33) _Xoverflow_error();
    newCap = policy::expand(v65, oldCap, v33+1);   // may wrap
    buf = operator new[](newCap*8);                // too small
    ... copy   while (oldBegin!=oldEnd) *dst++=*src++; // OOB write
}
```
```c
// PresentMPO – before (excerpt)
if ((a3 & 2)==0)
    COverlaySwapChain::CopyFrontToBackBuffer(this); // PrePresent missing
// no validation of a4 (HDR metadata)
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-mode client → DComp / DWM API → builds very large visual tree →
DWM core calls COcclusionContext::PreSubgraph() → size calculation
wraps → heap overflow in DWM service (NT AUTHORITY\SYSTEM).
Alternate path: crafted MPO / legacy swap-chain present → missing
PrePresent initialisation → use-after-free inside SetPerPresent...

Attack Vector
--------------------------------------------------------------------
Local, non-admin process capable of creating or controlling a Desktop
Composition visual tree (e.g. via DirectComposition, XAML or WinUI).
No special privileges are needed beyond the ability to create windows.

Patch Description
--------------------------------------------------------------------
• Re-implemented PreSubgraph() to use
  CVisual::FindTreeData()/GetOcclusionInfo() – removing hand-rolled
  vector growth and all pointer arithmetic.
• PresentMPO()/Present() now:
  – call PrePresent() to reset internal state safely.
  – use strongly-typed DXGI_HDR_METADATA_TYPE instead of raw uint.
  – funnel scan-out creation through helper routines with strict
    bounds checks.
  – consolidate error-paths; early bail-out prevents the old
    dangerous fall-through logic.
• Added extensive HRESULT checking; failures now fast-fail via
  MilInstrumentationCheckHR_MaybeFailFast().

Security Impact
--------------------------------------------------------------------
Prior to the fix, a local attacker could trigger heap corruption or a
use-after-free inside the high-privilege DWM process, enabling code
execution in the DWM session context and therefore full elevation of
privilege to SYSTEM.

Fix Effectiveness
--------------------------------------------------------------------
Manual buffer management is gone; all allocations are performed through
validated helpers, eliminating the integer-overflow window.  Calls to
PrePresent() guarantee internal pointers are valid before use, and the
enum change prevents out-of-range metadata types from reaching the
kernel driver.  No further uncontrolled arithmetic remains in the
patched paths, making the fix effective against the demonstrated flaw.
