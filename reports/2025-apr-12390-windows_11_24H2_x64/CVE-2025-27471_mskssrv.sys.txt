{'file': 'mskssrv.sys', 'confidence': 0.19, 'patch_store_uid': 'fdb6ca27-1793-4cda-8932-cb2765555e42', 'change_count': 1, 'cve': 'CVE-2025-27471', 'kb': 'KB5055523', 'date': 1751822601.5140274}
--------------------------------------------------------------------
CVE-2025-27471 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows kernel-mode streaming driver mskssrv.sys – routine
wil_details_FeatureReporting_RecordUsageInCache(), reached from the
SrvDispatchIoControl IOCTL handling path.

Vulnerability Class
--------------------------------------------------------------------
Race condition / improper locking of a shared in-kernel statistics
cache (CWE-667/591).

Detailed Root Cause Analysis
--------------------------------------------------------------------
The driver keeps a two-DWORD per-process cache that records how often a
particular "feature id" has already been reported to the Windows
feature-usage telemetry service.  The function receives
  a1 – output buffer to be filled
  a2 – pointer to the volatile cache (DWORD[2])
  a3 – feature id (0…>320)
  a4 – misc flag passed through

For feature id values a3 >= 320 the code stores the condensed 6-bit
index v7 = a3-320 in the second cache DWORD (*((DWORD*)a2+1)).
Bit 4 of that DWORD is a presence bit; bits 5–11 hold the 6-bit index.
The loop
  _InterlockedCompareExchange(a2+1,…)
sets bit-4 and the index, and *a1+16 is set to 1 if the record was
already in the cache (v9==true).

Pre-patch logic unconditionally executed the following block **even
when the record already existed**:
    *(_DWORD*)(a1+8)  = a3;   // mark for service call
    *(_DWORD*)(a1+4)  = 1;    // "need-to-report" flag
    *(_DWORD*)(a1+12) = a4;   // caller supplied data
Consequences:
1.  Every call that hit an already-cached feature id still forced the
    driver to queue a new telemetry request, defeating the purpose of
    the cache.
2.  Multiple concurrent callers repeatedly entered the same CAS loop
    and incremented the 6-bit counter until it wrapped, causing long
    spins or perpetual retry on saturation.
3.  Because the shared memory is only protected by the single CAS, the
    mis-handled presence check lets unprivileged code keep the driver
    busy indefinitely, exhausting CPU and starving legitimate
    streaming operations (kernel DoS).

Patch eliminates the flaw by:
• aborting the cache path when v7 >= 64 (out-of-range index).
• executing the expensive "report" block only when *a1+16 == 0, i.e.
  **only on a true cache miss**.
Thus already-present entries are no longer touched, preventing counter
overflow and the associated endless contention.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// pre-patch (simplified)
if ((unsigned)(a3-6)>=2) {
    v7 = a3-320;
    if (v7 < 64) {
        ... CAS loop sets bit4 + index ...
    }
    // executed even on cache hit ----------------------
    *(DWORD*)(a1+8)  = a3;
    *(DWORD*)(a1+4)  = 1;
    *(DWORD*)(a1+12) = a4;
    return a1;
}

// post-patch
if (v7 >= 64) goto LABEL_16;   // sanity cap
...
*(DWORD*)(a1+16) = v9;          // v9 == cache_hit?
...
while (v10 != v8);
if (!*(DWORD*)(a1+16)) {        // only when NOT cached
LABEL_16:
    *(DWORD*)(a1+8)  = a3;
    *(DWORD*)(a1+4)  = 1;
    *(DWORD*)(a1+12) = a4;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Remote/low-priv process
  -> DeviceIoControl(\\.\KsSvr, IOCTL_xxx, feature_id>=320)
  -> SrvDispatchIoControl
  -> FSRendezvousServer::RegisterStream
  -> wil_details_FeatureReporting_ReportUsageToService()
  -> wil_details_FeatureReporting_RecordUsageInCache()  <-- vulnerable
Each call with the same feature id re-enters the faulty path.

Attack Vector
--------------------------------------------------------------------
A network client (or local user) repeatedly sends crafted IOCTLs that
cause the driver to process the same high feature id (>=320).  Because
there is no caller privilege check on that path, an unprivileged
attacker can force the cache to thrash, tying up CPU time inside the
kernel and denying service to legitimate streaming sessions.

Patch Description
--------------------------------------------------------------------
1. Added upper-bound check   if (v7 >= 64) goto LABEL_16;   to block
   invalid indices.
2. Added   if (!*(a1+16)) { ... }   guard so the costly reporting block
   runs only on a genuine cache miss.
3. Adjusted label numbers; no other functional changes.

Security Impact
--------------------------------------------------------------------
Before the fix an attacker could:
• Force endless CAS retries and CPU exhaustion in kernel mode.
• Cause continuous, unnecessary telemetry traffic.
• Indirectly leak timing information about cached feature usage.
Overall result: remote denial-of-service of the streaming service and
potential wider system impact.

Fix Effectiveness
--------------------------------------------------------------------
The patch prevents the vulnerable code path from touching the shared
cache when the feature is already present and blocks out-of-range
indices.  Because the only write now occurs on a true miss, the race
window that allowed counter overflow and tight spinning is closed.
Static review shows no remaining unconditional writes; runtime DoS
surface is therefore mitigated.
