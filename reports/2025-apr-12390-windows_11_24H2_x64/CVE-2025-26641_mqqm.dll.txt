{'cve': 'CVE-2025-26641', 'kb': 'KB5055523', 'file': 'mqqm.dll', 'patch_store_uid': 'e5b1f0b5-92db-4e84-aff4-f04a70d2e713', 'change_count': 9, 'date': 1751820822.5108628, 'confidence': 0.23}
--------------------------------------------------------------------
CVE-2025-26641 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Message Queuing (MSMQ) user-mode service, mqqm.dll.  The
fault lies in the parser that walks SRMP / SOAP envelope sections when
a packet is received from the network.

Vulnerability Class
--------------------------------------------------------------------
Integer overflow and missing input validation leading to uncontrolled
resource consumption (CWE-400 / CWE-190).   A malformed length field in
the SRMP envelope header is trusted and used in pointer arithmetic,
allowing wrap-around and endless parsing that hangs the service.

Detailed Root Cause Analysis
--------------------------------------------------------------------
Structure involved:  
  struct CSrmpEnvelopeHeader  {
      WORD  Id;            // constant 0xA   (size field starts at +4)
      WORD  Reserved;      
      DWORD DataLength;    // number of UTF-16 characters that follow
      WCHAR Data[...];
  };

Old code path
-------------
• CQmPacket::CQmPacket() walks every section in the on-wire packet.  
• When it reaches an SRMP envelope section it calls
  CSrmpEnvelopeHeader::SectionIsValid().
• In the vulnerable build the symbol SectionIsValid is **mis-mapped** –
it actually points to wil::details::FeatureImpl<…>::__private_IsEnabled
(a tiny helper that just returns a feature-flag bit).  Therefore **no
validation at all** is performed on DataLength.
• CQmPacket then computes the position of the next section via
      next = hdr + ((2 * DataLength + 11) & 0xFFFFFFFC);
  The multiplication is carried out on a 32-bit register.  A
  DataLength larger than 0x80000000 causes 2*DataLength to overflow and
  wrap to a small positive value.  The resulting pointer appears to be
  inside the supplied buffer, so all subsequent boundary checks pass.
• The parser continues and may iterate indefinitely, allocate large
  memory blocks, or access invalid memory, exhausting CPU and/or RAM
  and rendering MSMQ unresponsive (denial-of-service).

New code path
-------------
The patch restores a real implementation of
CSrmpEnvelopeHeader::SectionIsValid and removes all feature-flag
short-cuts in the constructor.
Key checks now performed:
  1. tmp   = 2 * DataLength (64-bit)  
     if tmp > 0xFFFFFFFF -> throw (overflow guard)
  2. if DataLength == 0 -> throw
  3. GetNextSectionPtrSafe verifies that (this+8) .. (this+tmp+8)
     lies entirely inside the packet buffer.
  4. CheckNullTerminator ensures the UTF-16 string is NUL-terminated.
If any test fails ReportAndThrow() aborts parsing and the packet is
rejected early.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// old "validation" – actually just a feature-flag probe
char __fastcall IsEnabled(__int64 a1) {
    char tmp;   // no header checks at all
    GetCachedFeatureEnabledState(a1,&tmp);
    return tmp & 1;
}

// fixed validator (excerpt)
void __fastcall SectionIsValid(CSrmpEnvelopeHeader *this,char *End) {
    unsigned __int64 bytes = 2ull * *((unsigned int*)this + 1);
    if (bytes > 0xFFFFFFFF)
        ReportAndThrow("DataLength caused overflow");
    if (!*((DWORD*)this + 1))
        ReportAndThrow("Invalid data length ...");
    GetNextSectionPtrSafe((UINT64)this,8,bytes,End);
    CheckNullTerminator((BYTE*)this+8,(BYTE*)this+bytes+8);
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker sends crafted MSMQ message over TCP 1801 / HTTP SRMP.  
2. CSockTransport::HandleReceiveUserMsg()  
3. CQmPacket::CQmPacket() parses sections.  
4. Calls fake SectionIsValid – always returns success.  
5. Pointer arithmetic overflows; loop advances to wrong offset and may
   consume unbounded CPU / memory.  
6. Service thread stalls; queue manager stops processing -> DoS.

Attack Vector
--------------------------------------------------------------------
Unauthenticated network packet to the MSMQ service.  No credentials are
required; only the ability to send a malformed SRMP envelope with an
extreme DataLength field.

Patch Description
--------------------------------------------------------------------
• Implement proper CSrmpEnvelopeHeader::SectionIsValid with length,
  overflow and NUL-termination checks.  
• Remove conditional compilation/runtime feature flag that previously
  skipped these checks.  
• In CQmPacket::CQmPacket the validator is invoked unconditionally and
  subsequent pointer math uses the safe result.  
• Minor clean-ups in related classes (CAutoDeletePacketFromDuplicateMap,
  CSockTransport) are refactors, not core to the fix.

Security Impact
--------------------------------------------------------------------
Before the fix an attacker could craft a single packet that triggers an
infinite parse loop or extremely large memory operations, causing 100%
CPU utilisation and possible memory exhaustion inside the MSMQ service
(process mqsvc.exe), leading to denial-of-service and watchdog restarts.
No privilege escalation or data corruption is required.

Fix Effectiveness
--------------------------------------------------------------------
The new validation logic blocks all malformed lengths that could wrap
or be zero, and it is always executed.  Because parsing now relies on
64-bit arithmetic and explicit bounds checks, the overflow condition is
eliminated and resource usage stays bounded.  The DoS condition is no
longer reproducible with the previously malicious packets.
