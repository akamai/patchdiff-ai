{'kb': 'KB5055523', 'file': 'ntoskrnl.exe', 'change_count': 111, 'patch_store_uid': '998f4703-7363-48af-b1e4-3bf03bc6fbf9', 'confidence': 0.17, 'cve': 'CVE-2025-27739', 'date': 1751822663.974182}
--------------------------------------------------------------------
CVE-2025-27739 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows kernel – low-fragmentation-heap (LFH) / segment descriptor
handling inside ntoskrnl.exe (functions RtlpHpSegDescriptorValidate,
RtlpHpSegLfhVsDecommit and related helpers).

Vulnerability Class
--------------------------------------------------------------------
Untrusted pointer dereference / heap-metadata validation bypass
(CWE-822).

Detailed Root Cause Analysis
--------------------------------------------------------------------
The LFH back-end keeps per-segment descriptor arrays. A fast helper
(RtlpHpSegDescriptorValidate) receives an *arbitrary* address inside a
segment (parameter a2) and attempts to walk back to the descriptor:

1. `segHead = (*SegmentBase & Address)`                          
2. `desc = segHead + 32 * (((Address - segHead) >> Shift))`      
3. Trust `desc` if a few flag bits match.

Prior to the patch the code performed an *unconditional negative
adjustment* when the descriptor was marked “large-span” (bit 1 clear):

    desc -= 32 * *(unsigned __int8 *)(desc + 26);

Because the adjustment used a **user-controllable count** (the 1-byte
`SpanIndex`) without re-validating the final pointer, a crafted heap
layout could move `desc` *backwards* outside the real descriptor array.
Subsequent flag checks still succeeded and the returned pointer was
later dereferenced by several callers (e.g. RtlpHpSegLfhVsDecommit),
causing the kernel to read and/or write attacker-chosen kernel memory.

If an attacker can trigger a kernel free or decommit on such a fake
descriptor, arbitrary pool‐pointer dereference is reached and ﬁnally an
Elevation of Privilege.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
v5 = segHead + 32 * (((a2 - segHead) >> shift));
if (v5) {
    if ((*(BYTE*)(v5+24) & 1)) {
        if ((*(BYTE*)(v5+24) & 2)==0) {
            v5 -= 32 * *(BYTE*)(v5+26);   // attacker-controlled !
            if ((*(BYTE*)(v5+24) & 3)==3) // trust
                return v5;               // ← untrusted pointer leaves
        }
    }
}
```
```c
// after
v5 = segHead + 32 * (((a2 - segHead) >> shift));
v5  = v5 - 32 * *(BYTE*)(v5+26);           // same math
if (((*(BYTE*)(v5+24) & 3)==3) &&          // but …
    (segHead + (((v5-segHead)>>5)<<shift)==a2 ||
     (*(BYTE*)(v5+24) & 0x0C) >= 8))       // extra consistency tests
    return v5;
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User process
 → allocates and corrupts LFH metadata (SpanIndex overflow)         
 → calls NtFreeVirtualMemory / heap APIs                            
 → kernel reaches RtlpHpSegLfhVsDecommit                            
 → RtlpHpSegDescriptorValidate returns attacker pointer             
 → pointer is dereferenced → EoP.

Attack Vector
--------------------------------------------------------------------
Local, authorised attacker running arbitrary code in a user session.
By grooming heap segments and corrupting the `SpanIndex` byte, the
attacker can force the kernel to treat an arbitrary kernel address as a
valid segment descriptor.

Patch Description
--------------------------------------------------------------------
• RtlpHpSegDescriptorValidate was rewritten:                       
  – performs the subtract *before* initial checks;                 
  – re-computes that the supplied address really belongs to the
    candidate descriptor;                                          
  – requires either exact alignment or large-span bit to be set.    
• RtlpHpSegLfhVsDecommit now calls the validator and uses the safe
  return value; the previous size calculation was replaced by an
  explicit byte extract to avoid sign/shift mistakes.
• Multiple heap helper functions were hardened to propagate the new
  validation logic.

Security Impact
--------------------------------------------------------------------
Before the fix a local attacker could obtain arbitrary kernel
read/write by making the kernel dereference / update a forged segment
descriptor, allowing privilege escalation to SYSTEM.  The bug is rated
as Elevation of Privilege.

Fix Effectiveness
--------------------------------------------------------------------
The patched validator guarantees:                                   
1. the final descriptor pointer is still inside the real descriptor
   array;                                                           
2. alignment with respect to the original address is enforced;      
3. suspicious large-span descriptors without proper flags are
   rejected.                                                         

Combined with the modified callers the exploitable path is closed and
no obvious bypass is apparent.
