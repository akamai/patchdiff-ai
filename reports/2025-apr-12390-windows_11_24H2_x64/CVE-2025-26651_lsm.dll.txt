{'patch_store_uid': '8cc780fd-7b64-45ab-bdc0-860e19f5838a', 'confidence': 0.24, 'file': 'lsm.dll', 'date': 1751828845.3491733, 'change_count': 15, 'cve': 'CVE-2025-26651', 'kb': 'KB5055523'}
--------------------------------------------------------------------
CVE-2025-26651 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Local Session Manager (lsm.dll) – RPC server side handlers
for session-management operations.

Vulnerability Class
--------------------------------------------------------------------
Logic error / Exposed dangerous function (CWE-749) leading to service
crash (Denial-of-Service).

Detailed Root Cause Analysis
--------------------------------------------------------------------
The RPC method RpcGetSessionIds is exported by the LSM RPC interface.
In the vulnerable build the server stub executes the following code
right after entry:

    DebugBreak();
    return 0x8000FFFF;   // E_UNEXPECTED

DebugBreak() raises STATUS_BREAKPOINT in the calling thread.
Because the call is executed inside the service process (lsm.exe), and
because no structured exception handling surrounds the call, the
exception is unhandled and terminates the Local Session Manager
service.  Any caller that can reach the RPC endpoint can therefore
bring down LSM at will, causing a system-wide service disruption (no
new logon sessions, reconnects, etc.).  No parameter validation or
privilege check precedes the DebugBreak, so the crash is guaranteed on
every invocation.

Other large refactoring changes in
CTSSession::ConnectToTerminal/RpcLoggedOnCompleted were made, but they
do not participate in the DoS trigger path; the root cause is the
unconditional DebugBreak in RpcGetSessionIds.

Structures / parameters involved:
  • RPC opnum      : unknown (internal ID, not present in diff)
  • Server routine : RpcGetSessionIds()
  • Raised status  : STATUS_BREAKPOINT (0x80000003) via DebugBreak()

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
__int64 RpcGetSessionIds()
{
    DebugBreak();              // unconditionally crash
    return 2147500033i64;      // E_UNEXPECTED
}

// after
__int64 RpcGetSessionIds()
{
    if(!wil::details::FeatureImpl<...>::__private_IsEnabled(&impl))
        DebugBreak();          // executed only when feature flag says
                              // "debug"; disabled in production
    return 2147500033i64;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Client (attacker) -> LSM RPC endpoint -> opnum for RpcGetSessionIds ->
server routine executes DebugBreak -> STATUS_BREAKPOINT not handled ->
lsm.exe process terminates -> logon/session management unavailable ->
Denial-of-Service.

Attack Vector
--------------------------------------------------------------------
Any authenticated entity that can send RPC traffic to the LSM endpoint
(named pipe/ALPC – exact transport unknown) can invoke the vulnerable
method.  No special privileges or parameters are required.  Remote
reachability is "network" according to the CVE description; deeper
ACL details are unknown.

Patch Description
--------------------------------------------------------------------
The fix wraps the DebugBreak call inside a WIL runtime feature check:

    if (!Feature_2578215227::IsEnabled())
        DebugBreak();

The corresponding feature flag is disabled in production builds, so
DebugBreak is never executed for normal users.  In effect, the crash
vector is removed while still allowing developers to enable it in
instrumented/debug configurations.

Security Impact
--------------------------------------------------------------------
Prior to the patch an attacker could repeatedly crash the LSM service,
preventing user logons and reconnects and leading to a local or remote
Denial-of-Service.  No memory-corruption or privilege-elevation was
observed, only service termination.

Fix Effectiveness
--------------------------------------------------------------------
Because the dangerous statement is now guarded by a feature flag that
is disabled by default, ordinary deployments can no longer reach the
DebugBreak path.  Unless the flag is manually re-enabled (e.g. in an
internal debug build) the attack surface is closed; thus the patch is
considered effective.
