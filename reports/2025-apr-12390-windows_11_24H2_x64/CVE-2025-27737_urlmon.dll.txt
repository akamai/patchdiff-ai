{'date': 1751820804.0914526, 'file': 'urlmon.dll', 'cve': 'CVE-2025-27737', 'patch_store_uid': '702a1053-a90c-437f-9cf3-1c3307072be1', 'confidence': 0.15, 'change_count': 1, 'kb': 'KB5055523'}
--------------------------------------------------------------------
CVE-2025-27737 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
urlmon.dll – WIL feature-usage cache used by Security Zone Mapping
(CSecurityManager::ProcessUrlAction ->
 wil_details_FeatureReporting_RecordUsageInCache)

Vulnerability Class
--------------------------------------------------------------------
Security-feature bypass caused by improper input validation
(CWE-20)

Detailed Root Cause Analysis
--------------------------------------------------------------------
wil_details_FeatureReporting_RecordUsageInCache() records whether a
particular FEATURE_* policy has already been evaluated inside the
current process.  The caller passes
  a2 – pointer to two 32-bit volatile words that hold the per-feature
       cache (word0 = general flags, word1 = extended flags)
  a3 – the internal “usage id” that identifies what is being cached.

For usage ids >= 320 the low 6 bits of (a3-320) are stored in word1
(bits 5-10) together with a validity bit (0x10).  A maximum of 64
values (0-63) can therefore be represented.

Before the patch the code performed the following sequence:
  if (a3 > 7)                    // ids 0-7 handled earlier
  {
      v5 = a3-320;               // range 0-??
      if ((int)a3-320 < 64)      // only true for legal range
          update bitfield;       // atomic CAS into word1
      /* irrespective of success */
      *(DWORD*)(a1+4)  = 1;      // "first-time/inserted" flag
      *(DWORD*)(a1+8)  = a3;     // returned id
      *(DWORD*)(a1+12) = 0;      // error = S_OK
      return;
  }

Because the "inserted" flag was set unconditionally, **repeated calls
with the same in-range id, as well as any out-of-range id (>=384), were
reported to the upper layers as a first-time evaluation even when the
bit was already present or could not be stored at all**.  Higher-level
code (ProcessUrlAction and ultimately security-zone checks) trusts this
flag to decide whether additional enforcement (zone elevation prompts,
policy look-ups, etc.) is necessary.  By supplying a crafted usage id
>=384 an attacker could therefore keep the cache in the perpetual
"first-time" state and bypass zone security policy that should only be
skipped once per process.

There is no memory corruption: the defect is purely logical but has
security impact because it suppresses mandatory checks.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
if ((int)a3 - 320 < 64) {
    ... update bitfield ...
}
*(DWORD*)(a1 + 4) = 1;           // always set "inserted"
return a1;

// after
if ((int)a3 - 320 >= 64)
    goto LABEL_16;               // skip bitfield update entirely
...
if (!*(DWORD*)(a1 + 16)) {       // only when bit *not* already set
LABEL_16:
    *(DWORD*)(a1 + 4) = 1;       // now conditional
    *(DWORD*)(a1 + 8) = a3;
    *(DWORD*)(a1 + 12)= 0;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-supplied URL -> CSecurityManager::ProcessUrlAction() ->
Wil::details::FeatureImpl<...>::__private_IsEnabledPreCheck() ->
wil::details::ReportUsageToServiceDirect() ->
wil_details_FeatureReporting_RecordUsageInCache()  [vulnerable]

Attack Vector
--------------------------------------------------------------------
Local, non-privileged code running in any process that hosts urlmon.dll
(such as Internet Explorer mode, Office, or any WebBrowser control)
passes a crafted UrlAction/Feature id >= 384 to the zone-mapping API.
This keeps the per-process cache in an uninitialised state and prevents
subsequent security-zone enforcement, effectively bypassing the
Windows Security Zone Mapping feature.

Patch Description
--------------------------------------------------------------------
1. Added an explicit range check: if (a3-320) >= 64 the bitfield update
   is skipped entirely, preventing out-of-range ids from accessing the
   cache word.
2. Moved the population of the return structure (offsets +4/+8/+12)
   behind a new conditional block that executes **only when** the cache
   entry did not already exist (*a1+16 == 0).  This guarantees that the
   "inserted" flag is accurate.

Security Impact
--------------------------------------------------------------------
Prior to the fix, attackers could continuously fool higher-level zone
logic into believing it was handling a first-time event, thereby
skipping additional policy checks and bypassing the Windows Security
Zone Mapping protection.  No privilege escalation is gained, but code
that should have been blocked or prompted by zone elevation could run
without restriction.

Fix Effectiveness
--------------------------------------------------------------------
The patch removes the unconditional flag assignment and validates the
acceptable range before touching the cache, fully eliminating the
logic error.  No alternate path setting *(a1+4)=1 unconditionally
remains, so the bypass is closed.  No regression or new state leakage
is observable from the diff.
