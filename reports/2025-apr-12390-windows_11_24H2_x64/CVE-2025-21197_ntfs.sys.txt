{'patch_store_uid': '3b4551f8-8bc9-41c0-91d2-3ade95d85ce9', 'change_count': 22, 'kb': 'KB5055523', 'confidence': 0.24, 'cve': 'CVE-2025-21197', 'file': 'ntfs.sys', 'date': 1751822672.8602984}
--------------------------------------------------------------------
CVE-2025-21197 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
ntfs.sys – directory-change notification and traverse access helpers
(NtfsNotifyChangeDirectory, NtfsNotify[Access|Traverse]Check)

Vulnerability Class
--------------------------------------------------------------------
Improper Access Control / Information Disclosure (CWE-284)

Detailed Root Cause Analysis
--------------------------------------------------------------------
When an application issues IRP_MN_NOTIFY_CHANGE_DIRECTORY with the
WatchTree flag set, NTFS walks the SCB chain of the watched directory
and every sub-directory.  In the vulnerable build the helper
NtfsNotifyTraverseCheck performed a SeAccessCheck with a hard-coded
DesiredAccess value of FILE_TRAVERSE (0x20) for every element:

    SeAccessCheck( … , DesiredAccess = 0x20 , … );

FILE_LIST_DIRECTORY (0x0001) – the right that actually gate-keeps the
ability to enumerate names in a directory – was never validated.
Consequently a caller that could open any directory handle with only
traverse permissions could register a recursive change notification
and later receive the absolute file name of every object that changed
under that tree, even inside directories where LIST_DIRECTORY had been
explicitly denied.  The disclosed path information is passed back to
user-mode via ReadDirectoryChangesW / FindFirstChangeNotification, thus
constituting an information-disclosure issue.

The new code introduces a dedicated routine, NtfsNotifyAccessCheck,
called by the updated NtfsNotifyTraverseCheck (and selected from
NtfsNotifyChangeDirectory).  The function keeps the original desired
mask for the first element of the walk, but – if the hardening switch
byte_1C009AC9E is enabled – it clears bit 0 (LIST_DIRECTORY) for all
following elements:

    if (!FirstIteration)
        DesiredAccess &= ~FILE_LIST_DIRECTORY;

Therefore the root directory being watched must now pass
FILE_LIST_DIRECTORY, while lower components still require only
FILE_TRAVERSE, exactly matching expected Windows semantics.  Additional
changes in NtfsNotifyChangeDirectory capture the correct SUBJECT_CONTEXT
for impersonating threads, choose between the hardened and legacy
callbacks, and fall back to the strengthened path when the caller is
not an administrator.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Old (vulnerable) NtfsNotifyTraverseCheck
v12 = SeAccessCheck( SecurityDescriptor,
                     SubjectCtx,
                     1,            // TokenIsImpersonation
                     0x20u,        // FILE_TRAVERSE only!
                     …);
```

```c
// New NtfsNotifyAccessCheck – first loop keeps LIST_DIRECTORY,
// subsequent loops strip it so the root dir must be listable.
if (!v16)                    // first element ?
{
    v16 = 1;
    if (byte_1C009AC9E)      // hardening flag
    {
        DesiredAccess &= ~1u; // drop FILE_LIST_DIRECTORY for rest
        if (!DesiredAccess)
            break;           // no remaining bits – exit
    }
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User opens directory handle with FILE_TRAVERSE only.
2. Calls ReadDirectoryChangesW with WatchSubTree = TRUE.
3. NtfsNotifyChangeDirectory selects NtfsNotifyTraverseCheck.
4. NtfsNotifyTraverseCheck walks SCB chain and, before the patch,
   allows the request because each SeAccessCheck asks only for 0x20.
5. When a file later changes beneath an un-listable folder the filter
   manager surfaces the full relative path to the attacker.

Attack Vector
--------------------------------------------------------------------
A local, authenticated attacker opens a directory somewhere inside a
protected folder tree with FILE_TRAVERSE, sets up a recursive change
notification, and receives names of files in ancestor/peer folders that
he is not allowed to LIST.  No elevated privileges are required – only
standard traverse rights that are typically granted.

Patch Description
--------------------------------------------------------------------
• Introduced NtfsNotifyAccessCheck that performs per-component security
  descriptor resolution and SeAccessCheck with a variable DesiredAccess.
• First component must satisfy caller-supplied mask (includes
  LIST_DIRECTORY); later components are verified for TRAVERSE only.
• NtfsNotifyTraverseCheck was reduced to a thin wrapper that calls the
  new helper with DesiredAccess = FILE_TRAVERSE.
• NtfsNotifyChangeDirectory now chooses between hardened and legacy
  callbacks, captures/locks SUBJECT_CONTEXT correctly, and enforces the
  new access policy for non-administrative callers.
• Defensive flags (byte_1C009AC9E and *_IsEnabledDeviceUsageNoInline)
  allow the fix to be toggled at run-time.

Security Impact
--------------------------------------------------------------------
Before the fix, an attacker could harvest file and directory names
outside his LIST_DIRECTORY scope, resulting in information disclosure
within the NTFS namespace.  After the patch the SeAccessCheck on the
root directory blocks the request unless the caller actually holds
LIST_DIRECTORY on that object, closing the leak.

Fix Effectiveness
--------------------------------------------------------------------
The added first-component LIST_DIRECTORY check is executed for every
recursive notification request made by non-admins; failure aborts the
loop and NtfsNotifyChangeDirectory returns STATUS_ACCESS_DENIED.
Because the decision is made before the IRP is queued, no callbacks are
armed and no path information is ever disclosed.  The patch therefore
fully addresses the observed weakness; no bypass is apparent in the
modified control flow.
