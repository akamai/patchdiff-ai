{'confidence': 0.13, 'kb': 'KB5055523', 'file': 'ntoskrnl.exe', 'change_count': 111, 'patch_store_uid': '998f4703-7363-48af-b1e4-3bf03bc6fbf9', 'date': 1751828893.8082724, 'cve': 'CVE-2025-26648'}
--------------------------------------------------------------------
CVE-2025-26648 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows NT kernel (ntoskrnl.exe) – WOW64 thread-context helpers
PspWow64GetContextThread / PspWow64SetContextThread

Vulnerability Class
--------------------------------------------------------------------
Use-after-free / race condition (CWE-416) leading to improperly
locked sensitive data (CWE-591)

Detailed Root Cause Analysis
--------------------------------------------------------------------
NtGetContextThread / NtSetContextThread eventually call the internal
helpers PspWow64GetContextThread() or PspWow64SetContextThread() when
the target thread belongs to a 32-bit (x86) WOW64 process.

Prior to the patch these helpers processed a caller-supplied
PETHREAD ("Thread" argument) without first stopping the target
thread when it was not the current thread.  The code:
   1. validated the requested CONTEXT flags,
   2. called PspGetContextThreadInternal() or
      PspSetContextThreadInternal(),
   3. copied the register image to / from user memory with
      RtlCopyContext(),
   4. touched per-thread CPU-area buffers in the process object.

Because the thread kept running in parallel the following windows
existed:
   • The thread could exit, causing the KTHREAD / ETHREAD object to
     be freed and re-used while the helper still held its pointer.
   • Concurrent state changes could make the collected context
     inconsistent, leaking kernel data or writing stale values back
     into a re-allocated object.

Any subsequent access (e.g. RtlCopyContext, CPU-area I/O) therefore
operated on freed or re-purposed memory – a classic use-after-free
that allowed a local attacker with THREAD_GET/SET_CONTEXT rights to
corrupt kernel memory and elevate privileges.

Affected parameters / structures
   Thread   – caller-supplied ETHREAD pointer
   v57/ v59 – on-stack EXTENDED_CONTEXT buffers that are filled from
              freed memory regions
   ETHREAD.KernelApcDisable field – temporarily decremented without
              holding a reference, enabling premature rundown
   Per-process CPU-area (Process+0x418) – could be written with
              attacker-controlled data while unlocked

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// BEFORE – no suspension of remote thread
result = PspGetContextThreadInternal(Thread, ctx, 0, TRUE, 1);
... RtlCopyContext(localBuf, Flags, &wow64Ctx);   // may use freed ptr

// AFTER – thread is frozen first
if (Thread != KeGetCurrentThread()) {
    --KeGetCurrentThread()->KernelApcDisable;
    status = PsSuspendThread(Thread, NULL);       // guarantees liveness
    suspended = TRUE;
}
...
if (suspended) {
    PsMultiResumeThread(Thread, NULL, 1);
    KeLeaveCriticalRegion();
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-mode → NtSetContextThread / NtGetContextThread →
  PspWow64SetContextThread / PspWow64GetContextThread
   └─ uses Thread pointer without suspend
       ├─ thread terminates / reuses memory
       └─ helper continues, touching freed memory ⇒ kernel UAF

Attack Vector
--------------------------------------------------------------------
A local, low-privileged process opens a handle to a WOW64 thread it
owns (or can get a handle to) with THREAD_GET_CONTEXT /
THREAD_SET_CONTEXT rights.  While repeatedly calling
NtGet/SetContextThread it concurrently terminates or rapidly changes
the target thread, exploiting the race to trigger use-after-free and
achieve arbitrary kernel memory read/write, thus elevating to SYSTEM.

Patch Description
--------------------------------------------------------------------
1. Detects remote-thread case:  `if (Thread != KeGetCurrentThread())`.
2. Enters a critical region and calls PsSuspendThread() to hard-stop
   the target thread, recording a flag.
3. All early-exit paths now unwind by resuming the thread with
   PsMultiResumeThread() and leaving the critical region.
4. Type clean-ups and additional parameter validation were added but
   are incidental to the fix.

Security Impact
--------------------------------------------------------------------
Without the suspension the helpers could dereference an already-
freed ETHREAD/KTHREAD object, allowing privileged memory corruption
and leakage.  A successful exploit yields kernel-mode execution and
a full local privilege escalation.

Fix Effectiveness
--------------------------------------------------------------------
Suspending the target thread guarantees its object remains allocated
and its context stable for the entire operation, closing the race
window and eliminating the UAF condition.  The symmetric resume in
all exit paths prevents new hangs or leaks.  No further writable
paths to freed memory remain, making the fix comprehensive.
