{'cve': 'CVE-2025-26639', 'file': 'usbprint.sys', 'confidence': 0.35, 'change_count': 2, 'patch_store_uid': '20078406-f882-4478-9f41-a50957ff9ae2', 'date': 1751820782.3051956, 'kb': 'KB5055523'}
--------------------------------------------------------------------
CVE-2025-26639 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
usbprint.sys – USBPRINT_ProcessIOCTL() handler for the Microsoft
Windows USB Print class driver (USBPRINT).  Affected IOCTL is
IOCTL_USBPRINT_SET_DEVICE_ID (0x220058).

Vulnerability Class
--------------------------------------------------------------------
CWE-190: Integer overflow / wraparound leading to
CWE-122: Heap-based buffer overflow.

Detailed Root Cause Analysis
--------------------------------------------------------------------
At case 0x220058 (SET_DEVICE_ID) the driver receives a caller-supplied
buffer that contains a printer IEEE-1284 device-ID string.  The input
size is taken from
    CurrentStackLocation->Parameters.Create.Options
into a 32-bit variable named ‘Size’.

before patch
  Size + 1 is compared against 0x400 and, if the test passes, the code
  allocates Size+1 bytes with ExAllocatePool2().  The same untrusted
  Size is then used as the third parameter of memmove() when copying
  from the user buffer into the freshly allocated kernel pool buffer.

Because the addition is performed on a 32-bit value, a malicious Size
such as 0xFFFF_FFFF causes the expression (Size + 1) to wrap to 0,
pass the length test, and allocate only one byte.  memmove() is then
invoked with the original 0xFFFF_FFFF length, overflowing the pool
buffer and corrupting adjacent heap metadata / objects.  The attacker
controls both the overflow size and the overflow data (the input
buffer itself), enabling reliable pool manipulation and potential
execution of arbitrary code in kernel mode.

Patched behaviour
  • The length variable is widened to size_t (64-bit) eliminating the
    wraparound.
  • New bounds checks were added:
        if (FeatureFlag)  len < 0x400
        else              (len + 1) <= 0x400
    Both comparisons operate on 64-bit values, so the overflow path is
    blocked.
  • Failure paths return STATUS_INVALID_PARAMETER and skip the copy.

Affected structures / parameters
  – IOCTL code: 0x220058
  – INPUT: caller buffer (user-controlled)
  – VARIABLE: unsigned long Size (overflowed)
  – DESTINATION: heap buffer from ExAllocatePool2()

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
Size = CurrentStackLocation->Parameters.Create.Options;
if ( Size + 1 <= 0x400 ) {
    buf = ExAllocatePool2(PagedPool, Size + 1, TAG);
    if (buf) {
        memmove(buf, MasterIrp, Size);   // heap overflow
    }
}

// after (excerpt)
len = CurrentStackLocation->Parameters.Create.Options;
if ( FeatureFlag ) {
    if (len >= 0x400) goto fail;
} else if ( (size_t)(len + 1) > 0x400 ) {
    goto fail;
}
buf = ExAllocatePool2(PagedPool, (unsigned int)(len + 1), TAG);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User opens a handle to the USB printer device (\\.\USBPRINT...).
2. DeviceIoControl(h, 0x220058, InBuf, 0xFFFF_FFFF, …).
3. USBPRINT_ProcessIOCTL() → case 0x220058.
4. Size = 0xFFFF_FFFF; Size+1 wraps to 0 → passes check.
5. ExAllocatePool2() returns 1-byte buffer.
6. memmove(buf, InBuf, 0xFFFF_FFFF) overruns kernel heap.
7. Crafted data overwrites pool headers / objects → privilege
   escalation.

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker sending crafted IOCTL_USBPRINT_SET_DEVICE
_ID requests to the USB printer device interface.  No special
privileges are required beyond the ability to open the device (default
permissions grant this to standard users when a USB printer is
installed).

Patch Description
--------------------------------------------------------------------
• Replaced 32-bit length variable with size_t (64-bit).
• Added explicit upper-bound checks that run on 64-bit arithmetic,
  preventing wraparound.
• Early exit with STATUS_INVALID_PARAMETER when the buffer size is too
  large.
• No functional changes to the copy logic once parameters are valid.

Security Impact
--------------------------------------------------------------------
Before the patch any local user could trigger a controlled heap buffer
overflow in kernel mode, allowing execution of arbitrary code with
SYSTEM privileges or causing a denial-of-service (crash).

Fix Effectiveness
--------------------------------------------------------------------
The updated bounds checks eliminate the integer overflow condition and
therefore guarantee that the destination buffer is at least as large
as the number of bytes copied.  No alternative code paths leading to
an unchecked memmove() remain in this IOCTL handler, so the fix fully
mitigates the identified vulnerability.
