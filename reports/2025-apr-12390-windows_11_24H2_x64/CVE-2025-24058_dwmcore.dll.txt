{'confidence': 0.24, 'cve': 'CVE-2025-24058', 'file': 'dwmcore.dll', 'change_count': 45, 'date': 1751808443.8443031, 'kb': 'KB5055523', 'patch_store_uid': 'c22bb7ef-b7b4-46df-ab3e-d621aaee2fe5'}
--------------------------------------------------------------------
CVE-2025-24058 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Desktop Window Manager (dwmcore.dll) – overlay-processing /
occlusion engine used while building the per-frame composition scene
(DWM overlay / MPO path).

Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow arising from improper input validation of
caller-supplied list lengths (CWE-20, leads to CWE-122).

Detailed Root Cause Analysis
--------------------------------------------------------------------
The routine that generates the list of Multi-Plane Overlay (MPO)
candidates was implemented in two cooperating helpers:
  • CLegacyRenderTarget::CollectOverlayCandidates
  • COverlayContext::ComputeOverlayConfiguration

Both functions accepted a caller-controlled span of
COverlayContext* elements (coming from the client-side
DirectComposition channel).  Before the patch the code manually
expanded several internal raw buffers (see variables Src / lpMem /
v134 etc.) and moved elements with hand-rolled pointer arithmetic: 
    v42 = (__int64)&v31[-v32] >> 3;
    v43 = v42 - v34;            // number of elements to move
    memmove_0((void *)(v49 - v19), v2, v47);  // no final bounds check

The index arithmetic (v42,v43,v47…) was only partially range-checked
and still allowed the situation where
      • the computed element count became larger than the currently
        reserved buffer, or
      • multiplication “8 * count” silently wrapped.

Because the destination pointer was already advanced, the subsequent
memmove_0 wrote past the end of the small stack-based fallback buffer
(Src[128]) or the first heap buffer, thereby corrupting heap metadata
inside dwmcore’s default process heap.

The span length originates from the client RPC stream and is therefore
fully attacker-controlled from a low-integrity context.  A malicious
value triggers the out-of-bounds copy inside dwm.exe, which runs as
SESSION-1\LOCAL SYSTEM, yielding an elevation of privilege.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before – manual vector growth and unchecked memmove
if (v81 > 1) {
    v117[1] = v80;                  // element count (attacker-controlled)
    v19 = 8 * v80 - 8 * v32 - 8;    // byte count may wrap
    v91 = std::_Get_unwrapped_n(..., -(v19>>3));
    memmove_0((void*)(v91 - v19), &v33[8*v32], v19); // OOB write
}
```
```c
// after – entire algorithm replaced by safe helpers
CDesktopTree::CalcOcclusionAndCollectOverlayCandidates(v2);
return (CLegacyRenderTarget *)((char *)this + 56);
```
The patched version removes all manual buffer juggling and delegates
to a rewritten helper that uses std::vector-like containers with
implicit capacity checks.

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Low-privileged app sends crafted DirectComposition commands.
2. DWM marshals them into a span<COverlayContext*> with a maliciously
   large element count.
3. dwmcore!CLegacyRenderTarget::CollectOverlayCandidates is executed
   while preparing the next frame.
4. The function calls ComputeOverlayConfiguration.
5. Faulty memmove_0 overruns Src/heap buffer –> heap corruption –>
   controlled EIP or code-execution in dwm.exe.

Attack Vector
--------------------------------------------------------------------
Local – any sandboxed or low-integrity process that can create a
composition visual tree (e.g. via DirectComposition, UWP XAML, WinUI)
can supply the malicious span length without needing administrator
rights.

Patch Description
--------------------------------------------------------------------
Microsoft replaced the entire overlay-selection pipeline with a safer
implementation:
  • All ad-hoc raw-array manipulations were removed.
  • New helper CDesktopTree::CalcOcclusionAndCollectOverlayCandidates
    performs the work using well-bounded std::vector-style buffers.
  • Feature flag 2578215227 is checked in several call sites to gate
    the new logic and avoid legacy paths.
  • Unused code paths (e.g. GetDirtyRegion copy logic) were shortened
    to a single safe call.

Security Impact
--------------------------------------------------------------------
Prior to the patch a non-admin local attacker could reliably corrupt
heap memory inside the high-privilege dwm.exe process, leading to
arbitrary code execution as Local SYSTEM and full elevation of
privilege.  At minimum it allowed a denial-of-service (dwm crash/
logoff).

Fix Effectiveness
--------------------------------------------------------------------
The vulnerable manual buffer handling code paths were completely
removed; new paths rely on standard containers and perform strict
capacity checks.  No residual uncontrolled copies remain in the
rewritten helpers, making the fix effective for the originally
reachable attack surface.
