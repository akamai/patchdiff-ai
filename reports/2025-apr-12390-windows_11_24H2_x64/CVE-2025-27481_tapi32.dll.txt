{'patch_store_uid': '90436596-eb99-49e6-8c1a-18ccfac19b5e', 'date': 1751828793.4484754, 'kb': 'KB5055523', 'file': 'tapi32.dll', 'change_count': 9, 'confidence': 0.29, 'cve': 'CVE-2025-27481'}
--------------------------------------------------------------------
CVE-2025-27481 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Telephony API (tapi32.dll) – functions processing variable
length provider, country, device-status and address-status lists as
well as the asynchronous event dispatcher (AsyncEventsThread).

Vulnerability Class
--------------------------------------------------------------------
Integer overflow / out-of-bounds write resulting in a stack-based
buffer overflow (CWE-190 + CWE-121).

Detailed Root Cause Analysis
--------------------------------------------------------------------
Four public ANSI helper routines (lineGetProviderListA,
lineGetCountryA, lineGetLineDevStatusA, lineGetAddressStatusA) and the
internal AsyncEventsThread iterate over caller-supplied variable length
records that are embedded in the same buffer which is returned to the
caller.

Each structure contains:
  DWORD dwTotalSize          // overall buffer size
  DWORD dwNeededSize         // required size if too small
  DWORD dwUsedSize           // bytes used
  DWORD dwXXXXOffset         // offset to first list entry
  DWORD dwNumXXXX            // number of list elements

Before the patch the code trusted dwXXXXOffset and dwNumXXXX.  It
calculated the start pointer as

  base = (char*)&Struct->dwNeededSize + dwXXXXOffset;
  ptr  = base;
  for(i=0; i<dwNumXXXX; ++i) { ... ptr += ElemSize; }

No check ensured that
    dwXXXXOffset < dwTotalSize   AND
    dwNumXXXX * ElemSize + dwXXXXOffset <= dwTotalSize   AND
    the multiplication does not wrap a 32-bit integer.

If an attacker sets dwNumXXXX to a large value, the 32-bit multiplication
( e.g. 12 * dwNumProviders ) can overflow, producing a small positive
result.  The loop then writes past the end of the supplied buffer when
WideStringToNotSoWideString converts in-place Wide-char strings to
single-byte strings.  Because the pointer is derived from the caller’s
buffer, the overwrite can land on the thread stack (classic CWE-121) or
on adjacent heap allocations, allowing controlled memory corruption and
code execution.

AsyncEventsThread contained a similar flaw when it resized its event
buffer:  size = dwServerSuggested + 188.  No overflow check was present
so a huge server value resulted in allocation of a tiny buffer followed
by out-of-bounds writes while the thread parsed variable length events.

Impacted parameters/structures
  • LINEPROVIDERLIST: dwProviderListOffset / dwNumProviders
  • LINECOUNTRYLIST : dwCountryListOffset  / dwNumCountries
  • LINEDEVSTATUS   : dwAppInfoOffset      / dwNumOpens
  • LINEADDRESSSTATUS: dwForwardOffset     / dwForwardNumEntries
  • Async event buffer length returned by the telephony service

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// lineGetProviderListA – before
v5 = (char *)&lpProviderList->dwNeededSize + lpProviderList->dwProvider
     ListOffset;                 // unchecked
for(v3=0; v3<lpProviderList->dwNumProviders; ++v3) {
    WideStringToNotSoWideString(lpProviderList, v5);
    v5 += 12;                    // 12-byte element
}
```
```c
// lineGetProviderListA – after (excerpt)
v7 = 12ULL * lpProviderList->dwNumProviders;
if ( v7 > 0xFFFFFFFF ||
     (DWORD)v7 + dwProviderListOffset < dwProviderListOffset ||
     (DWORD)(v7 + dwProviderListOffset) > lpProviderList->dwTotalSize )
{
    TRACELogPrint(..., "Invalid offset or number of entries");
    return LINEERR_STRUCTURETOOSMALL; // 0x80000005
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User / remote service supplies a malformed telephony structure or event
buffer ➔ Windows TAPI client library (tapi32.dll) receives it ➔ any of
the vulnerable functions is invoked ➔ unchecked arithmetic computes a
pointer outside of caller-owned memory ➔ WideStringToNotSoWideString
writes past bounds ➔ stack/heap corruption ➔ attacker achieves code
execution in the context of the process using TAPI (often the
Telephony service running as NT AUTHORITY\LocalService or higher).

Attack Vector
--------------------------------------------------------------------
Unknown – the diff shows only local API misuse.  The CVE advisory
states that the issue can be triggered remotely through Windows
Telephony Service traffic, implying that a malicious network peer can
cause a vulnerable process to parse attacker-controlled structures.

Patch Description
--------------------------------------------------------------------
For each vulnerable routine Microsoft inserted gated validation code
(behind Feature_1714175289__private_IsEnabledDeviceUsageNoInline):
  1. Compute   bytes = elemCount * elemSize   in 64-bit.
  2. Reject if bytes > 0xFFFFFFFF (truncation)  OR
              bytes + offset < offset         (wrap) OR
              bytes + offset > dwTotalSize    (overflow beyond buf).
  3. On failure log and return LINEERR_STRUCTURETOOSMALL
     (-2147483595 / 0x80000005).

AsyncEventsThread additionally replaces   newSize = old + 0xBC
with an overflow-safe  ULongAdd()  and repeats the offset/size checks
before copying variable length data.

Security Impact
--------------------------------------------------------------------
Prior to the patch an attacker could reliably overflow stack or heap
buffers inside a privileged Telephony process, leading to denial of
service or arbitrary native code execution (Remote Code Execution as
per CVE-2025-27481).

Fix Effectiveness
--------------------------------------------------------------------
The added 64-bit arithmetic and explicit range checks eliminate both the
multiplication wraparound and the overrun past dwTotalSize, closing the
primitive that enabled the overflow.  Early bail-out with a documented
error code prevents further processing of malicious buffers.  No new
memory writes occur without successful validation, making the patch
fully effective for the covered code paths.
