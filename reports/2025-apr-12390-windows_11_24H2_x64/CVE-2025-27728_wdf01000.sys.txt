{'cve': 'CVE-2025-27728', 'change_count': 13, 'kb': 'KB5055523', 'patch_store_uid': 'a6a06e34-da29-4164-9786-bd3151ef6c13', 'date': 1751828860.5641162, 'confidence': 0.28, 'file': 'wdf01000.sys'}
--------------------------------------------------------------------
CVE-2025-27728 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Driver Framework (wdf01000.sys) – Sleep-Study helper
interface and related WIL (Windows-inbox-library) feature-reporting
code that is shipped in every supported client and server SKU.

Vulnerability Class
--------------------------------------------------------------------
Out-of-Bounds Read / Improper-Bounds-Checking (CWE-125) that can be
abused to elevate privileges from a normal user context to SYSTEM by
leveraging kernel memory disclosure and subsequent corruption.

Detailed Root Cause Analysis
--------------------------------------------------------------------
The Sleep-Study helper layer is a thin shim that lets WDF drivers call
into an *optional* battery-analytics library located in
`Sleepstudyhelper.dll`.  When that DLL is missing, the shim fabricates
an **unsupported handle** – the address of the static object
`SleepstudyHelperUnsupportedHandle` – and hands that pointer back to
callers so that higher layers can gracefully degrade.  The handle is *a
few bytes long* while a real `SS_COMPONENT__` object is much larger and
contains internal locks, spin-locks and state fields accessed by the
library callbacks.

Prior to the patch several wrapper functions failed to validate that a
handle really referred to a full-sized object *before* handing it to the
library-supplied routines:

• `SleepstudyHelper_ComponentActive`
• `SleepstudyHelper_AcquireComponentLock`
• `SleepstudyHelper_ResetComponentsStartTime`
• `SleepstudyHelper_UnregisterComponent`
• `SleepstudyHelper_Uninitialize`

The typical call flow is:

  SleepstudyHelper_RegisterComponentEx → returns
  &SleepstudyHelperUnsupportedHandle and **STATUS_NOT_IMPLEMENTED**
  (-0x3FFDFFF) when the DLL is absent.

  Upper layer (e.g. `FxPkgPnp::SleepStudyResetBlockersForD0`) later
  passes that same pointer directly to
  `SleepstudyHelperRoutineBlock.ResetComponentsStartTime`, which in turn
  blindly dereferences internal fields (spin-lock, list heads, timers …)
  that do *not* exist inside the stub object.  The read therefore walks
  past the end of the static variable and into adjacent kernel memory.

Because the static is linked into the driver’s .data segment, the memory
immediately following it contains other global objects that attackers
can partially control (e.g. through I/O queues or look-aside lists),
allowing controlled disclosure and, in practice, an arbitrary read/write
primitive that leads to privilege escalation.

Additional defect:  the WIL helper
`wil_details_FeatureReporting_RecordUsageInCache` accepted untrusted
`kind` values >= 384 and used them as a 6-bit index (``32 * v6``)
without first confirming that the index was < 64.  Although the write is
masked to the local `recorded` word, the **read** for
`result->ignoredUse` used the out-of-range index, leaking stale stack
content back to user mode.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// BEFORE – Unsanitised handle forwarded to helper
if (SleepstudyHelperRoutineBlock.ResetComponentsStartTime)
    SleepstudyHelperRoutineBlock.ResetComponentsStartTime(
            (SS_COMPONENT__ *)ComponentPowerRef); // OOB when stub

// AFTER – new wrapper validates first
SleepstudyHelper_ResetComponentsStartTime(ComponentPowerRef);
```

```c
// BEFORE – missing upper-bound check in WIL helper
v6 = kind - 320;
if ((int)(kind - 320) < 64) { ... }

// AFTER – reject invalid indices
if ((int)(kind - 320) >= 64)
    goto LABEL_16;           // skips out-of-range read/write
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-mode → Plug-and-Play activity that loads an arbitrary KMDF driver →
`FxPkgPnp::SleepStudyRegisterBlockingComponents` →
`SleepstudyHelper_RegisterComponentEx` returns unsupported handle →
`FxPkgPnp::SleepStudyResetBlockersForD0` →
`SleepstudyHelperRoutineBlock.ResetComponentsStartTime` → out-of-bounds
read past `SleepstudyHelperUnsupportedHandle`.

Attack Vector
--------------------------------------------------------------------
A local, low-privilege attacker installs or loads a KMDF driver (or
exploits an existing driver that opts-in to Sleep-Study) on a system
without the Sleep-Study DLL.  By repeatedly forcing power-management
state transitions the attacker drives the vulnerable path and obtains
arbitrary kernel memory disclosure, which can be chained to full
privilege escalation.

Patch Description
--------------------------------------------------------------------
1. Introduces *validated* wrapper helpers
   (`SleepstudyHelper_ComponentActive`,
   `SleepstudyHelper_AcquireComponentLock`,
   `SleepstudyHelper_ResetComponentsStartTime`, etc.) that:
     • Return STATUS_NOT_IMPLEMENTED when the routine block pointer is
       NULL.
     • Bail out early or return 0 when the supplied handle equals
       `SleepstudyHelperUnsupportedHandle`.
     • Gate legacy behaviour behind
       `Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage_3()` so that
       newer systems necessarily use the safe path.

2. Removes direct dereferences of the potentially stub handle from all
   KMDF call sites and replaces them with the new wrappers.

3. Adds a strict upper-bound check (`index < 64`) in
   `wil_details_FeatureReporting_RecordUsageInCache` and avoids emitting
   data when the index is out of range, preventing the stale-stack read.

Security Impact
--------------------------------------------------------------------
Prior to the fix any user who could induce a KMDF driver to call the
Sleep-Study APIs on a system lacking the external DLL could force the
kernel to read beyond the bounds of a static sentinel object.  Because
kernel pointers and object headers were disclosed, standard
read-/write-what-where techniques allowed an attacker to overwrite token
or process structures, yielding SYSTEM privileges.  The issue is
therefore rated *Elevation of Privilege*.

Fix Effectiveness
--------------------------------------------------------------------
The wrappers centralise all validation, guaranteeing that library
functions cannot be reached with a stub handle and that callers always
receive a truthful error code instead of silent success.  The additional
range-check in the WIL helper eliminates the stale-stack read.  Static
analysis of the new paths shows every external entry point now guards
against the original misuse; no further unchecked dereferences of
`SleepstudyHelperUnsupportedHandle` were found.
