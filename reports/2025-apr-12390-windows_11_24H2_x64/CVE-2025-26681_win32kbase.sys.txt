{'date': 1751822645.238318, 'cve': 'CVE-2025-26681', 'change_count': 483, 'patch_store_uid': '89fe3a67-ea3b-4bdc-a937-95016fe04e59', 'confidence': 0.19, 'kb': 'KB5055523', 'file': 'win32kbase.sys'}
--------------------------------------------------------------------
CVE-2025-26681 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
win32kbase.sys – NtDCompositionSendDwmLpcMessage system call that
marshals a user supplied message (and optional handles) to the Desktop
Window Manager (DWM) through an LPC port.

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use After Free (local privilege-escalation primitive)

Detailed Root Cause Analysis
--------------------------------------------------------------------
Prior to the patch NtDCompositionSendDwmLpcMessage lacked the necessary
lifetime management for several kernel objects that are touched while
the user-mode caller, the current process, and the DWM process are all
active concurrently.  In particular:

1.  No global DWM state lock was taken.  While the routine was
    preparing the LPC packet the DWM process object (struct _KPROCESS)
    could be released by another thread, leaving a stale pointer that
    was dereferenced later in the same call path.

2.  The routine duplicated up to two caller-supplied handles directly
    into the DWM process but, if any later stage failed, the clean-up
    path closed those duplicated handles *after* the address space of
    the target process had already been detached.  This closed the
    remote handle table entry while DWM still believed the handle to be
    valid, allowing subsequent DWM activity to access a freed kernel
    object.

3.  Once the LPC call succeeded the code did not zero out the local
    copies of the duplicated handles.  If an early kernel APC aborted
    the system call after the LPC but before return-to-user, the same
    handles would be closed a second time when the thread unwound,
    triggering a double close / UAF on the referenced object.

The patch introduces three mitigations that collectively remove the
UAF window:

  • CheckOrAcquireDwmStateLock() is invoked and remembered via the
    v24 flag so that the global composition state cannot change while
    objects are in use.

  • ReferenceDwmProcess() now increments the DWM process refcount and
    UserDereferenceDwmProcess() is called on all exits, guaranteeing
    the _KPROCESS structure remains live for the entire routine.

  • After every successful ObDuplicateObject() the duplicated handle is
    stored in v25; once the LPC round-trip completes the loop at the
    end of the function overwrites each stored handle with zero so that
    later clean-up logic cannot accidentally close it again.

Because the old implementation could free the duplicated handle (or the
process object) while it was still reachable from a second thread, an
attacker running in a low-privilege user session could reliably convert
this into a local privilege escalation by arranging for the freed
kernel object to be re-allocated as a more privileged structure.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// NEW: take global lock
if ((unsigned __int8)CheckOrAcquireDwmStateLock())
    v24 = 1;
...
// NEW: explicit process reference
PROCESS = ReferenceDwmProcess(v7);
...
// NEW: scrub duplicated handles after LPC completes
for (j = 0; j < v12; ++j)
    *((_QWORD *)&v25 + j) = 0;   // prevents double close / UAF
```
(The legacy version contained none of the above safeguards.)

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker calls NtDCompositionSendDwmLpcMessage with a crafted
   0x1C- or 0x20-byte message that contains one or two kernel handles.
2. System call duplicates those handles into the DWM process.
3. Attacker forces an error path (e.g. size > 0x20 or fake feature
   code) that results in premature unwinding.
4. Routine closes the duplicated handle *after* the DWM process has
   been detached, freeing the underlying object.
5. DWM continues to use the stale handle, creating a classic UAF that
   can corrupt privileged kernel data.

Attack Vector
--------------------------------------------------------------------
Local, authenticated user.  The only prerequisite is the ability to
invoke the win32k system call interface; no special privileges are
required beyond a GUI session.

Patch Description
--------------------------------------------------------------------
• Hard upper bound on user input: Size > 0x20 now returns STATUS_INVALID
  PARAMETER.
• Global DWM state lock acquired for the entire duration.
• Reference counting added for _KPROCESS representing DWM.
• Successful handle duplications are tracked and zeroed before return
  to prevent double closes.
• Extensive error handling added to close already-duplicated handles
  *before* detaching from the target process.

Security Impact
--------------------------------------------------------------------
The bug provided a reliable kernel-mode use-after-free that could be
steered to overwrite or re-allocate freed objects with attacker-chosen
content, ultimately allowing arbitrary code execution in kernel
context.  Under default Windows desktop configurations this translates
into a full SYSTEM privilege escalation.

Fix Effectiveness
--------------------------------------------------------------------
The new implementation removes the UAF condition by enforcing proper
locking, reference counting, and handle lifetime rules, and by
sanitising user input size.  No residual paths that operate on freed
objects can be reached, and attempts to repro the old crash now return
STATUS_INVALID_PARAMETER or STATUS_ACCESS_DENIED.  The fix is therefore
assessed as complete and effective.
