{'patch_store_uid': '2f5bc9c9-74c3-4725-89da-5e1fcab60ce7', 'confidence': 0.09, 'kb': 'KB5055523', 'change_count': 1, 'cve': 'CVE-2025-21191', 'date': 1751820819.5287068, 'file': 'lsadb.dll'}
--------------------------------------------------------------------
CVE-2025-21191 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Local Security Authority (LSA) – lsadb.dll, routine
wil_details_FeatureReporting_RecordUsageInCache().  The code is part
of the WIL (Windows-Implementation-Library) feature-usage cache that
is mapped shared between user-mode callers and the privileged LSA
service.

Vulnerability Class
--------------------------------------------------------------------
Time-of-check Time-of-use (TOCTOU) race condition leading to shared
memory corruption and consequent local privilege-escalation.

Detailed Root Cause Analysis
--------------------------------------------------------------------
The cache entry that describes whether a given feature has already
been reported is a pair of dwords referenced by the caller-supplied
pointer "a2".  Bit fields in the first dword mark the feature group
( 0-7 and 320-383 ) and whether the entry is already initialised.

The vulnerable build performs the following sequence for feature
ids 0/4, 1/5 and 320-383:
 1.  Load the current cache value into a local variable (v32, v24,
     v12 …).
 2.  Derive a result that *assumes* the value has not changed.
 3.  Use InterlockedCompareExchange() to attempt to write the new
     value back.
 4.  Regardless of whether step 3 actually inserted new data or
     merely observed an unchanged value, the routine unconditionally
     initialises the caller’s output structure:
        *(_DWORD*)(a1+4) = 1;              // marks “new usage”
        *(_DWORD*)(a1+8) = a3;             // feature id
        *(_DWORD*)(a1+16)= v13|v26;        // boolean already-set

Because the decision in step 4 is based on the *pre-exchange* value
(v12/v24/​v32) a window exists between the initial read (step 1) and
the atomic exchange (step 3).  A second thread that races through the
same path can win the compare-exchange, making the first thread
re-enter the loop.  When the first thread finally succeeds it uses
stale data to decide that the bit was not previously set and returns
"new usage" even though another writer is already in place.

Upper layers trust the returned structure to append a fresh entry
into LSA’s shared feature-usage array.  Two racing writers therefore
allocate two different slots for the same feature, allowing an
attacker to:
 • exhaust the fixed-size array and collide with adjacent LSA data;
 • overwrite control structures that LSA later dereferences;
 • execute code in the LSA security context (SYSTEM).

The condition is classic TOCTOU: the code checks the value, then uses
it after a time gap in which another core may have modified it.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable – feature group 320-383 (before patch)
unsigned __int32 v12 = *((_DWORD*)a2 + 1);
*
*(_DWORD *)(a1 + 16) = (v12 & 0x10) && (((v12 >> 5) & 0x3F) == v11);
// race: v12 may already be obsolete here
v12 = _InterlockedCompareExchange(a2+1,
          v12 ^ (((unsigned short)v12 ^ (32*v11)) & 0x7E0) | 0x10,
          v12);
*
*(_DWORD *)(a1 + 12) = 0;   // unconditionally claims "new usage"
*(_DWORD *)(a1 + 8)  = a3;
*(_DWORD *)(a1 + 4)  = 1;
```

```c
// fixed – same path (after patch)
BOOL already = (v7 & 0x10) && (((v7 >> 5) & 0x3F) == v6);
*(_DWORD *)(a1 + 16) = already;
if (!already)              // only initialise on first writer
{
    *(_DWORD *)(a1 + 12) = 0;
    *(_DWORD *)(a1 + 8)  = a3;
    *(_DWORD *)(a1 + 4)  = 1;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Client code                     (any low-priv user process)
  -> WilFeature::ReportUsage()
     -> wil_details_ReportUsageToService()
        -> wil_details_FeatureReporting_RecordUsageInCache()
            1. Reads cache entry (non-atomic)
            2. Races with second caller
            3. Returns structure indicating “first usage” twice
  -> LSA service trusts structure and appends to shared array
  -> Memory adjacent to array is corrupted – attacker gains SYSTEM.

Attack Vector
--------------------------------------------------------------------
A local, authenticated attacker spawns two or more threads that call
any public WIL Reporting API with the same feature id.  By saturating
all CPU cores the attacker forces the TOCTOU window, causing LSA to
enter duplicate cache items and corrupt its own memory.  No elevated
rights are required beyond the ability to execute code on the
machine.

Patch Description
--------------------------------------------------------------------
Microsoft rewrote wil_details_FeatureReporting_RecordUsageInCache()
into an explicit switch statement and, crucially:
 • Captures the post-cmpxchg value to decide whether the bit was
   newly set.
 • Populates the output structure *only* when the bit was absent
   (`if (!already)` guard).
 • Introduces separate boolean variables (v17/v26) for clarity.
This closes the race because both competing threads cannot now return
"first usage" – only the winner of the atomic exchange will set the
auxiliary fields.

Security Impact
--------------------------------------------------------------------
Before the fix a non-admin user could race two (or more) calls into
LSA and cause persistent corruption of LSA’s shared feature-usage
buffer.  Exploiting the corruption yields arbitrary write inside the
high-privileged LSA process and results in elevation to SYSTEM.  The
issue is tracked as CVE-2025-21191 with a CVSS vector of
privilege-escalation / local.

Fix Effectiveness
--------------------------------------------------------------------
The updated routine now bases its "is-first-usage" decision on the
post-exchange state, eliminating the TOCTOU window.  Duplicate
writers only obtain the "already used" result and therefore cannot
force LSA to insert multiple entries.  No further stale-data paths
were observed in the patched function, so the fix is considered
complete for this code path.
