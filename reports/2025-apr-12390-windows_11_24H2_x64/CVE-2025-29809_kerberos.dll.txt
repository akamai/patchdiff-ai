{'kb': 'KB5055523', 'date': 1751822590.8160806, 'change_count': 18, 'cve': 'CVE-2025-29809', 'confidence': 0.22, 'patch_store_uid': 'c980df41-0f46-4d0e-a6eb-ce59ab0cb38e', 'file': 'kerberos.dll'}
--------------------------------------------------------------------
CVE-2025-29809 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Kerberos – wil_details_FeatureReporting_IncrementUsageInCache
inside kerberos.dll (now renamed to
wil_details_FeatureReporting_RecordUsageInCache).

Vulnerability Class
--------------------------------------------------------------------
Information disclosure through un-initialised data / insecure storage
(CWE-922).

Detailed Root Cause Analysis
--------------------------------------------------------------------
The original routine wil_details_FeatureReporting_IncrementUsageInCache
accepted four parameters:
    a1 -> volatile signed __int32* FeatureCacheWord
    a2 -> int FeatureIdClass (0-4)
    a3 -> 64-bit value (unused)
    a4 -> _DWORD* UsageRecord  (returned to caller)

The function only touched UsageRecord indices 0,1,2 and 4.  Index 3 was
never written.  Because the record lives in the caller’s buffer the
untouched dword contains whatever stack value happened to be present at
the call site.  When the caller propagates the structure, that stale
stack value is disclosed, breaking the expected confidentiality of
kernel-resident data.

In addition, the function performed no explicit zeroing of the output
record before populating it, so if execution followed one of several
conditional branches some of the earlier indices (1 or 2) could also be
left untouched.  The problem is purely in output initialisation – no
bounds checks or pointer validation faults were observed in the diff.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// BEFORE (leaves UsageRecord[3] untouched)
  a4[1] = 0;             // index 1 initialised
  ...                    // many branches
  a4[4] = 0;             // index 4 initialised
  *a4 = (v10 & 1) == 0;  // index 0 initialised
  return result;         // a4[3] uninitialised!!
```
```c
// AFTER (entire buffer cleared first)
  *(_OWORD *)a1       = 0i64;   // zero first 16 bytes
  *(_QWORD *)(a1+16)  = 0i64;   // zero remaining 16 bytes
  ...                 // structure now fully initialised
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Caller allocates a 5-dword WIL usage record -> passes pointer to
...IncrementUsageInCache -> function conditionally fills fields and
returns -> caller uses or returns the record -> uninitialised dword is
leaked.
Exact higher-level API path is not present in the supplied data
(unknown).

Attack Vector
--------------------------------------------------------------------
Any local component that is able to invoke the affected feature
reporting helper and later expose the resulting record to user mode can
read unintentionally disclosed stack data.  Whether direct user-mode
code can reach the helper is not shown (unknown).

Patch Description
--------------------------------------------------------------------
1. Function renamed to *_RecordUsageInCache and its prototype changed
   so that the output buffer is now the first argument.
2. The first 32 bytes of the output buffer are explicitly zeroed with
   two 64-bit stores before any field is written.
3. New switch/branch logic ensures every code path fully initialises all
   members (indices 0-4) of the record.
No other logic impacting memory safety was added.

Security Impact
--------------------------------------------------------------------
Prior to the patch kernel stack contents could be disclosed to a
privileged attacker, violating the confidentiality requirement of the
Kerberos security boundary and enabling potential bypass of security
features that rely on secrecy of kernel data.

Fix Effectiveness
--------------------------------------------------------------------
The patch deterministically clears the entire output structure before
use, eliminating any uninitialised data leak and therefore fully
mitigating the vulnerability.
