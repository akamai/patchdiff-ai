{'patch_store_uid': 'c22bb7ef-b7b4-46df-ab3e-d621aaee2fe5', 'confidence': 0.23, 'file': 'dwmcore.dll', 'kb': 'KB5055523', 'date': 1751808152.457734, 'change_count': 45, 'cve': 'CVE-2025-24060'}
--------------------------------------------------------------------
CVE-2025-24060 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Desktop Window Manager (DWM) – dwmcore.dll

Vulnerability Class
--------------------------------------------------------------------
Improper input/bounds validation leading to out-of-bounds heap write

Detailed Root Cause Analysis
--------------------------------------------------------------------
Several helper routines used while building per-frame occlusion and
overlay data manipulate variable-length arrays that are stored in
COcclusionContext / COverlayContext objects.

Before the patch COcclusionContext::PreSubgraph() and
COverlayContext::ComputeOverlayConfiguration() perform manual pointer
arithmetic when they:
  • grow internal vectors (operator new[] / HeapAlloc)
  • uninitialised-copy existing entries
  • shift memory with memmove() to insert new elements

The code assumes that the destination buffer is large enough and that
index calculations cannot wrap.  If the caller supplies a visual tree
containing more than 0x7FFF sub-objects (or triggers repeated
Insert/Erase sequences) the computed index ‘v41 = v34 + 1’ can exceed
‘v86’ (current element count).  When that happens the next memmove()
(
  memmove_0(v88, v87, v19);
) copies 8 bytes beyond the end of the allocation, corrupting the heap
metadata that follows the vector buffer.  Because these allocations
reside in a process-wide heap running with High-IL, the corruption can
be exploited by a Low-IL attacker who controls composition data to
gain code-execution in the Desktop Window Manager service
(Elevation-of-Privilege).

Key affected structures/fields
  • COverlayContext::m_overlaySlots   (dynamic array)
  • COverlayContext::m_candidateList  (dynamic array)
  • COcclusionContext – water-mark stacks used during traversal

The overflow is triggered inside
  wil::details::vector_facade<>::insert<>()   (inlined)
  memmove_0(dest,src,len)
where ‘len’ is computed from unchecked arithmetic.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before (ComputeOverlayConfiguration)
v41 = v40 + 1;
if (v40 + 1 > v86) {
    std::_Xoverflow_error("overflow");  // dead-code, never taken
}
...
memmove_0(v88, v87, v19); // v19 derived from v41 – may overflow
```

```c
// after (ComputeOverlayConfiguration) – simplified, uses gsl/span and
// detail::vector_facade::insert() with proper bounds checking
if (wil::details::FeatureImpl<...>::__private_IsEnabled(...))
    detail::vector_facade<>::insert(...); // size validated
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-mode client ↦ DwmApi::UpdateLayeredWindow ↦ compositor builds a
large visual tree ↦ CDesktopTree::CalcOcclusionAndCollectOverlayCandidates()
↦ COverlayContext::ComputeOverlayConfiguration() ↦ unchecked insert
↦ heap corruption ↦ controlled EOP.

Attack Vector
--------------------------------------------------------------------
A local, sandboxed application submits a crafted batch of composition
commands (via DComp / Dwm APIs) containing thousands of nested visuals
and repeatedly toggles occlusion state.  The malformed graph causes
vector growth beyond INT_MAX and triggers the out-of-bounds write in
the DWM service process.

Patch Description
--------------------------------------------------------------------
Microsoft removed all hand-written pointer arithmetic and replaced it
with:
  • gsl::span based helpers that validate size and terminate on error
  • detail::vector_facade::insert()/erase()/reserve_region() that grow
    buffers using liberal_expansion_policy::expand() while checking
    for multiplication overflow.
  • New helper wil_details_FeatureReporting_RecordUsageInCache() that
    records state without touching raw bits.
  • Feature flag 2578215227 added; old code paths are executed only
    when the feature is disabled, allowing safe roll-back.

Security Impact
--------------------------------------------------------------------
Before the fix a low-privileged user could write beyond heap buffers in
the high-integrity DWM core process and run arbitrary code, achieving
local elevation of privilege (EOP).

Fix Effectiveness
--------------------------------------------------------------------
The patched code no longer performs unchecked ‘index+1 > count’
operations; vector expansion is centralised and tested.  All memmove()
operations use validated lengths and throw on overflow.  Exploit paths
through COcclusionContext / COverlayContext cannot corrupt memory, so
the issue is resolved.
