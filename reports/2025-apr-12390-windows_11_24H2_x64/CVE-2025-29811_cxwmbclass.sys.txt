{'change_count': 12, 'kb': 'KB5055523', 'cve': 'CVE-2025-29811', 'confidence': 0.28, 'date': 1751822631.570258, 'patch_store_uid': 'f740a6c5-97ee-43ae-b1a3-9b36880cde5b', 'file': 'cxwmbclass.sys'}
--------------------------------------------------------------------
CVE-2025-29811 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Mobile Broadband class driver (cxwmbclass.sys),
code that parses Network Transfer Blocks (NTB) and their NTB-Data
Pointer (NDP) lists while advancing the RX packet queue.

Vulnerability Class
--------------------------------------------------------------------
Improper Input Validation leading to heap based out-of-bounds write /
buffer overflow (CWE-20, CWE-122, CWE-125).

Detailed Root Cause Analysis
--------------------------------------------------------------------
When the RX DPC (EvtRxQueueAdvance) dequeues an NTB originating from a
mobile-broadband modem it walks the embedded NDP list and converts
every entry into an internal ring-buffer descriptor via
MbbRecvNtbUnpackIpNdp16/32().

1. The helper functions MbbNtbDetectNdp16Loop() and
   MbbNtbDetectNdp32Loop() are responsible for validating the chain of
   NDP tables that exist in the NTB.  In the original implementation
   the following errors existed:

   • The supplied offset to the *next* NDP table (wNextNdpIndex /
     dwNextNdpIndex) was trusted after only two trivial checks
     (size >= 8/0x10 and offset < blockLen).  No guarantee was made
     that offset+size stayed inside the current NTB, that the offset
     did not wrap around 16-bit or 32-bit arithmetic, or that the list
     was acyclic.

   • Large or self-referencing offsets therefore steered the loop to
     attacker-controlled heap memory while the parser still believed
     it was processing a valid NDP structure.

2.  MbbRecvNtbUnpackIpNdp16/32() trusts the NDP entry index that is
    read from the corrupted structure.  That index is used in the
    expression
        ringBase + ringStride * ringWriteIndex + 64
    to write eight control bytes into the RX fragment ring.  Because
    ringWriteIndex is attacker-controlled and the ring size is only
    compared once («if (write == size) STATUS_BUFFER_OVERFLOW») the
    calculated address can fall outside the allocated ring buffer and
    overwrite adjacent kernel heap objects.

3.  EvtRxQueueAdvance() previously invoked the unpack routines even
    when the per-packet pointer to the NDP (v5[5]) was NULL, leading
    to an immediate crash that masked the latent overflow
    vulnerability.

Exploitation therefore consists of crafting an NTB whose first NDP is
valid but whose «next» field points just beyond the legitimate NTB
buffer.  The second, attacker-controlled, fake NDP then contains a
large datagram index that overflows the ring boundary and redirects
the 8-byte write to an arbitrary heap location, allowing privilege
escalation from local user to kernel.
The attacker needs the ability to inject raw MBIM/NCM traffic – this
can be achieved from user mode by operating a software-only or USB
emulated modem visible to the driver.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// MbbNtbDetectNdp16Loop – before patch
if ( (int)v7 - (int)v1 >= v3 ||            // minimal bound check
     (v9 = *((WORD*)v7 + 2), v9 < 8) ||
     v8 > 0xFFFF - v9 ||                   // may wrap
     (unsigned int)v7 + v9 - v1 > v3 )     // no loop detection
   error;                                  // <-- insufficient
...
v7 = (char*)v1 + *((WORD*)v7 + 3);         // untrusted offset
```
```c
// EvtRxQueueAdvance – before patch
v7 = *(NCM_NTH32**)(v5[2] + 8);
/* v5[5] may be NULL but is still dereferenced */
MbbRecvNtbUnpackIpNdp32((MBB_RECEIVE_NDP_CONTEXT*)v5,
                        v7,
                        (NCM_NDP32*)v5[5],   // unchecked
                        (unsigned int*)v5+12,
                        v1);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Craft malicious NTB + NDP and deliver it through a modem interface.
2. NDIS miniport queues the NTB to the WMB class driver.
3. EvtRxQueueAdvance() pops the packet and calls
   MbbNtbDetectNdpXXLoop() and MbbRecvNtbUnpackIpNdpXX().
4. Invalid «next NDP» offset escapes the NTB buffer, fake NDP is
   parsed.
5. Oversized datagram index causes ringWriteIndex to wrap; an 8-byte
   value is written past the RX fragment ring into arbitrary heap
   memory.
6. Memory corruption enables local privilege escalation or crashes the
   kernel.

Attack Vector
--------------------------------------------------------------------
A local attacker that can present a crafted MBIM/NCM device (physical
USB gadget, virtual USB controller, or user-mode driver simulation)
feeds malicious NTBs to cxwmbclass.sys.  No elevated privileges are
required; the vulnerable driver runs in the kernel context and trusts
all data received from the device.

Patch Description
--------------------------------------------------------------------
The update introduces a compile-time feature flag
Feature_GE_MBIM_FUZZING_BUGFIXES__private_IsEnabledDeviceUsageNoInline()
that gates hardened code paths.

Key changes:
1.  MbbNtbDetectNdp16Loop / 32Loop
    • Added size-cap (<=0xFFF3 / 0xFFFFFFE7) and "offset+header <=
      blockLength" checks.
    • Detect wrap-around, self-references and duplicate traversal.
    • On failure returns STATUS_INVALID_BUFFER_SIZE.

2.  MbbRecvNtbUnpackIpNdp16 / 32
    • Verifies that the current entry index < total entry count before
      dereferencing.
    • Updates both ring write indices only once after finishing the
      loop, preventing mis-synchronisation.

3.  EvtRxQueueAdvance
    • Rejects packets whose NDP pointer is NULL before calling unpack
      functions and logs an error instead.

4.  All modified paths use the same new validation helper and share
    common error reporting that keeps the queue consistent.

Security Impact
--------------------------------------------------------------------
The additional validations stop attacker-controlled offsets from
escaping the NTB buffer and prevent ring-index wrap-arounds.
Consequently, the attacker can no longer obtain an out-of-bounds write
primitive, closing the privilege-escalation vector.

Fix Effectiveness
--------------------------------------------------------------------
Manual inspection of the patched code shows that every arithmetic
operation involving an untrusted offset or size is now preceded by
bounds checks that rule out integer wrap, buffer overlap, and list
loops.  NULL NDP pointers are rejected early.  No unchecked path from
external data to ringWriteIndex remains, indicating the fix is
comprehensive.

