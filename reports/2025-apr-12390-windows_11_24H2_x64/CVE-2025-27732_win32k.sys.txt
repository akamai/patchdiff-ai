{'cve': 'CVE-2025-27732', 'date': 1751820811.4227707, 'file': 'win32k.sys', 'patch_store_uid': '34643bdb-cbc3-45a0-8cba-802f308509af', 'change_count': 2, 'kb': 'KB5055523', 'confidence': 0.62}
--------------------------------------------------------------------
CVE-2025-27732 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
win32k.sys (Windows Graphics/Window Manager kernel driver)
Function: Win32kAsyncProcessFreezeThawSupportIsActive

Vulnerability Class
--------------------------------------------------------------------
CWE-591: Sensitive Data Storage in Improperly Locked Memory

Detailed Root Cause Analysis
--------------------------------------------------------------------
The helper routine Win32kAsyncProcessFreezeThawSupportIsActive is used
by higher-level win32k code (parent symbol: Win32kGetSupportedExports
Version) to decide whether asynchronous Freeze/Thaw processing support
is enabled for the current device/feature set.  

In the vulnerable build the routine was a stub that simply returned the
constant 0 (false) and was typed as returning a single signed char.  As
a result, all callers believed that async Freeze/Thaw support was never
active, even on devices where the feature should have been enabled.

Down-stream code therefore followed the legacy (synchronous) execution
path.  That path allocates and stores per-process state information
(including window station handles and related security tokens) but does
*not* lock or zero this memory once processing completes.  Because the
memory is only reference-counted and not secured with MmSecureVirtual
Memory or PeLockPages, it can be re-mapped into user mode after the
kernel pointer has been freed, allowing an unprivileged local user to
retrieve the stale data and leverage it for privilege escalation.

In short, the root cause is an always-false feature gate that disabled
the secure code path, causing sensitive kernel data to persist in
unlocked pageable memory.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
char Win32kAsyncProcessFreezeThawSupportIsActive()
{
  return 0;           // feature permanently disabled
}

// after
bool Win32kAsyncProcessFreezeThawSupportIsActive()
{
  return Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage() != 0;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User process --> win32k!NtUserxXXX (freeze/thaw API)
               --> Win32kGetSupportedExportsVersion
               --> Win32kAsyncProcessFreezeThawSupportIsActive
               --> returns 0 (vulnerable build)
               --> legacy path alloc / free without memory lock
               --> freed pages can be re-mapped by attacker

Attack Vector
--------------------------------------------------------------------
Local, post-authentication.  An attacker repeatedly triggers the
Freeze/Thaw path, then re-maps the freed memory into its own address
space to harvest residual kernel data and craft a privilege-escalation
payload.

Patch Description
--------------------------------------------------------------------
1. Changed return type from char to bool to match logical semantics.  
2. Replaced constant 0 with a runtime evaluation of
   Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage().  This enables
the secure (async) path only when the platform advertises support.  
No other code changes are shown, implying the secure path already locks
and zeros memory correctly.

Security Impact
--------------------------------------------------------------------
Before the patch, sensitive per-process objects were left in unlocked
pageable memory, allowing local information disclosure and an
escalation-of-privilege vector inside the Windows Graphics component.
After the patch the correct path is taken, preventing exposure.
CVSS impact aligns with an EoP vulnerability.

Fix Effectiveness
--------------------------------------------------------------------
The fix removes the unconditional false gate and defers the decision to
a feature-flag routine, which restores the intended security controls.
Assuming the flag function is accurate, the vulnerability is fully
mitigated.  No obvious regressions are introduced.
