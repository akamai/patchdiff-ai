{'kb': 'KB5055523', 'change_count': 13, 'file': 'wldap32.dll', 'patch_store_uid': 'ca230859-d37d-4894-8880-e7425bdefdb2', 'cve': 'CVE-2025-26670', 'date': 1751828833.978264, 'confidence': 0.23}
--------------------------------------------------------------------
CVE-2025-26670 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows – wldap32.dll (LDAP client) CryptStream TLS/SSL
handling code (functions such as LdapSendSsl, DecryptLdapReceive,
NegotiateSecureConnection, TearDownSecureConnection and
CryptStream destructor).

Vulnerability Class
--------------------------------------------------------------------
Use-After-Free / concurrent access to freed object (CWE-416).

Detailed Root Cause Analysis
--------------------------------------------------------------------
Each CryptStream object owns an SChannel security context structure
(‘SslContext’) stored at offset 0x40 (pre-patch) / 0x48 (post-patch).
The context is released in several places:
  • CryptStream::TearDownSecureConnection()
  • CryptStream::~CryptStream()
  • error paths inside NegotiateSecureConnection()

Before the patch these functions simply called the SChannel helper
(*(ctx->vtable+72)) and then overwrote the two QWORDs holding the
context with 0xFFFFFFFF… *without* synchronising with other threads.

At the same time other threads in the same LDAP connection invoked
crypto helpers that dereference the very same context, e.g. in
  • LdapSendSsl()  – EncryptMessage / QueryContextAttributesW
  • DecryptLdapReceive() – DecryptMessage / QueryContextAttributesW
  • SSPI negotiate loop – InitializeSecurityContextW, etc.
These readers ran in parallel and performed indirect calls through
the freed context, leading to use-after-free and arbitrary code
execution in the client process.

Patch analysis shows a new SRWLOCK embedded in CryptStream
(this+6).  Two helper wrappers were introduced:
  • CryptStream::AcquireSslContextLockExclusive/Release…
  • CryptStream::AcquireSslContextLockShared/Release…
All writers of the context (free, re-initialise) now take the lock in
exclusive mode, while all readers take it in shared mode.  The
embedded lock is initialised in the constructor.

The bug therefore was the lack of any lifetime synchronisation for the
shared security context inside CryptStream, allowing concurrent
threads to dereference it after it had been freed by another thread.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// BEFORE – no locking, context freed while in use
CryptStream::~CryptStream() {
  if (*((QWORD*)this+6) != 0xFFFFFFFFFFFFFFFF)
      (*(void(**)())(*((QWORD*)this+3)+72))(); // free ctx
  ...                                     // no synchronisation
}

// AFTER – context protected by SRWLOCK
CryptStream::~CryptStream() {
  CryptStream::AcquireSslContextLockExclusive(this);
  if (*((QWORD*)this+9) != 0xFFFFFFFFFFFFFFFF)
      (*(void(**)())(*((QWORD*)this+3)+72))();
  CryptStream::ReleaseSslContextLockExclusive(this);
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Thread-A calls ldap_unbind() → CryptStream::TearDownSecureConnection
   → frees SslContext (no lock) and returns.
2. Thread-B is still inside LdapSendSsl() or DecryptLdapReceive()
   and calls (*ContextVTBL+48) / QueryContextAttributes on the stale
   pointer.
3. Indirect call lands in freed / attacker-controlled memory – memory
   corruption → RCE.

Attack Vector
--------------------------------------------------------------------
A malicious or compromised LDAP server can keep several application
threads busy (e.g. by causing referrals) and then induce a second
thread to close the connection while the first thread is still inside
crypto routines, creating the UAF race.  No local privileges are
required; the attack is performed over the network.

Patch Description
--------------------------------------------------------------------
• Added an RTL_SRWLOCK field to CryptStream and initialised it in the
  constructor.
• New helper wrappers implement Acquire/Release in shared or
  exclusive mode.
• All read-only crypto operations (send/receive, negotiate loop)
  now call AcquireSslContextLockShared() / Release…Shared().
• All functions that free or re-initialise the SslContext
  (destructor, TearDownSecureConnection, NegotiateSecureConnection
  failure paths) take the lock in exclusive mode.
• LdapSendSsl was re-written to use the shared lock around the
  EncryptMessage call.
• Accessor added to query SSL attributes in a locked fashion.

Security Impact
--------------------------------------------------------------------
Without the lock a remote attacker could win the race and cause the
LDAP client to execute code at the address of a freed SslContext
vtable pointer.  The bug therefore enables remote code execution in
any Windows component that uses wldap32.dll (e.g. Active Directory
Tools, Outlook, etc.).  Local privilege is not required.

Fix Effectiveness
--------------------------------------------------------------------
The added SRWLOCK serialises all readers and writers of the security
context.  A writer (free) now waits until all readers complete, and
readers that start afterwards will see either a valid context or the
0xFFFFFFFF sentinel.  No other functional changes are visible, so the
patch fully mitigates the identified UAF race.
