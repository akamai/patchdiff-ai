{'kb': 'KB5055523', 'confidence': 0.24, 'change_count': 22, 'file': 'vertdll.dll', 'patch_store_uid': '26ddcc45-02aa-4654-9dd1-f76f97a3453f', 'cve': 'CVE-2025-27735', 'date': 1751822648.2708683}
--------------------------------------------------------------------
CVE-2025-27735 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
vert.dll – Virtual-secure heap / image-enclave support routines, mainly
RtlGetImageEnclaveConfig

Vulnerability Class
--------------------------------------------------------------------
Insufficient verification of data authenticity / bounds-check bypass
(CWE-345)

Detailed Root Cause Analysis
--------------------------------------------------------------------
RtlGetImageEnclaveConfig parses the PE load-configuration directory to
copy the IMAGE_ENCLAVE_CONFIG structure (max 0x50 bytes) back to the
caller.  In the vulnerable build the code treated the EnclaveConfig
field (offset +0xF8 in LOAD_CONFIG_DIRECTORY) as a 32-bit RVA and
verified it with 32-bit arithmetic only:
  v8 = (unsigned int)((_DWORD)v7 - ImageBase);
  if (v8 < SizeOfImage && v8 + 4 <= SizeOfImage) …
Because the upper 32 bits were silently discarded, an attacker could
craft a signed image whose EnclaveConfig pointer straddled the image
boundary (e.g. 0xFFFF_FFFF_XXXX_YYYY).  All subsequent size checks were
performed on the truncated 32-bit value, so the function believed the
pointer still lay inside the image and blindly executed

  memmove(UserBuffer, EnclaveConfigPtr, ConfigSize);

This provided a fully attacker-controlled memory disclosure / spoofing
primitive: the caller received up to 0x50 bytes from an arbitrary
kernel-address, and – more importantly – the enclave policy supplied by
this unverified buffer was accepted as authentic.  By returning a
forged IMAGE_ENCLAVE_CONFIG the attacker could lower enclave security
requirements and bypass Virtualisation-Based Security (VBS) policy
checks.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable – 32-bit maths, no lower-bound test
v7 = *(unsigned int**)(Config + 248);   // EnclaveConfig
v8 = (unsigned int)((_DWORD)v7 - ImageBase);
if (v8 < SizeOfImage && v8 + 4 <= SizeOfImage) {
    memmove(UserBuf, v7, *v7);          // blind copy
}

// fixed – full 64-bit verification
v7 = *(_QWORD *)(Config + 248);
if (v7 >= HeadersEnd) {
    v8 = v7 - HeadersEnd;
    if (v8 && v8 < SizeOfImage && v8 + 4 <= SizeOfImage) {
        … // extra length and upper bound checks
    }
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User process calls RtlGetImageEnclaveConfig with a crafted PE image
   mapped in memory.
2. Function reads the load-config directory.
3. EnclaveConfig pointer passes truncated 32-bit checks ➜ treated as
   valid.
4. memmove copies attacker-controlled memory into caller buffer.
5. Caller uses fake enclave policy ➜ VBS security feature bypassed.

Attack Vector
--------------------------------------------------------------------
Local attacker provides or loads a malicious image (DLL/EXE) that
contains a forged 64-bit EnclaveConfig pointer outside the image.  No
special privileges are needed beyond the ability to call the API.

Patch Description
--------------------------------------------------------------------
• Replaced all 32-bit arithmetic with 64-bit calculations.
• Added lower-bound check against SizeOfHeaders (v7 >= HeadersEnd).
• Confirmed EnclaveConfigSize (first DWORD) is between 4 and 0x50.
• Ensured (ptr + size) fits entirely inside SizeOfImage.
• All lengths are now validated before memmove.

Security Impact
--------------------------------------------------------------------
Before the fix an attacker could supply arbitrary enclave-configuration
bytes, effectively weakening or disabling required enclave protections.
This is categorised by Microsoft as a Security Feature Bypass in VBS.
No memory corruption is necessary; authenticity failure alone leads to
policy bypass.

Fix Effectiveness
--------------------------------------------------------------------
The new logic performs strict 64-bit boundary checks and size
validation, eliminating the truncation issue and preventing any pointer
from referencing data outside the mapped image.  The vulnerability is
therefore fully mitigated in the patched build.
