{'change_count': 9, 'patch_store_uid': '90436596-eb99-49e6-8c1a-18ccfac19b5e', 'kb': 'KB5055523', 'date': 1751822617.228897, 'cve': 'CVE-2025-21222', 'confidence': 0.16, 'file': 'tapi32.dll'}
--------------------------------------------------------------------
CVE-2025-21222 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Telephony API (TAPI) user-mode client library
file:   tapi32.dll (several public “*A” helper routines)

Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow / out-of-bounds write caused by missing
size-and-offset validation (CWE-122)

Detailed Root Cause Analysis
--------------------------------------------------------------------
All affected helper functions are the ANSI wrappers that post-process
variable-length structures previously filled by their Unicode (“*W”)
counterparts.  The structures are supplied by the Telephony service and
contain these critical fields:
  dwTotalSize            – size of caller-allocated buffer
  dwXxxOffset            – start of variable-length array within buffer
  dwNumXxx               – number of array elements

Prior to the patch the code blindly trusted dwNumXxx and dwXxxOffset.
The loop body:
  base = (BYTE*)Struct + dwXxxOffset;
  for (i = 0; i < dwNumXxx; ++i) {
      WideStringToNotSoWideString(Struct, base + i*ElemSize);
  }
advanced the pointer past the caller supplied buffer if the service
returned a large dwNumXxx or an offset near the end of the buffer.  For
example:
  lineGetProviderListA   – 12-byte elements
  lineGetCountryA        – 44-byte elements
  lineGetLineDevStatusA  – 40-byte elements
  lineGetAddressStatusA  – 24-byte elements

Because WideStringToNotSoWideString writes eight bytes of ANSI text per
call, any out-of-bounds iteration corrupts adjacent heap memory.  A
malicious Telephony server (reachable over RPC) can therefore craft a
structure whose computed end (offset + num*size) exceeds dwTotalSize or
wraps around 32-bit arithmetic, resulting in a controlled heap overflow
inside the client process.

AsyncEventsThread contained an allied integer-overflow: it allocated a
larger event buffer via  newSize = dwNeeded + 0xBC  without checking if
the addition wrapped, giving an attacker a second avenue to heap
corruption.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// lineGetProviderListA – vulnerable logic (pre-patch)
if (!ProviderListW && lp->dwNumProviders) {
    char *p = (char*)&lp->dwNeededSize + lp->dwProviderListOffset;
    for (i = 0; i < lp->dwNumProviders; ++i) {
        WideStringToNotSoWideString(lp, p);
        p += 12;                       // no bounds check
    }
}

// patched check (excerpt)
size64 = 12ULL * lp->dwNumProviders;
if (size64 > 0xFFFFFFFF ||
    size64 + dwProviderListOffset < dwProviderListOffset ||
    size64 + dwProviderListOffset > lp->dwTotalSize)
{
    return TAPIERR_STRUCTURETOOSMALL; // -2147483595
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker sends crafted TAPI response via Telephony service.
2. Client application calls e.g. lineGetProviderListA().
3. Unicode version fills caller’s buffer with attacker-controlled header
   fields (dwNum*, dwOffset*).
4. ANSI wrapper executes conversion loop without validating those
   fields and writes beyond the buffer.
5. Heap corruption leads to process crash or controlled code execution.

Attack Vector
--------------------------------------------------------------------
A remote or local attacker able to impersonate / interact with the
Telephony service (e.g., over MS-RPC) returns a malicious buffer to any
client application that calls the exposed TAPI API.  No additional
privileges are required on the client side.

Patch Description
--------------------------------------------------------------------
The update adds comprehensive integer and bounds validation before any
pointer arithmetic:
  • 64-bit intermediate multiplication (entrySize * dwNum).
  • Overflow check against 0xFFFFFFFF.
  • wrap-around check:  (size + offset) < offset.
  • final in-bounds check against dwTotalSize.
If any test fails, the function logs an error and returns
TAPIERR_STRUCTURETOOSMALL (-0x8000000B).

AsyncEventsThread now uses ULongAdd / Feature flag helpers to detect
addition overflow when computing the new buffer size.

Security Impact
--------------------------------------------------------------------
Prior to the fix an attacker could trigger deterministic heap buffer
overflows in any process that consumed TAPI responses, leading to
process crash or arbitrary code execution in the context of the victim
application (often SYSTEM for services that use TAPI).  Because the
offset/size fields are fully attacker-controlled, exploitation is
reliable.

Fix Effectiveness
--------------------------------------------------------------------
The patch introduces strict, explicit validation in every affected code
path and short-circuits execution before any write occurs out of bounds.
The same pattern is applied consistently across all wrappers, and the
AsyncEventsThread overflow is mitigated via safe arithmetic helpers.
No residual unchecked arithmetic related to these structures is present
in the patched diff, so the fix is considered effective.
