{'cve': 'CVE-2025-26672', 'change_count': 4, 'kb': 'KB5055523', 'confidence': 0.2, 'file': 'mprapi.dll', 'date': 1751822595.271052, 'patch_store_uid': 'df5c96ae-bf56-4fc6-929b-b0a727fc0bc8'}
--------------------------------------------------------------------
CVE-2025-26672 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Routing and Remote Access Service (RRAS) user-mode helper
library mprapi.dll.  Affected entry points are
  • MprAdminInterfaceDeviceGetInfo
  • MprAdminInterfaceEnumEx
  • MprAdminRoutingDomainsEnumEx
  • MprAdminConnectionEnumEx
These RPC client stubs are reachable through the RRAS management
interface (MS-RRASAPI).

Vulnerability Class
--------------------------------------------------------------------
CWE-126: Buffer Over-read caused by missing length validation and 32/64
bit size truncation (integer overflow).

Detailed Root Cause Analysis
--------------------------------------------------------------------
The vulnerable helpers transform data returned by the RRAS RPC server
into local structures that are subsequently delivered to the caller.
The server controls two critical length fields:
  • *EntriesRead / *TotalEntries – number of array elements to copy
  • The first DWORD inside the level-1 DEVICE_INFO structure – its
    documented cbSize.

1. MprAdminInterfaceDeviceGetInfo (level==1)
   ---------------------------------------------------------------
   Original code blindly accessed offset 0x228 (552) inside the
   returned buffer:
       if (*(QWORD*)(buf+552)) *(QWORD*)(buf+552)=buf+560;
   When cbSize < 0x230 the read crosses the end of the allocation and
   discloses adjacent heap contents to the caller.

2. *EnumEx helpers (Interface / RoutingDomain / Connection)
   ---------------------------------------------------------------
   The implementation allocates the destination array with:
       LocalAlloc(..., (unsigned int)(ElemSize * Entries))
   On 64-bit builds ElemSize*Entries is first truncated to 32 bits; a
   large Entries value supplied by the server therefore allocates far
   less memory than required.  Subsequent per-element memcpy or
   ConvertMpriToMprStructureInternal() loops iterate Entries times and
   read past the end of the undersized buffer supplied by RPC, leaking
   heap data into the returned array.

   Structure sizes involved
       InterfaceEx   : 1280 bytes
       RoutingDomain :  540 bytes
       ConnectionEx  : 1672 bytes

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – truncated allocation (InterfaceEnumEx)
char *dst = LocalAlloc(0x40, (unsigned int)(1280 * *Entries));
...
for(i=0; i<*Entries; ++i)
    ConvertMpriToMprStructureInternal(...);
```
```c
// before patch – unchecked size field (DeviceGetInfo)
if(*(QWORD*)(p+552)) *(QWORD*)(p+552) = p + 560;  // OOB read
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Attacker (unauthenticated network) -> RRAS RPC interface ->
Server replies with crafted Entries/Size fields -> mprapi.dll helper
allocates/traverses buffer -> over-reads heap -> helper returns
buffer containing unintended memory to attacker.

Attack Vector
--------------------------------------------------------------------
Remote attacker sends a crafted MS-RRASAPI RPC request that forces the
server to return malicious enumeration or device information data.
Because the client stub lives in the RRAS service process itself, the
attacker can trigger it over the network with no local privileges and
receive the leaked memory in the RPC response.

Patch Description
--------------------------------------------------------------------
The update inserts centralised parameter validation guarded by
Feature_986203450__private_IsEnabledDeviceUsageNoInline() and falls
back to legacy behaviour when the feature flag is disabled.
Key changes:
  • Verify dwLevel and cbSize: if cbSize < 0x230 return ERROR_INVALID_ 
    PARAMETER (87) and free the server buffer.
  • Before allocating, compute RequiredSize = ElemSize * Entries in
    64-bit precision and reject when RequiredSize > 0xFFFFFFFF.
  • All early-exit paths now free any temporary allocations.
  • Common error code paths consolidated to avoid double-free.

Security Impact
--------------------------------------------------------------------
Prior to the fix a malicious RRAS peer could coerce the service into
reading beyond the bounds of heap allocations and embed the leaked
bytes in the RPC reply.  The memory disclosure may include heap
headers, pointers or previously processed secrets, aiding further
exploitation or information gathering.

Fix Effectiveness
--------------------------------------------------------------------
The added 64-bit size checks eliminate the integer truncation, and the
cbSize sanity test prevents out-of-bounds field dereferencing.  All
paths that formerly leaked now abort with ERROR_INVALID_PARAMETER or
ERROR_NOT_ENOUGH_MEMORY, and allocated memory is freed.  Assuming the
feature flag is enabled system-wide, the patch fully addresses the
identified over-read conditions.
