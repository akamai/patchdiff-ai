{'confidence': 0.27, 'change_count': 2, 'date': 1751822589.7456465, 'file': 'tapisrv.dll', 'kb': 'KB5055523', 'patch_store_uid': '38b57009-9f8e-4426-8142-2d7f8db5f6f2', 'cve': 'CVE-2025-21205'}
--------------------------------------------------------------------
CVE-2025-21205 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Telephony Service (tapisrv.dll) – routine LGetAddressStatus
responsible for servicing the RPC method lineGetAddressStatus and
post-processing the returned LINEADDRESSSTATUS structure.

Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow (CWE-122)

Detailed Root Cause Analysis
--------------------------------------------------------------------
At entry the server receives from the client two crucial values:
  a2[4] – size of the LINEADDRESSSTATUS buffer requested by the
           caller (dwTotalSize)
  a3    – maximum buffer size transmitted via RPC

The routine first verifies that a2[4] <= a3 and that a2[4] >= 0x40,
then allocates a2[4] bytes on the heap via InitTapiStruct().  After
calling into the TSP driver ( callback in v19 ) the buffer *a4 now
contains provider-supplied data.

The service then post-processes the "forward list" that begins at

  DWORD dwForwardOffset = a4[11];
  DWORD dwForwardNumEntries = a4[9];   // each entry = 32 bytes

Original code (simplified):
    p = (DWORD*)((BYTE*)a4 + dwForwardOffset);
    for (i=0; i<dwForwardNumEntries; i++)
    {
        if ((*p & 0x30000) != 0)
            *p = (*p & 0xFFFCFFFE) | 1;   // overwrite in place
        p += 8;   // 8 DWORDs == 32 bytes
    }

No validation is performed to ensure that
   dwForwardOffset + 32*dwForwardNumEntries <= dwTotalSize (a4[0])

or that the arithmetic itself does not wrap.  A malicious TSP driver
or a remote attacker influencing the returned structure can therefore
set either field to force the loop to iterate past the end of the
allocated heap buffer, clobbering adjacent heap memory 32 bytes at a
time with largely attacker-controlled values (*p).  Subsequent heap
operations can be exploited to gain code execution inside the
Tapisrv.exe process running as NT AUTHORITY\NetworkService.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch
v11 = a4[9];                     // dwForwardNumEntries
if (v11)
{
    v12 = (_DWORD *)((char *)a4 + a4[11]); // dwForwardOffset
    v13 = v11;
    do
    {
        if ((*v12 & 0x30000) != 0)
            *v12 = *v12 & 0xFFFCFFFE | 1; // write
        v12 += 8;                         // next 32-byte entry
        --v13;
    } while (v13);
}
```

```c
// after patch (new validation)
if (Feature_IsEnabledDeviceUsageNoInline())
{
    size   = 32ULL * a4[9];         // bytes needed for list
    offset = a4[11];
    if (size > 0xFFFFFFFF || size + offset < offset || a4[0] < size + offset)
    {
        TRACELogPrint(..., "invalid forward list");
        a4[9] = 0;                  // neutralise list
        *a2 = 0x8000000D;           // TELEPHONY err = 0xC0000195
    }
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Client RPC lineGetAddressStatus -->
  Tapisrv!RemoteRequestProc -->
    LGetAddressStatus
      InitTapiStruct allocates heap buffer of client-supplied size
      TSP driver fills LINEADDRESSSTATUS
      Service iterates over forward list without bounds check
      Heap overflow occurs

Attack Vector
--------------------------------------------------------------------
An unauthenticated attacker sends a crafted lineGetAddressStatus RPC
request to the Telephony service on the target machine.  By controlling
values that the TSP driver copies into dwForwardOffset and
dwForwardNumEntries the attacker causes the service to overwrite heap
memory, leading to remote code execution.

Patch Description
--------------------------------------------------------------------
The patch introduces explicit bounds checking before processing the
forward list:
  • Calculates required size = 32 * dwForwardNumEntries (64-bit).
  • Verifies no 32-bit wrap-around and that
      offset + size <= dwTotalSize.
  • On failure sets dwForwardNumEntries to 0 and returns an error.
These checks are conditionally compiled behind
Feature_3235131707__private_IsEnabledDeviceUsageNoInline() but are
expected to be always enabled in production builds.

Security Impact
--------------------------------------------------------------------
Prior to the fix a remote, unauthenticated attacker could achieve
arbitrary heap overwrite inside the Telephony service, resulting in
remote code execution in the NetworkService context.  Successful
exploitation compromises the entire system.

Fix Effectiveness
--------------------------------------------------------------------
The added size/overflow checks prevent the forward list from ever
extending beyond the end of the allocated buffer, fully neutralising
the described heap overflow.  No other code paths write into the list
without these checks, so the fix is considered effective provided the
feature flag remains enabled.
