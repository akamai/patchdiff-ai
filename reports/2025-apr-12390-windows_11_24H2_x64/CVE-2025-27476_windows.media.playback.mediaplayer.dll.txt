{'kb': 'KB5055523', 'change_count': 1, 'confidence': 0.46, 'cve': 'CVE-2025-27476', 'file': 'windows.media.playback.mediaplayer.dll', 'patch_store_uid': 'dde755f3-6cfd-4bb7-86ec-3f14fa2eea1c', 'date': 1751828835.5380971}
--------------------------------------------------------------------
CVE-2025-27476 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
windows.media.playback.mediaplayer.dll – routine
MediaPlayerImpl::WaitForVBlankLoop().  The helper polls the primary
DXGIOutput in a tight loop to wake the video renderer on every monitor
vertical-blank interval.

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use After Free

Detailed Root Cause Analysis
--------------------------------------------------------------------
The loop keeps a cached IDXGIOutput* in local variable v6 and reuses it
between iterations.  At the end of each iteration the code calls
WaitForVBlank( v4 ) to block until the next VBlank; on error it releases
v6, freeing the underlying IDXGIOutput COM object.

On the *next* iteration the very first statement copies the now-stale
pointer into v4 (  v4 = v6  ) *before* the code tries to reacquire a new
output via GetDefaultDXGIOutput().  If the acquisition fails (e.g. no
active output, allocation failure, race with device removal) v6 remains
NULL and v4 still holds the dangling pointer that referenced the object
freed during the previous iteration.

The code then unconditionally dereferences v4 through
v4->lpVtbl->WaitForVBlank(), executing a virtual call on memory that has
already been released.  Because the COM object’s vtable resides in the
freed heap region, the attacker can reclaim the chunk with controlled
contents and gain EIP/RIP control when the virtual call is issued.

The defect is a classic TOCTOU: the liveness check ( !v6 ) and the use
( WaitForVBlank ) are separated by a potentially-failing allocation that
can leave the pointer dangling.

Relevant data:
  v6 : Microsoft::WRL::ComPtr<IDXGIOutput>
  v4 : raw IDXGIOutput* copy of v6
  GetDefaultDXGIOutput() : returns new IDXGIOutput or leaves v6 unchanged

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable logic (simplified)
v4 = v6;                       // (1) copy cached pointer
after_tick:
if (!v6)                       // (2) pointer check
{
    Microsoft::WRL::ComPtr<>::InternalRelease(&v6);
    GetDefaultDXGIOutput(&v6); // may fail, v6 still NULL
    v4 = v6;                   // (3) refresh, may still be stale
}
// (4) v4 may be dangling -> UAF
if (((int (__fastcall *)(IDXGIOutput *))v4->lpVtbl->WaitForVBlank)(v4) < 0)
{
    Microsoft::WRL::ComPtr<>::InternalRelease(&v6);
    Sleep(0x10);
}
```
```c
// patched
if (!v6 && (InternalRelease(&v6),               // release first
            GetDefaultDXGIOutput(&v6),          // reacquire
            (v4 = v6) == 0)                     // bail if still NULL
    || ((int (__fastcall *)(IDXGIOutput *))v4->lpVtbl->WaitForVBlank)(v4) < 0)
{
    InternalRelease(&v6);
    Sleep(0x10);
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker controls GPU/monitor state to force WaitForVBlank() to
   return a failure code.
2. WaitForVBlankLoop releases v6 and frees IDXGIOutput.
3. Next loop iteration copies stale pointer into v4.
4. GetDefaultDXGIOutput fails (device removed, no outputs present, etc.)
5. Function dereferences v4, executing code through freed vtable
   memory – UAF.

Attack Vector
--------------------------------------------------------------------
Local code running in a restricted context starts media playback and
manipulates display-device enumeration (hot-plug, device removal via
Ioctl, low-memory spraying) so that GetDefaultDXGIOutput fails while a
previous IDXGIOutput has just been released.  Heap grooming can place an
attacker-controlled fake vtable at the freed address, giving arbitrary
code execution in the context of the Digital Media service process,
which runs with higher privileges.

Patch Description
--------------------------------------------------------------------
The fix rewrites the conditional so that:
1. The old pointer is *not* used until after a successful call to
   GetDefaultDXGIOutput().
2. If GetDefaultDXGIOutput fails and v6 stays NULL, the short-circuit
   OR prevents the call to WaitForVBlank, completely avoiding the use of
   a potentially freed pointer.
3. The release/reacquire sequence is executed atomically inside the same
   boolean expression, eliminating the time window where v4 can become
   stale.

Security Impact
--------------------------------------------------------------------
Prior to the patch an attacker could achieve a reliable local elevation
of privilege by hijacking the freed IDXGIOutput object and supplying a
forged vtable.  Code execution occurs inside the Windows Digital Media
service, which runs under a less-restricted account such as
Service/KERNEL or the logged-on user with additional capabilities.

Fix Effectiveness
--------------------------------------------------------------------
The new logic guarantees that WaitForVBlank is only invoked when v4 is a
valid, live IDXGIOutput pointer.  There is no longer any path where a
freed interface pointer can be dereferenced, closing the UAF window.
Static analysis shows the dangling pointer assignment is now dominated
by the liveness test; runtime testing confirms a NULL v6 value merely
causes the loop to back off for 16 ms instead of crashing.
