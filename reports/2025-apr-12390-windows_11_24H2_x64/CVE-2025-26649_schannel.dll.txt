{'file': 'schannel.dll', 'kb': 'KB5055523', 'change_count': 34, 'patch_store_uid': '7dcbd1d8-ea00-4048-b511-5ff09787d90f', 'date': 1751820803.7289605, 'confidence': 0.32, 'cve': 'CVE-2025-26649'}
--------------------------------------------------------------------
CVE-2025-26649 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows – Secure Channel (schannel.dll)


Vulnerability Class
--------------------------------------------------------------------
CWE-362: Race Condition  
Secondary: CWE-416 Use-after-free (resulting from the race)


Detailed Root Cause Analysis
--------------------------------------------------------------------
Every SSL/TLS security context inside schannel is represented by a
CSslParentContext object.  Several SPI entry points (SpApplyControlToken,
SpLsaQueryContextAttributes, SpSetContextAttributes, SslFreeCustomBuffer
and assorted TLS-13 helper paths) access mutable members of this object,
most notably

  +0x08  -> pointer to implementation (‘child’) context
  +0x10  -> pointer to state / extension buffers
  +0x18  -> pointer to caller-supplied custom scratch buffer
  +0x20  -> DWORD   size of that custom buffer
  +0x08  -> int32   “in-use” counter (legacy refcount)

Prior to the patch none of these functions performed any real mutual
exclusion – they only used a fragile _InterlockedIncrement / Decrement on
a field at offset +0x08 to detect re-entrance.  Because the counter was
updated *after* the pointer dereferences, two threads could still enter
critical sections concurrently and operate on the same CSslParentContext.

A typical failing sequence:

  T1: SpApplyControlToken() … reads ctx->+18 (custom buffer)
  T2: SslFreeCustomBuffer() frees ctx->+18 and zeroes the field
  T1: continues to use the stale pointer ⇒ use-after-free / UAF

Because these calls execute in LSASS/SYSTEM context while the attacker
controls the data inside the freed buffer, the condition can be turned
into local privilege escalation.

The vulnerable window is any pair (or more) of SPI calls that touch the
same CSslParentContext from different threads belonging to the same logon
session.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before – SslFreeCustomBuffer  (simplified)
if (a2 != g_dwPackageId || !a1)
    return 0;
void *p = *(void **)(a1 + 0x18);   // no locking
if (p) {
    vtable_free(p, a3);            // free
    if (a4)
        *(void **)(a1 + 0x18) = 0; // zero pointer
}

// after – Accept/Release helpers
BYTE CSslParentContext::AcceptCall()
{
    return RtlTryAcquireSRWLockExclusive(this);  // fast exclusive lock
}
void CSslParentContext::ReleaseCall()
{
    RtlReleaseSRWLockExclusive(this);
}

// after – SslFreeCustomBuffer usage
if (FeatureEnabled && !AcceptCall(this))
    return SEC_E_TOO_MANY_CONTEXTS; //120
...
*(vtable)(ctx->+18)->Free(...);
ReleaseCall(this);
```
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker obtains a valid schannel security context (AcquireCredentials
   + InitializeSecurityContext etc.).
2. Thread-A calls SpApplyControlToken / SpSetContextAttributes etc.
3. While Thread-A is inside the function, Thread-B calls
   SslFreeCustomBuffer on the same context.
4. Thread-B frees ctx->CustomScratch and zeroes the pointer.
5. Thread-A continues executing with the dangling pointer ⇒ memory
   corruption in LSASS.


Attack Vector
--------------------------------------------------------------------
Local, authenticated.  Any user-mode process can call the SSPI / SChannel
APIs against its own negotiated context and run the two code paths in
parallel to corrupt LSASS memory, then craft the corruption to achieve
code execution and privilege escalation to SYSTEM.


Patch Description
--------------------------------------------------------------------
The update introduces a proper critical-section primitive around every
entry point that mutates or reads sensitive CSslParentContext state.

1. New methods
      CSslParentContext::AcceptCall()
      CSslParentContext::ReleaseCall()
   implement an exclusive Slim-Reader/Writer lock (SRWLOCK).  Where the
   feature switch is disabled, they fall back to the legacy refcount but
   now *gate* entry – only the first caller proceeds.

2. Each previously unsafe function now:
      • calls AcceptCall() at the very top; returns SEC_E_TOO_MANY_CONTEXTS
        (120) if the lock is already held.
      • performs its normal work.
      • calls ReleaseCall() in all exit paths.

3. Pointer operations were updated to use the ‘this’ offsets directly
   (strong typing) but no functional changes other than the lock.

4. SetGenericExtensionBuffers was replaced entirely and no longer touches
   shared state without protection.


Security Impact
--------------------------------------------------------------------
Before the patch an attacker could trigger a use-after-free on process
memory owned by LSASS, reliably leading to elevation of privilege
(SYSTEM) or denial-of-service.  The issue is tracked as
CVE-2025-26649 and is rated “Elevation of Privilege”.


Fix Effectiveness
--------------------------------------------------------------------
The added SRW lock provides strict mutual exclusion; only one thread may
operate on a CSslParentContext at a time.  All modified functions now
honour the lock on *all* code paths, including early returns and error
handlers, thereby eliminating the race window that allowed concurrent
free/use of the custom scratch buffer and other shared members.  No
residual caller-controlled paths bypass the Accept/Release pair, so the
fix is considered effective for the vulnerable entry points observed in
the diff.
