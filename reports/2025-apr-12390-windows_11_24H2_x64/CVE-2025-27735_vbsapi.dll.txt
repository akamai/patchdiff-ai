{'cve': 'CVE-2025-27735', 'patch_store_uid': 'a63240a9-836c-4100-8c09-1ea2660067f3', 'change_count': 5, 'confidence': 0.47, 'file': 'vbsapi.dll', 'date': 1751822598.8840106, 'kb': 'KB5055523'}
--------------------------------------------------------------------
CVE-2025-27735 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Virtualization-Based Security (VBS) user-mode library
vbsapi.dll – function
wil_details_FeatureReporting_RecordUsageInCache

Vulnerability Class
--------------------------------------------------------------------
Security-feature bypass / Insufficient verification of data
authenticity (CWE-345)

Detailed Root Cause Analysis
--------------------------------------------------------------------
The routine wil_details_FeatureReporting_RecordUsageInCache() keeps
per-process usage information for several VBS features in a tiny
in-memory cache pointed to by the volatile INT32 array *a2.  For
feature identifiers 320-383 it packs the index ( id-320 ) into the
second 32-bit element:
  bits  5-10 : 6-bit index  (0-63)
  bit       4: valid flag

The original code performed only a loose range test:
    v7 = a3 - 320;          // derive 6-bit index
    if (v7 < 64) {
        ... atomically set (0x10 | (v7<<5)) in a2[1] ...
    }
If v7 was outside the legal range (negative or >=64) the body was
skipped, but the function still executed the trailing block that
returned success to the caller and stored summary data into the result
buffer.  Because the atomic update never occurred, the cache remained
untouched yet upper-layer code believed the feature had already been
recorded/validated.

Any code path that subsequently relied on the presence of the cache
flag to prove that a security-sensitive feature had been previously
initialised would therefore be bypassed.  The flaw stems from
insufficient validation of the supplied feature identifier and from
accepting a logically unverified state as authentic.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
v7 = a3 - 320;
if (v7 < 64) {
    v8 = *((_DWORD *)a2 + 1);
    ... update 0x10 | (v7<<5) ...
}
*(_DWORD *)(a1 + 8)  = a3;   // success path always taken
*(_DWORD *)(a1 + 4)  = 1;
```
```c
// after
v7 = a3 - 320;
if (v7 >= 64)
    goto LABEL_16;           // treat as generic, no cache update
...
if (!*(_DWORD *)(a1 + 16))   // only if not already present
{
LABEL_16:
    *(_DWORD *)(a1 + 8) = a3;
    *(_DWORD *)(a1 + 4) = 1;
    *(_DWORD *)(a1 + 12) = a4;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker calls into VBS code path that ends up in
   wil_details_FeatureReporting_RecordUsageInCache() with a crafted
   feature id (a3) >=384 or <320.
2. v7 is computed and fails the v7<64 check; body skipped.
3. Function returns success even though a2[1] was never updated.
4. Caller assumes the feature had been validated and skips genuine
   verification, allowing security-feature bypass.

Attack Vector
--------------------------------------------------------------------
Local attacker running code inside the VBS-enabled environment invokes
an API that eventually records feature usage, supplying a specially
chosen feature identifier outside the expected 320-383 range.  No
additional privileges are required beyond the ability to reach the
API.

Patch Description
--------------------------------------------------------------------
• Added explicit upper-bound check: if (v7 >= 64) the function now
  leaves the caching fast-path immediately, preventing out-of-range
  values from being considered.
• Added conditional fall-back: the generic recording block is executed
  only when the cache update did not already succeed
  (*result.Valid == 0).

Security Impact
--------------------------------------------------------------------
Before the fix an attacker could make higher-level VBS components
believe that a protected feature had already been recorded or
verified, effectively bypassing the intended security gate.  This
undermines the authenticity guarantees of VBS and could be chained to
escalate privileges or maintain persistence in a protected enclave.

Fix Effectiveness
--------------------------------------------------------------------
The new upper-bound check ensures that only legal 6-bit indices reach
the cache update logic, while the additional conditional prevents
false success when no update occurred.  As no other paths write the
0x10/0x7E0 fields, the patch fully closes the bypass described above.
--------------------------------------------------------------------