{'file': 'microsoft.bluetooth.service.dll', 'change_count': 6, 'confidence': 0.13, 'date': 1751820836.1745026, 'kb': 'KB5055523', 'cve': 'CVE-2025-27490', 'patch_store_uid': '32c13f30-343e-44d9-a897-2eaa723677fa'}
--------------------------------------------------------------------
CVE-2025-27490 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Bluetooth Service (microsoft.bluetooth.service.dll)
Feature-flag / telemetry code generated by WIL (Windows Implementation
Library).  Affected routines are GetCurrentFeatureEnabledState( ) for
several feature IDs, wil_details_FeatureReporting_RecordUsageInCache( )
and FeatureImpl<...>::ReportUsage( ).  The vulnerable code executes in
the Bluetooth service process running as LOCAL SYSTEM.

Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow (CWE-122) caused by an out-of-bounds write
stemming from insufficient bounds checking (also results in potential
out-of-bounds read – CWE-125).

Detailed Root Cause Analysis
--------------------------------------------------------------------
The central issue is in wil_details_FeatureReporting_RecordUsageInCache
( address 1800287CC ).  The routine records feature usage in a per-
process heap structure whose second DWORD ( *(a2+1) ) contains a
6-bit index (bits 5-10) and a present flag (bit 4).

Old logic:
  • For usage kind values a3 >= 6 (except 6 & 7) the code computed
        v5 = a3 – 320;
  • It then entered the bit-update loop if
        (int)a3 - 320 < 64         // signed compare
    This allowed any a3 < 320 (negative v5) to satisfy the test because
    a negative number is still < 64.  v5 could therefore be –1, –2 …
  • v5 was multiplied by 32 and truncated to a 16-bit value:
        ((ushort)v6 ^ (ushort)(32*v5)) & 0x7E0
    When v5 is negative or ≥64 the left-shift is undefined and the
    masking expression yields a value that no longer fits inside the
    intended 6-bit field.  The resulting _InterlockedCompareExchange()
    writes arbitrary bits into *(a2+1).

Because *(a2+1) is part of a heap-allocated cache structure, clobbering
bits beyond the legal 0x7E0 mask corrupts adjacent heap memory.  A
caller that controls the a3 parameter can therefore perform a limited
but repeatable heap overwrite in the Bluetooth service.

Secondary contributing bugs fixed at the same time:
  • Several GetCurrentFeatureEnabledState( ) helpers used 32-bit
    temporaries to store a masked FEATURE_ENABLED_STATE value, causing
    sign/zero-extension mistakes that could propagate corrupted flag
    data to RecordUsageInCache.
  • FeatureImpl<...>::ReportUsage had a wrong prototype (DWORD* vs
    UINT*) and produced inconsistent stack layout, worsening the
    chances of detecting the corrupted cache entry.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable range check (before)
if ( (unsigned int)(a3 - 6) >= 2 ) {
    v5 = a3 - 320;
    if ( (int)a3 - 320 < 64 ) {     // negative numbers pass
        ... _InterlockedCompareExchange(a2+1, ... (32*v5) ... );
    }
    *(_DWORD*)(a1+4) = 1;           // mark "usage written"
}
```
```c
// patched check (after)
if ( (unsigned int)(a3 - 6) >= 2 ) {
    v5 = a3 - 320;
    if ( (int)a3 - 320 >= 64 )
        goto LABEL_16;              // bail out when index is out of
                                    // 0-63 range
    ...
    if ( !*(_DWORD*)(a1+16) )       // do not touch heap when entry
        goto LABEL_16;              // already present
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Local attacker calls any Bluetooth API that ends up in
   FeatureImpl<...>::ReportUsage(..).
2. ReportUsage forwards a crafted usage-kind value (a3) to
   wil_details_FeatureReporting_RecordUsageInCache(..).
3. The old function accepts an out-of-range a3 (<320 or >383) and
   computes a negative / oversized v5.
4. InterlockedCompareExchange writes an incorrect bitfield into the
   heap-resident cache, overflowing into neighbouring memory.
5. Subsequent heap activity in the service can turn the corruption into
   an elevation-of-privilege condition.

Attack Vector
--------------------------------------------------------------------
Requires local code execution with the ability to invoke Bluetooth
APIs (default for any user).  No special privileges are needed.  A
malicious application repeatedly sends crafted feature-usage records to
the service to corrupt the heap and execute arbitrary code in the
SERVICE context.

Patch Description
--------------------------------------------------------------------
• Added a strict upper AND lower bound check:
      if ((int)a3 - 320 >= 64)  ->  skip cache update.
  This blocks negative indices and values above 383.
• After the compare-exchange loop, the code now verifies whether the
  entry was already present (*entryPresent flag) and skips the write if
  so, preventing double updates.
• Ancillary hardening:
  – All temporaries holding masked FEATURE_ENABLED_STATE upgraded from
    32-bit to 64-bit.
  – Eliminated obsolete v12 flag and consolidated conditions.
  – Corrected ReportUsage prototype; now passes parameters with the
    right sizes and constant reporting kind.

Security Impact
--------------------------------------------------------------------
Before the patch a local attacker could reliably corrupt heap memory
inside the high-privilege Bluetooth service, leading to an elevation of
privilege (SYSTEM).  After patch, out-of-range indices cannot reach the
bit-update code path and double-record insertion is blocked, removing
any heap overwrite primitive.

Fix Effectiveness
--------------------------------------------------------------------
The additional range test guarantees v5 is in [0,63].  The extra
present-flag check avoids secondary corruption through duplicate
writes.  Type-width fixes close truncation issues feeding the cache
routine.  With these changes the specific out-of-bounds write is no
longer reachable; no alternate path writes to *(a2+1) with uncontrolled
values.  The patch therefore fully addresses the reported heap buffer
overflow.
