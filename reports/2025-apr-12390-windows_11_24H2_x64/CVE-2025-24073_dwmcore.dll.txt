{'change_count': 45, 'confidence': 0.15, 'patch_store_uid': 'c22bb7ef-b7b4-46df-ab3e-d621aaee2fe5', 'file': 'dwmcore.dll', 'kb': 'KB5055523', 'cve': 'CVE-2025-24073', 'date': 1751809281.872719}
--------------------------------------------------------------------
CVE-2025-24073 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Desktop Window Manager core library – dwmcore.dll
Function: COcclusionContext::PreSubgraph()

Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow / integer-overflow owing to improper
input validation (CWE-20, leads to memory corruption)

Detailed Root Cause Analysis
--------------------------------------------------------------------
The routine PreSubgraph() keeps, per-tree, an expandable vector of
COcclusionInfo* objects that lives in the owning CTreeData object:
    [ v4+176 ]  ->  begin
    [ v4+184 ]  ->  end
    [ v4+192 ]  ->  capacity end

When an occlusion-entry for the current visual tree is missing the
code performs a manual reallocation.

Old code path (excerpt):
  v63 = *(qword*)(vec.capEnd);       // current capacity end
  v64 = *(qword*)(vec.begin);
  v33 = (vec.end - vec.begin) >> 3;  // element count
  newCap = liberal_expansion_policy::expand(..., v33+1);
  buf   = operator new[](saturated_mul(newCap,8));
  ... copy loop ...

The arithmetic is carried out with 64-bit signed temporaries that are
later re-interpreted as unsigned. When v33 is attacker-controlled and
close to 0x8000_0000, the expression (v63-v64)>>3 or (v33+1) can wrap
into a negative value; the expansion policy then returns a very small
newCap.  The subsequent ‘saturated_mul(newCap,8)’ therefore allocates
far fewer bytes than will later be written by the copy loop:

  while (oldIt != oldEnd) {
      *dstIt++ = *oldIt;   // writes past new buffer
      *oldIt++ = 0;        // zeroes old element
  }

Because no bounds check exists for ‘dstIt’, the loop overruns the
newly-allocated buffer, corrupting the process heap.  A low-privileged
client can fully control the visual-tree size through the public
composition API and therefore trigger the overflow from a sandboxed
context.

Once corrupted, the attacker gains code-execution inside dwm.exe,
which runs as NT AUTHORITY\SYSTEM on the interactive session,
resulting in a local privilege-escalation.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – manual reallocation with unchecked math
v396 = detail::liberal_expansion_policy::expand(v65,
              (v63 - v64) >> 3, v33 + 1);
buf  = operator new[](saturated_mul(v396, 8ui64));
...
while (v85 != v83) {
    v88   = *v85;
    *v85  = 0;        // clear old slot
    *v86++= v88;      // *** OOB write when v86 >= buf+newCap ***
    ++v85;
}
```
```c
// after patch – no manual vector growth
TreeData      = CVisual::FindTreeData((CVisual*)v3, a2);
OcclusionInfo = CTreeData::GetOcclusionInfo(TreeData,
                                           this->m_passID,
                                           /*create*/1);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Low-privilege process creates an extremely large / crafted visual
   tree via DComposition / XAML.
2. dwmcore!COcclusionContext::PreSubgraph is executed while walking
   that tree.
3. Code path **“not-found -> allocate-new occlusion info”** is taken.
4. Integer overflow during capacity growth -> undersized allocation.
5. Copy loop writes beyond buffer → heap corruption.
6. Corrupted heap structures are subsequently used, leading to
   arbitrary code execution inside dwm.exe (SYSTEM).

Attack Vector
--------------------------------------------------------------------
Local   –   Any sandboxed or low-IL process that can issue DComp /
DirectComposition or XAML API calls and force DWM to render its visual
content.

Patch Description
--------------------------------------------------------------------
Microsoft replaced the entire hand-rolled allocation logic with calls
into trusted helpers:
  • CVisual::FindTreeData()
  • CTreeData::GetOcclusionInfo()
These helpers return a correctly-sized COcclusionInfo entry or create
one atomically, eliminating all manual pointer arithmetic.

All code that performed custom capacity calculations, calls to
operator new[], and element-copy loops has been deleted.  The new
implementation keeps only high-level operations and early-out checks;
no raw arithmetic on vector sizes remains.

Security Impact
--------------------------------------------------------------------
Before the fix a local attacker could cause a heap buffer overflow in
the SYSTEM-privileged DWM process, leading to elevation of privilege
or code execution with SYSTEM rights.  The bug is exploitable from any
sandbox that allows interaction with the window manager.

Fix Effectiveness
--------------------------------------------------------------------
The new code path no longer performs arithmetic on untrusted counts
and never reallocates buffers manually; therefore the integer
overflow/OOB scenario is completely removed.  No residual write path
references attacker-controlled offsets, making the patch effective
against the described vulnerability.
