{'date': 1751829059.949632, 'kb': 'KB5055523', 'change_count': 1, 'cve': 'CVE-2025-26669', 'patch_store_uid': '9cd94eb6-b985-4fb4-855d-4c1a18baab7b', 'confidence': 0.72, 'file': 'rasman.dll'}
--------------------------------------------------------------------
CVE-2025-26669 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Routing and Remote Access Service (RRAS) user-mode helper
module rasman.dll – function SubmitRequest() that marshals caller
parameters into a service request and later demarshals the service
response back into the caller’s buffers.

Vulnerability Class
--------------------------------------------------------------------
Out-of-bounds Read / Information Disclosure (CWE-125)

Detailed Root Cause Analysis
--------------------------------------------------------------------
SubmitRequest() handles many request op-codes.  For op-code 0x5E
(DeviceUsage) it copies variable-length data returned by the remote
RRAS service from an internal heap buffer (v11) into a caller supplied
output buffer (v4).

Prior to the fix the size check that protects this memcpy was executed
only when the undocumented feature flag
Feature_2659568953__private_IsEnabledDeviceUsageNoInline() evaluated to
TRUE.  On systems where the feature is disabled that guard is skipped
entirely:

  if (!featureEnabled) {
      /* no validation */
      memcpy(v4, v11 + 40, *((DWORD*)v11 + 8));
  }

The length in *((DWORD*)v11 + 8) is fully under the control of the
remote RRAS service and can be made larger than the actual allocation
that starts at (v11 + 40).  When this happens memcpy() reads beyond
the end of the heap allocation, copying stale heap data into the
caller’s buffer which is ultimately forwarded to the (unauthenticated)
network peer.  No crash occurs because the destination buffer size is
checked elsewhere; only the source is unchecked, producing an
information leak.

Affected variables / structures
  v11   – pointer to the service response buffer obtained from
           AllocateBuffer().
  *((DWORD*)v11 + 8) – 32-bit length field returned by the service and
           copied verbatim into the request packet.
  Size  – size of the caller supplied output buffer, passed on the
           stack.
  featureEnabled – result of the above feature flag helper; FALSE on
           all released Windows builds where the vulnerability is
           observable.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
/* before patch – size check hidden behind feature flag */
if ((unsigned)Feature_IsEnabledDeviceUsageNoInline(v6,&_ImageBase)) {
    if (*((DWORD*)v11 + 8) > (unsigned)Size)
        v13 = 603;          // ERROR_BUFFER_TOO_SMALL
    else
        memcpy_0(v4, v11 + 40, *((DWORD*)v11 + 8));
} else {
    /*  !!!  NO VALIDATION – OOB READ  !!! */
    memcpy_0(v4, v11 + 40, *((DWORD*)v11 + 8));
}

/* after patch – guard executed unconditionally */
if (*((DWORD*)v11 + 8) > (unsigned)Size) {
    v13 = 603;              // refuse to copy
} else {
    memcpy_0(v4, v11 + 40, *((DWORD*)v11 + 8));
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker establishes an RRAS connection and causes the client to
   call RasSubmitRequest(opCode 0x5E).
2. Attacker’s RRAS server crafts a reply whose length field
   (Offset 0x20 in the response packet => *((DWORD*)v11 + 8)) is larger
   than the real payload.
3. Client receives the reply; SubmitRequest() allocates a 0x1C00-byte
   buffer, copies the packet, and – because the feature flag is FALSE –
   directly memcpy()s the claimed length into the caller buffer.
4. Bytes past the end of the allocation are read and returned to the
   caller and can be sent back to the attacker, leaking heap memory
   from the RRAS process.

Attack Vector
--------------------------------------------------------------------
Unauthenticated network attacker operating a malicious RRAS server or
MITM position induces a Windows client to connect (e.g., via VPN
profile).  No local privileges are required.

Patch Description
--------------------------------------------------------------------
The update makes the bounds check unconditional and consistent:
  • The entire feature-flag branch was removed; validation now always
    executes.
  • *(DWORD*)(v11 + 32) (length) is set from the trusted Size variable
    instead of an alias that could refer to unrelated stack data.
  • Identical check is added when exporting the response back to the
    caller.
  • Numerous cosmetic refactorings (variable renames, logging GUID
    updates) but no behavioural change beyond the added validation.

Security Impact
--------------------------------------------------------------------
Before the fix an attacker could obtain up to 0x1C00-40 bytes of heap
memory per request, potentially exposing sensitive information such as
VPN credentials or heap addresses useful for further exploitation.
The vulnerability enables passive information disclosure only; no
remote code execution is believed possible through this specific read.

Fix Effectiveness
--------------------------------------------------------------------
The patched code validates the length every time regardless of feature
flags, returning ERROR_BUFFER_TOO_SMALL if the server-supplied length
exceeds the caller’s buffer.  No code paths remain that can copy data
without this comparison, effectively eliminating the out-of-bounds
read.

--------------------------------------------------------------------