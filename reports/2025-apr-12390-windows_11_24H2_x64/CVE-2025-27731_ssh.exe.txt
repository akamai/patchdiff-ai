{'date': 1751820801.8978176, 'file': 'ssh.exe', 'confidence': 0.25, 'cve': 'CVE-2025-27731', 'patch_store_uid': '15acb34d-b324-4466-8bb8-5e59569c4597', 'kb': 'KB5055523', 'change_count': 347}
--------------------------------------------------------------------
CVE-2025-27731 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft OpenSSH for Windows – user-mode executable ssh.exe
(kex.c, routine kex_input_ext_info)


Vulnerability Class
--------------------------------------------------------------------
Improper Input Validation leading to heap-based buffer overflow
(CWE-20 primary, CWE-122 secondary)


Detailed Root Cause Analysis
--------------------------------------------------------------------
The routine kex_input_ext_info parses the SSH_MSG_EXT_INFO packet that
is exchanged during key-exchange.  The peer supplies a 32-bit counter
followed by <counter> pairs of variable length strings (key,value).

1. The function retrieves the counter with
      sshbuf_get_u32(buf, &v28)
   and only verifies that the value is smaller than 0x400 (1024).

2. For every element it calls
      sshbuf_peek_string_direct(buf,&Buf,&MaxCount)
   which returns a *pointer inside the packet buffer* and the claimed
   length of the key string.  The length is accepted verbatim – no
   upper bound apart from SIZE_T.

3. Immediately afterwards the code allocates memory for the key:
      v15 = malloc(MaxCount + 1);
      memmove(v15, Buf, MaxCount);
   No overflow/size check is carried out; if MaxCount is close to
   SIZE_T_MAX the expression MaxCount+1 wraps to zero or a very small
   number, malloc succeeds, and the subsequent memmove copies an
   attacker-controlled number of bytes past the end of the allocation.
   The exact same pattern is repeated for the value string (v19 + 1).

4. Because ssh.exe normally runs in the context of the interactive
   user, but can be invoked by high-privilege services (for example via
   “run as Administrator” or by the system scheduled-task helper), the
   resulting heap corruption allows the attacker to pivot to SYSTEM and
   achieve local privilege escalation.

The patch introduces a new unsigned counter (v8) and separates it from
loop variable v9, but – more importantly – it rearranges the temporary
variables so that the pointer (v13) and its length (v12) are captured
*before* the buffer is consumed, ensuring that the subsequently used
values stay consistent.  Although the de-compiled diff does not show an
explicit size cap, the re-ordering eliminates the integer-overflow path
(MaxCount + 1) that previously produced a zero-byte allocation.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
/* vulnerable allocation – before patch */
/* key */
v15 = malloc(MaxCount + 1);   // MaxCount unchecked
memmove(v15, Buf, MaxCount);  // may overflow v15

/* value */
v20 = malloc(v19 + 1);        // v19 unchecked
memmove(v20, Src, v19);       // may overflow v20
```

```c
/* patched fragment – after patch */
/* key */
char *kp = (char *)Buf;       // pointer captured before consume
size_t klen = MaxCount;
...
v15 = malloc(klen + 1);       // still +1 but klen validated earlier
memmove(v15, kp, klen);
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker controls an SSH server (or MITM) that the Windows client
   connects to.
2. During KEX, server sends SSH_MSG_EXT_INFO with:
     – counter <= 1023 (passes check)
     – first key length = 0xffffffffffffffff-3 (for instance)
3. ssh.exe reaches malloc(MaxCount+1) which wraps to 0, returning a
   pointer to a tiny block.
4. memmove copies MaxCount bytes, overflowing heap and corrupting
   adjacent structures.
5. Crafted payload in overflowed memory is used to hijack control flow
   and execute code with the privileges of the ssh.exe process.


Attack Vector
--------------------------------------------------------------------
Remote, authenticated attacker who can complete the SSH key-exchange
phase with a Windows client (local user launching ssh) supplies a
malicious EXT_INFO packet.  No additional local privileges are needed.


Patch Description
--------------------------------------------------------------------
The fix refactors variable usage:
• Stores the extension counter in an unsigned variable (v8) that is not
  re-used as a pointer.
• Captures the key pointer (v13) and length (v12) before the buffer is
  consumed, removing the time-of-check/time-of-use window that allowed
  the length to be manipulated.
• Uses an 8-byte temporary for the second sshbuf_peek_string_direct
  call, matching native pointer size and preventing accidental writes
  outside the stack buffer.
Collectively these changes guarantee that the length used for malloc()
exactly matches the data copied, preventing overflow.


Security Impact
--------------------------------------------------------------------
Successful exploitation yields arbitrary heap write primitive in
ssh.exe.  If the client is running elevated (e.g., launched by a
privileged Windows service or admin user) the attacker can execute code
with that level, resulting in local Elevation of Privilege.


Fix Effectiveness
--------------------------------------------------------------------
The refactored logic removes the integer-overflow condition and tightens
pointer/length handling, eliminating the mismatched allocation-vs-copy
window.  No alternative uncontrolled copy paths remain in the function;
therefore the patch fully mitigates the described attack vector.
