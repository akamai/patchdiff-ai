{'file': 'kerb3961.dll', 'kb': 'KB5055523', 'cve': 'CVE-2025-29809', 'change_count': 1, 'confidence': 0.46, 'patch_store_uid': '1046c3e0-8f07-4a33-b307-44e0c32001a6', 'date': 1751822617.1222458}
--------------------------------------------------------------------
CVE-2025-29809 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Kerberos – kerb3961.dll, routine
wil_details_FeatureReporting_RecordUsageInCache

Vulnerability Class
--------------------------------------------------------------------
CWE-922  Insecure Storage of Sensitive Information (logic flaw caused
by missing bounds check / index truncation)

Detailed Root Cause Analysis
--------------------------------------------------------------------
The function maintains an in-process bit-field cache that records
whether a given Kerberos feature (identified by the integer a3) has
already been reported.  For feature IDs >= 320 the code derives an
index into the second 32-bit word referenced by parameter a2:

    v7 = a3 – 320        // expected range 0-63 (6 bits)

Bits 5-10 of that word (mask 0x7E0) hold the cached index and bit 4
(0x10) marks it as valid.  The pre-patch code performs the range
inspection only inside

    if (v7 < 64)
        { …atomic update… }

but **crucially continues execution as if the cache operation had
succeeded even when v7 >= 64**.  Two problems follow:

1.  Index truncation – when v7 >= 64 the cast to unsigned __int16 and
    the multiplication by 32 (<<5) wrap the value, so an out-of-range
    feature ID is silently forced into a wrong 6-bit value, corrupting
    the cache field shared with other features.

2.  False "already cached" state – the function unconditionally sets
       *(a1+4) = 1   and
       *(a1+8) = a3
    marking the feature as handled even though the cache was not
    updated.  Subsequent calls therefore skip mandatory Kerberos
    security logic that depends on accurate usage recording, enabling
    a local attacker who can supply large feature IDs to bypass the
    feature-based security mechanism.

Affected parameters / structures
  a2 : points to the two 32-bit words holding the cache bit-field
  a3 : attacker-controlled feature ID; values >= 384 (v7 >= 64) trigger
       the flaw
  a1 : output status structure whose "already cached" flag is set
       incorrectly

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Pre-patch (excerpt)
if ((unsigned)(a3-6) >= 2)            // feature >= 8 or custom 320+
{
    v7 = a3 - 320;
    if (v7 < 64)                      // cache only when index < 64
    {
        /* atomic update of bits 5-10 and bit 4 */
    }
    // executed regardless of success of the above
    *(DWORD *)(a1+8)  = a3;
    *(DWORD *)(a1+4)  = 1;            // mark as already handled
    *(DWORD *)(a1+12) = a4;
    return a1;
}
```
```c
// Post-patch (excerpt)
if ((unsigned)(a3-6) >= 2)
{
    v7 = a3 - 320;
    if (v7 >= 64)                     // new guard – index out of range
        goto LABEL_FALLBACK;
    /* atomic update (unchanged) */
    if (!*(DWORD *)(a1+16))           // only if cache says "new"
LABEL_FALLBACK:
        {
            *(DWORD *)(a1+8)  = a3;
            *(DWORD *)(a1+4)  = 1;
            *(DWORD *)(a1+12) = a4;
        }
    return a1;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Kerberos caller supplies an out-of-range feature ID (a3 >= 384).
2. wil_details_FeatureReporting_RecordUsageInCache is invoked.
3. v7 >= 64 causes the atomic cache update to be skipped.
4. Pre-patch logic nonetheless flags the feature as cached and returns
   success.
5. Higher-level Kerberos code assumes the feature had been recorded and
   omits additional security-critical processing – security feature is
   bypassed.

Attack Vector
--------------------------------------------------------------------
Local attacker able to invoke Kerberos routines with crafted feature
IDs can continually supply values >= 384.  Because the feature will
never really be cached the security check depending on the cache can
be bypassed, allowing repeated use without detection.

Patch Description
--------------------------------------------------------------------
The fix introduces two defensive measures:
1. An explicit range check `if (v7 >= 64) goto fallback;` that prevents
   any attempt to encode an out-of-range index into the cache field.
2. The fallback path (which logs the feature as new) is now executed
   only when the cache update actually failed (`!*(a1+16)`), ensuring
   accurate state.

Security Impact
--------------------------------------------------------------------
Prior to the patch an attacker could corrupt the cache or trick the
caller into believing a feature was already recorded, thereby disabling
or bypassing Kerberos security controls tied to feature usage.  This is
classified as a security feature bypass with potential exposure of
sensitive Kerberos information.

Fix Effectiveness
--------------------------------------------------------------------
The added upper-bound check completely blocks the invalid index path
and guarantees that the cache flag is only set when the atomic update
succeeds.  No residual paths allowing v7 >= 64 to be cached exist in
the patched code, making the fix effective for this specific flaw.
