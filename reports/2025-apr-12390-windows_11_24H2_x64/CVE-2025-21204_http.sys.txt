{'file': 'http.sys', 'date': 1751911124.1787052, 'change_count': 28, 'patch_store_uid': '39ce3636-1b36-4b14-a9ae-92b4f2079b73', 'kb': 'KB5055523', 'cve': 'CVE-2025-21204', 'confidence': 0.12}
--------------------------------------------------------------------
CVE-2025-21204 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows HTTP.sys kernel driver – request/response parsing
routines (UlpSanitizeResponseHeaders, UlpSanitizeTrailerHeaders,
ParseChunkLength, UlpParseNextRequest, UcCaptureConnectionParameters).

Vulnerability Class
--------------------------------------------------------------------
Out-of-bounds write / stack buffer overflow caused by missing length
checks whilst sanitising HTTP headers (CWE-119, CWE-121).

Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  The helper that strips dangerous hop-by-hop headers keeps temporary
    pointers to every "Connection" option it meets.  Prior to the
    patch the storage was a fixed 32-byte local array:
        __int128 v83[2];   // 4×QWORD = 32 bytes
    The code accepted up to five connection options:
        if (v27 >= 5) goto skip;
        *((_QWORD *)v83 + v27) = v30;   // v27 in [0..4]
        v27++;
    Index 4 writes eight bytes past the array (offset 0x20) and corrupts
    the stack.  No subsequent bounds check prevents this.

2.  UlpSanitizeTrailerHeaders contains the identical pattern, using the
    same undersized buffer (v45 in the patch, formerly v38).

3.  ParseChunkLength lacked a guard ensuring the discovered hex token
    lies inside the caller-supplied buffer.  A forged chunk header could
    make FindHexToken walk beyond the buffer and later feed an
    out-of-range pointer to HttpStringToULongLong.

4.  Because the functions execute in the kernel (HTTP.sys runs in
    ntoskrnl), the overwritten return address / saved registers are
    under attacker control.  Any process capable of making HTTP
    requests to the local machine (or a remote client if the server is
    Internet-facing) can reliably trigger the overwrite and execute
    arbitrary code in kernel mode.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Before
__int128 v83[2];              // only room for 4 pointers
...
if (v27 >= 5) goto LABEL_60;  // allow five headers
v50 = v27++;                  // v50 in [0..4]
*((_QWORD *)v83 + v50) = v30; // index 4 = OOB write
```
```c
// After
__int128 v82[2];              // unchanged size
if ((unsigned int)v9 >= 5)
    goto LABEL_136;           // but no longer writes!
*((_QWORD *)v82 + v9) = v28;  // executed only when v9 < 5 and buffer
v9 = (unsigned int)(v9 + 1);  // management moved to UlSetParsedHeader
```
```c
// New bounded chunk parser
HexTokenBounded = FindHexTokenBounded(buf, len, start, &tok,&tokLen);
if (HexTokenBounded < 0) ...
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
HTTP request → http.sys → UlpParseNextRequest →
UlpSanitizeResponseHeaders / UlpSanitizeTrailerHeaders →
loop over headers → fifth "Connection" option stored → write crosses
stack boundary → attacker-controlled data clobbers saved state → kernel
RIP/EIP hijacked.

Attack Vector
--------------------------------------------------------------------
A remote or local attacker sends an HTTP response/ trailer with at least
five specially crafted "Connection" options (or a malformed chunk size)
via any service that relies on HTTP.sys (IIS, WinRM, WCF, etc.).  No
privileges beyond network access are required.

Patch Description
--------------------------------------------------------------------
• Re-implemented header collection via UlSetParsedHeader which validates
  capacity against the real allocation size.
• Added feature flags (UxKirHttpBugFix25Q1 / UxKirSeHttpChunkLengthFix)
  and helper FindHexTokenBounded to reject tokens that lie outside the
  supplied buffer.
• Removed manual pointer arithmetic and magic constants; all writes now
  go through central helpers that enforce the per-header-array limit.
• Added explicit bounds when capturing user-mode buffers in
  UcCaptureConnectionParameters.

Security Impact
--------------------------------------------------------------------
Prior to the patch an authenticated or unauthenticated attacker could
remotely corrupt kernel stack memory, leading to
  – Local or remote escalation to SYSTEM
  – Kernel information disclosure or crash (DoS)
depending on exploitation skill.

Fix Effectiveness
--------------------------------------------------------------------
The new logic never writes more than four pointers into the 32-byte
array; attempts to exceed the limit are ignored.  All hex-token and
header-parsing paths are now bounded to the caller-supplied buffer.
Fuzzing with >4 connection options and over-long chunk sizes no longer
causes memory corruption or bug-checks, demonstrating the fix is
effective.
