{'patch_store_uid': 'e061d126-b20f-43fa-89f5-f35342ceac9e', 'confidence': 0.11, 'change_count': 379, 'kb': 'KB5055523', 'file': 'win32kfull.sys', 'date': 1751822673.5201418, 'cve': 'CVE-2025-26681'}
--------------------------------------------------------------------
CVE-2025-26681 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows kernel-mode driver win32kfull.sys – graphics
sub-component that manages per-device font tables
(DEVICE_PFTOBJ::bLoadFonts).

Vulnerability Class
--------------------------------------------------------------------
Use-After-Free (CWE-416) caused by a multi-threaded race condition
that allows the same PDEV font table (PFF) to be created and freed
concurrently.

Detailed Root Cause Analysis
--------------------------------------------------------------------
Each graphics device (PDEV) keeps a list of PFF structures that
describe the fonts physically resident on that device.  The helper
routine
    DEVICE_PFTOBJ::bLoadFonts(HDEV)
was responsible for lazily loading this list:
  1. Take a semaphore locked at (SessionState + 96 + 4872).
  2. Search the per-PDEV hash for an existing PFF.
  3. If none was found allocate a new PFFMEMOBJ, call
     PFFMEMOBJ::bLoadDeviceFontTable(), then re-take the semaphore and
     insert the new object into the per-device hash list.
  4. Finally call PFFMEMOBJ::~PFFMEMOBJ(), which frees the underlying
     allocation unless it had previously been "kept" with
     vKeepIt().

The bug: the first semaphore is released *before* the expensive font
load takes place.  Nothing prevents a second thread from entering the
function, observing that no PFF exists yet, and performing the same
allocation.  When the two threads race back to the second semaphore
one of them wins and successfully inserts its PFF; the loser detects
that a PFF is now present and skips the insertion.  Because the loser
never calls vKeepIt() its temporary PFFMEMOBJ is destroyed, freeing
the memory.  However several fields from that freed allocation (most
importantly the FONTDIFF structures referenced via the PFF hash) were
already published globally during the load phase and are subsequently
reachable from kernel rendering paths.  Any later dereference of those
pointers results in a use-after-free of kernel pool memory.

Affected data:  PFF objects linked through *(PFF **) (SessionState +
96 + 4872) and every indirect structure reachable from the freed
PFFMEMOBJ (font directory entries, glyph bitmaps, etc.).

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Before patch – relevant fragments
SEMOBJ<17>::SEMOBJ<17>(&v22, v7 + 4872);
v8 = DEVICE_PFTOBJ::pPFFGet(this, v20, &v21);
SEMOBJ<17>::vUnlock(&v22);
if (!v8) {
    PFFMEMOBJ::PFFMEMOBJ((PFFMEMOBJ *)v19, ...);
    if (v19[0] && PFFMEMOBJ::bLoadDeviceFontTable((PFFMEMOBJ *)v19,v20)){
        SEMOBJ<17>::SEMOBJ<17>(&v22, v7 + 4872);
        if (!DEVICE_PFTOBJ::pPFFGet(this, v20, &v21))  // race window
            PFFOBJ::bAddHash((PFFOBJ *)v19, 0);
        SEMOBJ<17>::vUnlock(&v22);
    }
    PFFMEMOBJ::~PFFMEMOBJ((PFFMEMOBJ *)v19);  // frees loser’s object
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-mode → GDI API that ends up in
  GreDeviceLoadFonts → DEVICE_PFTOBJ::bLoadFonts()
Two or more caller threads pointing at the same HDEV run
concurrently:
  Thread A and thread B both pass the first pPFFGet() check, allocate
  separate PFFMEMOBJs, load the font tables and publish internal
  pointers.  Whichever thread loses the insertion race frees its
  PFFMEMOBJ while shared pointers still reference it → UAF.

Attack Vector
--------------------------------------------------------------------
A local, low-privilege process opens a printer/display device context
and spawns two threads that simultaneously invoke a font-triggering
GDI call (e.g., AddFontResourceEx/StartDoc).  With careful timing the
racing path frees pool memory that remains reachable from the global
PFF hash.  The attacker can then reclaim the freed pool with
controlled data and gain arbitrary kernel read/write leading to
elevation of privilege.

Patch Description
--------------------------------------------------------------------
The patched routine signature becomes
    bLoadFonts(HDEV, uint NumFonts)
Major hardening steps:
1. A per-device GOT_FONTS bit (0x40) in the PDEV flag field is set
   atomically using InterlockedCompareExchange.  The first thread that
   sets this bit becomes the *sole* loader; later callers bail out
   early.
2. The font count is now supplied explicitly (a3) so that secondary
   threads do not have to re-query device state while the first thread
   is loading.
3. Additional *Feature_H2E_WPA3SAE* checks and early exits are added
   to allow safe disablement.
4. Ref-counting logic stays, but PFFMEMOBJ is only destroyed when the
   object was never inserted, removing the double-free window.

Security Impact
--------------------------------------------------------------------
Before the patch an authenticated local attacker could reliably trigger
kernel-mode use-after-free, corrupting pool memory and executing
arbitrary code in ring-0, thereby escalating to SYSTEM.  The flaw is
rated Elevation of Privilege; remote exploitation is not required.

Fix Effectiveness
--------------------------------------------------------------------
Serialisation of font loading via an interlocked GOT_FONTS flag closes
the race, guaranteeing that at most one PFFMEMOBJ is created per
PDEV.  Subsequent callers operate on the already-initialised object
and no longer touch freed memory.  No alternative UAF path was
identified in the updated code, so the fix is considered effective.
