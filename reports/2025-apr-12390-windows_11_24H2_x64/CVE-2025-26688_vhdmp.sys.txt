{'date': 1751820800.6117198, 'file': 'vhdmp.sys', 'patch_store_uid': '6a876d1b-36cd-4e02-9ac4-9045a84bd776', 'confidence': 0.13, 'change_count': 3, 'cve': 'CVE-2025-26688', 'kb': 'KB5055523'}
--------------------------------------------------------------------
CVE-2025-26688 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Virtual Hard-Disk mini-port driver (vhdmp.sys).
The faulty code is located in the mirror-creation helper
VhdmpiInitializeMirror() and reached through the user-accessible
IOCTL path that initialises a VHD “mirror” file.  A secondary,
non-security-relevant change is present in VhdmpiDeleteVirtualDisk().


Vulnerability Class
--------------------------------------------------------------------
Stack-based Buffer Overflow (CWE-121).


Detailed Root Cause Analysis
--------------------------------------------------------------------
Input buffer a3 (size a4 bytes) is supplied by the caller and has the
following layout:
  DWORD  OffsetToPath;        // *a3
  DWORD  PathLengthBytes;     // a3[1]
  BYTE   Flags[?]             // *(BYTE *)a3+8 …
The driver copies this data into a local UNICODE_STRING that lives on
the kernel stack (variable v66/v68):

  *((QWORD *)&v66 + 1) = (char *)a3 + *a3;   // Buffer
  LOWORD(v66)           = *((WORD *)a3 + 2); // Length
  WORD1(v66)            = v66;               // MaximumLength = Length

Before the patch the only validation was
    if (a4 < 0xC || OffsetToPath < 0xC || PathLength == 0 ||
        a4 < OffsetToPath || a4-OffsetToPath < PathLength) fail; 
Critically, no check assured that PathLengthBytes is a multiple of two
or that a terminating L"\0" would fit.  If the caller supplies an odd
length value, the string is treated as WCHAR[PathLength/2] by
sub-routines such as VhdmpiCreateBackingStore() and lower Rtl‐string
helpers.  Those helpers append a wide NUL, writing two bytes past the
end of the stack buffer v66.  Because v66 sits next to other saved
registers and frame data, this off-by-two write corrupts the stack
frame and can be leveraged to hijack execution when the function
returns, yielding kernel-mode code execution.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// pre-patch excerpt (vhdmp.sys)
if (a4 < 0xC || (v19 = *a3, *a3 < 0xC) ||
    (v14 = a3[1]) == 0 || a4 < v19 || a4 - v19 < v14)
    goto fail;
...
*((_QWORD *)&v66 + 1) = (char *)a3 + *a3;   // Buffer
LOWORD(v66)            = *((_WORD *)a3 + 2); // Length (possibly odd)
WORD1(v66)             = v66;               // MaximumLength
```

```c
// patched validation
if (a4 < 0xC) goto fail;
oddSafe = Feature_IsEnabled();
pathOff = *a3;
pathLen = a3[1];
if (!oddSafe) {
    if (pathOff < 0xC || pathLen == 0) goto fail;
} else {
    if (pathOff < 0xC || pathLen == 0 || (pathLen & 1)) goto fail; // NEW
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User process opens a VHD handle and sends the IOCTL that eventually
   calls VhdmpiInitializeMirror().
2. The supplied buffer contains OffsetToPath = 0x10, PathLength = 0x15
   (odd) followed by crafted data.
3. Old validation accepts the buffer.
4. UNICODE_STRING is built on the stack with Length = 0x15.
5. Rtl-helpers append a wide NUL => write 2 bytes past v66.
6. On function epilogue the corrupted stack frame is used, allowing the
   attacker to redirect execution in kernel space -> privilege
   escalation.


Attack Vector
--------------------------------------------------------------------
Any local, authenticated user who can open the VHDMP device
(e.g. through the public CreateFileW("\\.\GlobalRoot\Device\Vhdmp...")
interface) can send the mirror-initialisation IOCTL with a crafted
parameter block to trigger the overflow and run arbitrary code in
kernel context.


Patch Description
--------------------------------------------------------------------
1. Added a feature-gated validation branch that rejects input when
   PathLengthBytes is zero OR not aligned to WCHAR (length & 1).
2. Refactored error-handling paths so the function aborts before the
   UNICODE_STRING is built.
3. Other changes are cosmetic (trace IDs, label renames) or relate to
   DvRundownWorkQueue in VhdmpiDeleteVirtualDisk and are not
   security-relevant.


Security Impact
--------------------------------------------------------------------
Prior to the patch a user-mode attacker could corrupt the kernel stack
from ring-3, leading to arbitrary execution in the Windows kernel and
full local elevation of privilege.


Fix Effectiveness
--------------------------------------------------------------------
The added length-alignment check completely blocks the malformed
buffers required for exploitation, and it is performed before the
unsafe UNICODE_STRING is created.  Provided no alternate path bypasses
Feature_2119187769__private_IsEnabledDeviceUsageNoInline(), the patch
is effective in preventing the stack overflow.

