{'date': 1751820822.6490295, 'patch_store_uid': '052ca79a-9638-4c9a-8db4-c867fa67de76', 'confidence': 0.19, 'kb': 'KB5055523', 'cve': 'CVE-2025-26686', 'change_count': 2, 'file': 'tcpip.sys'}
--------------------------------------------------------------------
CVE-2025-26686 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows kernel networking driver  (tcpip.sys) – IPv4/IPv6
routing/neighbor management routine IppRedirectPath.

Vulnerability Class
--------------------------------------------------------------------
Race-condition / use-after-free due to improper locking and reference
handling (also leads to double-dereference).

Detailed Root Cause Analysis
--------------------------------------------------------------------
IppRedirectPath is invoked when the stack processes an ICMP Redirect or
similar routing hint.  The routine locates the affected PATH structure,
fetches the corresponding NEIGHBOR object and, when required, replaces
the next-hop pointer inside the PATH.

Pre-patch logic manipulates these shared structures manually:
  1. It bumps the reference count of the new NEIGHBOR via
     IppReferenceNeighborEx().
  2. It acquires a *different* scalable lock that protects the ROUTE
     table, not the PATH itself.
  3. It calls IppSetNextHopInPathUnderLock() to overwrite the PATH
     field, then releases the lock.
  4. On many error paths it dereferences the same objects again.

Two fundamental problems follow from this design:

• Missing object-specific lock
  The PATH object’s own spin lock is never held while the next-hop
  pointer is replaced.  Concurrent readers obtaining the PATH from the
  route cache can race and obtain a pointer to the *old* NEIGHBOR after
  it has already been dereferenced (and possibly freed), yielding a
  dangling pointer that is subsequently used for packet processing.

• Unbalanced reference handling
  The code path labelled LABEL_25/LABEL_29 dereferences the PATH twice
  when v7 == Path (this happens whenever IppRouteToDestinationInternal
  returns the original path).  The double decrement drives the PATH
  refcount to zero prematurely, making the structure re-usable while it
  is still in active use by other CPUs.

Both issues allow controlled kernel memory corruption.  Because the
routine is reachable through attacker-supplied ICMP Redirect packets,
the flaw can be exploited remotely to execute arbitrary code in kernel
mode.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// pre-patch (simplified)
v21 = IppRouteToDestinationInternal(..., &v26); // v26 == new PATH
...
NextHopFromPath = IppGetNextHopFromPath(v26);
...
IppReferenceNeighborEx(NextHopFromPath, 1);
RtlAcquireScalableWriteLock(**(...)+832,&v30); // wrong lock
IppSetNextHopInPathUnderLock(Path, NextHopFromPath,0,v23);
KeReleaseInStackQueuedSpinLock(&v30);
...
IppDereferenceNeighbor(v27);          // ok
if (v7) IppDereferencePath(v7);       // may equal Path
...
IppDereferencePath(Path);             // second deref -> UAF
```

```c
// post-patch
IppUpdateNextHop(Path, NextHopFromPath); // atomic helper
...
IppDereferencePath(v7, ...);           // balanced
...
IppDereferencePath(Path, ...);         // single final deref
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker sends a crafted ICMP Redirect that forces the stack to call
   IppRedirectPath().
2. Routine finds existing PATH (Path) and concurrent traffic keeps a
   reference to it.
3. Redirect forces a next-hop change; old code swaps pointer without
   proper PATH lock and over-releases references.
4. Parallel CPU accesses freed PATH/NEIGHBOR memory, leading to heap
   corruption and controlled RIP/RSP when corrupted object is later
   dereferenced.

Attack Vector
--------------------------------------------------------------------
Unauthenticated remote attacker on the same network segment sends a
sequence of forged ICMP Redirect (IPv4) or Router Advertisement (IPv6)
messages crafted to race the PATH update logic.  No local privileges are
required.

Patch Description
--------------------------------------------------------------------
• Introduces new helper IppUpdateNextHop() that acquires the correct
  PATH-level lock, swaps the next-hop pointer atomically, and guarantees
  symmetrical reference counting.
• Removes hand-rolled RtlAcquireScalableWriteLock/KeRelease pair.
• Splits previously aliased variables ensuring each structure pointer
  (INTERFACE, PATH, NEIGHBOR) is kept in its own register.
• Adds feature gating code that rejects certain invalid next-hop
  pointers before they are referenced.

Security Impact
--------------------------------------------------------------------
Pre-patch race enables remote, kernel-mode use-after-free.  Successful
exploitation gives an attacker arbitrary code execution with SYSTEM
privileges (network-to-kernel RCE).  Denial-of-service is also trivial.

Fix Effectiveness
--------------------------------------------------------------------
The patch centralises pointer exchange in a vetted helper that holds the
correct lock and balances references, eliminating the observed race and
double dereference.  No residual paths to update next-hop remain in this
routine; however, other call-sites must use the same helper to guarantee
full mitigation.
