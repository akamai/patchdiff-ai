{'kb': 'KB5055523', 'change_count': 1, 'date': 1751828848.825399, 'confidence': 0.23, 'patch_store_uid': 'e3f743f4-49d3-4f66-a2b7-7ec0ad88441a', 'file': 'vmwp.exe', 'cve': 'CVE-2025-27491'}
--------------------------------------------------------------------
CVE-2025-27491 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Hyper-V worker process (vmwp.exe) – feature-usage reporting
helper  wil_details_FeatureReporting_RecordUsageInCache.

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use-After-Free caused by corrupted reference/validity cache.

Detailed Root Cause Analysis
--------------------------------------------------------------------
The helper wil_details_FeatureReporting_RecordUsageInCache stores a
feature-usage result into a two-DWORD, interlocked cache that is shared
by many Hyper-V worker threads (pointer a2).

For feature identifiers 320-383 the lower six bits of field 0x7E0 in the
second DWORD are supposed to hold (id-320); bit 0x10 marks the entry as
valid.  Before the patch the code only verified that (id-6) >= 2 and
then performed a *signed* comparison
    if ((int)id - 320 < 64)
which accepts *all* values smaller than 320 (negative result) as well as
any value whose distance from 320, when truncated to 16 bits, fits into
the six-bit field.  Out-of-range ids therefore reach the bit-packing
logic:
    new = v6 ^(((uint16)v6 ^ (uint16)(32*v5)) & 0x7E0) | 0x10;
where v5 = id-320.  When v5 is negative or >=64 the 32*v5 term is
undefined for the intended field width and arbitrary bits end up in
0x7E0.  Concurrent threads subsequently mis-interpret the cache as still
"valid" and skip re-initialisation of associated per-feature data
structures.  If those structures have already been freed by the first
thread, later code paths operate on dangling pointers – a classic
use-after-free that occurs in the Hyper-V worker context and is
reachable from guest-triggered feature reporting.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
v5 = a3 - 320;
if ((int)a3 - 320 < 64)              // accepts negative / huge ids
{
    v6 = *((DWORD *)a2 + 1);
    ...
}
*(_DWORD *)(a1 + 12) = 0;            // always mark success
```
```c
// after
v5 = a3 - 320;
if ((int)a3 - 320 >= 64)             // bail out when out-of-range
    goto LABEL_16;                   // fall back to safe path
...
if (!*(_DWORD *)(a1 + 16))           // only if first time
{
LABEL_16:
    *(_DWORD *)(a1 + 12) = 0;
    ...
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
VirtualMachine::ConstructGuestRam()
  -> MemoryManager::CreateRam()
    -> wil::details::FeatureImpl::ReportUsage()
      -> wil::details::ReportUsageToService()
        -> wil_details_FeatureReporting_RecordUsageInCache()
          (corrupts cache and frees structure)
        -> later worker thread rereads cache and uses freed memory.

Attack Vector
--------------------------------------------------------------------
An authenticated guest (or management API caller) can request feature
logging with a crafted identifier <320 or >383.  The malformed id is
forwarded through the above call chain, corrupts the shared cache, and
subsequent hypercalls executed by any VM cause a use-after-free inside
the host-side vmwp.exe process, enabling code execution across the VM
boundary.

Patch Description
--------------------------------------------------------------------
1. Added an upper-bound check: if ((int)id-320 >= 64) skip the bitfield
   update and fall back to the generic path (LABEL_16).
2. Moved the structure-initialisation code behind a conditional that
   only runs when the cache entry was *not* previously marked valid,
   preventing double-free/double-initialisation.
3. Renamed jump labels (cosmetic).

Security Impact
--------------------------------------------------------------------
Without the fix, out-of-range feature identifiers let an attacker corrupt
shared state and induce a use-after-free, leading to arbitrary code
execution in the privileged Hyper-V worker process and thus potential
host compromise from a guest VM.

Fix Effectiveness
--------------------------------------------------------------------
The explicit upper-bound guard entirely blocks ids outside 320-383 from
reaching the bit-packing logic, eliminating the state corruption path.
Coupled with the new first-time check, double-free conditions are also
closed.  No other routes to the vulnerable code were modified, so the
patch appears complete for this specific flaw; nevertheless adjacent
range checks should be reviewed for similar signed/unsigned issues.
