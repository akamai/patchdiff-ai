{'confidence': 0.12, 'date': 1751820861.4459474, 'change_count': 22, 'cve': 'CVE-2025-27742', 'kb': 'KB5055523', 'file': 'ntfs.sys', 'patch_store_uid': '3b4551f8-8bc9-41c0-91d2-3ade95d85ce9'}
--------------------------------------------------------------------
CVE-2025-27742 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
ntfs.sys – functions NtfsCheckRestartTable() and ReadRestartTable().
Both are part of the NTFS log-file ( $LogFile ) recovery code that
parses the on-disk Restart Table contained in every Restart Log
Record.

Vulnerability Class
--------------------------------------------------------------------
Out-of-Bounds Read / Missing bounds check (CWE-125).

Detailed Root Cause Analysis
--------------------------------------------------------------------
The Restart Table header (pointed to by parameter a1) contains the
following relevant fields:
  +0000  USHORT  EntrySize        (size of each table entry)
  +0002  USHORT  EntryCount       (number of allocated entries)
  +0004  USHORT  FirstFree        (offset OR index of first free)
  +0006  USHORT  Flags            (bit0 == INDEX_MODE)
  +0018  DWORD   FreeListHead     (offset OR index of first free)
  +0020  DWORD   FreeListTail     (offset OR index of last  free)
  +0024  ENTRY[] Table entries

If Flags & 1 is clear, the list fields contain byte offsets inside the
same buffer; when the bit is set they contain 1-based indexes that must
be converted to an offset with   offset = EntrySize*(idx-1)+24.

NtfsCheckRestartTable() validates most header fields and every ENTRY
value, but the original code performs *no* validation on the variable
"j" *before* dereferencing it while following the singly-linked free
list:

    for (j = Header->FreeListHead; j; j = *(DWORD*)((BYTE*)Header + j))
        ...

An attacker can forge FreeListHead (or a subsequent link field) so that
"j" is larger than the size of the mapped Restart Table.  The first
iteration will therefore read 4 bytes from an address that lies past
the end of the caller-supplied buffer (kernel heap or pool).  Because
this buffer resides in kernel address space, the access constitutes an
out-of-bounds read that discloses kernel memory content.  The read
value is later surfaced back to user mode through NTFS error reporting
or crash dumps, fulfilling the information-disclosure scenario.

The same unchecked walk is reachable from ReadRestartTable(), which
extracts the table from the on-disk $LogFile during mount or recovery
and directly forwards the caller-controlled buffer to
NtfsCheckRestartTable().  No privileges beyond the ability to modify
raw disk data are required.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – unchecked dereference inside list walk
for ( j = *((unsigned int *)a1 + 4); (_DWORD)j;          
      LODWORD(j) = *(_DWORD *)((char *)a1 + j) )
{
    if ( (_DWORD)j == -1 ) { *a3 = 65; return 0; }
    if ( v10 )                                // index mode
        j = (unsigned int)*a1 * (j - 1) + 24; // no bounds check!
}

// after patch – bounds verified on every hop
for ( j = *((unsigned int *)a1 + 4); ; j = *(unsigned int *)((char *)a1 + j) )
{
    if (!j) return 1;
    if (j == 0xFFFFFFFF) { *a3 = 65; return 0; }

    if (Feature_2225344826__private_IsEnabledDeviceUsageNoInline()) {
        if (IndexMode) {
            if (j > EntryCount) { *a3 = 63; return 0; }
            j = EntrySize*(j-1)+24;
        } else {
            if (j > TableEnd || j < 0x18 || (j-24)%EntrySize) {
                *a3 = 64; return 0; }
        }
        continue;
    }
    /* fallback – still re-checks before use */
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. ReadRestartTable()
   – maps a Restart Log Record from $LogFile.
2. Calls NtfsCheckRestartTable(ptr_to_table, size, status_out).
3. NtfsCheckRestartTable() enters free-list loop and dereferences an
   attacker-controlled offset without first checking bounds.
4. Kernel reads 4 bytes beyond the supplied buffer, leaking memory.

Attack Vector
--------------------------------------------------------------------
A local attacker with raw write access to an NTFS volume (e.g. through
PhysicalDrive, removable media, or a crafted VHD) crafts a malicious
$LogFile containing a Restart Table with an oversized FreeListHead/
link value.  When Windows mounts the volume or runs chkdsk, the kernel
parses the log record and triggers the out-of-bounds read, disclosing
kernel memory contents.

Patch Description
--------------------------------------------------------------------
The update introduces per-hop validation of the free-list pointer
("j"):
  • For INDEX_MODE tables: verify j <= EntryCount before converting
    it to a byte offset.
  • For OFFSET_MODE tables: ensure j is within [0x18, TableEnd] and is
    aligned to EntrySize.
Only after these checks does the code dereference or transform the
value.  Validation can be dynamically enabled through
Feature_2225344826__private_IsEnabledDeviceUsageNoInline().  The caller
(ReadRestartTable) was also adjusted to pass the correct pointer types
and jump target.

Security Impact
--------------------------------------------------------------------
Prior to the fix, specially crafted on-disk data allowed an
out-of-bounds 4-byte read from arbitrary kernel addresses located
immediately after the allocated Restart Table buffer.  The leaked data
could be returned to user mode through NTFS diagnostic paths, resulting
in an information-disclosure vulnerability (CVE-2025-27742).  A crash
was also possible if the address crossed an invalid page boundary.

Fix Effectiveness
--------------------------------------------------------------------
The added range and alignment checks guarantee that every dereference
remains inside the validated Restart Table buffer, removing the OOB
read.  Because the checks are executed on every pointer hop, chains of
malicious links are also covered.  The only residual risk would be if
systems explicitly disable the associated feature flag, but the flag is
enabled by default; otherwise, the patch fully mitigates the flaw.
