{'change_count': 45, 'patch_store_uid': 'bd09f57b-d0cd-49a1-b8f0-74513dc775f1', 'file': 'shellhost.exe', 'cve': 'CVE-2025-27729', 'kb': 'KB5055523', 'confidence': 0.24, 'date': 1751822689.5779955}
--------------------------------------------------------------------
CVE-2025-27729 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Shell – shellhost.exe, specifically the interaction between
wWinMain() and UXFrameHelpers::HandleCommandLineLaunch().

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use-After-Free (dangling pointer reused as a HANDLE).

Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  In wWinMain the stack variable  “Str” is first used to point to a
    heap buffer returned by wil::GetModuleFileNameW().
2.  Inside the *WaitForDebuggerPresent* loop the buffer is released with
        CoTaskMemFree(Str);
    yet the variable is **not** nulled.
3.  Execution later proceeds to the legacy UX Frame launch path:
        UXFrameHelpers::HandleCommandLineLaunch(&Str, lpCmdLine);
4.  Because Str still contains the freed address, the callee observes a
    non-NULL value and treats it as a HANDLE:
        v6 = *a1;                   // stale pointer
        CloseHandle(v6);            // closes random memory
5.  The freed buffer is thus re-freed through CloseHandle(), producing a
    dangling HANDLE/memory situation.  Subsequent code in wWinMain

        WaitForSingleObject(Str,…);
        CloseHandle(Str);

    dereferences the same stale value again, completing the
    use-after-free window and enabling attacker-controlled memory reuse.
6.  Because the stale pointer comes from a heap allocation whose content
    is partly influenced by the command line, an attacker can steer the
    freed address to overlap with controlled data and pivot execution.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// wWinMain – before patch
if ( Str )                     // 1. free the buffer
    CoTaskMemFree(Str);
...
UXFrameHelpers::HandleCommandLineLaunch(&Str, lpCmdLine);  // 2. pass dangling ptr
...
WaitForSingleObject(Str, INFINITE); // 3. reuse after free
```
```c
// UXFrameHelpers – before patch
v6 = *a1;                      // stale pointer from wWinMain
if ( (char *)*a1 - 1 <= 0xFFFFFFFFFFFFFFFD )
{
    LastError = GetLastError();
    CloseHandle(v6);           // double–free / wrong free
    SetLastError(LastError);
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
wWinMain()
  └── WaitForDebugger* loop frees Str    → dangling pointer
  └── UXFrameHelpers::HandleCommandLineLaunch(&Str,…)
          └── CloseHandle(Str)           → double-free of heap block
  └── WaitForSingleObject(Str,…)
  └── CloseHandle(Str)                  → use-after-free on same value

Attack Vector
--------------------------------------------------------------------
Any mechanism that launches *shellhost.exe* with the legacy
"UXFrameHost" command line while Feature_MDW is enabled (and
Feature_SWT_2 is **disabled**) causes the vulnerable path to execute.
A malicious local or remote actor can manipulate heap state around the
freed buffer so that the stale address refers to attacker-controlled
memory, leading to arbitrary code execution in the context of the
current user.

Patch Description
--------------------------------------------------------------------
•  A new feature flag **Feature_SWT_2** is introduced.  When it is
   enabled, wWinMain diverts to an entirely new command-line parsing
   implementation (large CLI::App based code) that never reuses the
   freed *Str* pointer.
•  UXFrameHelpers::HandleCommandLineLaunch() now contains

       if (Feature_SWT_2) FailFast();

   making the legacy helper unreachable once the flag is turned on.
•  No direct changes were made to the faulty CloseHandle() logic; the
   fix relies on **removing all legitimate callers** under the new
   configuration.

Security Impact
--------------------------------------------------------------------
Prior to the patch an attacker could achieve local code execution (and,
via crafted files/links, remote code execution) with the privileges of
ShellHost by exploiting the dangling pointer/handle.  Successful
exploitation bypasses standard Windows security boundaries.

Fix Effectiveness
--------------------------------------------------------------------
The patched build effectively neutralises the vulnerability **when
Feature_SWT_2 is enabled by default**, because the vulnerable code is no
longer reachable and will terminate the process if called.  However, the
underlying bug still exists in the legacy helper; if the flag is ever
turned off the issue resurfaces.  Complete remediation would require
eliminating the variable reuse or nulling *Str* before reuse rather than
feature-gating.
