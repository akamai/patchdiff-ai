{'change_count': 94, 'kb': 'KB5055523', 'cve': 'CVE-2025-29811', 'date': 1751822668.372384, 'confidence': 0.33, 'patch_store_uid': '92fd4486-d861-4f02-897b-83c4b31ee84e', 'file': 'mbbcx.sys'}
--------------------------------------------------------------------
CVE-2025-29811 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Mobile Broadband Class Driver (mbbcx.sys) – multiple status
handler and utility routines that translate MBIM/NDIS TLVs coming from
user-mode, the modem firmware, or the bus into WWAN structures that are
returned to callers or indicated to NDIS.

Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow caused by improper input validation / integer
overflow (CWE-122, CWE-125, CWE-20).

Detailed Root Cause Analysis
--------------------------------------------------------------------
All vulnerable paths share the same bug pattern.  Variable-length TLVs
are parsed without validating that the advertised element count and
length fields can be trusted.  The original code calculates the size of
an output buffer as
   required = fixed_header + element_count * element_size
and immediately allocates memory:
   ExAllocatePool2( NonPagedPoolNx, required & 0xFFFFFFFF , TAG );

Missing checks allow ‘required’ to wrap past 0xFFFFFFFF or to be larger
than the caller-supplied a5 buffer.  After the undersized allocation the
code moves element_count * element_size bytes into the buffer, corrupting
adjacent pool memory.  Examples from the diff:
   v21 = 12 * count;                   // provider blacklist
   if (v21 > 0xFFFFFFFF) goto error;   // added in patch

   v20 = 80 * providers + 16;          // provider lists
   if (v20 > 0xFFFFFFFF) goto error;   // added in patch

   *a7 += *(_DWORD*)(tlv+4);           // context state TLV length was
                                       // added after allocation

Functions fixed:
 • MbbNdisNetworkBlacklistHandler
 • MbbNdisSignalStateStatusHandler
 • MbbNdis*ProviderStatusHandler (Home/Preferred/Visible/MultiCarrier)
 • MbbUtilValidateAndMbbToWwanContextStateEx (V2 / EX3)
 • MbbNdisPacketServiceStatusHandlerHelper (v3+)
 • MbbUtilMbbToWwanSmsReceive
etc.

Patching adds:
 • 64-bit length arithmetic and explicit ‘> 0xFFFFFFFF’ guards
 • a5 (incoming length) re-checked against computed size
 • MbbIsVariableFieldValid() calls for every variable field
 • Early error returns (-1073676267 / STATUS_INVALID_PARAMETER)
 • Feature flag gating (IsEnabledDeviceUsageNoInline) to block the whole
   parser when fuzzing protection is on.

Without these checks, any caller able to supply crafted TLVs (e.g. a
compromised broadband modem or a local admin via IOCTL_NDISUIO) can make
the driver write past the end of a NonPaged pool buffer while running in
kernel context.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
v21 = 12i64 * a4[1];                  // bytes for blacklist entries
Pool = ExAllocatePool2(NonPagedPoolNx, v21+20, TAG);
...
memmove(pool+offset, src, v21);       // overflow if v21 wrapped

// after
v21 = 12i64 * a4[1];
if (v21 > 0xFFFFFFFF || (int)v21+20 < v21 || a5 < v21+20)
    goto error;
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User / modem supplies crafted MBIM TLV ➜ miniport raises
NdisMIndicateStatusEx ➜ mbbcx.sys status handler (e.g.
MbbNdisNetworkBlacklistHandler) ➜ internal utility (e.g.
MbbUtilValidateAndMbbToWwanContextStateEx) ➜ undersized pool allocation
➜ memcpy/memmove using attacker-controlled length ➜ pool corruption.

Attack Vector
--------------------------------------------------------------------
Local privileged code (or a malicious USB/LTE modem) that can send MBIM
commands or NDIS status indications to mbbcx.sys.  No kernel privileges
are required; the overflow happens in the driver while processing the
attacker-controlled TLVs.

Patch Description
--------------------------------------------------------------------
• All length calculations switched to 64-bit and compared against
  0xFFFFFFFF before casting to 32-bit.
• Added bounds checks:  aggregated_length < element_length, a5 >= needed
  size, element_count sanity, TLV header minimums.
• Added calls to MbbIsVariableFieldValid for every variable field.
• If any check fails the function now returns STATUS_INVALID_PARAMETER
  and indicates a benign 32-byte status buffer instead of continuing.
• Defensive feature gate
  Feature_GE_MBIM_FUZZING_BUGFIXES__private_IsEnabledDeviceUsageNoInline
  can disable the parser entirely.

Security Impact
--------------------------------------------------------------------
Before the patch a local attacker could trigger kernel heap overflows and
out-of-bounds reads in mbbcx.sys, leading to denial-of-service (bugcheck)
or elevation of privilege in the Windows kernel (CVE-2025-29811, AV:L/
AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H score 7.8).

Fix Effectiveness
--------------------------------------------------------------------
The patched code stops processing when any size calculation would wrap
or exceed the caller-supplied buffer and never copies more data than the
allocated buffer can hold.  All previously unsafe paths now return an
error before allocation or copy, preventing the overflow.  No remaining
integer-truncation paths were observed in the modified functions.