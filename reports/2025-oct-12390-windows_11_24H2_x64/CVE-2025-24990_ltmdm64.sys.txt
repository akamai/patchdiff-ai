{'date': 1763406111.3739612, 'file': 'ltmdm64.sys', 'confidence': 0.13, 'cve': 'CVE-2025-24990', 'change_count': 5, 'patch_store_uid': '2ef9587d-d12e-4efa-97f8-9cdcd571719c', 'kb': 'KB5066835'}
--------------------------------------------------------------------
CVE-2025-24990 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
ltmdm64.sys – 64-bit Agere / Lucent soft-modem kernel driver that ships
with Windows.  The vulnerable routine is SerialGetConfigDefaults()
invoked from the driver’s DriverEntry() path.


Vulnerability Class
--------------------------------------------------------------------
CWE-822: Untrusted Pointer Dereference (leads to kernel-mode memory
corruption / EoP)


Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  The original SerialGetConfigDefaults() prototype is

        __int64 SerialGetConfigDefaults(char *Dst, const void **a2)

    The function expects two parameters:
      • RCX – pointer to an internal SERIAL_DEFAULTS structure that is
        zero-initialised and then filled.
      • RDX – pointer to a UNICODE_STRING-like object (assumed to be the
        driver’s registry path).  The code treats it as:
            Length  = *(WORD *)a2;            // offset +0
            Buffer  = (void *)a2[1];          // offset +8

2.  In DriverEntry() the function is invoked **with only one argument**:

        SerialGetConfigDefaults(&driverDefaults);

    Therefore RDX is *not* initialised by the caller and instead holds
    whatever value happened to be in that register at the time of the
    call.  From the callee’s point of view this value is trusted and is
    immediately dereferenced.

3.  Inside SerialGetConfigDefaults() the bogus RDX value is used to
    compute the following:

        SIZE_T v4 = *(WORD *)a2 + 2;                // pool size
        PVOID p   = ExAllocatePoolWithTag(..., v4); // allocate
        memmove(p, a2[1], *(WORD *)a2);             // copy attacker ptr

    a2[1] is treated as the buffer pointer and *(WORD *)a2 is treated as
    the length.  Because the contents of RDX are under attacker control
    an unprivileged user can steer the kernel to:

      • Read arbitrary user-mode or kernel-mode memory (source)
      • Write that data into kernel pool (dest)
      • Later dereference the newly-filled pool when building the RTL
       _QUERY_REGISTRY_TABLE array

4.  No attempt is made to verify that RDX points to valid, kernel-mode
   memory or that the length is sane.  The driver therefore performs an
   *untrusted pointer dereference* and copies an attacker-controlled
   amount of data, creating a classic kernel memory corruption / info-
   disclosure primitive that can be leveraged for privilege escalation.

5.  Because the vulnerable path executes during driver load, controlling
   RDX is as easy as preparing the register state immediately before the
   NtLoadDriver() system call returns.  A normal user who can load the
   built-in driver (possible on many systems due to mis-set ACLs or by
   abusing existing services) gains arbitrary kernel read/write.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Vulnerable function before patch (excerpt)
SIZE_T v4 = *(unsigned __int16 *)a2 + 2;          // length from attacker
PVOID Pool = ExAllocatePoolWithTag(PagedPool, v4, 'COMX');
...
memmove(Pool, a2[1], *(unsigned __int16 *)a2);    // copy from ptr in a2
```
```c
// Call site – missing the second argument
SerialGetConfigDefaults(&driverDefaults);         // RDX is attacker-set
```
```c
// After patch – function body replaced
void _security_init_cookie()
{
    if (!_security_cookie || _security_cookie == 0x2B992DDFA232)
        __fastfail(6);
    _security_cookie_complement = ~_security_cookie;
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker prepares CPU register RDX to point to controlled memory and
   loads ltmdm64.sys (e.g., via Service Control Manager).
2. DriverEntry() calls SerialGetConfigDefaults(&driverDefaults).
3. SerialGetConfigDefaults() trusts RDX, reads attacker length/ptr and
   performs unchecked memmove() into kernel pool.
4. Corrupted pool contents are later parsed, yielding arbitrary kernel
   R/W or a subsequent crash, enabling elevation of privilege.


Attack Vector
--------------------------------------------------------------------
Any local user capable of triggering the loading of the native
ltmdm64.sys driver (e.g., via the Fax service or by installing an Agere
modem) can supply crafted register context so that RDX references
attacker-controlled user memory when the vulnerable routine is reached.
No special privileges are required beyond the ability to start the
service/driver.


Patch Description
--------------------------------------------------------------------
Microsoft chose to *remove the vulnerable driver entirely* instead of
surgically fixing the bug:

1. SerialGetConfigDefaults() was wiped and replaced with
   _security_init_cookie() – a stub that only validates the GS cookie.
2. DriverEntry_0 now calls this new stub; internal cookie logic was
   centralised.
3. The main DriverEntry() implementation was replaced by a stub that
   immediately returns STATUS_INVALID_DEVICE_REQUEST (-0x4000000C).
4. __report_gsfailure() was hardened to invoke __fastfail() instead of
   KeBugCheckEx(), ensuring an immediate fail-fast rather than a blue
   screen.
5. Net effect: ltmdm64.sys can no longer be loaded, making the attack
   surface unreachable on supported Windows builds.


Security Impact
--------------------------------------------------------------------
Prior to the update an unprivileged local attacker could dereference an
arbitrary pointer in kernel context, leading to pool memory corruption,
information disclosure, and ultimately elevation to SYSTEM.  Successful
exploitation provides full kernel privileges.


Fix Effectiveness
--------------------------------------------------------------------
By stubbing out the vulnerable code and preventing the driver from
loading, the patch removes every reachable code path that contained the
untrusted pointer dereference.  Because the module now fails during
initialisation, the vulnerable routine cannot execute, fully mitigating
CVE-2025-24990.  No residual attack surface remains unless an attacker
can restore an older, vulnerable copy of ltmdm64.sys and bypass Windows
Driver-Signature Enforcement, which is outside the threat model of this
update.

