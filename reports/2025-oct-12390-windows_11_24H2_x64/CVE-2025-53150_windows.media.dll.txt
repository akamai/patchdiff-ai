{'confidence': 0.27, 'cve': 'CVE-2025-53150', 'file': 'windows.media.dll', 'kb': 'KB5066835', 'patch_store_uid': '0f2e33f7-3143-4f1b-8865-2b030f23c6e2', 'change_count': 160, 'date': 1763406141.4376204}
--------------------------------------------------------------------
CVE-2025-53150 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows – Media Foundation / windows.media.dll
( Adaptive Streaming – CMFSourceBufferManager class )


Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use-After-Free
CWE-362: Race Condition / Missing Synchronisation


Detailed Root Cause Analysis
--------------------------------------------------------------------
CMFSourceBufferManager owns one or two cached pointers to the current
IMFAdaptiveMediaStreamVariant object ( members
  • m_dwReferencePointEpoch
  • m_fInsideBufferFillingTask )
These members keep only a *raw* interface pointer.

The public helper
  GetCurrentStreamVariant(IMFAdaptiveMediaStreamVariant **ppVar)
returned one of those raw pointers directly:
  * no AddRef was taken
  * no lock was held while the field was read

While one thread was retrieving the pointer, another thread could
concurrently enter code paths such as
  • TrySetTimeStampOffsetForDiscontinuity()
  • NotifyMainSourceBufferFlushed()
that overwrite/Release() the same member fields.  This left the caller
with a dangling IMFAdaptiveMediaStreamVariant*.  Subsequent vtable
access by the caller dereferenced freed memory – classic UAF.  Because
Media Foundation runs inside privileged service processes (e.g.
BroadcastDVRServer, AudioSvc), a carefully-crafted media stream could
co-ordinate the race and pivot the UAF into an elevation of privilege.

The absence of reference counting and critical-section protection is
the root cause; the race window starts immediately after the raw
pointer is read and lasts until the caller either AddRefs it (never
happened) or is finished using it (undefined lifetime).


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before (pseudo, decompiled)
*ppStreamVariant = this->m_dwReferencePointEpoch ?
                    (IMFAdaptiveMediaStreamVariant*)this->m_dwReferencePointEpoch :
                    (IMFAdaptiveMediaStreamVariant*)this->m_fInsideBufferFillingTask;
// no AddRef, no lock
return S_OK;
```
```c
// after
EnterCriticalSection(&this->m_xOnLowMemoryRetryTimer);
*ppStreamVariant = nullptr;
...
if (this->m_dwReferencePointEpoch)
{
    InternalAddRef(&(this->m_dwReferencePointEpoch));
    *ppStreamVariant = (IMFAdaptiveMediaStreamVariant*)this->m_dwReferencePointEpoch;
}
...
LeaveCriticalSection(...);
return hr;
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User data triggers asynchronous playback changes.
2. Thread A calls GetCurrentStreamVariant() and receives non-AddRef’d
   pointer.
3. Thread B flushes or seeks (NotifyMainSourceBufferFlushed /
   TrySetTimeStampOffsetForDiscontinuity) and releases the variant.
4. Thread A continues to use freed object – UAF.


Attack Vector
--------------------------------------------------------------------
Local attacker supplies specially crafted adaptive streaming media and
controls timing (seek, flush, buffer-switch) to win the race.  The
attacker needs code execution in an unprivileged media client process
but can escalate to the service account hosting the MF pipeline.


Patch Description
--------------------------------------------------------------------
• Entirely replaced GetCurrentStreamVariant:
  – Acquires m_xOnLowMemoryRetryTimer critical section.
  – Always zero-initialises *ppStreamVariant.
  – Takes an InternalAddRef on whichever cached pointer is returned.
  – Releases the lock before returning.

• Related functions augmented to use the same lock and to reset
  m_ullWaitForContinuityKey to eliminate stale pointers.

• Extensive WIL feature gates added but the core safety fix is the
  AddRef + critical-section pair.


Security Impact
--------------------------------------------------------------------
Before the patch an authenticated local attacker could cause media
foundation code to dereference freed memory, achieving arbitrary code
execution inside a higher-privilege process, leading to elevation of
privilege (EoP).  Memory corruption is process-wide; system
compromise is possible.


Fix Effectiveness
--------------------------------------------------------------------
The new implementation closes the race window by:
  1. Serialising access with a critical section.
  2. Incrementing the COM reference count before returning the
     pointer, guaranteeing object lifetime to the caller.
No residual path returns an unreferenced pointer, therefore the UAF
condition is removed.  Patch is judged effective provided all callers
respect COM reference conventions.
