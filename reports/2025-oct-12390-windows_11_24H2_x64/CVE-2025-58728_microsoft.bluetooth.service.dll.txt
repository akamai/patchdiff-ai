{'patch_store_uid': '2050fd76-c48f-4b6a-8213-cb0e4e18e962', 'date': 1763403059.459626, 'change_count': 92, 'confidence': 0.19, 'kb': 'KB5066835', 'file': 'microsoft.bluetooth.service.dll', 'cve': 'CVE-2025-58728'}
--------------------------------------------------------------------
CVE-2025-58728 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Bluetooth Service (microsoft.bluetooth.service.dll).  The
affected routines belong to the WinRT implementation used by
BluetoothAdvertisementPublisher-related objects.


Vulnerability Class
--------------------------------------------------------------------
Use-After-Free / Dangling Reference (CWE-416).


Detailed Root Cause Analysis
--------------------------------------------------------------------
Several WinRT getter helpers exposed internal COM objects without
proper reference management:

1.  GapAdvertisementPublisherStatusChangedArgsImpl::
    get_FixedDeviceAddress()
2.  GapAdvertisementPublisherStatusChangedArgsImpl::
    get_SetRequestGUID()
3.  RuntimeClassImpl<…>::GetWeakReference()

Before the patch the two *get_* methods simply copied an internal
ComPtr (stored in the object at offsets 0xB0..0xC0 and 0xC8..0xD8) to
the caller-supplied pointer:

    *a2 = this[11];            // no AddRef

The caller owns the returned IReference<> and will Release() it.
Because the service did **not** AddRef, the last Release() frees the
object that is still cached inside the service instance.  Subsequent
service activity (for example inside
GapAdvertisementPublisherRequestStatus::Update or later status
notifications) re-uses that dangling pointer, yielding a classic
use-after-free.

GetWeakReference() had a different but related bug.  The vtable entry
was pointing to a completely unrelated helper
(wil::details::FeatureImpl::GetCachedFeatureEnabledState).  That code
assumed a totally different object layout and performed arbitrary
bit-wise updates (_InterlockedAnd / _InterlockedCompareExchange) on the
first DWORDs of the Bluetooth runtime object.  This corrupted the
cached weak-reference slot at offset +0x30 and could leave a freed
Microsoft::WRL::Details::WeakReferenceImpl object referenced from the
instance, again leading to UAF when another thread dereferenced the
weak reference.

Key data involved
  - this+0x30 / this+0x48 : cached IWeakReference pointer/flag field
  - this+0xB0..0xD8      : ComPtr holding IReference<GapRemoteAddress>
                           and IReference<GUID>
  - flag bytes at +0xB0+10, +0xC8+18 indicating presence of a value

The absence of AddRef() and the vtable mismatch made the lifetime of
these internal COM objects unsynchronised with the external reference
count expected by WinRT, enabling controlled memory re-use inside the
bluetooth service process.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// pre-patch get_SetRequestGUID
if (!a2) return E_POINTER;
*a2 = this[11];      // raw pointer leak, no AddRef
return S_OK;

// pre-patch RuntimeClassImpl::GetWeakReference (actually wrong body)
*(_QWORD *)a2 = 0;
int state = *(_DWORD *)a1;            // interprets bluetooth object as WIL data
// … manipulates the first 32 bits, potentially clearing ref flags …
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Low-privilege code obtains IGapAdvertisementPublisher-related event
   args from the bluetooth WinRT API.
2. Calls FixedDeviceAddress() or SetRequestGUID().
3. Service copies out the internal pointer without AddRef and returns
   it to the client.
4. Client releases the returned interface; refcount reaches zero and
   the underlying IReference object is freed.
5. Later, while processing
   GapAdvertisementPublisherRequestStatus::Update(), the service
   accesses the cached pointer, now pointing to freed memory.
6. Carefully timed heap grooming lets the attacker place controlled
   data at that address, achieving code execution in the bluetooth
   service (running as LocalSystem), hence Elevation of Privilege.


Attack Vector
--------------------------------------------------------------------
Local.  Any sandboxed or ordinary user that can interact with the
Windows Runtime bluetooth APIs can trigger the faulty getter and free
the object at will.


Patch Description
--------------------------------------------------------------------
The update introduces correct lifetime handling:

1. Both *get_* methods now
   • validate the presence flags,
   • call WRL::Make<Nullable<…>> / MakeReferenceGUID() to create a **new
     IReference** instance,
   • AddRef() the created object before returning, and
   • release internal temporary pointers correctly.
2. GetWeakReference() was entirely replaced.  The new code
   • creates a WeakReferenceImpl with CreateWeakReference(),
   • writes it to the instance’s cache slot using an
     InterlockedCompareExchange64 with a high-bit marker,
   • handles the existing cached reference path with
     SafeUnknownIncrementReference(), ensuring the weak reference stays
     alive.
3. Additional argument/flag validation was added to
   GapAdvertisementPublisherRequestStatus::Update() to avoid operating
   on partially initialised structures.


Security Impact
--------------------------------------------------------------------
Prior to the patch, a local attacker could reliably trigger a
use-after-free in the bluetooth service, re-allocate the freed memory
with attacker-controlled contents, and hijack control-flow inside a
LocalSystem process, resulting in privilege escalation.


Fix Effectiveness
--------------------------------------------------------------------
The patch converts raw pointer returns into properly reference-counted
objects and rewrites the weak-reference caching logic with atomic
safety.  No further code paths returning internal ComPtrs without
AddRef were observed in the provided diffs.  Provided the new object
creation helpers are correct, the specific UAF is eliminated.  A full
audit of similar getters in other Gap* classes is still recommended.
