{'cve': 'CVE-2025-55686', 'file': 'printworkflowservice.dll', 'patch_store_uid': 'cfbf7ece-1a89-464d-80de-2d625e11c5f0', 'date': 1763403040.8584487, 'confidence': 0.27, 'kb': 'KB5066835', 'change_count': 76}
--------------------------------------------------------------------
CVE-2025-55686 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows PrintWorkflowUserSvc – specifically the in-process COM
implementation inside printworkflowservice.dll that exposes the
PrintSupportSettingsBroker, PrintSupportSession and related helper
classes (LaunchSettingsUIForPrinterAsync, Get*PrintTicket, CloseView,
SetPrintSupportSettingsProcessId, GetTempFileForConversionAsync, …).


Vulnerability Class
--------------------------------------------------------------------
Use-After-Free / Dangling-state access (CWE-416)


Detailed Root Cause Analysis
--------------------------------------------------------------------
The broker keeps a single byte flag stored at +0x0D8 (shown in the
listing as *(_BYTE *)(object + 216)).  The flag becomes TRUE only after
LaunchSettingsUIForPrinterAsync successfully marks the object as
"active" and allocates several subordinate resources:
  • window-handles and modal-experience manager objects
  • hstring buffers that hold the current / modified print ticket
  • SRWLOCK-protected structures that reference the caller’s process
    and temp files.

Before the patch the following public methods never verified that the
object had reached the active state and therefore assumed that all
pointers were valid:
  • GetCurrentPrintTicket()
  • SetModifiedPrintTicket()
  • SetPrintSupportSettingsProcessId()
  • CloseView()
  • PrintSupportSessionCommon::GetTempFileForConversionAsync()

If an attacker invoked any of those APIs on a new
PrintSupportSettingsBroker instance *before* calling
LaunchSettingsUIForPrinterAsync, the methods would dereference members
that were still uninitialised (or had already been released after a
previous session) leading to use-after-free on:
  – hstring at +0x070 (current ticket)
  – window-manager IUnknowns at +0x038 / +0x020
  – SRWLOCK-protected ticket structures at +0x038 / +0x050
  – process/event handles at +0x098 etc.

Because the service runs as LOCAL SERVICE while the attacker controls
the broker object through the UWP Print Support extension interface, a
UAF gives controlled pointers inside the privileged process.  In
practice the attacker can replace the freed memory with a fake vtable
and achieve LOCAL SERVICE code-execution.


Vulnerability Code Snippets
--------------------------------------------------------------------
Before (no state check):
```c
// GetCurrentPrintTicket
winrt::hstring::hstring(a2, (const winrt::hstring*)(this + 0x70));
```
After (added validation):
```c
if (FeatureEnabled && !*((BYTE*)this + 0xD8))
    wil::details::in1diag3::Throw_Hr(..., 0x8000000E);
```
Similar guard was added to SetModifiedPrintTicket, CloseView,
SetPrintSupportSettingsProcessId and several coroutine resumes.


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker obtains IPrintSupportSettingsBroker COM pointer from the
   service.
2. Calls GetCurrentPrintTicket() (or any other vulnerable method)
   *without* first launching the settings UI.
3. Method dereferences uninitialised member; memory has been freed or
   never allocated.
4. Service follows dangling pointer and executes attacker-supplied
   memory → privilege escalation.


Attack Vector
--------------------------------------------------------------------
Local, authenticated user owning a Print Support extension can talk to
PrintWorkflowUserSvc over the documented WinRT interfaces.  No
additional privileges are required.


Patch Description
--------------------------------------------------------------------
1. Introduced a gating byte at offset +0xD8 that represents
   "BrokerInitialised".  LaunchSettingsUIForPrinterAsync now sets the
   flag to 1 on success and clears it on cleanup.
2. Every externally reachable method starts with:
      if (FeatureEnabled && !BrokerInitialised)
          Throw_Hr(E_INVALIDARG /*0x8000000E*/)
   This prevents any access to internal members when the object is in
   an invalid lifecycle stage.
3. Added extensive HRESULT checking and size/overflow validation in
   coroutine helpers and temp-file creation path.
4. Increased object size (from 0x240 to 0x330/0x3D0 bytes) to keep new
   guard members and bookkeeping fields.


Security Impact
--------------------------------------------------------------------
Prior to the fix a malicious extension could achieve Local Elevation of
Privilege by triggering a use-after-free inside the service’s
high-integrity process.  Successful exploitation yields code execution
in the PrintWorkflowUserSvc context (NT AUTHORITY\LOCAL SERVICE).


Fix Effectiveness
--------------------------------------------------------------------
The added flag check is present in every entry point that previously
dereferenced broker fields.  Any attempt to call them out of order now
results in an immediate, fail-fast HRESULT 0x8000000E, eliminating the
UAF.  No remaining unguarded paths were observed in the supplied
patch; therefore the fix is technically sound.
