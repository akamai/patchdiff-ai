{'date': 1763407822.32426, 'file': 'win32k.sys', 'cve': 'CVE-2025-55679', 'change_count': 10, 'patch_store_uid': '8c8b659d-3011-4601-8c41-fcbe9438b8d5', 'kb': 'KB5066835', 'confidence': 0.23}
--------------------------------------------------------------------
CVE-2025-55679 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
win32k.sys  –  ApiSet host-resolution helpers and session-attach      
helper functions (ApiSetpGetContractKeyInfo, ApiSetpResolveHost,     
W32*AttachToSession*  family, Win32kKernelExportsSet).

Vulnerability Class
--------------------------------------------------------------------
Improper Input Validation leading to out-of-bounds read /            
information disclosure (CWE-20, CWE-200).

Detailed Root Cause Analysis
--------------------------------------------------------------------
1. User mode passes a UNICODE contract-name buffer and length to the 
   win32k internal routine ApiSetpResolveHost().  This routine in    
   turn calls ApiSetpGetContractKeyInfo() to split the name into     
   <host>  <version> and <locale> components.                        

2. In the unpatched ApiSetpGetContractKeyInfo the algorithm walks    
   the buffer backwards using                                          
        v9  = (BYTE*)a1 + 2*a2;  // points AFTER last WCHAR          
        do { v9 -= 2; ... } while (...)                              
   to search for delimiters ‘-’, ‘.’ or ‘~’.                          
   The loop terminates only when a delimiter is encountered OR a     
   separate counter (v11) under-flows to zero.  No check ensured     
   that at least one delimiter exists in the supplied string.        

3. For inputs that contain none of the expected delimiters, or are   
   shorter than the minimum length ( <5 WCHAR ), v9 is decremented   
   past the start of the user buffer.  The code then dereferences    
   *v9 and other positions (v14 / v12 in the listing) that now point 
   into win32k address space, effectively reading arbitrary kernel   
   memory.  The collected bytes are copied into the caller-supplied  
   output structure (a4 / a7) which is returned to user mode through 
   ApiSetpResolveHost, leaking the stale kernel contents.            

4. Similar lack of range checking existed in several session-attach  
   helpers (W32AttachToSessionAndExecute_*) where the SessionId       
   provided by user space was trusted.  An attacker could supply a   
   value larger than the real session table, causing the kernel to   
   index outside the gSessionGlobalSlots array and disclose          
   arbitrary data while computing call-outs.                         

5. Win32kKernelExportsSet accepted a size parameter a3 but tested    
   only for non-zero.  When the caller lied about the size being 1   
   (eight bytes) while supplying a 128-bit OWORD pointer, the second 
   half of the kernel pointer was copied from uninitialised memory   
   and potentially leaked later.                                     

Parameters / structures affected:                                    
   • ApiSet CONTRACT_KEY_INFO (a4) – fields 12..24 filled with       
     garbage from kernel space.                                      
   • gSessionGlobalSlots[]  – indexed with unchecked SessionId.      
   • Global variable KernelExports written with partially            
     initialised data.                                               

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before – ApiSetpGetContractKeyInfo (excerpt)
while (1) {
    v9 -= 2;              // moves BEFORE user buffer if no '-' found
    v14 = *v9;            // OOB read
    --v11;               // length counter wraps
    if ((_BYTE)v14 != 45) break;  // exit condition depend on data
}
...
*(_WORD *)(a4+18) = a2;   // trust potentially corrupted indices
```
```c
// after – tightened validation
v4 = a2;                  // keep original length
if (a2 < 5) return 0;
...
if (a2 <= 1u) return 0;   // stops under-flow
...
if (a2 > 7u && ... )      // extra pattern and length checks
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-mode syscall (e.g. win32k!NtUserResolveApiSet)                  
 -> ApiSetpResolveHost()                                            
    -> ApiSetpGetContractKeyInfo(userBuffer, userLen, &KeyInfo)     
       ‑--   unchecked backward scan causes kernel memory read       
    -> ApiSetpResolveHost copies KeyInfo into caller buffer (a7)     
 -> Leaked kernel bytes now in user space.                           

Attack Vector
--------------------------------------------------------------------
A local, low-privileged process passes a crafted short or            
delimiter-free UNICODE contract string (or an oversized SessionId)   
via a win32k system call that ultimately reaches                     
ApiSetpGetContractKeyInfo / session-attach helpers, forcing the      
code to read past the caller-controlled buffer and return kernel     
memory to the process.  No special privileges are required.          

Patch Description
--------------------------------------------------------------------
1. ApiSetpGetContractKeyInfo:                                        
   • Formal parameter changed to raw 64-bit pointer for clarity.     
   • Introduced v4 to preserve original length and multiple length   
     guards before every decrement.                                  
   • Added explicit "a2 <= 1" / "a2 > 4" / 
     "a2 >= 5" checks to stop pointer under-flow.                  
   • Added pattern-verification code (checking for "MS-" etc.) and   
     wrote additional safe-guards into the output structure.         
   • Zero-initialised a4+32 and other tail fields.                   

2. ApiSetpResolveHost:                                               
   • Re-implemented hashing using new helper ApiSetpGetSearchKeyHash
     which receives the sanitised key structure.                     
   • Rejects section index unless SessionId < W32GetMaxSessionCount.

3. Win32kKernelExportsSet: now requires size >=2 (16 bytes) before   
   copying an OWORD into KernelExports.                              

4. All W32AttachToSessionAndExecute_* helpers and                    
   W32SessionAttachAndCalloutDispatch:                               
   • Call W32GetMaxSessionCount() and bail out when SessionId is     
     outside the table;                                              
   • Constant tag changed to runtime value 1198682965;               
   • Numerous variables renamed and zeroed for robustness.           

Security Impact
--------------------------------------------------------------------
Prior to the patch a local attacker could obtain contents of         
win32k heap and neighbouring kernel memory, bypassing KASLR,         
building reliable exploits, or disclosing sensitive data belonging   
to other processes.  The flaw does not grant direct code execution   
but materially lowers the barrier for further kernel compromise.     

Fix Effectiveness
--------------------------------------------------------------------
The added bounds checks ensure the scanning pointer never crosses    
buffer limits and that supplied SessionIds are below the maximum     
allowed.  Global copy operations now verify size arguments.  No      
additional leakage paths are visible in the patched code segment;    
therefore the fix is judged complete for the reported scenario.      
Future regressions remain possible if new delimiters are introduced  
without corresponding length validation.                             

