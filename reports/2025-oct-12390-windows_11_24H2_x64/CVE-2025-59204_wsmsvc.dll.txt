{'cve': 'CVE-2025-59204', 'confidence': 0.22, 'change_count': 4, 'file': 'wsmsvc.dll', 'date': 1763406125.7751846, 'kb': 'KB5066835', 'patch_store_uid': '57b2a4c2-b625-46a0-9077-70590f2a26f0'}
--------------------------------------------------------------------
CVE-2025-59204 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Management Services (wsmsvc.dll).  Affected routines are
multiple wil::details::FeatureImpl<...>::GetCurrentFeatureEnabledState
instantiations and the corresponding ReportUsage helper that prepare
and return feature-state bitmasks.

Vulnerability Class
--------------------------------------------------------------------
CWE-908: Use of Uninitialized Resource / Variable leading to
information disclosure.

Detailed Root Cause Analysis
--------------------------------------------------------------------
Each GetCurrentFeatureEnabledState<T>() template builds a 32-bit
feature-state word that is returned to the caller via an *output
parameter* (a2).  The original implementations zeroed the destination
( *a2 = 0 ) but constructed the final bitmask using *uninitialized
stack variables* that were conditionally assigned.  Two independent
issues are visible:

1.  Uninitialized flag variables
    a)  v8 / v6 (TestLabVal)
    b)  v12 (TestGateImp)
    c)  v9 / v10 / v12 (UxLabTest)

    In several control-flow paths these locals were read before they
    were written.  They were then OR-ed into the result or tested when
    deciding whether to clear bit 10 (0x400).  Consequently, up to
    four bytes of stack data leaked to the caller.

2.  Uninitialized reporting buffer
    FeatureImpl<T>::ReportUsage() built a small struct on the stack
    (v9/v10) and passed it to wil::details::ReportUsageToService().
    When the feature had not yet been cached ( *a1 & 4 == 0 ) the
    helper copied an eight-byte return value into the same local
    buffer but never initialised the remaining fields.  Those leftover
    bytes were transmitted to the usage-tracking service.

Data involved
  * 32-bit feature state word returned to the management caller.
  * Two-byte reporting flags handed to ReportUsageToService().

Because the code runs inside the Windows Remote Management service
context, stack data from wsmsvc.dll threads could be disclosed to any
local process that is able to query feature state or trigger usage
reporting.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// TestGateImp – before
char v12; // si        // <-- never initialised if (v9&0xC00)!=3072
...
if ( v12 && !v10 )
    *(_DWORD *)a2 &= ~0x400u;   // uses indeterminate v12
```

```c
// TestLabVal ReportUsage – before
__int16 v10;  // not initialised
...
return ReportUsageToService(
        a1 + 2,
        54237977i64,
        ((unsigned int)v4 >> 10) & 1,
        ((unsigned int)v4 >> 11) & 1,
        &v9,          // &v9 contains v10
        v6,
        0);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. External code (e.g. WinRM client or local COM consumer) calls into
   wsmsvc to query a WIL feature state or records usage.
2. wsmsvc.dll::GetCurrentFeatureEnabledState<T>() executes the buggy
   logic and copies uninitialised flag bits into the output parameter.
3. The caller receives the 32-bit value or causes the service to send
   a usage packet that contains the uninitialised bytes.
4. The leaked stack content can be read back by the attacker.

Attack Vector
--------------------------------------------------------------------
Local.  Any authenticated local user capable of invoking the Windows
Management service API that queries feature state or usage reporting
can receive the uninitialised data.

Patch Description
--------------------------------------------------------------------
Microsoft removed all conditionally initialised locals and replaced
them with deterministic values:

* Variables that previously carried indeterminate data are now
  declared as int and initialised to 0 (v6, v7, v10, etc.).
* Bit 0 (valid flag) is always set in the returned state word
  ( *a2 = v7 | v8 | 1 ).
* Entire decision trees relying on v12 or similar flags were deleted.
* ReportUsage() now:
  - Receives a64-bit boolean constant instead of caller-provided flag.
  - Fully initialises the two-byte state (v9 = 3; v8 = 0).

Security Impact
--------------------------------------------------------------------
Prior to the patch, up to four bytes of stack memory from the
wsmsvc.dll thread could be disclosed per API call, potentially
revealing pointers or other sensitive data useful for ASLR bypass or
further exploitation.  Because the service runs with NETWORK SERVICE
privilege the leak crosses a privilege boundary, qualifying as an
information-disclosure vulnerability.

Fix Effectiveness
--------------------------------------------------------------------
The diff shows explicit initialisation of every previously
unconditional local, elimination of dead flags, and guaranteed setting
of the validity bit.  All observed code paths now write fully defined
values before they are read or returned, making the fix effective for
these particular template instantiations.  No evidence is available
regarding other, non-patched instantiations; if any exist they should
be reviewed separately.
