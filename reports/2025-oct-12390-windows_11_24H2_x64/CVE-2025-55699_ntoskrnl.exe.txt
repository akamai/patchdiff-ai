{'file': 'ntoskrnl.exe', 'kb': 'KB5066835', 'cve': 'CVE-2025-55699', 'patch_store_uid': 'c1b97b38-6328-4043-8cf8-12e6eafee863', 'date': 1763407861.858766, 'confidence': 0.25, 'change_count': 222}
--------------------------------------------------------------------
CVE-2025-55699 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows NT kernel – Plug-and-Play subsystem (ntoskrnl.exe)
Function: PnpValidatePropertyData, responsible for validating user
supplied registry-style data that is passed in PnP property IOCTLs.

Vulnerability Class
--------------------------------------------------------------------
Out-of-bounds read leading to kernel information disclosure.
(CWE-125 / results in CWE-200)

Detailed Root Cause Analysis
--------------------------------------------------------------------
1. PnpValidatePropertyData receives:
   • psz  – pointer to caller-supplied buffer that contains a value of
             type REG_SZ / REG_MULTI_SZ / REG_EXPAND_SZ, etc.
   • SecurityDescriptorLength (cb) – length of the buffer in bytes.
   • a3   – property type/flags (upper nibble 0x2000 == string types).

2. For string types the original code entered the branch beginning at
   label 17:
      while ( *(_WORD*)psz )            // ❶ dereference first WORD
      {
          /* calculate remaining size */
          /* scan for terminating NUL */
          /* advance psz past the NUL */
      }

3. The loop advanced the psz pointer blindly by the computed length
   plus two bytes and then immediately re-evaluated `*(_WORD*)psz`.
   If the last string inside the user buffer was missing the required
   trailing NUL (or was only partially present), psz became equal to
   cb (end-of-buffer).  The very next iteration dereferenced
   *(_WORD*)psz (❶) which now lies beyond the caller-controlled
   allocation.

4. Because the access is a kernel read, the function leaks the first
   16-bit value that happens to reside past the end of the buffer.  By
   supplying a length that ends exactly at the boundary an attacker can
   read arbitrary adjacent kernel memory until a zero word is hit.

5. The function later copies, returns, or otherwise makes decisions
   based on the over-read data, enabling an authorised local attacker
   to disclose uninitialised kernel memory, bypass KASLR, or trigger a
   crash.

6. Patch converts the manual scan to RtlStringCbLengthW, which takes
   the remaining buffer size and fails if a terminator is not found
   within that bound, removing the out-of-range dereference.

Key structures / fields affected:
   REG_MULTI_SZ / REG_SZ validation path (v10 == 0x2000)
   psz pointer and cb length parameter.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
while ( *(_WORD *)SecurityDescriptor )               // OOB ❶
{
    ...
    SecurityDescriptor += 2 * (v28 >> 1);            // advances to end
}
```
```c
// after
while ( *(_WORD *)psz )
{
    if (RtlStringCbLengthW((PCWSTR)psz, cbRemaining, &len) < 0)
        return STATUS_INVALID_PARAMETER;
    ...
    psz = (PWSTR)((PBYTE)psz + len + 2);             // only if safe
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-mode
  SetupDiSetDeviceProperty / CM_Set_DevNode_Property
    ↓ issues IOCTL to the device stack
Kernel
  PiSetDevicePropertyData
    → PnpValidatePropertyData (vulnerable)
      → OOB read if buffer is missing final NUL terminator

Attack Vector
--------------------------------------------------------------------
A local, non-admin attacker that can call PnP property APIs or craft a
custom IRP_MJ_PNP request supplies a REG_MULTI_SZ buffer whose last
string is not terminated.  When the kernel validates the buffer it
reads past the caller’s allocation and discloses adjacent kernel
memory.

Patch Description
--------------------------------------------------------------------
• Function signature changed to take a 64-bit aligned pointer.
• Manual UTF-16 scanning logic removed.
• Added RtlStringCbLengthW with explicit remaining-length argument –
  provides built-in bounds checking.
• Additional size checks (<= 0xFFFE) and early returns added.
• Edge cases consolidated under the new helper Feature gate paths.

Security Impact
--------------------------------------------------------------------
Prior to the patch a specially crafted PnP property request could cause
ntoskrnl to read beyond a user-supplied buffer, leaking uninitialised
kernel memory to user mode or crashing the system.  The issue is
classified as an information disclosure vulnerability (CVE-2025-55699)
with local attack scope.

Fix Effectiveness
--------------------------------------------------------------------
The patched code no longer performs unchecked pointer arithmetic; every
string length is now calculated through RtlStringCbLengthW, which fails
if the terminator is outside the remaining buffer.  Therefore the out-
of-bounds read path is closed.  No residual risk is evident unless
future changes bypass the helper or mis-calculate the remaining size.
