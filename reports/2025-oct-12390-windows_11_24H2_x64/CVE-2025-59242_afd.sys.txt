{'confidence': 0.08, 'cve': 'CVE-2025-59242', 'patch_store_uid': 'd18657ac-5d16-40b0-bfc8-644001aeac77', 'change_count': 51, 'kb': 'KB5066835', 'file': 'afd.sys', 'date': 1763407965.0166388}
--------------------------------------------------------------------
CVE-2025-59242 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Ancillary Function Driver for WinSock (afd.sys)
Function affected: AfdBuildPacketChain (also related stub function
KnrNrpGetAddressInfoW)  
Driver versions prior to the June-2024 security update.

Vulnerability Class
--------------------------------------------------------------------
Heap-based Buffer Overflow (CWE-122) caused by 32-bit integer wrap /
underflow while computing the size of a kernel-mode heap allocation
(CWE-191).

Detailed Root Cause Analysis
--------------------------------------------------------------------
AfdBuildPacketChain builds an MDL/packet list for a transmit IRP.  It
iterates over user-supplied 24-byte buffer descriptors and may copy
several consecutive user buffers into one kernel buffer that is
obtained from AfdGetBuffer().

1.  For every new segment the code accumulates the total length in the
    32-bit variable v61 and finally calculates

        v52 = (v5 ? v61 : 0) + v12;   // v52 is ULONG (32-bit)

    v52 is the value passed as the ‘Length’ argument to
    AfdGetBuffer().

2.  If the attacker supplies more than 0xFFFF_FFFF bytes in total, the
    addition silently wraps to a small positive 32-bit value, so the
    allocation is far smaller than the amount of data that will later
    be copied.

3.  Immediately afterwards the routine performs

        memmove(dst, src, v12);          // copy current segment
        ... (loop) ...                   // copy previous segments

    The copy length is taken from the un-truncated 64-bit segment
    fields (v12/v61), therefore more bytes are written than the pool
    block really owns, corrupting adjacent heap structures in the
    non-paged pool.

4.  No bounds check exists after the wrap occurs; the error code (v3)
    is only stored but execution continues, so the overflow always
    happens once the size rolls over.

5.  Because afd.sys runs with SYSTEM privileges, corrupting pool data
    enables a local attacker to gain arbitrary code execution in
    kernel mode.

A second contributing bug in KnrNrpGetAddressInfoW truncated 64-bit
pointer-sized arguments to 32-bit integers when forwarding the request
into the RPC runtime.  Although not directly responsible for the
overflow, this mismatch could be used to craft descriptors whose
length fields exceed 4 GB and trigger the wrap in step 1.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable (pre-patch)
ULONG v52 = (v5 != 0 ? v61 : 0) + v12;   // 32-bit addition may wrap
Buffer = AfdGetBuffer(v52, 0, FsContext[6], 1);
...
memmove(v27, *(const void **)(v11 + 8), v12);   // copy > v52 bytes
```
```c
// fixed (post-patch)
ULONG v51 = (v5 ? v60 : 0) + v12;        // length still ULONG but
                                         // earlier code now tracks
                                         // sizes in 64-bit (v60)
Buffer = AfdGetBuffer(v51, 0,
                      *((_QWORD *)FsContext + 6), 1);
// additional 64-bit validation against MmUserProbeAddress added
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Unprivileged process issues `WSASend()` / `TransmitFile()` with a
   crafted AFD
tpacket array whose cumulative size exceeds 4 GB.
2. afd.sys receives the IRP and enters AfdBuildPacketChain.
3. Length accumulation overflows 32 bits; a small kernel buffer is
   allocated.
4. memmove() copies the full user data into this undersized buffer,
   overrunning heap metadata.
5. Corrupted pool structures are later used by the kernel, enabling
   code execution in ring-0.

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker.  Any user that can open a Winsock
socket can supply the malicious transmit request; no special
privileges are required.

Patch Description
--------------------------------------------------------------------
1. Re-typed many size and pointer variables from 32-bit to 64-bit.
2. Added explicit 64-bit checks against `MmUserProbeAddress` before any
   user data copy.
3. Removed indirect dereference of `MmUserProbeAddress` to prevent
   stale pointer misuse.
4. Updated `KnrNrpGetAddressInfoW` prototype to use 64-bit pointer
   types and switched to `Ndr64AsyncClientCall`, eliminating pointer
   truncation.
5. Reworked reference counting with `_InterlockedIncrement64` to avoid
   use-after-free during error unwinding.

Security Impact
--------------------------------------------------------------------
A successful exploit gives kernel-mode (SYSTEM) code execution from an
unprivileged account, thereby allowing complete machine compromise.
The vulnerability is therefore classified as Elevation of Privilege.

Fix Effectiveness
--------------------------------------------------------------------
With 64-bit arithmetic the size parameter cannot wrap, and the added
range checks ensure any attempt to exceed user-space limits is caught
before the copy occurs.  Because the buffer size now always matches
(or exceeds) the amount that is copied, the heap overflow vector is
eliminated.  No alternative path to trigger the original condition is
visible in the patched code.
