{'patch_store_uid': '4982c2f6-66f9-4775-8788-70d40239f49e', 'confidence': 0.25, 'date': 1763406132.367911, 'file': 'windows.networking.connectivity.dll', 'kb': 'KB5066835', 'change_count': 4, 'cve': 'CVE-2025-59201'}
--------------------------------------------------------------------
CVE-2025-59201 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Networking Connectivity run-time (windows.networking.connectivity.
dll) – more precisely the in-proc COM server class
Windows::Networking::Connectivity::ConnectionProfileServer that backs the
public WinRT API  IConnectionProfile.GetNetworkConnectivityLevel().  The
helper WIL feature-gate routines that live in the same module are also
touched by the patch.

Vulnerability Class
--------------------------------------------------------------------
Improper Access Control / Local Privilege-Escalation (CWE-284)

Detailed Root Cause Analysis
--------------------------------------------------------------------
The vulnerable routine was
   Windows::Networking::Connectivity::ConnectionProfileServer::
   GetNetworkConnectivityLevel().
The method executes inside the Network Connection Status Indicator (NCSI)
service, which runs with SYSTEM privileges, but it is callable by any
local user through the WinRT broker.

Prior to the patch the implementation tried to obtain the active network
interface through several private COM interfaces that are *supplied by the
caller* via IAgileReference members stored inside the ConnectionProfile
object:
   •  m_networkInterface2AgileRef
   •  m_networkInterfaceAgileRef

The old code resolved those AgileReferences directly (Resolve()) and then
blindly dereferenced the resulting interface pointers.  Afterwards it
called a long chain of privileged helper methods such as
INetworkConnectionProfilePrivate::GetName(), GetState(), etc., and even
released/free’d the memory that the untrusted object returned (CoTaskMem-
Free, Release).

No impersonation, capability check, or parameter validation was performed
before executing the privileged COM calls.  Therefore a low-privileged
client could craft an arbitrary IAgileReference that points to an
attacker-controlled COM object.  When the server resolved that reference
it would execute attacker-supplied COM code in the SYSTEM context, giving
a direct elevation-of-privilege primitive.

Secondary risk: By returning fake heap buffers the attacker could also
coerce the service into double-free or arbitrary-free conditions through
the unguarded CoTaskMemFree/Release paths that were executed after the
privileged call chain.

The auxiliary WIL feature helper functions were not the primary root
cause, but they also performed unchecked 64-bit writes to an *int* buffer
and have been simplified by the patch.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
ptr = this->m_networkInterface2AgileRef.ptr_;
connectedProfile.ptr_ = 0;
ptr->Resolve(ptr, &IID_INetworkConnectionProfilePrivate, (void**)&connected);
...
networkInterface.ptr_->GetState(networkInterface.ptr_, &interfaceState);
CoTaskMemFree(networkInterface.ptr_);      // free of attacker memory
...
```

```c
// after (completely removed)
// The whole AgileRef resolution block is gone.  The method now queries
// WCM through an internal handle obtained with HandleManager::GetWcmHandle
// and never touches caller-controlled COM objects.
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Low privilege client obtains a ConnectionProfile object.
2. Client embeds a malicious IAgileReference pointing to a controlled COM
   object that implements INetworkConnectionProfilePrivate.
3. Client invokes GetNetworkConnectivityLevel().
4. Service (SYSTEM) resolves the AgileReference, runs attacker COM code,
   and performs privileged operations (state queries, frees, releases)
   against attacker-supplied data.
5. Attacker’s code executes with SYSTEM rights.

Attack Vector
--------------------------------------------------------------------
Any local user or sandboxed AppContainer that can call the publicly
available WinRT API IConnectionProfile.GetNetworkConnectivityLevel() can
inject a crafted ConnectionProfile instance and reach the vulnerable
server-side code path.  No additional privileges are required.

Patch Description
--------------------------------------------------------------------
1. Entire AgileReference-resolution branches were **deleted**.  The method
   now:
   • obtains connectivity data strictly through the internal WCM handle via
     WcmQueryParameter(),
   • avoids all caller-supplied COM interfaces,
   • short-circuits enormous amounts of legacy / obsolete code.
2. The helper FeatureImpl::<...>::GetCurrentFeatureEnabledState() routines
   were rewritten and their parameter types corrected; numerous telemetry
   and reporting calls were removed to eliminate unsafe memory writes.

Security Impact
--------------------------------------------------------------------
Before the fix a non-privileged process could execute arbitrary COM code
inside the NCSI service and therefore elevate to SYSTEM.  Additionally,
forced CoTaskMemFree/Release on attacker buffers allowed memory-corruption
primitives that could also be weaponised for EoP.

Fix Effectiveness
--------------------------------------------------------------------
By completely removing the ability to resolve caller-controlled
IAgileReference objects and by obtaining connectivity information only via
trusted internal APIs, the attack surface is closed.  Unless other paths
re-introduce unguarded AgileReference resolution, the patch is considered
effective against the described privilege-escalation vector.
