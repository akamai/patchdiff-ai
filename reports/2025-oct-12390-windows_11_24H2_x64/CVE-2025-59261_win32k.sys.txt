{'change_count': 10, 'patch_store_uid': '8c8b659d-3011-4601-8c41-fcbe9438b8d5', 'kb': 'KB5066835', 'cve': 'CVE-2025-59261', 'file': 'win32k.sys', 'confidence': 0.13, 'date': 1763403132.4001718}
--------------------------------------------------------------------
Unknown-CVE Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
win32k.sys  (Windows Graphics / Session-management and call-out helper
routines)

Vulnerability Class
--------------------------------------------------------------------
Time-of-check Time-of-use (TOCTOU) race condition leading to out-of-
bounds session indexing and unintended process attachment which
results in local elevation of privilege.

Detailed Root Cause Analysis
--------------------------------------------------------------------
Several helper paths that dispatch user-mode originated “call-out”
requests first free the caller-supplied DD_SURFACE_LOCAL structure with
EngFreePrivateUserMem_0(), then immediately reuse data that had been
stored in that same object (most importantly the SessionId cast to
unsigned int).  Because the memory is released **before** the value is
consumed, another thread running in the same process can win the race
and re-allocate or otherwise alter that memory.  The stale, attacker
controlled SessionId is subsequently used as an index into the global
session slot tables (gSessionGlobalSlots / gLowSessionGlobalSlots) and
is also passed to
    W32GetReferencedSessionProcessWithTag(sessionId, …)
which returns a KPROCESS pointer that the kernel blindly trusts.  The
pointer is later fed to KeStackAttachProcess / KeUnstackDetachProcess
so that arbitrary code is executed in a process context chosen by the
attacker.  Because no attempt was made to ensure that the supplied
SessionId is inside the valid range, a forged value could:
  • exceed the number of configured sessions and index past the end of
    gSessionGlobalSlots (OOB read/write)
  • reference a session that is in the middle of tear-down, bypassing
    normal synchronisation (use-after-free)
Both cases allow a local, already authenticated user to execute kernel
code in a more privileged session, effectively escalating privileges
inside the kernel.

The race starts at the first instruction after the
EngFreePrivateUserMem_0() call in functions such as
  • W32AttachToSessionAndExecute__lambda_*  (four separate lambdas)
  • W32SessionAttachAndCalloutDispatch()
  • W32AttachToSessionAndExecute__lambda_2da4d1…()

Once the free has happened, the following sensitive values are still
consumed:
  v3  = (unsigned int)a1   // session id copied from freed object
  v6-v7 / *a2              // callout parameters inside freed buffer
No locks are held while those variables are reused.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – W32AttachToSessionAndExecute lambda
v3 = (unsigned int)a1;
EngFreePrivateUserMem_0(a1, a2);          // memory released
if ( v3 == v4 ) {                         // TOCTOU: v3 now stale
    …
    v6 = *a2;                             // also taken from freed mem
    v7 = *(fnptr)(…);
    if ( v7 ) v7(v6);                     // executes in chosen session
}

// after patch – part of same routine
MaxSessionCount = W32GetMaxSessionCount();
EngFreePrivateUserMem_0(v7, v6);          // extra defensive free
if ( v8 < MaxSessionCount && W32GetSessionState() ) {
    …                                    // proceeds only when bounded
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User process allocates DD_SURFACE_LOCAL, crafts bogus SessionId.
2. Calls a GDI / win32k API that reaches
   W32SessionAttachAndCalloutDispatch() with that object.
3. Function frees the object, then re-reads the stale SessionId.
4. Out-of-range id is fed to W32GetReferencedSessionProcessWithTag() or
   used as direct index into gSessionGlobalSlots.
5. win32k attaches the current thread into the wrong process/session
   and calls a kernel callback under attacker control – privilege
   escalation.

Attack Vector
--------------------------------------------------------------------
Local authenticated attacker running a crafted user-mode program that
spawns multiple threads.  One thread issues the vulnerable win32k API,
while another thread quickly reallocates or modifies the freed memory,
changing the embedded SessionId before the kernel consumes it.

Patch Description
--------------------------------------------------------------------
1. Added explicit call to W32GetMaxSessionCount() and rejected session
   numbers >= MaxSessionCount in all affected lambdas and in
   W32SessionAttachAndCalloutDispatch.
2. Reworked loops that iterate over sessions to respect the validated
   maximum.
3. Converted hard-coded 32-bit tag constants to 64-bit to prevent
   unsigned truncation.
4. Added second EngFreePrivateUserMem_0() to ensure pointers are not
   reused after free.
5. In Win32kKernelExportsSet() added a length check (a3 >= 2) before
   copying caller-supplied data into global KernelExports.

Security Impact
--------------------------------------------------------------------
Before the patch an attacker could:
  • Force win32k to attach the calling thread into an arbitrary process
    or into memory outside the valid session array.
  • Execute kernel call-outs in that improper context.
  • Gain SYSTEM privileges or cause kernel memory corruption / BSOD.
Attack requires only local, authenticated access – no admin rights.

Fix Effectiveness
--------------------------------------------------------------------
The added MaxSessionCount validation closes the out-of-bounds window,
and the additional EngFreePrivateUserMem_0() plus tightened bounds
checks remove the TOCTOU race on the freed surface object.  No further
path exists that uses an unvalidated session index after free, so the
patch is considered effective against the described exploit path.
