{'date': 1763403146.4774234, 'confidence': 0.13, 'cve': 'CVE-2025-59294', 'change_count': 59, 'file': 'dwmapi.dll', 'kb': 'KB5066835', 'patch_store_uid': '90c2c377-0120-4522-801b-0bb067d94c1b'}
--------------------------------------------------------------------
CVE-2025-59294 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows dwmapi.dll – client-side IPC wrapper classes CApiPortClient and
CPortClient that are used by high-level public DWM APIs such as
Dwm​SetIconicLivePreviewBitmap, DwmEnableBlurBehindWindow,
DwmQueryThumbnailSourceSize, etc.


Vulnerability Class
--------------------------------------------------------------------
Information Disclosure / Exposure of Sensitive Information to an
Unauthorized Actor (CWE-200) caused by returning a pointer to
uninitialised or previously-freed shared memory that may contain data
belonging to other callers or to the Desktop Window Manager process.


Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  DWM client code stores application–supplied extra data (bitmaps,
    thumbnails, colourisation parameters, etc.) in a per-connection
    "extra data" section that is owned by the CPortClient/CApiPortClient
    object:
       *  the base address of that section is kept in field
          this+0x08 (  this[1]  in the de-compiler listing), and
       *  its current committed length is kept in *this (DWORD at
          offset 0).

2.  Old implementation of
       CApiPortClient::LockExtraDataPointer(uint size, void **out)
    (see before-patch listing) is trivial:
       • it merely checks that  size <= *this ;
       • then calls EnsureExtraDataSection(), which may create or grow
         the section but never initialises the new bytes; and finally
       • returns the raw section base pointer through *out.

3.  Any caller that requests less than the real section size therefore
    receives a pointer that covers not only its own data but also
    bytes that belong to previous callers.  Those bytes are left in an
    un-initialised state (or contain data from a prior bitmap copy) and
    can be read back by an un-privileged application.  Typical leaked
    data include window thumbnails, live-preview frames, colourisation
    buffers and other visual artefacts handled by dwmapi on behalf of
    other windows and/or other processes.

4.  Because the section is created with PAGE_READWRITE | SEC_COMMIT and
    mapped into every process that uses the DWM public API, the problem
    becomes a cross-process information disclosure: any application can
       • connect to the DWM ALPC port,
       • call LockExtraDataPointer() with a small size, and
       • read past the valid range to obtain pixels or other data that
         were written by a different window-owner.

5.  The same section is freed in CPortClient::~CPortClient.  In the
    original code the destructor blindly HeapFree()s the buffer even if
    other threads still hold the pointer returned by
    LockExtraDataPointer(), turning the info-leak into a potential
    use-after-free as well.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// === before patch ===
__int64 CApiPortClient::LockExtraDataPointer(uint sz, void **pp)
{
    if (sz > *(DWORD*)this)
        return E_INVALIDARG;
    EnsureExtraDataSection(this);          // zero-initialisation missing
    *pp = *((void **)this + 1);            // raw base pointer
    return 0;
}

// === after patch ===
if (FeatureEnabled()) {
    rc = EnsureConnected(this);
    rc = CPortClient::AcquireExtraData(this->pPort, sz, pp); // bounded
} else {
    // legacy path (see above)
}
```
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker calls a public DWM API that ends up in
   CApiPortClient::LockExtraDataPointer().
2. Function returns the base of the shared extra-data section
   regardless of the requested size.
3. Attacker reads beyond the end of its own buffer and obtains
   uninitialised or previously-freed data created by another window or
   another process.


Attack Vector
--------------------------------------------------------------------
A user-mode process running under the current desktop session simply
calls documented DWM APIs (e.g. DwmSetIconicLivePreviewBitmap followed
by DwmQueryThumbnailSourceSize) and then reads from the pointer
returned by LockExtraDataPointer() past the requested size.
No special privileges are required; physical access is not necessary
contrary to the original advisory wording.


Patch Description
--------------------------------------------------------------------
Microsoft introduced a runtime feature-flag (Feature_2578215227) that
activates a new, safe code path:
1. LockExtraDataPointer now calls CPortClient::AcquireExtraData(), which
   allocates exactly the number of bytes requested and zero-initialises
   them in the DWM process before mapping them into the caller.
2. The raw section base pointer is no longer returned; callers receive
   only the bounding pointer supplied by AcquireExtraData.
3. In the destructor of CPortClient the buffer is freed only when the
   feature flag is disabled; under the new path the memory lifetime is
   managed by DWM and not released in user-mode, eliminating the
   dangling-pointer scenario.
4. Several public-API entry points were refactored to pass the client
   CApiPortClient handle explicitly, ensuring that the new allocation
   rules are consistently applied.


Security Impact
--------------------------------------------------------------------
Before the patch any un-privileged process could read arbitrary bytes
from the DWM shared extra-data section, obtaining window thumbnails and
live-preview frames belonging to other windows and potentially other
users, constituting an information-disclosure vulnerability tracked as
CVE-2025-59294.


Fix Effectiveness
--------------------------------------------------------------------
The patched logic enforces:
• Strict size-bounded allocations via AcquireExtraData();
• Zero-initialisation of newly-committed memory;
• No exposure of the entire shared section base pointer to callers;
• Elimination of premature HeapFree() by delegating lifetime management
  to the ALPC service side when the feature is enabled.

These changes close both the out-of-bounds read and the dangling
pointer, effectively mitigating the information disclosure.
