{'patch_store_uid': '451fecbd-3bc0-465d-a24d-a870929408dd', 'kb': 'KB5066835', 'file': 'winload.exe', 'cve': 'CVE-2025-55338', 'confidence': 0.55, 'date': 1763402986.4567502, 'change_count': 45}
--------------------------------------------------------------------
CVE-2025-55338 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows boot environment (winload.exe) – routine BlArchConfigureMtrrForTxt
Sinit, responsible for programming variable-range MTRRs during Intel TXT
measured launch.

Vulnerability Class
--------------------------------------------------------------------
Improper input validation / hardware register mis-configuration (failure
to clear address bits above the implemented physical address width when
writing MSR 0x200–0x20F variable MTRRs).

Detailed Root Cause Analysis
--------------------------------------------------------------------
Before the patch, BlArchConfigureMtrrForTxtSinit accepted three caller-
controlled parameters:
  a1 – physical base address to map
  a2 – size in bytes
  a3 – caller-supplied flag mask that is later ORed into IA32_MTRR_DEF_TYPE

The function directly programmed every variable MTRR pair (BASE and MASK)
with values derived from a1 and a2:
  BASE = (unsigned int)a1 & 0xFFFFF000 | 6
  MASK = ((-size & 0xFFFFFF) << 12) | 0x800

Only the low 32 bits of a1 were used, and **no attempt was made to mask
bits above the processor’s physical address width (PAW)**.  On recent
x64 CPUs the PAW may be 48 bits or larger; therefore any non-zero bits in
a1 that fall into the PAW..63 range are silently written into the MSRs.

Writing out-of-range address bits violates the SDM requirement that these
bits be programmed to zero, producing undefined behaviour.  Because the
undefined behaviour occurs *before* the TXT SINIT ACM executes, a
physical attacker who supplies a crafted a1/a2 (for example via an
alternate bootloader or modified Boot Configuration Data) can coerce the
firmware into:
  • aliasing cacheability attributes to unexpected regions,
  • mapping ROM regions as cacheable / writable, or
  • disabling the intended SINIT overlap protection.

Any of the above conditions breaks the root-of-trust expected by BitLocker,
allowing subsequent write-what-where attacks on the boot code and
ultimately a BitLocker bypass.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// BEFORE – address bits above PAW not cleared
__writemsr(v15 - 1, (unsigned int)a1 & 0xFFFFF000 | 6);
__writemsr(v15, ((unsigned __int64)(-v21 & 0xFFFFFF) << 12) | 0x800);

// AFTER – mask with PAW-derived v20 before writing
__writemsr(v16 - 1, ((_DWORD)v20 << 12) & (unsigned int)a1 | 6);
__writemsr(v16, ((v20 & ~(unsigned __int64)(v23 - 1)) << 12) | 0x800);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. External agent provides crafted base/size to Windows boot environment
   (exact higher-level call chain unknown).
2. winload.exe calls BlArchConfigureMtrrForTxtSinit(a1,a2,a3).
3. Function enters branch where a1 bits are copied straight into MTRR
   MSRs without PAW masking.
4. CPU interprets illegal MTRR settings, exposing writable/aliasing
   regions before SINIT/BitLocker measurements.

Attack Vector
--------------------------------------------------------------------
Physical attacker boots a custom medium (USB, PXE, etc.), supplying
malicious BCD or hand-crafted boot code that invokes the routine with a
base address containing set bits above PAW.  Because the attack happens
before BitLocker secrets are sealed, the attacker can tamper with ROM or
RAM while bypassing BitLocker’s expected protections.

Patch Description
--------------------------------------------------------------------
1. Function signature extended with new char a4 flag (enables strict mode).
2. New helper BlpArchGetMaxMtrrPhysicalAddress() is called; its return
   value is converted to a page-frame-number mask v20.
3. All subsequent writes to IA32_MTRR_PHYSBASEn / IA32_MTRR_PHYSMASKn are
   ANDed with v20, ensuring bits above the real physical address width
   are forced to zero.
4. Minor refactor: variables renamed, interrupt-enable wrapper updated.

Security Impact
--------------------------------------------------------------------
Prior to the fix, improper MTRR contents could:
  • make normally read-only flash/ROM cacheable-writeback and writable,
  • alias memory attributes to different physical areas, or
  • disrupt TXT SINIT measurements.
A motivated physical attacker could exploit any of these effects to load
unsigned code early in the boot sequence and bypass BitLocker full-disk
encryption.

Fix Effectiveness
--------------------------------------------------------------------
The new mask v20 is derived from the CPU’s reported physical address
width and is applied to *every* BASE and MASK MSR write site, closing the
out-of-range window.  No residual paths writing raw a1/a2 values remain
in the function.  Therefore the patch fully mitigates this specific
mis-configuration vector.
