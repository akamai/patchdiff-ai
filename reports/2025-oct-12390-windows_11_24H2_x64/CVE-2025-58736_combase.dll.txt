{'patch_store_uid': 'd1e9d746-720d-4647-8cb2-ec67327d5cc6', 'date': 1763407723.2457254, 'confidence': 0.24, 'kb': 'KB5066835', 'file': 'combase.dll', 'change_count': 13, 'cve': 'CVE-2025-58736'}
--------------------------------------------------------------------
CVE-2025-58736 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
combase.dll – runtime COM infrastructure, class-activation cache
(CClassCache and its nested CClassEntry objects).

Vulnerability Class
--------------------------------------------------------------------
Use-After-Free / Dangling Pointer (CWE-416).

Detailed Root Cause Analysis
--------------------------------------------------------------------
CClassCache keeps a global hash table that maps CLSIDs to
CClassEntry objects.  CClassEntry::Create() performs a two-phase
construction:
 1. CreateIncomplete() allocates a new entry and returns it through
    the caller-supplied **pCE.
 2. Complete() finalises the entry and may temporarily release the
    cache writer lock ( *pfLockReleased = 1 ).

If Complete() had to release the lock another thread can insert an
entry for the same CLSID before the first thread reacquires the lock.
After Complete() returns with fLockReleased==1, Create() performs a
LookupCE() to see whether an equivalent entry has appeared.  When one
is found ( variable v13 / v14 in the old build ) the old code destroys
its own newly allocated object:
    CDropTargetAdapter::`scalar deleting destructor'(*pCE, ...);

However the function forgets to update the caller-visible pointer
*pCE so the caller continues to hold a dangling pointer that now
references freed memory.  Subsequent cache operations, reference
counting or interface method calls operate on reclaimed memory and
can be steered by an attacker once the freed region is reused – a
classic Use-After-Free condition.

An analogous pattern existed in CClassEntry::Complete() for TreatAs
handling: when a TreatAs target already existed a dangling pointer
could again be returned to the caller.

Affected fields / parameters
  * pCE – out parameter that receives the final CClassEntry pointer.
  * _dwFlags bit 0x02 (CCE_INCOMPLETE) used to detect Complete() state.
  * Global hash table  CClassCache::_ClassEntries.
  * Writer lock        CClassCache::_mxs.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
//  Before – object freed but caller still holds old pointer
if (v14) {                     // duplicate found
    v19 = (CDropTargetAdapter *)*v9;  // old entry
    if (*v9)
        CDropTargetAdapter::`scalar deleting destructor'(v19, v12);
    /* *v9 is not reassigned – dangling pointer returned */
}

//  After  – pointer replaced with the canonical entry
if (*v10)
    CDropTargetAdapter::`scalar deleting destructor'(*v10, v13);
if (Incomplete >= 0)
    *v10 = (CDropTargetAdapter *)v14; // <- fix
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Client calls CoCreateInstance / activation for CLSID X from two
   threads concurrently.
2. Thread A enters CClassEntry::Create() – allocates Entry A.
3. Complete() releases writer lock to query TreatAs; fLockReleased=1.
4. Thread B meanwhile inserts Entry B for the same CLSID into the
   cache and returns.
5. Thread A resumes, detects duplicate, frees Entry A but still
   returns pointer to Entry A -> dangling pointer.
6. Caller later dereferences pointer, leading to UAF.

Attack Vector
--------------------------------------------------------------------
Local (or remote via COM/RPC) code issues concurrent activation calls
for the same CLSID, wins the race to provoke duplicate insertion, and
then triggers subsequent method calls on the freed object.  Memory
re-use under attacker control enables arbitrary code execution.

Patch Description
--------------------------------------------------------------------
1. After detecting an existing entry the function now:
   • frees the temporary object; and
   • **assigns *pCE to the canonical entry** before returning.
2. Similar logic added to Complete() via new helper
   CClassEntry::CompleteTreatAs().
3. Added Feature-flag checks and telemetry asserts but they are
   cosmetic; the critical fix is the pointer reassignment.
4. Refactored bucket insertion through CHashTable::Add() – no logic
   change.

Security Impact
--------------------------------------------------------------------
Prior to the patch any caller of CClassEntry::Create() / Complete()
could receive a pointer to freed memory, leading to: 
 • Arbitrary code execution in the COM runtime process context.
 • Possible privilege escalation if activated under elevated COM
   server security settings.
The issue is rated Remote Code Execution because COM activation can
be driven cross-process via RPC.

Fix Effectiveness
--------------------------------------------------------------------
The patched build guarantees that the out parameter always references
valid live memory before returning.  All observed UAF paths have been
covered in both Create() and Complete(); no residual dangling pointer
paths are visible in the diff.  The fix appears effective.
