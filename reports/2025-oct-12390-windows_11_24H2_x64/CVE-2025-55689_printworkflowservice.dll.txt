{'change_count': 76, 'confidence': 0.2, 'kb': 'KB5066835', 'cve': 'CVE-2025-55689', 'date': 1763403021.6846497, 'file': 'printworkflowservice.dll', 'patch_store_uid': 'cfbf7ece-1a89-464d-80de-2d625e11c5f0'}
--------------------------------------------------------------------
CVE-2025-55689 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows PrintWorkflowUserSvc – specifically printworkflowservice.dll
implementations of
• PrintSupportSettingsBroker::GetCurrentPrintTicket
• PrintSupportSettingsBroker::IsCentennialApp
• PrintSupportSettingsBroker::CloseView
• PrintSupportSession::SessionStateHandler::SetSessionState

Vulnerability Class
--------------------------------------------------------------------
Use-after-free (CWE-416) caused by missing object-lifecycle/state checks
and illegal state transitions that lead to accesses of previously
released internal members.

Detailed Root Cause Analysis
--------------------------------------------------------------------
Several broker/session objects inside the PrintWorkflowUserSvc maintain
state bytes and pointers that reflect whether the object is still
valid.  The critical flag is a single byte located at offset +0xD8
(decimal 216) of PrintSupportSettingsBroker.  When CloseView() is
invoked the object tears down its internal IFrameworkView pointer
(stored at +0x20) and sets the flag, but earlier builds allowed other
methods to be called afterwards:

1. GetCurrentPrintTicket() copied an hstring that is located at +0x70
   (offset 112) without verifying that the broker was still active.  If
   the surrounding object had already been disposed the pointer inside
   the hstring could have been freed, producing a dangling read and, in
   the presence of attacker-controlled data, a write-what-where during
   reference count manipulation.

2. CloseView() itself could be executed twice.  The second call would
   dereference the freed IFrameworkView (*this+0x20) and call its
   virtual Release() -> Use-after-free.

3. IsCentennialApp() could lazily initialise application data after the
   broker was marked inactive, again touching freed members.

In addition, SessionStateHandler::SetSessionState accepted illegal
state transitions.  An attacker could cause a second state update after
CloseView tore down the view.  The routine accessed *parent+0x190 or
*parent+0x130 (background task, window, etc.) which could already be
released, extending the UAF surface beyond the broker object.

Because all these calls can be triggered through the Print Support
WinRT interface by a normal user process, the bug yields local
Elevation of Privilege inside the PrintWorkflowUserSvc service account.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// OLD: GetCurrentPrintTicket – no state validation
winrt::hstring::hstring(a2, (const hstring *)(a1 + 112));

// NEW: added guard
if (FeatureEnabled && !*(BYTE *)(a1 + 216))
    wil::Throw_Hr(0x8000000E);   // E_NOT_VALID_STATE

// OLD: CloseView – double free possibility
if (*(QWORD *)this + 4) {
    v3 = *((QWORD *)this + 3);   // freed ptr
    ... (*vtable)(v3, 88);       // UAF
}

// NEW: upfront guard prevents second invocation
if (FeatureEnabled && !*((BYTE *)this + 216))
    wil::Throw_Hr(0x8000000E);

// OLD: SetSessionState – no transition check
if (a3 != 1 && (*a1 == 256 || ...)) { ... }
// NEW: transition must pass
if (IsStateTransitionAllowed(a1, a2, a3)) { ... }
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User-mode sandboxed app communicates with the Print Support
   broker via WinRT.
2. App closes the print-support view (CloseView) making the service
   free internal objects.
3. App immediately calls either GetCurrentPrintTicket(), CloseView()
   again, or forces a forbidden session-state transition.
4. The service dereferences internal pointers that now refer to freed
   memory – attacker controls contents through heap grooming.
5. Crafted data placed in reclaimed memory allows arbitrary pointer
   corruption and code execution in the PrintWorkflowUserSvc context.

Attack Vector
--------------------------------------------------------------------
Local – the attacker only needs the ability to load and call the public
WinRT PrintSupport APIs from a desktop or UWP application.  No special
privileges are required.

Patch Description
--------------------------------------------------------------------
The update introduces three protective measures:
1. A per-object validity byte (offset +216) is now checked at the top
   of GetCurrentPrintTicket(), CloseView() and IsCentennialApp().  When
   the feature flag Feature_2578215227 is active and the object is not
   in the valid state, the functions raise HRESULT 0x8000000E
   (E_NOT_VALID_STATE) or 0x80070490 (ERROR_NOT_FOUND) instead of
   accessing the freed memory.
2. CloseView() received new error-code locations (0x180/0x181) so the
   first call still completes, while a second call fails fast.
3. SessionStateHandler::SetSessionState now calls
   IsStateTransitionAllowed() before updating the state, blocking all
   previously reachable illegal transitions that could operate on
   destroyed parent structures.

Security Impact
--------------------------------------------------------------------
Before the fix an attacker could trigger a use-after-free and corrupt
heap structures in a privileged service, leading to local Elevation of
Privilege (EoP).  Code execution would run under the PrintWorkflow
service SID, escaping the user context.

Fix Effectiveness
--------------------------------------------------------------------
The added state guard prevents any call into the broker after the
object is disposed, eliminating the dangling pointer dereferences.
Combined with stricter session-state validation the formerly reachable
UAF paths are closed.  No residual code paths using the freed members
remain visible in the patched binary; therefore the fix appears
complete for the identified issue.
