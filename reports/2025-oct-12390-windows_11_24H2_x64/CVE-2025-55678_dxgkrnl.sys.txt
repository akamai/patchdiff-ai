{'cve': 'CVE-2025-55678', 'kb': 'KB5066835', 'file': 'dxgkrnl.sys', 'patch_store_uid': 'afe9fa6e-0a1c-4325-b44e-2c4e6256a6dd', 'confidence': 0.22, 'date': 1763406019.1815848, 'change_count': 230}
--------------------------------------------------------------------
CVE-2025-55678 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows – dxgkrnl.sys (DirectX Graphics Kernel)
Function: DXG_GUEST_VIRTUALGPU_VMBUS::VmBusSendCreateAllocation()

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use-After-Free

Detailed Root Cause Analysis
--------------------------------------------------------------------
VmBusSendCreateAllocation() builds a variable-length VM-bus message that
contains a header, optional private runtime data, driver data and a per
allocation descriptor array.  It allocates a single heap buffer
("VirtualAddress"  /  v103) with operator new[ ] and fills it before the
message is synchronously sent to the Hyper-V virtual GPU back-end.

In the original implementation the pointer that tracks the heap block is
stored in two variables:
  • v103 – returned to the caller through **a12** so the caller can keep
    using the buffer after the API returns.
  • v23  – a working copy that is later passed to
    DXGQUOTAALLOCATOR<>::operator delete() at the common epilogue
    (LABEL_74).

When execution follows the success path, *v23 is **not** reset to NULL
until **after** the buffer address is copied to *a12.  Consequently the
function’s epilogue frees the buffer that has just been handed to the
caller, leaving the caller with a dangling pointer.  Any later access by
the caller results in a classic use-after-free on non-paged pool memory
in the DirectX graphics kernel.

Because the freed region is reused by subsequent pool allocations, an
attacker running in the same partition can groom pool usage, reclaim the
block with controlled data and obtain powerful primitives (e.g. write
where / read-after-free) in kernel mode, permitting local privilege
escalation.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// BEFORE
*v116 = (unsigned __int8 *)v103;   // return buffer to caller
v23 = 0i64;                        // <-- v23 *often* not cleared
...
LABEL_74:
DXGQUOTAALLOCATOR<>::operator delete(v23); // unconditional free

// AFTER (patch)
*v114 = (unsigned __int8 *)v101;   // return buffer to caller
v26   = 0i64;                      // working copy cleared
...
LABEL_145:
DXGQUOTAALLOCATOR<>::operator delete(v26); // freed only when !returned
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User-mode driver calls D3DKMTCreateAllocation with crafted
   parameters.
2. Dxgkrnl reaches VmBusSendCreateAllocation().
3. Allocation succeeds -> buffer v103 is allocated and filled.
4. Function copies v103 to *a12, but leaves same address in v23.
5. Common epilogue deletes v23, freeing the memory still referenced by
   the caller.
6. Caller (still in kernel context) later dereferences its copy – UAF.

Attack Vector
--------------------------------------------------------------------
Local, authenticated user.  Any process that can issue D3DKMT
Ioctls (e.g. via Direct3D) can reach the vulnerable path without
additional privileges.

Patch Description
--------------------------------------------------------------------
The fix introduces an explicit working variable (v26) that is only set
to the heap pointer when an error path needs to tear it down.  On the
success path v26 is reset to NULL immediately after the pointer is
returned to the caller, ensuring the epilogue never frees memory that
remains in use.  Additional refactoring (size validation, feature gate
checks) is unrelated to the UAF but part of the hardening.

Security Impact
--------------------------------------------------------------------
An attacker controlling GPU allocation calls can obtain a dangling
kernel pointer to released non-paged pool.  By recycling the freed block
with attacker-controlled data the attacker can corrupt kernel memory and
gain code execution in kernel mode, resulting in local privilege
escalation (EoP).  No system crash is required – exploitation is fully
reliable on supported Windows versions.

Fix Effectiveness
--------------------------------------------------------------------
The patched routine frees the buffer only when it is *not* exposed to
the caller, eliminating the dangling pointer.  All observed exit paths
now clear the local free pointer before the unconditional delete,
rendering the original UAF unexploitable.

