{'cve': 'CVE-2025-55688', 'kb': 'KB5066835', 'date': 1763406118.0938044, 'file': 'printworkflowservice.dll', 'confidence': 0.46, 'change_count': 76, 'patch_store_uid': 'cfbf7ece-1a89-464d-80de-2d625e11c5f0'}
--------------------------------------------------------------------
CVE-2025-55688 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows PrintWorkflowUserSvc (printworkflowservice.dll)
specifically the class
PrintSupportSessionCommon::DeleteTempFiles and related helper
functions in the Print Support settings broker.

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use-After-Free (local privilege-escalation primitive).

Detailed Root Cause Analysis
--------------------------------------------------------------------
PrintSupportSessionCommon owns a collection of temporary files that
must be removed when a print job finishes.  Two pointer-sized fields
 at offset +0x10 and +0x18 ("start" and "end") were treated as a raw
contiguous C-array of winrt::Windows::Storage::IStorageFile
interfaces:

    start = *((QWORD*)this + 2);
    end   = *((QWORD*)this + 3);

The pre-patch loop walked this memory with

    while (start != end) { DeleteAsync(start); start += 8; }

DeleteAsync internally releases (DecRef) the IStorageFile object.  If
that was the final reference the COM object is destroyed, freeing the
memory that the loop will dereference on the very next iteration.  The
result is a classic use-after-free; the freed slab can be re-allocated
by attacker-controlled data before the second iteration, allowing an
arbitrary vtable pointer to be executed inside the PrintWorkflowUserSvc
process (SYSTEM integrity).

Why the misuse occurs:
 • The real container held at this+0x30 is an
   IVectorView<IStorageFile>, *not* a flat array; its implementation
   provides no stability or contiguity guarantees.
 • Treating the collection as a raw buffer bypasses the reference
   counting semantics that WinRT expects, so object lifetime is not
   preserved across the loop.
 • Once the first DeleteAsync drops the refcount to zero, the loop’s
   cached pointer is stale but is nevertheless incremented and
   dereferenced.

A user running in the *caller* context can supply a crafted
IStorageFile implementation or arrange precise heap reuse to hijack
control-flow in the privileged service.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable loop (pre-patch)
void DeleteTempFiles(this) {
    QWORD cur = *((QWORD*)this + 2);
    QWORD end = *((QWORD*)this + 3);
    while (cur != end) {
        int opt = 1;
        DeleteAsync(cur, &tmp, &opt);   // releases *cur
        IWindow::~IWindow(&tmp);
        cur += 8;                       // uses freed memory
    }
}

// safe enumeration (post-patch)
if (FeatureEnabled) {
    auto view = (IVectorView*) (this + 0x30);
    UINT32 size = view->Size();
    for (UINT32 i = 0; i < size; ++i) {
        ComPtr<IStorageFile> file;
        view->GetAt(i, &file);          // fresh reference each time
        DeleteAsync(file.Get(), &tmp, &opt);
        ...
    }
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker starts a print job that causes temp files to be registered
   with PrintSupportSessionCommon.
2. Service finishes the job and calls
   PrintSupportSessionCommon::DeleteTempFiles.
3. First DeleteAsync frees the IStorageFile instance.
4. Loop increments raw pointer and dereferences freed memory.
5. Service executes attacker-controlled vtable, yielding SYSTEM code
   execution.

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker running with normal user rights submits a
print job through the Print Workflow API and forces the service to
store attacker-controlled IStorageFile references.  By reclaiming the
freed pool between iterations (e.g., via heap grooming) the attacker
redirects the next virtual call and elevates privileges.

Patch Description
--------------------------------------------------------------------
1. Added a feature flag check (Feature_2578215227) that selects a new
   enumeration path.
2. The new path:
   • Obtains the collection pointer stored at this+0x30 as
     IVectorView.
   • Queries Size() and iterates with GetAt(index) on every step,
     obtaining a fresh, reference-counted interface each time.
   • No longer relies on contiguous memory; object lifetime is correct.
3. Legacy contiguous-memory path is kept only when the feature flag is
   disabled (not expected in production builds).
4. Defensive checks were also added to CloseView() to block illegal
   re-entrance and to centralise error handling, but they are
   secondary.

Security Impact
--------------------------------------------------------------------
The flaw allows a local user to execute arbitrary code in the context
of PrintWorkflowUserSvc (NT AUTHORITY\SYSTEM).  Successful exploitation
provides full machine compromise and bypasses the Windows privilege
separation model.

Fix Effectiveness
--------------------------------------------------------------------
The patched code no longer dereferences stale pointers; each iteration
retrieves a fresh interface whose lifetime extends past the call to
DeleteAsync, eliminating the use-after-free window.  Remaining risk:
if the new feature flag is forcibly disabled, the vulnerable branch is
reachable again.  Provided the flag is permanently on for supported
builds, the fix is effective.
