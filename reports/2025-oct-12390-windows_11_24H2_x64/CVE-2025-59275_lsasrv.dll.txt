{'change_count': 30, 'patch_store_uid': 'b152918f-5cdf-4476-a46d-deb61ecd20b3', 'confidence': 0.15, 'kb': 'KB5066835', 'file': 'lsasrv.dll', 'cve': 'CVE-2025-59275', 'date': 1763407748.833308}
--------------------------------------------------------------------
CVE-2025-59275 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Local Security Authority Sub-system Service (lsass.exe) – user-mode
library lsasrv.dll (handle management, secret, policy and account
APIs).

Vulnerability Class
--------------------------------------------------------------------
Improper validation of user-supplied kernel / process handles leading
to privilege-elevation primitives (CWE-1287 + resulting CWE-122/125
mem-corr).

Detailed Root Cause Analysis
--------------------------------------------------------------------
Most public LSASS RPC APIs accept an opaque LSAP_DB_HANDLE returned by
previous Lsar* or DsRoler* calls.  Before the April patch the
following entry points trusted the caller-supplied handle and
immediately dereferenced it:

  • LsarDeleteObject
  • LsarSetSecurityObject
  • LsarQuerySecurityObject
  • LsarClose / LsapCloseHandle wrappers
  • Multiple helper paths (secret/privilege update, machine cert, etc.)

The handle value is not an actual pointer; it is a 64-bit value that
encodes an index into an internal table plus some integrity cookies.
Because no verification was performed, a malicious client could forge
an arbitrary 64-bit value that passes superficial format checks but
points outside the valid table.  When the server later processed the
handle it executed one of the following unsafe sequences:

  1. Convert handle to pointer (addition / masking)
  2. Treat the resulting address as LSAP_DB_OBJECT
  3. Read or write object fields (flags, SID, linked lists, vtable)

If the forged value points into attacker-controlled user memory
(lsass.exe runs as SYSTEM and has SeDebugPrivilege) the read/write is
performed with SYSTEM integrity, giving the attacker an arbitrary
kernel-object write primitive.  In practice this allows:

  • Overwrite of adjacent LSASS objects → privilege escalation to
    SYSTEM inside the process
  • Out-of-bounds read of privileged memory regions (token theft or
    credential disclosure).

The bug exists because LsapDbVerifyHandle() was never called in the
above entry points; only some newer code paths gated by a disabled
feature flag (Feature_606380347) performed the check.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – LsarDeleteObject
__int64 __fastcall LsarDeleteObject(void **a1)
{
  return LsapDeleteObject(a1, 1);   // no verification
}

// after patch
if(!LsapDbVerifyHandle(*a1, 0, 0, 0))
    return LsapDeleteObject(a1, 1);
return status;                      // rejects forged handle
```

```c
// before patch – LsarClose
v5 = LsapDbDereferenceObject(...);  // uses supplied handle directly
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker obtains a legitimate Policy handle via LsarOpenPolicy.
2. Crafts a fake LSAP_DB_HANDLE value that encodes an address under
   attacker control (e.g., shared memory section).
3. Calls vulnerable API, e.g. LsarDeleteObject(forgedHandle).
4. lsasrv.dll dereferences the address → arbitrary read/write inside
   LSASS, leading to code execution as SYSTEM.

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker.  Requires the SeTcbPrivilege-less RPC
endpoint but no administrator rights; any service running under the
attacker’s account token can send the forged handle over LPC / ALPC
and elevate inside LSASS.

Patch Description
--------------------------------------------------------------------
1. Introduced ubiquitous call to
   LsapDbVerifyHandle(handle,0,0,0) at the top of every API that
   accepts a LSAP_DB_HANDLE.
2. Replaced direct LsapDeleteObject/LsapCloseHandle with new wrappers
   LsarDeleteObject / LsarClose that first verify the handle.
3. Hardened helper routines (secret, privilege, machine-cert code) to
   call LsarClose instead of LsapCloseHandle.
4. SecHandleTable::NextHandle reworked to randomise / align handle
   allocation making brute-force guessing harder.

Security Impact
--------------------------------------------------------------------
A successful exploit gives the attacker read/write access to LSASS
process memory and consequently the ability to:

  • Inject arbitrary code into LSASS running as NT AUTHORITY\SYSTEM.
  • Extract credential material (NTLM hashes, Kerberos keys).
  • Elevate privileges locally (EoP) and potentially perform lateral
    movement with stolen creds.

Fix Effectiveness
--------------------------------------------------------------------
Patched functions now reject any handle that fails
LsapDbVerifyHandle().  Because every public entry point was updated
and internal helpers were redirected to the new safe wrappers, the
forged-handle primitive is effectively removed.  No residual path that
bypasses the check was observed in the supplied diff, so the fix is
considered complete.

