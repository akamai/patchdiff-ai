{'kb': 'KB5066835', 'cve': 'CVE-2025-55685', 'date': 1763403042.850828, 'change_count': 76, 'patch_store_uid': 'cfbf7ece-1a89-464d-80de-2d625e11c5f0', 'file': 'printworkflowservice.dll', 'confidence': 0.27}
--------------------------------------------------------------------
CVE-2025-55685 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows PrintWorkflowUserSvc – specifically the COM-based helper
classes found in printworkflowservice.dll:
 • PrintSupportSettingsBroker
 • PrintSupportVirtualPrinterSourceSession
 • OpenWithViewModel shim wrappers produced by the C++/WinRT
   code-generator.
These helpers are instantiated inside the PrintWorkflowUserSvc
service running as LocalSystem.

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use-After-Free (dangling pointer returned from service
interfaces and later dereferenced after the backing object was
released).

Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  Several automatically generated *produce<…>::get_*/Get* methods
    simply returned a raw internal member pointer (often an
    `hstring` or interface pointer) that belonged to the service
    object itself.
    Example (before patch):
       v3 = a1 + 80;          // member hstring inside broker
       winrt::hstring::hstring(&v6,(hstring*)v3); // no AddRef –
                                                 // just alias
       *a2 = v6;              // return caller a direct reference
    The same pattern existed in:
       • GetAppInfo
       • GetPrinterName
       • GetTargetStorageFilePath
2.  In the very large coroutine
    PrintSupportSettingsBroker::LaunchSettingsUIForPrinterAsync
    the broker pointer stored in the coroutine frame (*a1+449* in
    the old build) was *not* reference-counted.  As soon as the
    async state machine suspended, other threads could release the
    broker, leaving the frame with a dangling pointer that is later
    dereferenced when the coroutine resumes (e.g. when it accesses
    *(broker+168) or *(broker+64)).
3.  Because PrintWorkflowUserSvc is running as SYSTEM and the
    attacker only needs to be an authenticated local user able to
    call the exposed broker interfaces, the dangling pointer can be
    exploited to achieve elevation of privilege.  The attacker
    forces the broker object to be destroyed while the coroutine is
    still live and then supplies controlled memory at the freed
    address.
4.  Absence of any strong lifetime management (AddRef/Release) or
    deep copy when returning strings is therefore the root cause.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// BEFORE – GetPrinterName (abridged)
winrt::hstring::hstring(&v6, (hstring*)(a1+80)); // alias internal
*a2 = v6;                                         // return dangling
```
```c
// AFTER – GetPrinterName (abridged)
PrinterName = PrintSupportSettingsBroker::GetPrinterName(
                 (a1-16)&-(a1!=0), &tmp);
*a2 = *PrinterName;      // uses freshly copied hstring
*PrinterName = 0;        // original zeroed, no aliasing
```
```c
// BEFORE – coroutine stores raw pointer
*(_QWORD*)(a1+256) = a1-112;           // no AddRef
```
```c
// AFTER – coroutine takes a strong ref
*(_QWORD*)(a1+16) = broker;
if(broker) broker->AddRef();           // holds object alive
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Client calls IPrintSupportSettingsBroker::LaunchSettingsUIFor­
   PrinterAsync().
2. Service enters coroutine LaunchSettingsUIForPrinterAsync.
3. Coroutine stores raw broker pointer and suspends on an await.
4. Attacker triggers code path that releases the broker (e.g.
   closing the related print session).
5. Coroutine resumes and dereferences the freed broker memory,
   leading to UAF – typically write-what-where through vtbl member
   access.

Attack Vector
--------------------------------------------------------------------
Local, authenticated user creates a printing session and then uses
COM to talk to PrintWorkflowUserSvc.  By carefully timing the life
cycle of the print session versus the coroutine await points, the
user frees the broker while it is still referenced inside the
service and gains code execution in the SYSTEM context.

Patch Description
--------------------------------------------------------------------
The February 2025 security update introduces comprehensive life-
cycle fixes:
1. All *produce* accessors now delegate to internal helper methods
   that *copy* the requested hstring/path into a stack variable
   before returning it – no more aliasing of internal members.
2. Coroutine frame now stores a *reference-counted* pointer to the
   broker (`AddRef` on entry, `Release` in every exit path),
   increasing the object size from 0x240 to 0x330 bytes.
3. Numerous new clean-up cases were added to ensure every early
   exit releases its references, eliminating dangling pointers.

Security Impact
--------------------------------------------------------------------
Before the patch a local attacker could cause PrintWorkflowUserSvc
(to which he already has access) to dereference freed memory and
execute arbitrary code as LocalSystem, thereby elevating privileges.
After patch, callers only receive independent copies, and the
service keeps strong references for the whole async duration,
removing the UAF condition.

Fix Effectiveness
--------------------------------------------------------------------
The ref-counting added to the coroutine plus the deep-copy helpers
eliminate all observable paths where a dangling pointer could be
exposed.  Each exit path now releases the held reference exactly
once, preventing both leaks and double-frees.  No residual alias of
internal members remains, so the fix is considered effective.

