{'date': 1763402989.4541268, 'confidence': 0.45, 'cve': 'CVE-2025-58729', 'file': 'lsm.dll', 'change_count': 14, 'patch_store_uid': 'da4e902e-c230-48a6-bd3a-79fec5239c44', 'kb': 'KB5066835'}
--------------------------------------------------------------------
CVE-2025-58729 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Local Session Manager (lsm.dll) – code paths handling the
ALPC tunnel between LSM and CSRSS.  Affected classes: CCsrPipe,
CCsrMgr and helper routine SendLpcMessage / OnReplyMessage.


Vulnerability Class
--------------------------------------------------------------------
Improper input validation resulting in a nullable-pointer de-reference
(CWE-1287, leads to denial-of-service / system crash).


Detailed Root Cause Analysis
--------------------------------------------------------------------
The LSM service exchanges ALPC messages with CSRSS through CCsrPipe.
For reply traffic the structure _WINSTATIONREPLYMESSAGEMSG contains
three correlated fields:
  • BYTE  DoNotWait        (offset +0x??)
  • DWORD *pStatus         (offset +0x20)
  • DWORD *pResponse       (offset +0x28)
When DoNotWait == 1, both pStatus and pResponse must be non-NULL so
that LSM can copy the kernel return value back to user space and
signal the event handle stored at +0x10.

Prior to the patch the kernel side implementation assumed this
contract but never verified it:
  1. CCsrMgr::LpcWorker() fetched the CCsrPipe pointer from the ALPC
     message attribute and dispatched sub-commands.
  2. For sub-command 2 (reply) it executed the following sequence
        **((_DWORD**)v2 + 8)  = *((_DWORD*)v2 + 14);
        **((_DWORD**)v2 + 11) = *((_DWORD*)v2 + 20);
        SetEvent(*((HANDLE*)v2 + 9));
     which blindly dereferences pResponse and pStatus.
  3. If a malicious client set DoNotWait == 1 but left the two
     pointers NULL (or pointed them to invalid user memory) the kernel
     would touch address 0x0 (or an arbitrary address) from kernel
     mode, immediately triggering a bugcheck (KERNEL_MODE_EXCEPTION_NOT_HANDLED).

A similar unchecked dereference existed in CCsrPipe::SendLpcMessage()
when LSM built such messages to send to CSRSS – an inconsistent
message could be emitted by the kernel and later received back,
propagating corrupted state.


Vulnerability Code Snippets
--------------------------------------------------------------------
Old code (no validation, lsm.dll):
```c
// CCsrMgr::LpcWorker – dispatching reply
**((_DWORD **)v2 + 8) = *((_DWORD *)v2 + 14);
**((_DWORD **)v2 + 11) = *((_DWORD *)v2 + 20);
SetEvent(*((HANDLE *)v2 + 9));
```

New code (patched):
```c
// CCsrPipe::OnReplyMessage – verify first
if (*((_QWORD *)a2 + 1) && *((_QWORD *)a2 + 4)) {
    **((_DWORD **)a2 + 1) = *(_DWORD *)a2;
    **((_DWORD **)a2 + 4) = *((_DWORD *)a2 + 6);
    SetEvent(*((HANDLE *)a2 + 2));
} else {
    _DbgPrintMessage(8, "OnReplyMessage: pResponse or pStatus is NULL");
    return STATUS_INVALID_PARAMETER;
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker establishes an ALPC connection to LSM via CSRSS.
2. Attacker sends a fabricated _WINSTATIONREPLYMESSAGEMSG with:
      DoNotWait = 1
      pStatus   = NULL
      pResponse = NULL
3. CCsrMgr::LpcWorker() routes message to CCsrPipe::OnReplyMessage()
   (pre-patch this code did not exist, so dereference occurred inside
   LpcWorker itself).
4. Kernel touches NULL -> bugcheck -> system reboot.


Attack Vector
--------------------------------------------------------------------
Local attacker in a normal user session that can communicate with
CSRSS/LSM over the documented WinStation ALPC port.  No elevated
privilege is needed; only the ability to send a crafted reply message.


Patch Description
--------------------------------------------------------------------
1. Added a dedicated function CCsrPipe::OnReplyMessage() that validates
   pStatus and pResponse before dereferencing them and returns
   STATUS_INVALID_PARAMETER on failure.
2. Updated CCsrMgr::LpcWorker() to call the new helper and to record
   the returned NTSTATUS; it now emits debug output and avoids sending
   a follow-up reply if OnReplyMessage failed.
3. Hardened CCsrPipe::SendLpcMessage():
     • Verifies input pointer ‘pMsg’ is non-NULL.
     • For APINUMBER == 9 (reply) checks consistency between DoNotWait
       flag and the two embedded pointers and logs unexpected
       combinations.
     • Rejects invalid combinations with STATUS_INVALID_PARAMETER.
4. All new checks are guarded by a Feature flag so they can be
   selectively enabled; if disabled the old behaviour is preserved.


Security Impact
--------------------------------------------------------------------
Before the fix an unprivileged user could cause a kernel NULL pointer
(or arbitrary pointer) dereference in lsm.sys, resulting in a system
crash and denial of service.


Fix Effectiveness
--------------------------------------------------------------------
The added NULL/consistency checks terminate processing early with
STATUS_INVALID_PARAMETER, preventing kernel dereference.  The new code
paths cover both message reception (OnReplyMessage) and emission
(SendLpcMessage), closing the gap in both directions.  No remaining
unchecked dereference of pStatus/pResponse was observed in the diff,
so the patch is deemed effective.

