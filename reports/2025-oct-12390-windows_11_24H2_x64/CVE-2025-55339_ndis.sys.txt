{'patch_store_uid': '61880bb8-8be2-4fbf-89ce-c726fb7b76b4', 'kb': 'KB5066835', 'confidence': 0.23, 'cve': 'CVE-2025-55339', 'date': 1763407735.814864, 'change_count': 7, 'file': 'ndis.sys'}
--------------------------------------------------------------------
CVE-2025-55339 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows kernel – NDIS.sys (Network Driver Interface
Specification) helper routines that validate user-supplied variable
length buffers processed by IOCTL 0x170008/0x17000C and related PnP
request codes.

Vulnerability Class
--------------------------------------------------------------------
CWE-125: Out-of-bounds Read (caused by faulty integer / bounds
validation)

Detailed Root Cause Analysis
--------------------------------------------------------------------
Several helper routines that are reached from ndisHandlePnPRequest()
validate attacker-controlled NDIS_VAR_DATA_DESC or
NDIS_OFFSET_AND_LENGTH descriptors before the kernel converts them to
UNICODE_STRING structures.  The central check is performed by
ndisValidateEmbeddedBufferBounds().

Before the patch the routine executed the following logic
  start = Base + Offset        (v8  = a1 + a5)
  end   = start + Length       (v11 = v8 + a6)
  if ( end < start || … ) fail

Missing checks:
1. It never verified that Offset itself is inside the caller buffer
   (only Offset+Length was compared).
2. It did not catch under-flows such as Length < Offset that wrap when
   promoted to 64-bit.
3. Callers (for example
   ndisValidateNdisVarDataDescInputString()) passed uninitialised data
   to ndisValidateAndConvertWcharStringToUnicodeString():
        return ndisValidateAndConvertWcharStringToUnicodeString(
                   v7[0], *v6, (_DWORD)v6, 0, a4);
   Here v6 was never initialised; its random contents became the
   length parameter, resulting in an arbitrary read past the validated
   user buffer.

An attacker supplies a descriptor whose header lives inside the user
buffer but whose Offset field is close to UINT_MAX and whose Length is
small.  Because of the missing under-flow/over-flow checks the
validation accepts the buffer.  When the kernel later copies the
string, (start,length) points outside the user allocation and reads
kernel memory.

Affected parameters / structures
• a1 : base address of user buffer (64-bit)
• a2 : total size of user buffer (DWORD)
• a5 / a6 : Offset / Length inside NDIS_VAR_DATA_DESC
• a3  : pointer to descriptor inside the same user buffer

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// ndisValidateNdisVarDataDescInputString (BEFORE)
result = ndisValidateNdisVarDataDescInputBufferBounds(...,&v7);
if ((_BYTE)result)
    // v6 is NEVER initialised -> bogus length
    return ndisValidateAndConvertWcharStringToUnicodeString(
                v7[0], *v6, (_DWORD)v6, 0, a4);
```
```c
// ndisValidateEmbeddedBufferBounds (BEFORE)
start = a1 + a5;          // no check that start >= a1
end   = start + a6;       // may wrap
if (end < start || end > a1+a2) fail;
```
```c
// ndisValidateEmbeddedBufferBounds (AFTER)
end_of_buf = a1 + a2;
start      = a1 + a6;
end        = start + a7;
if (end_of_buf < a1            // buffer wrap
 || a8 && a7 && ((a8-1)&start) // alignment
 || a7 && a7 < a6              // Length < Offset  **NEW**
 || start < a1                // Offset before buffer **NEW**
 || end < start               // overflow **NEW**
 || end > end_of_buf) fail;
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User process issues DeviceIoControl to the NDIS device with an
   IOCTL that is handled in ndisHandlePnPRequest().
2. The buffer contains crafted NDIS_VAR_DATA_DESC structures.
3. ndisHandlePnPRequest() calls ndisValidateNdisVarDataDescInputString
   (or 32-bit variant) which in turn calls
   ndisValidateEmbeddedBufferBounds().
4. Because of missing checks the malicious descriptor passes
   validation.
5. ndisValidateAndConvertWcharStringToUnicodeString() copies the string
   using the untrusted Offset/Length, performing a kernel pool read
   outside the original user buffer.
6. The leaked memory can contain privileged pointers or data that can
   be re-used for elevation of privilege.

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker.  No special privileges are required
other than the ability to open the NDIS device and send crafted IOCTLs
(e.g. via CreateFile("\\\.\Ndisuio" …) on Windows client).

Patch Description
--------------------------------------------------------------------
1. Hardened ndisValidateEmbeddedBufferBounds():
   • Added explicit check that Offset and Offset+Length are inside the
     user buffer (under-flow / over-flow detection).
   • Added optional alignment mask parameter.
   • Reordered arguments; callers updated accordingly.
2. Re-implemented ndisValidateNdisVarDataDescInputString() and
   ndisValidateNdisVarDataDesc32InputString() to:
   • Verify that the descriptor header itself (8/16 bytes) fits in the
     buffer.
   • Call the new embedded-buffer helper instead of re-implementing
     arithmetic.
   • Pass the real descriptor length (*a3) instead of an uninitialised
     register.
3. ndisValidateNdisOffsetAndLengthInputBufferBounds() simplified to a
   single call to the hardened helper.
4. ndisHandlePnPRequest() modified to use the new helpers and purified
   variable handling, eliminating use-of-uninitialised data.

Security Impact
--------------------------------------------------------------------
Prior to the patch a local attacker could craft a buffer that passes
validation and forces the kernel to read beyond the end of the user
allocation, disclosing arbitrary kernel memory and paving the way for
privilege escalation to SYSTEM.  The issue is tracked as
CVE-2025-55339.

Fix Effectiveness
--------------------------------------------------------------------
All callers now funnel through the revised
ndisValidateEmbeddedBufferBounds(), which blocks both offset/length
wrap-around and misalignment.  The previous uninitialised variable
usage has been removed.  No residual path performing unchecked pointer
arithmetic was observed in the updated diff, indicating the fix is
comprehensive for this code path.
