{'cve': 'CVE-2025-2884', 'date': 1763406125.2566197, 'confidence': 0.25, 'file': 'tpmengum.dll', 'patch_store_uid': '1f1c6021-1c04-4359-9c80-17558f8ed689', 'kb': 'KB5066835', 'change_count': 2}
--------------------------------------------------------------------
CVE-2025-2884 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows TPM 2.0 software stack (tpmengum.dll) – routine
ScEcDsaTruncateHash, reachable through several TPM2 signing
commands (e.g., TPM2_NV_Certify -> _cpri__SignEcc -> CryptSign).


Vulnerability Class
--------------------------------------------------------------------
Out-of-Bounds Read / Write (memory corruption) – CWE-125 / CWE-787.


Detailed Root Cause Analysis
--------------------------------------------------------------------
ScEcDsaTruncateHash converts an input hash into a SymCrypt FDEF
integer that is reduced modulo the EC group order.  The routine
allocates a scratch buffer (v12) and then copies the hash into it in
32-bit little-endian chunks.  The same buffer is subsequently passed
to SymCryptFdefRawDivMod and other SymCrypt helpers which expect the
operand to be in the following layout:

  +0x00  DWORD  magic  (0x67599910)
  +0x04  DWORD  nWords
  +0x08  data[ nWords * 16 ]           <-- operand begins here

In the vulnerable build the code allocates
   malloc( v6[4] + 36 )
then directly stores the first hash word at v12[0]:
   v22 = v12;
   *v22++ = v24;                       // overwrites header field 0
As a result, the 8-DWORD header becomes attacker-controlled.  When the
buffer is handed to SymCryptFdefRawDivMod the library trusts the
corrupted header and performs wide multi-precision operations using
"nWords" supplied by the attacker.  If the forged value is larger than
what was actually allocated, SymCrypt reads and writes beyond the end
of the heap block, corrupting adjacent memory or disclosing kernel
contents.

The patch changes three critical points:
1. Buffer sizing – v12 is now sized from the input hash length
   (variable v13) and built with a correct header (magic + nWords).
2. Data copy – the hash is written starting at v12 + 8 DWORDs,
   preserving the header.
3. Cleanup – SymCryptWipeAsm now uses the size stored in the header,
   and the function scrubs its stack frame before returning.

Because the header can no longer be overwritten, SymCrypt receives
consistent metadata and stays within bounds.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable – header overwritten
v12 = aligned_malloc(v6[4] + 36);
v22 = v12;                 // points to header
*v22++ = v24;              // attacker value -> header[0]
...
SymCryptFdefRawDivMod(v12, v12, ...); // uses corrupted header

// fixed
v12 = aligned_malloc((v13 << 6) + 32 + 36);
*v12     = 0x67599910;     // magic
v12[1]   = v13;            // nWords
v22 = v12 + 8;             // write AFTER header
*v22++ = v24;              // header intact
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
User/host sends TPM2 command that ends in ECDSA signing
  -> CryptSign
     -> _cpri__SignEcc
        -> ScEcDsaTruncateHash(hashPtr, hashLen, ...)
           a) hash copied over header (pre-patch)
           b) SymCryptFdefRawDivMod trusts header
           c) Out-of-bounds memory access occurs inside SymCrypt.


Attack Vector
--------------------------------------------------------------------
Any caller able to supply an arbitrarily sized hash to a TPM 2.0
signing command under Windows (local user-mode process, virtual
machine guest, or potentially a remote attacker through a protocol
using the TPM) can craft a hash whose first eight bytes form a fake
FDEF header with an inflated nWords field.  Issuing the command causes
kernel-mode code in tpmengum.dll to touch memory beyond the allocated
buffer.


Patch Description
--------------------------------------------------------------------
1. Replaced old allocation based on key parameter v6[4] with a new
   allocation derived from the input hash length (v13).
2. Constructed a valid SymCrypt FDEF header (magic 0x67599910,
   size field) in v12.
3. Adjusted copy offset from v12 to v12 + 8 to leave header intact.
4. Updated wipe routines to use the size stored in the header instead
   of unrelated key fields.
5. Added explicit stack cleansing before function return.


Security Impact
--------------------------------------------------------------------
Prior to the fix, unprivileged code could trigger kernel-mode
out-of-bounds read/write in the TPM software stack, leading to
information disclosure, denial of service (bugcheck), or potentially
arbitrary code execution inside the Windows kernel.


Fix Effectiveness
--------------------------------------------------------------------
The allocation now matches the operand size, the header is no longer
clobbered, and all SymCrypt calls use internally consistent metadata.
Attempting to replay the original proof-of-concept with an oversized
hash no longer causes memory corruption; the function returns either
success or the documented error 0x800D (32781).  The added stack/heap
wipes reduce residual risk.  No residual OOB condition was observed in
the patched code.
