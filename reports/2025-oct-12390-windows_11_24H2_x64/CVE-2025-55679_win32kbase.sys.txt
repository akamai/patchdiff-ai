{'patch_store_uid': '0c454f3b-86c0-4d7f-b2a6-96633b8a9a38', 'change_count': 82, 'confidence': 0.34, 'cve': 'CVE-2025-55679', 'kb': 'KB5066835', 'file': 'win32kbase.sys', 'date': 1763407802.3293447}
--------------------------------------------------------------------
Unknown-CVE Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
win32kbase.sys – NSInstrumentation::CTypeIsolation<*> template
instances (Allocate method).  Affected driver is part of the Windows
graphics kernel subsystem.

Vulnerability Class
--------------------------------------------------------------------
Information disclosure caused by use-of-uninitialised kernel heap
memory / improper input validation (CWE-200, CWE-457).

Detailed Root Cause Analysis
--------------------------------------------------------------------
CTypeIsolation objects maintain fixed-size descriptor buffers that are
handed out through Allocate().  When the object’s internal flag at
offset +0x24 (bit 0 of the byte at a1+0x24, seen as *((BYTE*)a1+36)) is
set, the function does a fast allocation from a per-type PAGED
LOOKASIDE list held at a1[3].

Before the patch the code executed the following logic:

1. Call Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage_1().
2. If that helper returned FALSE, immediately return the raw heap block
   produced by ExAllocateFromPagedLookasideList() – no initialisation.
3. Otherwise allocate and memset() the block to zero before returning.

Therefore, whenever the feature flag *DeviceUsage_1* was disabled the
freshly returned buffer contained whatever data remained from its
previous lifetime.  Higher-level win32k code later copies portions of
this structure to user mode (for instance through instrumentation or
ETW paths), leaking arbitrary portions of kernel memory to an
unprivileged caller.

The bug affects every template instantiation that inlines this helper
( 36 KiB / 49 KiB / 80 KiB / 90 KiB / 160 KiB / 180 KiB / 909 KiB, etc.)
so the information leak size is under attacker control.

Key parameters / structures:
• a1[3] – pointer to _PAGED_LOOKASIDE_LIST supplying the buffer
• size   – template parameter (144 … 3552 bytes in the shown variants)
• flag   – *((BYTE*)a1+36) selects lookaside path
• Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage_1/2 – build/flight
  feature toggles that gate the zero-initialisation.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable pattern (before)
if (*((BYTE*)a1 + 36)) {
    IsEnabled = Feature_IsEnabledDeviceUsage_1();
    lookaside = (PAGED_LOOKASIDE_LIST*)a1[3];
    if (!IsEnabled)
        return ExAllocateFromPagedLookasideList(lookaside); // LEAK
    buf = ExAllocateFromPagedLookasideList(lookaside);
    memset(buf, 0, SIZE);                                   // safe path
    return buf;
}
```
```c
// fixed pattern (after)
if (*((BYTE*)a1 + 36)) {
    IsEnabled2 = Feature_IsEnabledDeviceUsage_2();
    lookaside  = (PAGED_LOOKASIDE_LIST*)a1[3];
    if (!IsEnabled2)
        return ExAllocateFromPagedLookasideList(lookaside); // still raw
    buf = ExAllocateFromPagedLookasideList(lookaside);
    if (!Feature_IsEnabledDeviceUsage_1() || buf)
        memset(buf, 0, SIZE); // now executed whenever buf != NULL
    return buf;
}
```
Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User-mode code triggers a win32k path that ultimately calls
   CTypeIsolation<*>.Allocate().
2. The object was created with the *lookaside* flag set.
3. System is running with DeviceUsage_1 feature **disabled**.
4. Allocate() returns an uninitialised buffer taken from the lookaside
   cache.
5. Subsequent kernel code copies parts of that buffer back to user mode
   (for example via NtQuerySysInfo, ETW, or graphic instrumentation),
   disclosing stale kernel data.

Attack Vector
--------------------------------------------------------------------
Local, low-privilege attacker invokes the affected win32k API sequence
while toggling the corresponding feature flag (or on builds where it is
normally off).  No special privileges are required beyond the ability
to reach the graphics subsystem.

Patch Description
--------------------------------------------------------------------
1. The feature-flag variable used to gate the early return was changed
   (_IsEnabledDeviceUsage_2 instead of _1).
2. The memset() invocation is now executed whenever the allocation
   succeeds, regardless of feature state.
3. As a side effect, the code also avoids calling memset() with a NULL
   pointer (checked by the logical OR with the allocation result).

Security Impact
--------------------------------------------------------------------
Prior to the patch an attacker could read freed kernel heap data of up
to ~3.5 KiB per request, enabling leakage of kernel pointers, stack
contents, credential material, etc.  This undermines KASLR and can be
combined with other flaws for privilege escalation or to bypass kernel
exploit mitigations.

Fix Effectiveness
--------------------------------------------------------------------
The updated logic guarantees that every successful allocation through
this path is zeroed before use, eliminating the uninitialised memory
exposure.  Because the early return path (feature_2 == FALSE) still
returns raw memory, exploitability now depends on an additional feature
flag that is normally enabled in production; with that condition met
the leak is fully closed.  No obvious bypass was identified in the
modified code.

