{'cve': 'CVE-2025-59210', 'file': 'refsdedupsvc.exe', 'patch_store_uid': 'a412586d-d565-48b9-897e-ba0ae0acb19e', 'change_count': 87, 'kb': 'KB5066835', 'date': 1763403061.738247, 'confidence': 0.25}
--------------------------------------------------------------------
CVE-2025-59210 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Resilient File System (ReFS) – Deduplication Service
(refsdedupsvc.exe).  Affected routines are spread over the B-tree index
management code (CmsTableCursorBase, CmsBPlusTable and helpers).

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use-After-Free (dangling pointer to an already un-pinned page
buffer).

Detailed Root Cause Analysis
--------------------------------------------------------------------
1. Cursor creation
   Function CmsTableCursorBase::StartAtCore accepted its flag parameter
   as an 8-bit value:
       char a4   // before patch
   Callers, however, supply _EMS_CURSOR_FLAGS – a 16-bit bit-field.  The
   high-order flag 0x2000 (HandleIgnoreCaseNotFound) was silently
   truncated and therefore lost.

2. Internal state initialisation
   The lost bit means the cursor never sets its internal state bit 0x04
   (stored at offset +93h inside the cursor object).  Later code relies
   on that bit to keep the index page pinned while the structure is
   being modified.

3. Page deletion path
   CmsBPlusTable::DeleteIndexEntry assumes that, when the 0x2000 flag is
   active, the page being modified stays pinned until the undo record is
   committed.  Because the flag was lost, the function executed the
   unpin logic (CmsVolume::Unpin) even though the caller still held a
   raw pointer to the page.  Subsequent reads or writes through that
   dangling pointer produced a classic use-after-free on the page
   buffer.

4. Similar flag checks exist in UpdateParentDirectorRow and the
   fail-over lambda; all of them mis-behaved for the same reason and
   could operate on freed memory.

5. Exposure
   A low-privileged user can trigger the vulnerable code path by
   crafting a directory operation that causes the deduplication service
   to perform a bucket-collapse with the HandleIgnoreCaseNotFound flag
   set.  Because the flag is dropped, the service mishandles reference
   counts, accesses a freed page buffer and eventually executes
   attacker-controlled data or crashes.

Structures / offsets involved
   Cursor object        : +93h   (state flags)
   SmsPage              : freed via CmsVolume::Unpin()
   Undo record flag     : byte 20 (bit 3 added by the patch)

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
char __fastcall StartAtCore(__int64 obj, __int64 tx, __int64 stack,
                            char flags)
{
    ...
    if ((flags & 4) != 0)
        *(BYTE*)(obj+93) |= 2;
    // 0x2000 impossible here – truncated
}

// after
char __fastcall StartAtCore(__int64 obj, __int64 tx, __int64 stack,
                            __int16 flags)
{
    *(BYTE*)(obj+93) |= 1;
    if (flags & 4)
        *(BYTE*)(obj+93) |= 2;
    if (FeatureIsEnabled() && (flags & 0x2000))
        *(BYTE*)(obj+93) |= 4;          // keep page pinned
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Caller passes _EMS_CURSOR_FLAGS containing 0x2000 to StartAtCore.
2. Flag lost -> cursor state bit 0x04 never set.
3. DeleteIndexEntry / UpdateParentDirectorRow decide that the target
   page can be unpinned early.
4. CmsVolume::Unpin frees or recycles the buffer.
5. Same routine continues to operate on *a3 / *v20 – dangling pointer.

Attack Vector
--------------------------------------------------------------------
Local attacker performs a file-system operation that causes ReFS
Deduplication to execute a bucket collapse where the
HandleIgnoreCaseNotFound flag must be honoured.  Malicious timing or
crafted on-disk structures cause the freed page to be re-allocated with
attacker-controlled data, leading to elevation of privilege inside the
SYSTEM-level service.

Patch Description
--------------------------------------------------------------------
• StartAtCore: parameter widened to 16-bit; explicit handling of 0x2000
  and propagation into cursor state.
• Added Feature_ReFS_Fix_HandleIgnoreCaseNotFound_Racing_With_Bucket_
  Collapse* gating helper.
• DeleteIndexEntry, UpdateParentDirectorRow and the fail-over lambda are
  updated to:
  – accept extra arguments that forward the preserved flag,
  – set new undo-record bit 0x08 when 0x2000 is active,
  – keep pages pinned until the operation fully completes,
  – adjust reference-count offsets (+340 instead of +324).

Security Impact
--------------------------------------------------------------------
Before the patch an unprivileged user could trigger a use-after-free in
SYSTEM context, leading to denial-of-service or, with precise heap
spray, arbitrary code execution in the Windows kernel address space.

Fix Effectiveness
--------------------------------------------------------------------
The widened parameter guarantees that all 16 flag bits are preserved,
allowing the high-order 0x2000 flag to be acted upon.  All affected call
sites now recognise the flag and keep the page pinned, eliminating the
dangling pointer.  Additional undo-record tagging provides defence in
depth.  No residual path was seen that still truncates the flag, so the
fix is judged effective.
