{'file': 'ntoskrnl.exe', 'change_count': 222, 'confidence': 0.24, 'kb': 'KB5066835', 'patch_store_uid': 'c1b97b38-6328-4043-8cf8-12e6eafee863', 'cve': 'CVE-2025-50152', 'date': 1763406177.882771}
--------------------------------------------------------------------
CVE-2025-50152 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows kernel – ntoskrnl.exe routine PnpValidatePropertyData(), which
is used by Plug-and-Play code to sanity-check user-supplied registry
property data before it is written into the kernel/device property
store.

Vulnerability Class
--------------------------------------------------------------------
Out-of-bounds read  (CWE-125) leading to local elevation of privilege.

Detailed Root Cause Analysis
--------------------------------------------------------------------
PnpValidatePropertyData() receives a caller-controlled buffer
(SecurityDescriptorLength bytes) that contains registry-style property
data.  For string-based types (base type bits 0x2000, i.e. REG_SZ and
REG_MULTI_SZ) the original implementation manually walked the WCHAR
buffer looking for a terminating NUL (resp. double-NUL for
REG_MULTI_SZ):

  • It dereferenced *(_WORD*)SecurityDescriptor before verifying that
    at least two bytes are still inside the caller-supplied length.
  • If the buffer lacked a terminator the while() loops continued
    reading past the end of the user buffer, first into uninitialised
    kernel stack/heap and then into unrelated kernel memory.  All
    arithmetic was performed on size_t variables that were updated
    only after the read, therefore the out-of-bounds access happened
    before the length check (v22 > v4) caught it.

Because PnpValidatePropertyData() executes in kernel context while the
supplied buffer is still mapped from user mode, an attacker owning a
HANDLE to an arbitrary PDO or FDO can supply a property value whose
final WCHAR is at the very end of the user buffer with no following
NUL.  When the kernel probes the first missing terminator it crosses
into kernel address space, disclosing memory contents and potentially
allowing the caller to infer kernel addresses or privilege bits later
used for LPE.

Other sub-cases (REG_BINARY zero-mask and fixed-size types) were
subject to separate checks and are not affected.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// BEFORE
while ( *(_WORD *)SecurityDescriptor ) {
    v23 = (v4 - v22) >> 1;              // bytes still available
    ...                                 // no check before deref
}

// AFTER
while ( *(_WORD *)psz ) {
    if ( RtlStringCbLengthW((STRSAFE_PCNZWCH)psz,
                             v4 - v20, &pcbLength) < 0 )
        return STATUS_INVALID_PARAMETER;
    ...                                 // safe length probe
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User process calls a Plug-and-Play interface that eventually reaches
   IoSetDevicePropertyData()/IoSetDeviceInterfacePropertyData.
2. The user passes REG_SZ or REG_MULTI_SZ property data whose final
   WCHAR is the last byte of the buffer, omitting the required NUL.
3. Kernel captures the buffer and calls PnpValidatePropertyData().
4. The function enters the 0x2000 branch and the old loop reads past
   the buffer end, leaking kernel memory.

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker with the ability to set device/interface
properties supplies a malformed REG_SZ / REG_MULTI_SZ value that is
not NUL-terminated within the reported length.

Patch Description
--------------------------------------------------------------------
1. Parameter renamed to psz and typed as __int64* for stricter
   alignment.
2. All manual WCHAR scanning logic replaced by
   RtlStringCbLengthW(), which refuses to scan past the provided size
   and returns the exact substring length in pcbLength.
3. Cumulative length tracking (v20) plus explicit comparisons prevent
   integer wrap-around and enforce maximum 0xFFFE bytes per string.
4. Simplified type filter `((v7 - 18) & 0xFFFFFFFD)` protects against
   unexpected sub-type values.

Security Impact
--------------------------------------------------------------------
Out-of-bounds read in kernel context can disclose arbitrary kernel
memory to user space and may be chained with other primitives to
obtain SYSTEM privileges.  Microsoft classifies the outcome as local
Elevation of Privilege.

Fix Effectiveness
--------------------------------------------------------------------
The new implementation calls a vetted string length helper that never
reads beyond the supplied buffer and validates every substring in
REG_MULTI_SZ.  All size additions are checked for overflow and maximum
length.  Therefore the specific out-of-bounds read described above is
no longer reachable.  No residual bypass is evident from the patch.
