{'file': 'refsv1.sys', 'cve': 'CVE-2025-55687', 'confidence': 0.25, 'change_count': 9, 'date': 1763408715.7397375, 'kb': 'KB5066835', 'patch_store_uid': 'cf676364-63cd-43e6-a72d-2bcd5824cf1e'}
--------------------------------------------------------------------
CVE-2025-55687 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Resilient File System (ReFS) kernel driver
(refsv1.sys).  The affected routines implement access checking,
security-descriptor query / modification and FCB creation.

Vulnerability Class
--------------------------------------------------------------------
CWE-362: Race condition (improper synchronisation)
CWE-416: Use-after-free (dangling pointer to freed security
structure)

Detailed Root Cause Analysis
--------------------------------------------------------------------
ReFS stores security information in a reference-counted structure
(REFS_SHARED_SECURITY, layout unknown; pointer held at FCB+0xB8 /
VCB+0xB8).  Prior to the patch, many code paths retrieved that pointer
and used fields inside the underlying SECURITY_DESCRIPTOR without
       1. taking a reference (RefsReferenceSharedSecurity) and
       2. holding the protecting push-lock (offset +0xC0, same object)

Consequently another thread could concurrently execute
RefsModifySecurity() and exchange the shared pointer, then
RefsDereferenceSharedSecurity() would free the old descriptor while it
was still being used by:
 • RefsCanAdministerVolume()
 • RefsNotifyAccessCheck()
 • RefsQuerySecurity()
 • AccessCheck() helper
 • RefsCreateFcb() path that inserts a new FCB into the AVL table

The windows above occur between the time the old code reads
FCB->SharedSecurity (or VCB->SharedSecurity) and the time SeAccessCheck
/ SeQuerySecurityDescriptorInfo dereferences the embedded SD at
+0x14.

Typical sequence (simplified):
  T0: thread A calls RefsCanAdministerVolume()
      v9 = *(vcb->SharedSecurity)
  T1: thread B calls RefsModifySecurity() and replaces the same field,
      then dereferences the old object, dropping refcount to zero;
      memory is freed.
  T2: thread A continues execution, passes freed memory to
      SeAccessCheck(), resulting in pool-use-after-free.  Because the
      data are interpreted as a SECURITY_DESCRIPTOR, the attacker can
      craft fake memory and escalate privileges to SYSTEM.

No refcount meant the window existed even on SMP systems with normal
I/O workloads; a local low-privileged user could reliably win the race
by spraying FCB security updates.

Vulnerability Code Snippets
--------------------------------------------------------------------
Before (no lock / ref):
```c
v9 = *(struct _PRIVILEGE_SET **)(*(_QWORD *)(v8 + 8) + 8i64); // get
Control = v9[1].Control;                // use it immediately
...
SeAccessCheck(a4, p_HighPart, 1u, Control, ...);
```
After (take lock + ref):
```c
ExAcquirePushLockSharedEx(a3 + 192, 0i64);
v9 = *(_QWORD *)(a3 + 184);     // SharedSecurity
v17 = v9;
RefsReferenceSharedSecurity(*(_QWORD *)(a3 + 88), v9);
ExReleasePushLockEx(a3 + 192, 0i64);
...
SeAccessCheck(...);
...
RefsDereferenceSharedSecurity(*(_QWORD *)(a3 + 88), &v17);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Low-privileged process opens the same file/volume twice.
2. Thread A issues a read or user action causing
   RefsCanAdministerVolume()/RefsNotifyAccessCheck()/AccessCheck().
3. Thread B rapidly calls NtSetSecurityObject() on that file,
   executing RefsModifySecurity() which swaps the shared security
   pointer.
4. Thread B frees the old object when refcount reaches zero.
5. Thread A continues, dereferences dangling pointer, leading to pool
   corruption / controlled SD evaluation.

Attack Vector
--------------------------------------------------------------------
Local attacker with the ability to open a ReFS file or volume and to
set its security descriptor.  No additional privileges are required;
any authenticated user on the machine can trigger the race.

Patch Description
--------------------------------------------------------------------
1. Added explicit push-lock acquisition around every read or write of
   the SharedSecurity pointer (shared for read, exclusive for write).
2. Inserted RefsReferenceSharedSecurity() immediately after obtaining
   the pointer, and matching RefsDereferenceSharedSecurity() in all
   exit paths.
3. RefsModifySecurity() now switches the pointer while holding the
   lock, then releases it after the dereference of the old object.
4. RefsCreateFcb() enlarged the nonpaged FCB allocation to store a new
   lock / pointer slot and initialised it to zero.
5. Minor housekeeping: new pool tag size, new magic number, updated
   field offsets affected by the structural change.

Security Impact
--------------------------------------------------------------------
The race permitted a pool use-after-free in kernel context.  An
attacker could craft a fake SECURITY_DESCRIPTOR in freed memory and
convince SeAccessCheck() to grant arbitrary access, leading to
privilege escalation to SYSTEM.  Reliability is high because the race
is in hot code paths and the attacker controls timing.

Fix Effectiveness
--------------------------------------------------------------------
The added locking and reference counting correctly close the race
window for the analysed paths.  All sites that previously touched
FCB/VCB->SharedSecurity now follow the new protocol.  No remaining
unlock-on-error leaks were observed.  Effectiveness appears complete
for the provided diff, but other undocumented call sites were not
reviewed (status: assumed adequate).
