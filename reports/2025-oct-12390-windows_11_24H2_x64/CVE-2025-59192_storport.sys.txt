{'confidence': 0.12, 'kb': 'KB5066835', 'file': 'storport.sys', 'patch_store_uid': '1f3fb521-81bb-427b-ba05-efd542c865dd', 'change_count': 18, 'cve': 'CVE-2025-59192', 'date': 1763407719.2289891}
--------------------------------------------------------------------
CVE-2025-59192 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows storage port driver  (storport.sys) – several IOCTL
handlers that parse user-supplied request buffers:
  • RaidAdapterStorageInternalQueryPropertyIoctl()
  • RaValidateProtocolCommandIoctl()
  • RaUnitStorageDiagnosticIoctl()
  • NvmeAdapterFirmwareGetInfoIoctlCompletion()

Vulnerability Class
--------------------------------------------------------------------
Buffer Over-read / out-of-bounds read (CWE-126)

Detailed Root Cause Analysis
--------------------------------------------------------------------
All four vulnerable entry points accept DeviceIoControl requests that
carry a variable-length structure supplied from user mode.  Every
structure contains length and offset fields that must all reference
memory that resides inside the caller’s input/output buffer.  In the
original (before-patch) code this invariant was **not** completely
verified.

Typical flow (RaValidateProtocolCommandIoctl shown):
 1. The IRP input buffer base is taken from
    IRP->AssociatedIrp.SystemBuffer (`v3`).
 2. *InputBufferLength* is read from *(v3+16) into `v6`.
 3. When `v6` is **smaller than 0x54 bytes** the code should fail, yet
    the old test only guaranteed `v6 >= 0x14`, letting many truncated
    buffers pass further validation.
 4. The function then blindly dereferences secondary fields such as
      • ProtocolSpecificDataLength   (*(v4+24))
      • CommandSpecificDataLength    (*(v4+32))
      • DataToDeviceTransferLength   (*(v4+36))
     and combines them with likewise uncontrolled *offset* fields
     (*(v4+44 / +48 / +52)).
 5. Whenever one of those offsets pointed outside the real user buffer
    the driver read (and sometimes later copied back) kernel memory
    located beyond the user allocation – a classic **over-read**.

Other IOCTL helpers show the same pattern: they depended on the caller
for correct sizing and only performed incomplete range checks, e.g.
   if (v33 + 40 <= v55) { ... }
while the caller could make `v55` reference untrusted data in the same
buffer, effectively bypassing the comparison.

Because storport.sys runs with kernel privileges, any user able to send
these IOCTLs can make the driver leak arbitrary kernel bytes or crash
by triggering a page-fault.  Leaked data can be combined with other
issues to achieve local elevation of privilege.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – RaValidateProtocolCommandIoctl
v6 = *(unsigned int *)(v3 + 16);
if ((unsigned int)v6 >= 0x54) {       // intended minimal size
    ...                               // continues parsing
} else if ((unsigned int)v6 >= 0x14)  // <-- weak fallback
{                                     // still continues!
    *(_DWORD *)(v4 + 16) = 3;
    return STATUS_INVALID_PARAMETER;
}
...
// unchecked arithmetic on caller-controlled offsets
v12 = *(unsigned int *)(v4 + 48);
if (v12 < v7 + 80 || (v12 & 7) != 0 || v6 < v12 + v11)
    goto fail;                        // BUT v6 was not validated
```
```c
// after patch
v6 = *(_DWORD *)(v3 + 16);
if (v6 < 0x54)
{
    *(_DWORD *)(v4 + 16) = 3;
    return STATUS_INVALID_PARAMETER;
}
...
if (v10 < (unsigned)__int64)*(unsigned int *)(v4 + 24) + 80 ||
    (v10 & 7) != 0 ||
    *(unsigned int *)(v3 + 16) < v10 + v9)
    goto fail;
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker opens a handle to the target disk or controller device.
2. DeviceIoControl issued with IOCTL_STORAGE_PROTOCOL_COMMAND (or one of
   the other affected codes) using a deliberately **undersized** input
   buffer but patched length/offset fields.
3. storport.sys dispatches the IRP to one of the listed helper
   functions.
4. Old code trusts the forged size/offset and reads past the caller’s
   allocation, copying kernel memory into the same buffer.
5. Control returns to user mode with the IRP success status and the
   buffer now containing leaked data.

Attack Vector
--------------------------------------------------------------------
Local, user-mode code running with any privileges sufficient to open the
underlying device (typically *\Device\RaidPort*).  No admin rights are
required.

Patch Description
--------------------------------------------------------------------
The update introduces **strict, consistent boundary checks** before any
nested field is dereferenced:
 • Minimal structure size is raised to 0x54 bytes and enforced with an
   early return.
 • Every *Offset*+*Length* pair is now compared against the real
   SystemBuffer length.  The constant *80* (header size) is added to
   the offset to ensure the data area is inside the same allocation.
 • Misaligned offsets (bit-wise `& 7`) are rejected.
 • Several helper functions were rewritten to abort on *any* validation
   failure instead of attempting to continue.
 • New feature-flag checks were removed; validation no longer depends on
   experimental run-time options.

Security Impact
--------------------------------------------------------------------
Prior to the fix a normal user could read arbitrary, potentially
sensitive kernel memory (pointers, credentials, ASLR values) and use
that information to bypass kernel protections, culminating in a local
Elevation of Privilege.  The issue is rated CWE-126.

Fix Effectiveness
--------------------------------------------------------------------
The added length/offset and alignment checks cover every place where the
caller-controlled pointer is consumed.  All code paths that formerly
used secondary offsets now first verify that the computed end address
is inside the input buffer.  Attempts to supply truncated or
mis-aligned buffers immediately fail with STATUS_INVALID_PARAMETER.
No residual unchecked arithmetic was observed in the patched diff, so
the fix is considered effective.
