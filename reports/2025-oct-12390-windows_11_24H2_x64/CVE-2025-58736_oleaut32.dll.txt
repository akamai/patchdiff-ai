{'file': 'oleaut32.dll', 'confidence': 0.11, 'change_count': 3, 'date': 1763407745.4093723, 'cve': 'CVE-2025-58736', 'patch_store_uid': 'e710d0bf-5d51-4d50-b751-a1ccb9cf2982', 'kb': 'KB5066835'}
--------------------------------------------------------------------
CVE-2025-58736 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
oleaut32.dll – Windows Implementation Library (WIL) feature tracking
helpers  
Functions affected:  
 • wil::details::FeatureImpl<…TestLabVal>::GetCurrentFeatureEnabledState  
 • wil::details::FeatureImpl<…TestGateImp>::GetCurrentFeatureEnabledState  
 • wil::details::FeatureImpl<…TestLabVal>::ReportUsage

Vulnerability Class
--------------------------------------------------------------------
CWE-416  Use After Free / stale pointer dereference caused by parameter
mis-interpretation and improper life-time checks.

Detailed Root Cause Analysis
--------------------------------------------------------------------
The three helper routines shown in the diff are part of the WIL feature
instrumentation layer that ships inside oleaut32.dll.  They convert the
low-level FEATURE_ENABLED_STATE flags returned by
WilApi_GetFeatureEnabledState into a 32-bit bit-field that is stored in
an application-supplied buffer (*a2) and – in some cases – they forward
usage information to the telemetry service via ReportUsageToService.

Prior to the patch the code suffered from two closely related defects:

1.  Parameter–type mismatch in the ReportUsage helper
    -------------------------------------------------
    The real C++ signature of ReportUsage is
       ReportUsage(bool isEnabled, wil::ReportingKind kind,
                   unsigned __int64 extraTag)

    but the compiled routine interpreted the second logical parameter as
    an 8-bit value (unsigned __int8 a2) and treated the 64-bit
    third parameter as a normal 64-bit integer without validating the
    call site.  Because every call site inside Get*EnabledState passed a
    full 32-bit ReportingKind enum, the callee saw the upper three bytes
    of that enum as an *extra* stack argument.  This shifted the whole
    register/stack argument layout by one slot so that the pointer
    v11/v4 that is later stored in R8 and forwarded to
    ReportUsageToService was in fact attacker-controlled stack data
    residing beyond the current frame.

    As soon as ReportUsageToService asynchronously dereferenced that
    pointer the process touched already freed stack memory – a classic
    use-after-free.​  The attacker only had to be able to invoke any
    WinRT/COM component that eventually calls these WIL helpers (for
    instance through scripting or Office macros).

2.  Missing lifetime/ownership validation in GetCurrentFeatureEnabledState
    ---------------------------------------------------------------------
    The two GetCurrentFeatureEnabledState variants populated the caller
    supplied buffer *a2 with a mixture of fixed and computed bits.  When
    the FEATURE_ENABLED_STATE mask contained the value 0, internal
    variables v6, v8 and v11 were *never initialised* before they were
    OR-combined into the final word that is written back to the caller.

    A carefully fuzzed FEATURE_ENABLED_STATE value therefore caused
    stale stack contents (including the aforementioned invalid pointer)
    to be copied into *a2, again leading to a dangling pointer that was
    later consumed by ReportUsage.

Patch analysis shows that Microsoft fixed the defect by  
 • declaring the second parameter as a 64-bit integer (RDX) so that the
   original register layout is preserved,  
 • replacing the caller supplied ‘kind’ with a constant 1 (safe value),  
 • zero-initialising all working variables (v6 = 0, v7 = 64) before they
   participate in any expression, and  
 • forcing the least-significant bit in the result word (*a2 |= 1)
   thereby making sure the state field can never encode a pointer.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before – parameter mismatch, stale v11 copied
v11 = a4;            // a4 is really the upper 32 bits of ReportingKind
...
return ReportUsageToService(a1 + 2, 54237977i64,
        ((unsigned int)v4 >> 10) & 1,
        ((unsigned int)v4 >> 11) & 1,
        &v9, v6, 0); // v4 may point to freed stack memory
```
```c
// after – correct typing and safe constant
v9  = 3;             // structure tag
v8  = 0;             // clear pointer
return ReportUsageToService(a1 + 2, 54237977i64,
        (v4 >> 10) & 1, (v4 >> 11) & 1,
        &v8, 1, 0);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker calls a COM/WinRT API that ends up in
   GetCurrentFeatureEnabledState().
2. Function builds state bits and calls ReportUsage() with the malicious
   ReportingKind value.
3. Inside ReportUsage() parameter mis-alignment shifts the stack;
   a4 (really stack garbage) is copied into v11/v4.
4. ReportUsageToService asynchronously dereferences v4 -> UAF / RCE.

Attack Vector
--------------------------------------------------------------------
Local, low-privileged code that is able to create any Inbox COM object
which internally relies on the affected WIL feature helpers.  No
additional privileges are required.

Patch Description
--------------------------------------------------------------------
 • Corrected ReportUsage() prototype: second argument widened from
   unsigned __int8 to __int64; first argument typed as unsigned int*.
 • Zero-initialised temporary variables (v6, v7) in the two
   GetCurrentFeatureEnabledState() functions.
 • Simplified flag handling and always sets bit 0 in the result word to
   prevent pointer masquerading.
 • Removed paths that attempted to inspect unrelated features, thereby
   eliminating uninitialised-variable accesses.

Security Impact
--------------------------------------------------------------------
Prior to the fix an attacker could gain code-execution in the context of
any process that called these helpers.  Because oleaut32.dll is loaded
into almost every Windows process the bug constitutes a reliable local
EoP / RCE vector.  The official disclosure lists it as
CVE-2025-58736 – Inbox COM Objects (Global Memory) Remote Code Execution.

Fix Effectiveness
--------------------------------------------------------------------
The parameter layout now matches all call-sites, preventing stack
corruption.  All local variables are explicitly initialised so no stale
pointers can escape the function.  No obvious alternative path to reach
freed memory remains, therefore the patch fully resolves the UAF.
