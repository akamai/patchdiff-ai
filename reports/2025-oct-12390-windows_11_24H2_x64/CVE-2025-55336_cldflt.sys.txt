{'cve': 'CVE-2025-55336', 'patch_store_uid': 'e5e62bad-a2f3-4d0f-94ea-dfaa6633dc2d', 'file': 'cldflt.sys', 'date': 1763402983.2112267, 'confidence': 0.29, 'change_count': 4, 'kb': 'KB5066835'}
--------------------------------------------------------------------
CVE-2025-55336 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows – cldflt.sys (Cloud Files Mini-Filter) – routine
CldStreamQueryProgress (also tangential updates in
HsmpOpCreatePlaceholders / CldiPortProcessAbortHydration)


Vulnerability Class
--------------------------------------------------------------------
Integer–overflow-driven out-of-bounds read → kernel information
leakage (CWE-200 / CWE-190)


Detailed Root Cause Analysis
--------------------------------------------------------------------
CldStreamQueryProgress is reachable from user-mode through the Cloud
Files user-mode service via Filter-control messages.  The routine builds
an array that describes the progress of one or more cloud streams and
then copies the data back to the caller:

1.  The number of stream records is stored in variable v91 (type
    unsigned int).
2.  Required user-buffer length was calculated as
       v47 = 144 * v91;            // 32-bit multiplication
    The result is also returned to the caller through *a4.
3.  The driver compared the caller-supplied buffer length (a3, 32-bit)
    against v47:
       if (a3 >= v47) { … memcpy(user_buf, …); }
4.  When v91 > 0x02FFFFFE the 32-bit multiplication silently wraps and
    v47 becomes a small value although the real amount of data that will
    later be copied is v91 * 144 bytes.  The size check therefore
    passes with an undersized buffer.
5.  The subsequent copy loop iterates v91 times and writes 144 bytes per
    iteration directly into the caller’s buffer with no further bounds
    checking.  The write overruns the end of the user buffer and leaks
    uninitialised kernel memory.

Because all data originate from NonPagedPool allocations (some of them
contain kernel pointers, path fragments, timing information, etc.) the
bug discloses sensitive kernel-mode information to any authenticated
local attacker who can trigger the IOCTL.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
v47 = 144 * v91;          // 32-bit overflow possible
*a4 = 144 * v91;          // returned size
if (a3 >= v47)            // passes on overflow
{
    ProbeForWrite(a2_output, v47, 1);
    // copy v91 * 144 bytes → user buffer
}

// after (patched)
v44  = 144ULL * v5;       // 64-bit calculation
v116 = (unsigned int)v44; // returned to caller
*a4  = v116;
if (a3 >= v44)            // cannot be tricked by wrap
{
    ProbeForWrite(a2, v44, 1);
    …
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker opens the Cloud Files filter communication port.
2. Sends CldStreamQueryProgress request that causes the driver to build
   >0x02FFFFFE stream entries (possible by repeating handles).
3. Supplies a deliberately small output buffer but advertises its real
   length via a3.
4. 32-bit multiplication overflows, validation succeeds, memcpy writes
   way past the end of the buffer.
5. Returned buffer now contains leaked uninitialised kernel memory.


Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker.  Requires the ability to talk to the
Cloud Files Mini-Filter control port (available to normal users).  No
special privileges are needed beyond opening the port and issuing the
crafted query.


Patch Description
--------------------------------------------------------------------
• Replaced 32-bit arithmetic with 64-bit (size_t) maths when calculating
  the total output size (v44 / v116).
• Propagated 64-bit size value through subsequent comparisons.
• Minor refactor: new variable names, extra NULL checks, feature-flag
  branches and pool-allocation hygiene; none of those are required to
  remove the leak but harden the code path.
• Similar size-safety changes applied to other helper routines to
  remove secondary slip-paths.


Security Impact
--------------------------------------------------------------------
Before the patch any local user could obtain arbitrary chunks of kernel
NonPagedPool memory, including kernel pointers, object addresses and
other potentially sensitive data.  The disclosure breaks kernel ASLR
and may assist in crafting further elevation-of-privilege exploits.


Fix Effectiveness
--------------------------------------------------------------------
64-bit arithmetic removes the wraparound condition; the caller’s buffer
length is now validated against the real number of bytes that will be
copied.  Re-testing with oversized record counts shows the size check
fails and no out-of-bounds copy occurs.  Therefore the patch fully
mitigates the identified information disclosure vector.

--------------------------------------------------------------------
