{'patch_store_uid': '19cf186f-c366-45f0-99fc-3c9896dd206c', 'kb': 'KB5066835', 'cve': 'CVE-2025-59211', 'change_count': 203, 'confidence': 0.09, 'date': 1763406290.8604317, 'file': 'wpncore.dll'}
--------------------------------------------------------------------
CVE-2025-59211 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Push Notification Core (wpncore.dll) – specifically the C++/WinRT
utility code that constructs winrt::hstring objects and several internal
memcpy_s wrappers.

Vulnerability Class
--------------------------------------------------------------------
Information disclosure caused by use of uninitialised / mismatched data
(CWE-200 ‑ Exposure of Sensitive Information to an Unauthorized Actor).
The root is a logic/implementation error rather than a classic buffer
overflow.

Detailed Root Cause Analysis
--------------------------------------------------------------------
1. The exported symbol winrt::hstring::hstring(ushort const *, uint)
   should allocate a shared_hstring_header, copy the caller-supplied UTF-16
   buffer, and attach the header pointer to the hstring object (8-byte
   field).

2. Before the patch the body of the constructor was *not* the expected
   allocation routine.  It was in fact a copy of the helper routine
   memcpy_s_2:
       errno_t memcpy_s_2(void *Dest, size_t DestSz, void *Src,
                          size_t SrcSz)

   The compiler/linker therefore attached a *completely different
   prototype* to the constructor symbol.  Parameter layout on x64 is:
       RCX=this, RDX=a2(ushort const *), R8=a3(length), R9=undefined.

   memcpy_s_2 interprets these registers as
       Dest  = this                     (8 bytes)
       DestSz= a2 (pointer, not size)   (8 bytes)
       Src   = a3 (length, garbage ptr) (8 bytes)
       SrcSz = R9 (indeterminate)

3. Because the argument types are mismatched the function usually hits its
   early-out paths (e.g. SrcSz==0, Dest==NULL checks), *returns success*,
   and leaves the hstring object completely uninitialised.  Whatever
   8-byte value happened to be in the hstring instance prior to the call
   remains there.

4. When the uninitialised hstring is later marshalled back to user code
   (e.g. as part of a Push Notification payload or when reading WinRT
   properties) that stale pointer can be dereferenced, copied or
   serialised.  As a result kernel-mode or highly privileged process
   memory may be disclosed to the unprivileged caller.

5. Two helper variants (memcpy_s and memcpy_s_1) also contained inverted
   validation logic that could leave destination buffers partially filled
   with uninitialised data when Source==NULL or when size checks failed.
   These contributed to, but were not solely responsible for, the leak.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Before – constructor body is really memcpy_s_2
errno_t __cdecl memcpy_s_2(
        void *const Destination,
        const rsize_t DestinationSize,
        const void *const Source,
        const rsize_t SourceSize)
{
  if(!SourceSize) return 0;          // returns success, no writes
  ...
}

// After – real constructor inserted
winrt::hstring *__fastcall winrt::hstring::hstring(
        winrt::hstring *this,
        const unsigned __int16 *src,
        unsigned int len)
{
  shared_hstring_header *hdr = 0;
  if(len) {
      hdr = precreate_hstring_on_heap(len);
      memcpy(hdr+28, src, 2*len);
  }
  *(void **)this = hdr;              // invariant now initialised
  return this;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-mode program -> WinRT Notification API -> wpncore!SomePublicMethod ->
constructor winrt::hstring::hstring(ushort*,len) (actually memcpy_s_2) ->
returns uninitialised hstring -> value propagated back to caller or over
IPC -> attacker reads memory contents referenced by stray pointer/value.

Attack Vector
--------------------------------------------------------------------
Local, authorised but low-privileged user or sandboxed process making
legitimate WinRT / Push-notification calls that internally create
hstrings.  No special capabilities are required beyond the ability to
invoke the affected API surface.

Patch Description
--------------------------------------------------------------------
1. Replaced the wrong body of winrt::hstring::hstring with a purpose-built
   routine that:
   • Allocates a shared_hstring_header via precreate_hstring_on_heap.
   • Correctly copies or zero-initialises the UTF-16 buffer.
   • Stores the resulting header pointer into the hstring object.

2. Re-implemented memcpy_s_1 and memcpy_s to match the official CRT
   semantics – validation before copy, guaranteed zeroing on failure, and
   correct errno propagation.  This prevents partial/uninitialised data
   from being left in caller buffers.

Security Impact
--------------------------------------------------------------------
Prior to the fix any call path that constructed an hstring could leak
8-bytes of uninitialised kernel or process memory to user space.  An
attacker could repeatedly call the API to sample memory and glean
sensitive information (addresses, pointers, or previously processed
payload data).  The issue is information disclosure only; no direct code
execution primitive was identified.

Fix Effectiveness
--------------------------------------------------------------------
The new constructor initialises the object deterministically and cannot
return success without setting its internal pointer field.  The updated
memcpy_s variants ensure that destination buffers are scrubbed on error.
Static review of the diff shows the defect is fully removed; runtime
validation is still recommended but no residual attack path is evident
from the patched code.
