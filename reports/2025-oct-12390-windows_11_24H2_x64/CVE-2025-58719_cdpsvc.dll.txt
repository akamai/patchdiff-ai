{'change_count': 8, 'confidence': 0.34, 'date': 1763403082.9418578, 'file': 'cdpsvc.dll', 'cve': 'CVE-2025-58719', 'patch_store_uid': '0e54175f-9f22-44cd-8cdd-4e0fede69033', 'kb': 'KB5066835'}
--------------------------------------------------------------------
CVE-2025-58719 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Connected Devices Platform Service (cdpsvc.dll).
Faulty helper: lambda_dde3f900c43be7a54739f39c59f549c9_::operator(),
called from CDPComDevice::DeviceCallback::OnAppTargetListReceived().

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use After Free triggered by a heap buffer under-allocation that
causes out-of-bounds writes and subsequent heap corruption.

Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  OnAppTargetListReceived() forwards its parameters to a std::function
    wrapping lambda_dde3f900c43be7a54739f39c59f549c9_::operator().

2.  The lambda receives:
      a1 -> wrapper holding two fields
            +0  : struct containing the source ICDPAppId
            +8  : WORD  *TargetCountPtr (number of char* targets)
            +16 : QWORD *TargetStrings   (array of char* pointers)
      a2 -> output buffer (CDPComDeviceResult) where the lambda must
            create an array of cloned strings and store its address at
            offset +64.

3.  Original code allocated the pointer array with:
        v6 = CoTaskMemAlloc( **(WORD**)(a1+8) );
    This size parameter is *count* rather than
    count * sizeof(char*) (8 bytes on x64).  For any count > 1 the
    buffer is 7× too small, so the next line
        *(_QWORD *)(a2+64)[i] = ...
    writes past the end of the allocation.

4.  The overflow corrupts the heap’s control data or adjacent
    allocations managed by CoTaskMemAlloc() (COM task allocator).  The
    corrupted pointers are later released by CoTaskMemFree() during
    normal cleanup, freeing memory that is already overwritten and
    still in use elsewhere – a classic use-after-free.

5.  Because cdpsvc runs as NT AUTHORITY\LOCAL SERVICE (or SYSTEM on some
    SKUs) the corrupted heap region resides in a privileged process.
    Attackers controlling the target list can therefore obtain
    arbitrary code execution in that context.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable allocation (before)
v6 = CoTaskMemAlloc(**(unsigned __int16 **)(a1 + 8)); // size == count
...
*(_QWORD *)(a2 + 64) = v6;             // array of LPSTR
...
*(_QWORD *)(*(_QWORD *)(a2 + 64) + 8i64 * v4) = CoTaskMemAlloc(v8);
```
```c
// fixed allocation (after)
SIZE_T sz = **(unsigned __int16 **)(a1 + 8);
if (FeatureEnabled)
    sz *= 8i64;                        // sizeof(LPVOID)
*(_QWORD *)(a2 + 64) = CoTaskMemAlloc(sz);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Application (or attacker)
  -> ICDPAppTargetList API
     -> cdpsvc!CDPComDevice::DeviceCallback::OnAppTargetListReceived()
        -> std::function thunk
           -> vulnerable lambda operator()
              • under-allocates pointer array
              • copies each target string, writing past buffer
        -> later cleanup frees corrupted memory => UAF / EoP.

Attack Vector
--------------------------------------------------------------------
Local, authenticated user sends a crafted AppTargetList containing a
large number of target strings via the Connected Devices Platform IPC
channel (RPC/ALPC).  By spraying heap blocks and controlling the count
field the attacker induces an out-of-bounds write that corrupts adjacent
allocator metadata, leading to use-after-free and elevation of
privileges.

Patch Description
--------------------------------------------------------------------
1. Computes allocation size as TargetCount * 8 bytes (pointer size).
2. Keeps the change behind a WIL feature flag, enabled in the patched
   build.
3. Adds early bailout if any allocation fails (returns
   E_OUTOFMEMORY).
4. Refactors std::function setup but no behavioral change relevant to
   the bug.

Security Impact
--------------------------------------------------------------------
Prior to the patch, an attacker could achieve arbitrary heap overwrite
inside cdpsvc, resulting in use-after-free and potential code execution
with Local Service or SYSTEM privileges.  This constitutes an Elevation
of Privilege vulnerability.

Fix Effectiveness
--------------------------------------------------------------------
The patch removes the under-allocation bug by multiplying the element
count with sizeof(LPVOID).  All write indexes remain unchanged, so no
further overflow is possible.  Provided that the WIL feature flag is
shipped enabled by default, the fix fully mitigates the issue.  No
regression or alternate path using the old size was observed in the
shown diff.
