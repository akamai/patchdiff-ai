{'cve': 'CVE-2025-59278', 'date': 1763407741.5371454, 'file': 'msv1_0.dll', 'patch_store_uid': 'd1fda99a-cb03-4b57-bc0b-7a115cd23d46', 'confidence': 0.27, 'kb': 'KB5066835', 'change_count': 8}
--------------------------------------------------------------------
CVE-2025-59278 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Authentication – msv1_0.dll (LSA authentication package).
The affected routines are several template instances of
wil::details::FeatureImpl::<T>::GetCurrentFeatureEnabledState() and
FeatureImpl::<T>::ReportUsage() that are used while evaluating Feature
Management gates inside the logon provider.


Vulnerability Class
--------------------------------------------------------------------
Improper Validation of Specified Type of Input (CWE-1287).


Detailed Root Cause Analysis
--------------------------------------------------------------------
1. The helper routine GetCurrentFeatureEnabledState() combines the raw
   FEATURE_ENABLED_STATE value returned by WilApi_GetFeatureEnabledState
   with a custom bit-mask and stores the resulting 32-bit status into a
   caller-supplied buffer (argument a2).

2. In the vulnerable build the final status word is derived through a
   multi-branch construction that uses two temporary flags (v10 / v11).
   Depending on FeatureEnabledState, one of the branches may leave v10
   in its default (uninitialised) state, yet the value is still tested
   later and copied into the least-significant bit of the result:
       if ((*(DWORD*)a2 & 0x40)==0 || !v10)
           v11 = 0;
       *(DWORD*)a2 = v11 | (*(DWORD*)a2 & 0xFFFFFFFE);
   Consequently, a crafted FeatureEnabledState that avoids the paths
   which set v10 allows an indeterminate stack byte to be OR-ed into the
   status field.

3. The affected buffer is passed upstream to the LSA authentication
   logic.  Because the status controls whether additional hardening
   checks ("gate" or "audit" modes) are enforced, an attacker that can
   influence the FeatureEnabledState bits (e.g. via per-user registry-
   based Feature Management overrides) can force the authentication code
   to believe that a security-sensitive feature is disabled, bypassing
   subsequent privilege checks.

4. A second defect exists in FeatureImpl<...>::ReportUsage().  The
   function prototype previously treated the second parameter as an
   8-bit boolean although all call sites pass a 64-bit ReportingKind
   enum.  This caused stack argument mis-alignment; the boolean was read
   as ReportingKind and forwarded to ReportUsageToService, permitting
   attacker-controlled values to be interpreted as flags.

5. Together these flaws constitute an elevation-of-privilege:  a local
   authenticated user can select a crafted FEATURE_ENABLED_STATE value
   (or ReportingKind) that removes mandatory restrictions during the
   logon process and obtains SYSTEM-level token.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – Feature_TestLabVal::GetCurrentFeatureEnabledState
v10 = 0;
v11 = 1;
if ( (v9 & 0xC00) == 3072 || (v9 & 0x40) != 0 )
{
    ReportUsage(&impl);
    v10 = 1;                    // may remain 0 on other paths
}
if ( (*(_DWORD *)a2 & 0x40) == 0 || !v10 )
    v11 = 0;                    // uninitialised v10 used here
*(_DWORD *)a2 = v11 | *(_DWORD *)a2 & 0xFFFFFFFE;
```
```c
// before patch – ReportUsage() signature mismatch
__int64 ReportUsage(_DWORD *this, unsigned __int8 kind, ...)
// patched to
__int64 ReportUsage(unsigned int *this, __int64 kind, ...)
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Local attacker prepares per-user Feature Management registry values
   so that WilApi_GetFeatureEnabledState() returns a crafted state.
2. Attacker initiates an NTLM/Kerberos logon that reaches
   msv1_0!GetCurrentFeatureEnabledState().
3. The function writes the uninitialised flag into the status field,
   clearing the enforcement bit.
4. Authentication continues without the intended hardening gate and the
   attacker obtains elevated privileges.


Attack Vector
--------------------------------------------------------------------
Local – the attacker must already possess an account and be able to
manipulate user-controlled feature overrides (HKCU\Software\Microsoft\
FeatureManagement) or pass specific input that influences the
FEATURE_ENABLED_STATE value consumed by msv1_0.dll.


Patch Description
--------------------------------------------------------------------
1. The flag-building logic was rewritten.  All intermediate variables
   are now initialised and the final status word is composed in a single
   expression:
       *a2 = v7 | v8 | 1;
   guaranteeing that bit-0 is deterministically set.

2. Unnecessary branches and the dependence on v10/v11 were removed,
   eliminating any read of uninitialised memory.

3. Parameter lists of ReportUsage() were corrected (bool -> int64) and
   the internal call to GetCachedFeatureEnabledState() now references
   the correct feature trait, preventing stack mis-alignment.

4. Several functions changed unsigned/signed widths to avoid sign
   extension issues when masking FEATURE_ENABLED_STATE.


Security Impact
--------------------------------------------------------------------
Prior to the fix a local attacker could suppress authentication
hardening gates by injecting malformed Feature Management data.  The
resulting logic bypass lets the attacker obtain a SYSTEM token, yielding
an Elevation of Privilege within the local machine context.


Fix Effectiveness
--------------------------------------------------------------------
The new implementation removes all branches that previously left
variables uninitialised and enforces deterministic construction of the
status word.  The corrected function signature prevents stack
corruption.  No alternate uncontrolled paths remain visible in the
patched code, suggesting the fix is effective; however, a comprehensive
review of all FeatureImpl templates is advisable to rule out similar
issues in other instantiations.
