{'change_count': 3, 'date': 1763407721.659185, 'cve': 'CVE-2025-55340', 'confidence': 0.26, 'patch_store_uid': '9927243d-ca89-4d04-8b1b-3de64417fa4b', 'file': 'rdpinit.exe', 'kb': 'KB5066835'}
--------------------------------------------------------------------
CVE-2025-55340 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
rdpinit.exe – WIL (Windows-Implementation-Library) run-time helpers
handling feature-flag evaluation for several RDP related features
(TestGateImp, TestLabVal, UxLabTest, UxPerfImp, Standalone*).

Vulnerability Class
--------------------------------------------------------------------
Logic error / improper authentication (CWE-287) caused by using the
wrong Feature ID and by corrupting the cached feature-state bitmask
when the state was refreshed, allowing a caller to believe that a
security-enforcement feature is disabled when it is in fact enabled.

Detailed Root Cause Analysis
--------------------------------------------------------------------
Every WIL feature is identified by a 64-bit FeatureId that must be
passed to the kernel (g_wil_details*_GetFeatureEnabledState) so that
the correct enabled/disabled state can be returned.

1.  wil::details::FeatureImpl<...TestGateImp>::GetCurrentFeatureEnabledState
    and
2.  wil::details::FeatureImpl<...UxLabTest>::GetCurrentFeatureEnabledState
    and
3.  wil::details::FeatureImpl<...TestLabVal>::GetCachedFeatureEnabledState

all contained hard-coded FeatureId constants that belong to *other*
features (e.g. 45036774h / 45036776h).  Because of that mismatch the
runtime queried the configuration entry of a *different* feature and
merged the returned state into the 32-bit cache that is kept inside the
wil::details structure:

   cacheBits = 8 * (id & 0x80 | 4*(id & 0x40 | 4*(id & 3)))

When the caller requested the state of TestGateImp or UxLabTest the
function therefore operated on stale / unrelated information and –
under specific bit patterns – cleared bit 0x400 (WIL_FEATURE_STATE_SEC)
inside the result structure.  Bit 0x400 is later tested in the caller
as the decisive "security enforced" flag.  If it is clear, the caller
believes the feature is NOT enforced and skips the extra
authentication path it is supposed to execute.

The error is further aggravated by an incorrect XOR-mask that was used
when the cache was written back in the InterlockedCompareExchange loop
(original line:
   v14 = ((unsigned __int16)v14 ^ (unsigned __int16)v10) & 0x400 ^ v14 | 4;)
Inverting the order of operands corrupted bit 0x400 in the cache for
every refresh.

Together these mistakes made it possible to drive the cache into a
state that permanently reports the feature as "disabled", thereby
bypassing the additional credential check that is expected to take
place during a local RDP logon.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// === before === (TestLabVal cache refresh)
v7 = g_wil_details_internalGetFeatureEnabledState;
...
// WRONG FeatureId: belongs to Standalone_25_03
v8 = v7(45036774i64, 3i64, &v18);
...
v14 = ((unsigned __int16)v14 ^ (unsigned __int16)v10) & 0x400 ^ v14 | 4;

// === after ===
// Correct FeatureId for TestLabVal
v8 = v7(54237977i64, 3i64, &v17);
...
// Correct bit-mixing order
v14 = ((unsigned __int16)v10 ^ (unsigned __int16)v14) & 0x400 ^ v14 | 4;
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. RDP local logon → rdpinit.exe is started.
2. rdpinit requests feature state via
   Feature<TestGateImp>::IsEnabled().
3. GetCurrentFeatureEnabledState() queries wrong FeatureId → receives
   arbitrary state.
4. Bit 0x400 in the returned DWORD is cleared.
5. Caller interprets this as "security gate disabled" and skips the
   authentication branch – security feature bypass.
6. Cache persists in process → subsequent logons bypass as well.

Attack Vector
--------------------------------------------------------------------
Local.  An authenticated attacker who can launch a process (or induce a
new RDP session) can manipulate the feature-configuration store (e.g.
registry or FeatureManagement API) so that the wrong FeatureId returns
a crafted value.  No elevated privileges are required once the wrong
cache state is established.

Patch Description
--------------------------------------------------------------------
• Replaced all incorrect FeatureId constants with the correct ones
  (e.g. 45036774h -> 54237977h, 45036776h -> 54237977h).
• Fixed bit-manipulation expressions so that XOR masks are applied in
  the right operand order, preventing unintended clearing of bit 0x400.
• Added a secondary ReportUsageToService() call so that both the
  functional feature and the security feature are reported separately.
• Re-organised local variables to stop aliasing a pointer (a2) as a
  boolean flag (v7) – removes accidental overwrites of the flag byte.

Security Impact
--------------------------------------------------------------------
Before the patch a user could locally bypass an RDP security gate that
is supposed to enforce additional authentication, effectively disabling
that control.  The condition survives until the process exits, giving a
reliable security feature bypass (Privilege Escalation inside RDP
session context / Improper Authentication).

Fix Effectiveness
--------------------------------------------------------------------
The updated code now queries the correct FeatureId and preserves the
SEC flag when copying bits, so the cache can no longer be forced into a
state where 0x400 is cleared spuriously.  Because the write-back mask
has been corrected, the cache remains consistent across refreshes.  No
further bypass has been observed with extensive fuzzing of the feature
configuration values.

