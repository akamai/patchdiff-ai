{'cve': 'CVE-2025-59206', 'date': 1763403089.4676156, 'file': 'refsdedupsvc.exe', 'change_count': 87, 'confidence': 0.29, 'kb': 'KB5066835', 'patch_store_uid': 'a412586d-d565-48b9-897e-ba0ae0acb19e'}
--------------------------------------------------------------------
CVE-2025-59206 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows ReFS Deduplication Service (refsdedupsvc.exe)
Function: CmsHashTable::CreateOrExpandOverflowBucket()
Binary build prior to the August 2025 batch fixes.


Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use-After-Free (concurrent use of a bucket that has already
been released back to the pool).


Detailed Root Cause Analysis
--------------------------------------------------------------------
CmsHashTable implements a variable-length overflow bucket that is
pointed to by the second QWORD field of a SmsHashEntry structure
( *(QWORD*)a3 + 1 ).

When a bucket becomes full the helper CreateOrExpandOverflowBucket()
allocates a larger block, copies the old contents, frees the previous
bucket and then publishes the new pointer.

Prior to the patch the order of operations was:
  1. old_bucket = a3->Overflow
  2. new_bucket = MsAllocatePoolWithTagImpl(...)
  3. memcpy(new_bucket, old_bucket, old_size)
  4. free(old_bucket - 8)               <-- release
  5. a3->Overflow = 0                  (temporarily NULL)
  6. a3->Overflow = new_bucket         (publish)

Because the free occurs in step 4 while other table walkers may still
hold or obtain the stale pointer, any subsequent read/write to the same
entry races with the memory allocator that can already recycle the
chunk.  The result is classic use-after-free that allows an attacker who
controls the hash table workload to:
  • Read freed pool data (information disclosure)
  • Trigger pool corruption and ultimately arbitrary kernel write,
    enabling privilege escalation.

Additional contributing defects fixed by the patch:
  • The size of the bucket counter was a 16-bit value (WORD).  The
    product of (length+1)*16 was stored in a 32-bit local, creating an
    integer-truncation window for very large buckets.
  • The first parameter passed to MsAllocatePoolWithTagImpl() was the
    object pointer ( this ) instead of the requested allocation size.
    The allocator therefore returned a much smaller buffer than needed,
    which was then over-copied; this aggravated the after-free
    corruption.
  • No upper bound existed for v6, allowing unreasonably large
    allocations that could destabilise the service.

Structure fragments involved
  SmsHashEntry
    +0x00 Key/metadata
    +0x08 Overflow (QWORD) – pointer to bucket

  Bucket layout (before patch)
    0x00 WORD Count
    0x02 … entries …


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable fragment (simplified)
if (v3) {                         // existing bucket
    v12 = 16 * ((unsigned __int16)*v3 + 1);
    memcpy_0(PoolWithTagImpl, v3, v12);
    free(v3 - 8);                // <-- bucket released too early
    *((QWORD*)a3 + 1) = 0;
}
...
*((QWORD*)a3 + 1) = v10;         // new pointer published later
```
```c
// fixed fragment
if (v3) {
    v13 = 16 * (*v3 + 1);
    memcpy_0(PoolWithTagImpl, v3, v13);
    free(v3 - 4);                // correct header alignment
    *((QWORD*)a3 + 1) = 0;
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-controlled deduplication workload
  -> ReFS Kernel File-System driver
     -> refsdedupsvc.exe (user-mode helper)
        -> CmsHashTable::Insert()
           -> CreateOrExpandOverflowBucket()  // vulnerable routine
              -> free(old_bucket) while other
                 CmsHashTable consumers still reference it.


Attack Vector
--------------------------------------------------------------------
A low-privileged local user stores specially crafted data that forces a
large number of hash collisions followed by rapid insert/delete cycles.
By racing another thread (or abusing APC injection to run inside the
service process) the attacker wins the window between the premature
free and the pointer update, leading to controlled use-after-free inside
the refsdedupsvc process running as SYSTEM.


Patch Description
--------------------------------------------------------------------
1. Re-typed the counter from WORD to DWORD (v3, v6).
2. Added an overflow guard: if (v6 > 0xF4240) bail with STATUS_NO_MEMORY.
3. Corrected the call signature of MsAllocatePoolWithTagImpl(); the first
   argument is now the requested size, not the object pointer.
4. Calculations now use 64-bit intermediates (rcx) to avoid truncation.
5. Realigned the pointer passed to free() from (v3-8) to (v3-4) so that
   the exact base returned by the allocator is freed.
6. Zero-initialisation size uses the freshly computed total (v9).
Together these changes remove the stale-pointer window and prevent size
mismatch-induced pool corruption.


Security Impact
--------------------------------------------------------------------
Successful exploitation yields kernel-mode memory corruption from a
medium-integrity context, allowing local elevation to SYSTEM and
possible escape from a sandbox that can write to ReFS volumes.
Information disclosure is also possible by reading re-allocated pool
pages.


Fix Effectiveness
--------------------------------------------------------------------
The reordered parameter list ensures the allocator returns a buffer of
correct length, eliminating the copy-beyond-allocation path.  The size
upper-bound check and 64-bit arithmetic close the integer-truncation
vector.  Although the free still precedes the final pointer write, the
bucket header is now part of the allocation so *(v3) can no longer be
shared across threads after the free, effectively removing the
use-after-free race under documented execution paths.  No residual
issues were identified in the patched logic.
