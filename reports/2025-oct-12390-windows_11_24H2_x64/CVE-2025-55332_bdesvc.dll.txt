{'patch_store_uid': '1a19a051-6137-4f63-b4c8-3d7ae9d228f0', 'kb': 'KB5066835', 'change_count': 3, 'file': 'bdesvc.dll', 'cve': 'CVE-2025-55332', 'date': 1763403023.313475, 'confidence': 0.13}
--------------------------------------------------------------------
CVE-2025-55332 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows BitLocker Device-Encryption service (bdesvc.dll)
Functions:
 • FveEnableEAS::ProvisionDeviceEncryption()
 • FveEnableEAS::BackupRecoveryPasswordWithRetry()
 • FveEnableEAS::BackupRecoveryPassword()

Vulnerability Class
--------------------------------------------------------------------
Improper Enforcement of Behavioral Workflow (CWE-841) – Security
feature bypass in the BitLocker device-encryption provisioning flow.

Detailed Root Cause Analysis
--------------------------------------------------------------------
When Device Encryption is provisioned the service executes the
following ordered steps (simplified):
 1. Determine the target FVE volume path.
 2. Compute the required provisioning steps (backup password,
    create TPM protector, delete clear key, etc.).
 3. Carry out each required step.
 4. Commit the accumulated changes to the FVE volume.

In the vulnerable build step 4 is performed with a plain call to

    FveCommitChanges(<VolumeHandle>);

This basic API commits whatever state currently exists on the volume.
If any earlier step (e.g. backup of the recovery password, TPM
protector creation, clear-key deletion) silently failed or was
intentionally interrupted, the commit still succeeds and BitLocker is
left enabled **without the expected protective artefacts**.  An
attacker that can influence the environment (for example by blocking
network connectivity so that cloud/AD/MSA backup fails, or by
preventing TPM protector creation) can therefore force Device
Encryption to finish in a mis-configured state – typically leaving a
clear key on disk.  With physical access the attacker can then use the
residual clear key to unlock the drive, completely bypassing the data
-at-rest protection BitLocker is supposed to guarantee.

The patch introduces a guarded call to a newer API:

    if ( Feature_BitLocker_Block_Backup_DeviceEncryption )
        FveCommitChangesEx(<Handle>, 0x0A);
    else
        FveCommitChanges(<Handle>);

FveCommitChangesEx takes an explicit flag mask (0x0A) that instructs
the FVE driver to **refuse the commit unless all mandatory backup and
protector requirements are satisfied**.  If the feature switch is not
yet enabled the code falls back to the old behaviour, preserving
compatibility.  All logging identifiers were also updated, but the
security fix is the change from the unconditional FveCommitChanges()
call to the conditional, policy-aware FveCommitChangesEx().

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
v19 = FveCommitChanges(v24);   // commits even if backup/protector failed
...

// after (excerpt)
if (Feature_BitLocker_Block_Backup_DeviceEncryption)
{
    v19 = FveCommitChangesEx(v25, 0x0A); // enforce policy
    if (v19 < 0) { /* error path */ }
}
else
{
    v20 = FveCommitChanges(v25);         // legacy path
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User or MDM requests Device-Encryption →
2. FveEnableEAS::ProvisionDeviceEncryption() called.
3. Function determines provisioning steps; finds that recovery password
   backup and TPM protector creation are needed.
4. Attacker causes the backup step (network, OneDrive, AD, etc.) to
   fail or to be skipped.
5. Despite v6 < 0 from failed backup, code path continues, reaches
   FveCommitChanges(vHandle) which returns success.
6. Volume is left encrypted but still contains an un-revoked clear key
   (or lacks a TPM protector), allowing anyone with physical access to
   boot and read data.

Attack Vector
--------------------------------------------------------------------
A local attacker with physical access starts Device Encryption during
initial device setup (or forces an enterprise policy refresh) and then
blocks network / cloud connectivity or otherwise sabotages the backup
and protector-creation steps.  Because the service commits the changes
unconditionally, encryption is finalised without the required security
artifacts, letting the attacker later obtain the clear key and bypass
BitLocker protection.

Patch Description
--------------------------------------------------------------------
1. Introduced a new feature gate
   Feature_BitLocker_Block_Backup_DeviceEncryption.
2. Replaced unconditional FveCommitChanges() with
   FveCommitChangesEx(handle, 0x0A) when the feature is enabled.  The
   extended commit API validates that mandatory backup / protector
   prerequisites are met before accepting the commit.
3. Added fallback to the original API when the feature flag is not yet
   enabled to maintain compatibility.
4. Numerous ancillary changes (renamed WPP trace IDs, variable
   initialisation clean-ups, type corrections) that have no security
   impact but accompany the main fix.

Security Impact
--------------------------------------------------------------------
Prior to the patch a malicious actor could cause Device Encryption to
complete without a valid recovery protector or backup, effectively
leaving a clear key on the disk.  This renders the encryption
ineffective against offline or stolen-device attacks, constituting a
Security Feature Bypass (CVE-2025-55332).

Fix Effectiveness
--------------------------------------------------------------------
Using FveCommitChangesEx with the 0x0A control flags moves the
enforcement into the kernel: if the recovery key is not adequately
protected / backed up the commit fails and the provisioning routine
bails out, preventing the vulnerable end state.  Because the new path
is protected by a feature flag, the mitigation is only active when the
BitLocker_Block_Backup_DeviceEncryption feature is enabled; if the flag
is disabled the legacy behaviour remains, but Microsoft can remotely
switch the feature on for all supported systems.  Assuming the flag is
enabled, the fix robustly closes the workflow gap and prevents the
bypass.
