{'confidence': 0.18, 'date': 1763403089.415635, 'cve': 'CVE-2025-55677', 'change_count': 9, 'kb': 'KB5066835', 'file': 'das.dll', 'patch_store_uid': '7aecb5ec-5226-4c8f-bc4c-a65d5f327faa'}
--------------------------------------------------------------------
CVE-2025-55677 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Device Association Broker (das.dll) – routine
PnpValidatePropertyData()

Vulnerability Class
--------------------------------------------------------------------
Untrusted Pointer Dereference  (CWE-822)

Detailed Root Cause Analysis
--------------------------------------------------------------------
The Device Association Broker service exposes an internal validation
helper named PnpValidatePropertyData().  The routine is reached with a
user-supplied buffer address (the first argument) and the buffer
length.  Prior to the fix the prototype was

    NTSTATUS PnpValidatePropertyData( WCHAR *Buffer,
                                      ULONG Length,
                                      ULONG PropertyType );

and the code immediately dereferenced the caller-controlled pointer in
several type-specific paths without first probing that the address
belongs to the broker’s own address space.

Critical paths that performed blind dereferences were:

1. DEVPROP_TYPE_STRING_LIST   (PropertyType & 0x2000)
   The routine walked the list by reading successive WCHARs until it
   reached a terminator.  No try/except or ProbeForRead() was applied.

2. DEVPROP_TYPE_INT64ARRAY    (type 0x10)
   A loop read 64-bit values via
        *(INT64 *)&Buffer[4*Index]
   again with no access check.

3. DEVPROP_TYPE_SECURITY_RELATIVE (type 0x13)
   The pointer was passed straight to
        RtlValidRelativeSecurityDescriptor()
   – a call that dereferences the pointer internally.

Because the broker is running as LOCAL_SYSTEM, a low-privileged caller
could supply an arbitrary kernel or process address through the public
DeviceIoControl/RPC surface that eventually leads to this helper.  The
service then dereferenced the supplied address in its own security
context, yielding a read/AV primitive that can be weaponised to elevate
privilege (e.g. by mapping the target address with read/write access or
by abusing the called API to perform writes).

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – type 0x10 path
case 16:                         // DEVPROP_TYPE_INT64ARRAY
  if (!StringSecurityDescriptor)
      return STATUS_INVALID_PARAMETER;
  while (Index < Length >> 3) {
      if ( *(__int64 *)&StringSecurityDescriptor[4*Index] < 0 )
          return STATUS_INVALID_PARAMETER;
      ++Index;                  // <== unchecked dereference
  }
```
```c
// before patch – string list ( & 0x2000 )
while (*StringSecurityDescriptor) {
    ...                         // no ProbeForRead – arbitrary address
    ++StringSecurityDescriptor;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User process -> DeviceAssociation RPC / IOCTL ->
    das!PnpValidatePropertyData() ->
        blind dereference of caller pointer ->
        code executes in LOCAL_SYSTEM context.

Attack Vector
--------------------------------------------------------------------
Any authenticated local user can supply a crafted DEVPROPERTY structure
that contains an arbitrary 64-bit address as the data pointer and a
small non-zero length.  The broker service will call
PnpValidatePropertyData() with that pointer and will dereference it
while running as SYSTEM, enabling information disclosure or controlled
crashes that lead to elevation of privilege.

Patch Description
--------------------------------------------------------------------
1. Function signature changed to take a generic 64-bit value
      (__int64 SecurityDescriptorInput) rather than a WCHAR* – forcing
   callers through an updated marshal layer.
2. A dedicated local variable (v5) of type INT64* is used and is
   validated before every dereference.
3. New guarded path
      Feature_KernelPnP_PropertyValidation__private_IsEnabled...
   probes the user pointer when the property is a multi-string.
4. Extra length/terminator checks were added and the old unaligned
   8-byte read through a WCHAR* alias was replaced with an aligned
   INT64* read.
5. The helper wil_details_FeatureReporting_RecordUsageInCache() was
   updated to carry an additional flag so that the validation state is
   preserved across feature-usage reporting.

Security Impact
--------------------------------------------------------------------
Prior to the patch any local user could cause the Device Association
Broker (running as SYSTEM) to dereference an attacker-controlled
pointer.  This enables:
• Arbitrary read/write in the service process (if the address is mapped
  by the attacker) or
• Controlled AV that can be turned into privilege-escalation via
  standard exploitation primitives.
The issue therefore constitutes a local Elevation of Privilege.

Fix Effectiveness
--------------------------------------------------------------------
The updated code now:
• Performs explicit NULL and length checks;
• Probes the caller-supplied buffer through the feature-flag helper
  before use;
• Uses aligned 64-bit accesses consistent with the declared pointer
  type;
• Ensures every dereference is preceded by bounds validation.

No residual unchecked pointer paths were observed in the patched
routine, making the fix effective against the originally exploited
vector.
