{'confidence': 0.29, 'change_count': 6, 'date': 1763407734.1517072, 'cve': 'CVE-2025-55333', 'patch_store_uid': 'efb29de7-ce28-4d45-a691-32e878d118b2', 'kb': 'KB5066835', 'file': 'fvevol.sys'}
--------------------------------------------------------------------
CVE-2025-55333 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows BitLocker driver  (fvevol.sys)
Functions affected: FveFilterDeviceControl() and
FvePdcActivatorCallback().  These routines implement BitLocker
IOCTL-handling and automatic device-activation logic.


Vulnerability Class
--------------------------------------------------------------------
Logical error – incomplete comparison / missing factors
(CWE-1023).


Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  Device state for a BitLocker-protected volume is stored in a
    bit-field located at offset +0x318 (decimal 792) of the device
    extension ("State" below).  The driver decides whether it is safe
    to renew a Platform-Data Collection (PDC) activation or to perform
    Read/Write cleanup by evaluating this field.

2.  In the vulnerable build the following test is executed inside
    FvePdcActivatorCallback():

        if ((State & 0x100) == 0 ||
            (Path = *(QWORD *)(Ext+0x3D8),           // +984
             Path) &&
            *(WORD *)Path &&
            *(WORD *)(Path+2) >= 0x10 &&
            (*(BYTE *)(Path+8) & 0xC0) != 0x40)

    The test is meant to guarantee that *both* of the following are
    true before calling Pdcv2ActivationClientRenewActivation():
        a) The device is in the REQUIRED-ACTIVATION state (bit 0x100).
        b) The secondary path buffer at +0x3D8 is valid and meets size
           and flag requirements.

3.  Because of operator precedence and the missing explicit
    “!= 0” after the comma expression, the pointer stored in Path is
    silently converted to a boolean *before* the size/flag tests are
    evaluated.  Therefore the overall right-hand side of the OR clause
    is true as long as State & 0x100 is clear – regardless of any of
    the additional checks.  In short, the comparison is incomplete;
    many illegal states fall through the check.

4.  When this occurs the function proceeds to call
    Pdcv2ActivationClientRenewActivation() while the device is still
    locked or not properly initialised.  Through physical access an
    attacker can exploit the erroneous state transition to bypass the
    expected BitLocker protection boundary (e.g. attach the disk in a
    pre-boot environment and trigger the callback via crafted ACPI
    table events).

5.  A related mismatch exists in FveFilterDeviceControl() for the
    IOCTL pair 0x455610D8 / 0x455610DC (Read-Write Device
    INIT/CLEANUP).  The cleanup path unconditionally executed
        FveUnlockDriver();
    even when the reference counter became negative, leaving the
    driver unlocked and the volume unprotected until the next system
    resume.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable
if ((v10 & 0x100) == 0 ||
    (v13 = *(QWORD *)(a4+984), v12 = 192, v13) &&
    *(WORD *)v13 && *(WORD *)(v13+2) >= 0x10 &&
    (*(BYTE *)(v13+8) & 0xC0) != 0x40)
{
    ... // renew activation although pre-conditions not met
}

// fixed
if ((v10 & 0x100) == 0 ||
    ( (v13 = *(QWORD *)(a4+984)) != 0 &&
      *(WORD *)v13 && *(WORD *)(v13+2) >= 0x10 &&
      (*(BYTE *)(v13+8) & 0xC0) != 0x40))
{
    ... // only executed when pointer and size are valid
}
```

```c
// FveFilterDeviceControl – old cleanup
if (_InterlockedDecrement(&Ext->RwRefCnt) < 0)
    KeBugCheckEx(...);
FveReadWriteDeviceCleanup(Ext,0);
FveUnlockDriver(Ext);   // unlocks even when count under-flows

// fixed cleanup
cnt = _InterlockedDecrement(&Ext->RwRefCnt);
if (!FeatureFlag && cnt < 0)
    KeBugCheckEx(...);
FveReadWriteDeviceCleanup(Ext,0);
if (!FeatureFlag)           // driver remains locked otherwise
    FveUnlockDriver(Ext);
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker powers on a BitLocker-protected machine and gains physical
   access to the storage device.
2. A crafted hardware event (or a fuzzed IOCTL 0x455610DC sequence)
   forces the driver into an unexpected state with bit 0x100 cleared
   while other activation bits remain set.
3. FvePdcActivatorCallback() is invoked and, because of the incomplete
   comparison, considers the state acceptable, calling
   Pdcv2ActivationClientRenewActivation().
4. BitLocker assumes that authentication requirements are still
   satisfied and temporarily allows read/write access, effectively
   bypassing the encryption boundary.


Attack Vector
--------------------------------------------------------------------
Requires physical possession of the target drive and the ability to
initiate PDC activation or IOCTL sequences during early boot (e.g.
through a malicious bootloader or specialised hardware test jig).
No administrative credentials are needed.


Patch Description
--------------------------------------------------------------------
1. Added an explicit pointer-validity test ("!= 0") inside the logical
   expression in FvePdcActivatorCallback(), ensuring *all* secondary
   conditions are evaluated.
2. Re-ordered logic so that trace-only assignments (v12) are removed
   from the security-relevant comparison.
3. In FveFilterDeviceControl() the read/write reference counter is now
   stored in a local variable, logged, and only triggers a bug-check
   (or driver unlock) when a dedicated feature flag is disabled.
4. Numerous trace-identifier updates; these have no behavioural
   impact.


Security Impact
--------------------------------------------------------------------
Prior to the patch an attacker could place the BitLocker filter driver
in an inconsistent state that led to:
 • Unauthorised renewal of PDC activation, and consequently
   transparent access to encrypted data.
 • Premature release of the driver lock protecting a volume.
This constitutes a Security Feature Bypass with potential full loss of
confidentiality for the encrypted partition.


Fix Effectiveness
--------------------------------------------------------------------
The corrected comparisons enforce all intended pre-conditions.  The
reference counter can no longer underflow without an immediate system
bug-check, and the driver lock is retained when expected.  No bypass
has been identified after applying the patch.

