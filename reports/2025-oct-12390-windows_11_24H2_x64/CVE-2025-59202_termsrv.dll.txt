{'file': 'termsrv.dll', 'cve': 'CVE-2025-59202', 'change_count': 52, 'kb': 'KB5066835', 'patch_store_uid': 'cf210279-8bb0-4830-a920-6d53b71486c8', 'date': 1763407724.6232648, 'confidence': 0.17}
--------------------------------------------------------------------
CVE-2025-59202 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Remote Desktop Services (termsrv.dll) – reference-counting
helper templates (CTSPrivateObject<...>, CForwardSink, CSessionMonitor
and several other Release and InternalRelease methods).


Vulnerability Class
--------------------------------------------------------------------
Use-After-Free / Incorrect reference count handling (CWE-416).


Detailed Root Cause Analysis
--------------------------------------------------------------------
Every object that is managed by the TS private-object template carries a
64-bit reference counter at offset +24h and several debug/flags fields
(+0Ch, +20h, +32h, etc.).  The Release()/InternalRelease() routines must

  1. locate the real ref-counted base object,
  2. atomically decrement *(QWORD*)(Base+24h), and
  3. invoke *(PVOID*)(*(QWORD*)Base + <vtbl offset>) when the counter
     reaches zero.

In the vulnerable builds the generated Release functions used the wrong
pointer when they executed steps 1-3.

Examples
• CTSPrivateObject<IShadowEx>::Release used the argument a1 directly,
  although the real ref-counted object lives at *(QWORD*)(a1+1592).
• CEventDispatcher::CForwardSink::Release did the opposite: it first
  dereferenced *((QWORD*)this+1) and then operated on that address while
  the correct base pointer is the object itself.

Because the refcount was updated on an unrelated structure the real
object’s counter stayed unchanged while its interface pointer(s) were
released.  When the last correct Release executed, the counter became
negative, causing the destructor call to run on memory that had already
been freed earlier.  Any subsequently dereferenced members (or a reused
heap allocation) yielded a classic use-after-free memory corruption in
termsrv.dll, a service running as NT AUTHORITY\SYSTEM.

The bug is purely logical; no out-of-bounds address calculation is
needed – a valid but wrong address is chosen for all atomic operations
and for the final vtable dispatch.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Before (IShadowEx example)
if ( *(_DWORD *)(a1 + 12) == 1 ) { ... }
v2 = _InterlockedDecrement64((volatile signed __int64 *)(a1 + 24));
if ( !v2 )
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 56))(a1,1);

// After
v1 = *(_QWORD *)(a1 + 1592);         // fetch real object
if ( *(_DWORD *)(v1 + 12) == 1 ) { ... }
v2 = _InterlockedDecrement64((volatile signed __int64 *)(v1 + 24));
if ( !v2 )
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v1 + 120))(v1,1);
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Client code obtains two or more interface pointers that eventually
   reference the same underlying TS object (e.g., IShadowEx & IAudit).
2. One thread invokes Release on the first interface – reference counter
   of the *wrapper* object is decremented to zero, destructor frees the
   shared allocation.
3. Another thread (or later operation) calls a method on the second
   interface.  The pointer is still non-NULL but now refers to freed
   memory, leading to controlled use-after-free and instruction pointer
   hijack in the service context.


Attack Vector
--------------------------------------------------------------------
Local, authenticated RDP session.  An attacker loads a custom DLL or
uses documented RDS COM interfaces to create multiple references to the
same server-side object and controls their destruction order to trigger
premature free.


Patch Description
--------------------------------------------------------------------
Microsoft replaced the faulty pointer arithmetic with explicit selection
of the correct base object before touching refcount-related fields.  All
atomic operations and destructor calls now use this verified base
address.  Additionally, the helper that captures stack traces was
changed from CaptureObjectStackTrace() to a local wrapper
sub_18000E890(), but this is cosmetic.


Security Impact
--------------------------------------------------------------------
The incorrect reference counting allowed controlled use-after-free in
termsrv.dll.  Because the service runs as SYSTEM, a local attacker that
can establish an RDP session could execute arbitrary code with
SYSTEM-level privileges (elevation of privilege).


Fix Effectiveness
--------------------------------------------------------------------
The updated functions consistently compute the base object pointer and
pass it to:
• the debug stack-trace ring buffer,
• the atomic refcount decrement, and
• the final destructor dispatch.

No paths remain that modify *(Base+24h) of a different object than the
one whose vtable is invoked, eliminating the premature free condition.
A code review of all Release helpers in termsrv.dll shows identical
changes across every template instantiation, indicating complete
coverage.
