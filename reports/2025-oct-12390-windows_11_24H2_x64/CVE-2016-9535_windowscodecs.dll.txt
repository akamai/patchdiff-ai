{'cve': 'CVE-2016-9535', 'kb': 'KB5066835', 'date': 1763403050.2118447, 'file': 'windowscodecs.dll', 'patch_store_uid': '770b2931-a4a8-483f-bd9d-fa1d9120b168', 'confidence': 0.2, 'change_count': 30}
--------------------------------------------------------------------
CVE-2016-9535 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Imaging Component (WIC) – windowscodecs.dll.  The vulnerable
code is the built-in copy of LibTIFF predictor routines
(PredictorEncode/Decode and helper functions such as horAcc*/horDiff*,
fpAcc/fpDiff, swabHorAcc16) and the tile initialisation helper
CLibTiffDecoderBase::CheckTiledTIFF.


Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow arising from missing parameter validation
and integer-overflow in size/stride calculations (CWE-122, CWE-190).


Detailed Root Cause Analysis
--------------------------------------------------------------------
1. All predictor helpers receive a caller-supplied byte count (a3) that
   is derived from image tile/row dimensions stored in the TIFF file.
   The functions assumed that:
     • a3 was non-negative, and
     • a3 was an exact multiple of the per-pixel stride held in the
       codec context (*((int*)(ctx+432)+1)).
2. When these assumptions were false the loops that walk the buffer
   (e.g. horDiff8/horAcc8/horAcc16/horDiff16) executed a
   "while(vRemaining>=stride)" pattern, updating the buffer by
   *adding* or *subtracting* values that lay stride bytes back.
3. If a3 < 0 the loop condition was true after unsigned promotion and
   wrote far beyond the start of the heap buffer.  If a3 was positive
   but not divisible by stride the final iteration(s) wrote past the
   end of the allocation.
4. CLibTiffDecoderBase::CheckTiledTIFF contained similar unchecked
   arithmetic when computing tile counts:
        numTiles = (width+tileW-1) / tileW;   // potential overflow
   followed by an allocation sized using the wrapped value, allowing
   later predictor helpers to operate on undersized memory.
5. In all cases the size/stride values originate from the attacker
   controlled TIFF header, so a malformed image could reliably trigger
   an out-of-bounds write in a process that merely opens or previews
   it.

Affected parameters / structures
- a3:  byte count per row/tile passed to predictor helpers.
- ctx+432: structure holding stride and function table.
- this+824/828: tileW/tileH in CheckTiledTIFF.


Vulnerability Code Snippets
--------------------------------------------------------------------
Before (horAcc8):
```c
v5 = *(int *)(result + 4);        // stride
if (a3 > (int)v5) {
   if (!(a3 % (int)v5)) {
      v6 = (unsigned int)(a3 - v5);
      ...                    // unguarded loop
   }
}
```
After:
```c
v6 = *(int *)(*(_QWORD *)(a1+432)+4);
if (IsEnabledFeat2578 && a3 % (int)v6)
   return 0;                    // reject mis-aligned length
...
return 1;                       // success flag
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Application loads crafted TIFF.
2. WIC calls CLibTiffDecoderBase::CheckTiledTIFF -> mis-sized tile
   values are accepted (pre-patch) and small heap buffer allocated.
3. During decoding Predictor*Encode/Decode helpers are invoked with a3
   taken from the TIFF directory.
4. horDiff*/horAcc*/fpAcc/fpDiff loops run past allocation and corrupt
   heap, leading to crash or controlled data overwrite.


Attack Vector
--------------------------------------------------------------------
Opening, previewing, or indexing a malicious TIFF image (e.g. via File
Explorer thumbnail, Outlook attachment, Edge, or any third-party
program that relies on WIC) triggers the vulnerable code inside the
calling process.


Patch Description
--------------------------------------------------------------------
• All helpers now treat the byte-count argument as unsigned and verify
  the sign bit.
• Added feature-gated runtime checks that reject rows/tiles whose
  length is not an exact multiple of stride or (bps*stride).
  On failure TIFFErrorExt is invoked and the function returns 0.
• Loops were re-written to use early exit and 64-bit counters; several
  helpers changed their return type to propagate success/failure.
• CheckTiledTIFF gained strict validation for           
     – stride alignment (multiple of 16),
     – non-zero tile width/height,
     – integer overflow in (w+h) arithmetic.            
  It now returns errors before allocating, and the allocation is sized
  with size_t-safe arithmetic.
• Defensive code paths are enabled under the internal WIL feature id
  2578215227.


Security Impact
--------------------------------------------------------------------
Prior to the patch a crafted TIFF could cause a heap buffer overflow
leading to process crash or potential remote code execution in the
context of the calling application.  The issue is tracked as
CVE-2016-9535.


Fix Effectiveness
--------------------------------------------------------------------
The added validation fully blocks the originally reported misaligned
or negative sizes and protects all arithmetic that previously
overflowed.  Because the hardened paths are conditional on a Feature
flag, effectiveness relies on the flag being enabled in production
builds; if disabled the legacy vulnerable behaviour persists.
No residual overflow conditions were observed in the updated code.

