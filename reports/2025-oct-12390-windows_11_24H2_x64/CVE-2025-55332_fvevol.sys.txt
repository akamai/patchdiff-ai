{'patch_store_uid': 'efb29de7-ce28-4d45-a691-32e878d118b2', 'change_count': 6, 'file': 'fvevol.sys', 'cve': 'CVE-2025-55332', 'confidence': 0.24, 'kb': 'KB5066835', 'date': 1763403052.4465086}
--------------------------------------------------------------------
CVE-2025-55332 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft BitLocker filter driver  (fvevol.sys)  – routine
FveFilterDeviceControl() that processes DeviceIoControl IRPs for the
BitLocker volume-filter device.

Vulnerability Class
--------------------------------------------------------------------
Improper enforcement of behavioral workflow / reference counter logic
(CWE-841).

Detailed Root Cause Analysis
--------------------------------------------------------------------
FveFilterDeviceControl() implements an internal reference counting
scheme that protects the driver against raw read / write operations
while BitLocker is active.  Two private IOCTLs are used:
 • 0x455610D8 – FveReadWriteDeviceInit   (increments counter and
   eventually calls FveLockDriver()).
 • 0x455610DC – FveReadWriteDeviceCleanup (decrements counter and, when
   the count reaches 0, calls FveUnlockDriver()).

Before the patch the code simply performed
    _InterlockedDecrement(&DevCtx->ReadWriteUsers);
then *unconditionally* executed FveReadWriteDeviceCleanup() and
FveUnlockDriver(), the only safety net being a BugCheck when the count
became negative.  An attacker able to send the cleanup IOCTL without a
matching init IOCTL could therefore drive the counter below zero.  If
crash-handling was suppressed (for example, on systems booted with
"no-reboot" or with special feature flags) the negative value was
accepted and FveUnlockDriver() was still invoked, leaving the volume in
an unlocked state and bypassing BitLocker protections.

Patch changes:
1.  The return value of InterlockedDecrement() is stored (v23).
2.  If the new feature flag
    Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage_1() is enabled and
    the count goes negative, the driver now *only logs* the anomaly; it
    no longer calls FveUnlockDriver().
3.  When the flag is *not* enabled the old BugCheck path is preserved,
    but FveUnlockDriver() is still skipped if the count is negative.

Therefore the unlock routine can now only be reached when the reference
count is valid (>=0), eliminating the possibility of releasing the
BitLocker lock through an unbalanced IOCTL sequence.

Other changes in the diff (ETW / WPP GUID updates, parameter reduction
in FveDiscoverVolume, cosmetic renaming) are bookkeeping and do not
impact the core issue.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// BEFORE
case 0x455610DC:                     // FVE_RW_DEVICE_CLEANUP
    if (!a2->RequestorMode) {
        _InterlockedDecrement(&DevCtx->ReadWriteUsers);
        if (DevCtx->ReadWriteUsers < 0)
            KeBugCheckEx(...);
        FveReadWriteDeviceCleanup(DevCtx, 0);
        FveUnlockDriver(DevCtx);     // executes even if count was wrong
    }

// AFTER
v23 = _InterlockedDecrement(&DevCtx->ReadWriteUsers);
if (FeatureEnabled) {
    if (v23 < 0)
        WPP_SF_qd(...);              // log only
} else if (v23 < 0) {
    KeBugCheckEx(...);               // legacy behaviour
}
FveReadWriteDeviceCleanup(DevCtx, 0);
if (!FeatureEnabled)                 // unlock only on valid path
    FveUnlockDriver(DevCtx);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker opens the BitLocker device (\\.\FVEVolume{GUID}).
2. Sends IOCTL 0x455610DC without ever having sent IOCTL 0x455610D8.
3. ReadWriteUsers becomes -1.
4. Pre-patch: driver proceeds to FveUnlockDriver() -> volume unlocked.
5. Post-patch: negative count is detected and unlock is *not* executed.

Attack Vector
--------------------------------------------------------------------
Requires physical or local administrator access to issue the proprietary
DeviceIoControl codes (e.g., from WinPE or malicious kernel driver).
No authentication to BitLocker secrets is required – the workflow error
alone is sufficient to drop the driver lock.

Patch Description
--------------------------------------------------------------------
• Stores the result of InterlockedDecrement() and validates it before
  unlocking.
• Skips FveUnlockDriver() when the reference counter is negative.
• Adds WPP telemetry instead of unconditional BugCheck under a guarded
  feature flag.
• Minor re-layout of local variables and ETW provider changes.

Security Impact
--------------------------------------------------------------------
A local attacker can bypass BitLocker’s read/write protection layer and
obtain unencrypted access to the protected volume, defeating the
confidentiality guarantee of BitLocker (security feature bypass).

Fix Effectiveness
--------------------------------------------------------------------
The added counter check blocks the only path that led to an unintended
call to FveUnlockDriver(), thereby enforcing the intended workflow.  No
other obvious paths remain that allow the counter to underflow while
still reaching the unlock routine, so the patch is considered effective
for this specific issue.
