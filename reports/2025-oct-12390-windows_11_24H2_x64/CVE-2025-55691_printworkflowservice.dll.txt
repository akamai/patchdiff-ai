{'file': 'printworkflowservice.dll', 'date': 1763403015.0499089, 'cve': 'CVE-2025-55691', 'kb': 'KB5066835', 'change_count': 76, 'confidence': 0.18, 'patch_store_uid': 'cfbf7ece-1a89-464d-80de-2d625e11c5f0'}
--------------------------------------------------------------------
CVE-2025-55691 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows PrintWorkflowUserSvc (printworkflowservice.dll) –
implementation of the internal COM/WinRT interface
Windows::Graphics::Internal::Printing::PrintSupport::
IPrintSupportSettingsBroker.

Vulnerability Class
--------------------------------------------------------------------
Use-after-free (CWE-416).

Detailed Root Cause Analysis
--------------------------------------------------------------------
Two broker helper methods were exported through the WinRT
implementation class
  winrt::impl::produce<...
       PrintSupportSettingsBroker,
       IPrintSupportSettingsBroker>::
           GetAppInfo()
           GetPrinterName()
Each received a "this" pointer (a1) and an out-parameter pointer (a2)
intended to receive either an IWindow* (app info) or an HSTRING
(printer name).

Old flow (simplified):
1. Initialise *a2 = 0.
2. Construct a temporary stack object     
      __int64 v6;                      // holds the return object
3. Call a helper that populates v6.
4. Copy v6 into the caller-supplied *a2.
5. Zero v6 and immediately invoke the appropriate destructor:
      IWindow::~IWindow(&v6)  or
      handle_type<>::close(&v6)
6. Return 0.

Because ownership of the returned object was never transferred, step 5
frees the memory that *a2 continues to reference.  Any subsequent use
of *a2 by the caller operates on freed memory, forming a classic
use-after-free.  The defect is in the object-lifetime contract: the
implementation assumed a move-semantics copy, but instead performed a
shallow pointer copy followed by destruction of the original holder.

The problem affects:
 • IWindow objects obtained via
   AppInfoHelper::GetAppInfoFromHwnd()
 • HSTRING buffers obtained via winrt::hstring::hstring()
Both structures contain internal vtables/buffers that, once freed, may
be re-occupied by attacker-controlled data leading to controlled code
execution when later dereferenced by high-privilege code.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Vulnerable pattern (before patch)
*vOut = 0;
AppInfoHelper::GetAppInfoFromHwnd(&v6, hwnd);
__int64 tmp = v6;   // shallow copy
v6 = 0;             // detach pointer
*vOut = tmp;        // caller now holds dangling pointer
IWindow::~IWindow(&v6);   // frees object just copied

// Patched pattern
*vOut = 0;
AppInfo = PrintSupportSettingsBroker::GetAppInfo(thisAdj, &v6);
__int64 tmp = *AppInfo;
*AppInfo = 0;       // transfer ownership safely
*vOut = tmp;
IWindow::~IWindow(&v6);    // now operates on null object
```
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Low-privilege client obtains a proxy to the privileged
   IPrintSupportSettingsBroker interface exposed by
   PrintWorkflowUserSvc.
2. Client invokes GetAppInfo() or GetPrinterName().
3. Service executes vulnerable code path, freeing the object while the
   pointer is still returned to the client.
4. Client heap-sprays / re-allocates memory at the freed address.
5. Subsequent service-side use of the stale pointer (e.g., reference
   count manipulation, vtable call, string access) results in
   controlled memory corruption, permitting privilege escalation.

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker.  Any user able to communicate with
PrintWorkflowUserSvc through the COM/WinRT broker interface can supply
crafted calls and heap layout to exploit the dangling pointer.

Patch Description
--------------------------------------------------------------------
The patch changes both methods to:
1. Delegate the actual data retrieval to static helper methods that
   allocate the return value and return its address.
2. After the helper returns, copy the pointer value out and NULL the
   helper-owned pointer (*AppInfo = 0 or *PrinterName = 0).
3. Only then invoke the destructor on the temporary holder, which now
   contains a null pointer, preventing accidental free of the object
   passed to the caller.

In effect, explicit ownership transfer is performed before any
cleanup, ensuring the object’s lifetime extends beyond the function
scope.

Security Impact
--------------------------------------------------------------------
Prior to the patch, the service could return dangling IWindow or
HSTRING pointers to itself or other high-privilege consumers.  An
attacker able to influence the heap layout could turn the use-after-
free into arbitrary code execution in the PrintWorkflowUserSvc
context, elevating to SERVICE or SYSTEM privileges.

Fix Effectiveness
--------------------------------------------------------------------
The new code pattern eliminates the double-free/dangling-pointer
condition by:
 • Returning the address of an allocated object instead of the object
   itself.
 • Nulling the original owner before destruction, preventing the free.
A review shows that no further destructor executes on the pointer now
held by the caller, so lifetime is preserved.  Therefore, the fix is
considered effective for these two call sites; however, other methods
should be audited for the same pattern.
