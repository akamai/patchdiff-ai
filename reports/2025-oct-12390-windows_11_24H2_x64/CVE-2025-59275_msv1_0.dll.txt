{'kb': 'KB5066835', 'cve': 'CVE-2025-59275', 'date': 1763407671.544485, 'confidence': 0.22, 'change_count': 8, 'file': 'msv1_0.dll', 'patch_store_uid': 'd1fda99a-cb03-4b57-bc0b-7a115cd23d46'}
--------------------------------------------------------------------
CVE-2025-59275 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows NTLM authentication implementation – msv1_0.dll, routine
SsprHandleChallengeMessage().  All supported Windows versions that
ship this DLL are affected.


Vulnerability Class
--------------------------------------------------------------------
Improper validation of specified type / length (CWE-1287) leading to a
heap-based buffer overflow (CWE-122) and out-of-bounds read (CWE-125).


Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  SsprHandleChallengeMessage() is responsible for parsing a received
    CHALLENGE_MESSAGE and constructing the final AUTHENTICATE_MESSAGE
    that will be sent to the server.

2.  While converting the received AV-pairs to absolute pointers the
    code copies variable–length fields (domain, user, workstation, …)
    into a freshly allocated buffer.  The allocation size is computed
    as

        TotalSize = AvLenUser + AvLenDomain + … + 88;

    where the individual *AvLen* values are WORDs coming from the
    attacker controlled CHALLENGE_MESSAGE.

3.  In the vulnerable build the temporary 32-bit variables that hold
    the intermediate result are signed (`ecx`/`int`).  When an attacker
    supplies a length large enough so that `AvLen + 6` overflows the
    signed 32-bit range the comparison

        if ( TotalSize < AvLen )  // sanity check

    is bypassed, causing **TotalSize to become a small positive
    integer**.  The allocation performed through
    `NtLmAllocateLsaHeap(TotalSize)` therefore returns a buffer that is
    far too small.

4.  Immediately afterwards the routine calls SspContextCopyString() to
    copy the user-supplied strings into that buffer.  Because the input
    lengths are still the original attacker chosen WORDs, a classic
    heap based buffer overflow occurs.

5.  The overwrite happens in an LSASS process, so the attacker can
    corrupt adjacent heap metadata / objects and execute arbitrary code
    in the LocalSystem security context, effectively gaining an
    elevation of privilege.

6.  The patch replaces the signed temporaries with *unsigned* variables
    (`unsigned int v114`, `unsigned __int16 v116 …`) and repeats the
    range checks using the new variables.  Any wrap-around now leaves
    the value larger than the additive operand, triggering the failure
    path and aborting processing before memory is allocated/copied.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable – before patch
v113 = **(_DWORD **)(Ctx + 0x68);        // user size (signed)
v114 = LOWORD(AvPair->Len);
if (!v114) v114 = 4;
v115 = v114 + v113 + 6;                  // may wrap signed int
if (v115 < v114)                         // check bypassed after wrap
    return STATUS_INTEGER_OVERFLOW;
...                                   // alloc v115 bytes then memcpy()
```

```c
// fixed – after patch
v114 = **(_DWORD **)(Ctx + 0x68);        // still user controlled
unsigned __int16 base = LOWORD(Av->Len);
if(!base) base = 4;
unsigned __int16 needed = base + v114 + 6;
if (needed < base)                       // cannot be bypassed now
    return STATUS_INTEGER_OVERFLOW;
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker initiates NTLM authentication against a local service that
   uses SSPI.
2. Malicious CHALLENGE_MESSAGE containing oversized AV-pairs is
   delivered to LSASS.
3. LSASS -> msv1_0!SsprHandleChallengeMessage()
4. Integer wrap in size calculation → undersized heap buffer.
5. SspContextCopyStringAbsolute() overflows the heap buffer.
6. Crafted data corrupts process memory → arbitrary code in LSASS.


Attack Vector
--------------------------------------------------------------------
Local, authenticated.  Any user able to trigger NTLM authentication to
LSASS (e.g. via localhost SMB loopback or token-manipulation APIs) can
supply the crafted CHALLENGE_MESSAGE.


Patch Description
--------------------------------------------------------------------
• Replaced signed loop/index variables with unsigned equivalents.
• Added additional width-preserving variables (`_WORD *`, `unsigned
  __int16`) for all attacker supplied length fields.
• Re-ordered and strengthened integer-overflow checks before memory
  allocation.
• All WPP logging calls switched from *D_0* to typed *D* variants (no
  functional impact, just refactoring).
• Numerous renamings/initialisations – defensive hardening but central
  fix is the unsigned arithmetic and revised range validation.


Security Impact
--------------------------------------------------------------------
Before the fix an authorised but unprivileged attacker could craft a
challenge that causes a heap overflow in LSASS, culminating in
arbitrary code execution with SYSTEM privileges (local elevation of
privilege).  Remote exploitation is not possible because the attacker
already needs to control the local NTLM client data.


Fix Effectiveness
--------------------------------------------------------------------
With the patched code the calculated *needed* buffer size can no longer
wrap below the contributor length; any attempt to use pathological
sizes causes STATUS_INTEGER_OVERFLOW, aborting authentication.  No
further code paths copy data into an undersized allocation, therefore
the heap overflow is fully mitigated.

