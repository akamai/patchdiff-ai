{'patch_store_uid': '14c93d55-e7f4-46a3-bba2-3ab2772ab3d9', 'change_count': 7, 'cve': 'CVE-2025-59208', 'confidence': 0.08, 'date': 1763403032.4664145, 'kb': 'KB5066835', 'file': 'urlmon.dll'}
--------------------------------------------------------------------
CVE-2025-59208 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
urlmon.dll  (CINetHttp::QuerySameSiteCookieLevel)
Introduced in the WinINet / URLMon networking stack that is used by
MapUrlToZone and other higher-level URL classification helpers.

Vulnerability Class
--------------------------------------------------------------------
Out-of-bounds Read leading to information disclosure (CWE-125).

Detailed Root Cause Analysis
--------------------------------------------------------------------
QuerySameSiteCookieLevel asks the caller-supplied IInternetBindInfo
object for string id 26 (documented as
BINDSTRING_SAME_SITE_COOKIE_LEVEL) by calling GetBindString():

    hr = pBindInfo->GetBindString(26, &pv);

The API contract for GetBindString is that it returns an array of
Unicode strings that the callee must free with CoTaskMemFree().  The
original implementation, however, unconditionally interprets the first
4 bytes of the returned buffer as a 32-bit integer cookie level:

    *(DWORD *)this + 318 = *(DWORD *)pv;   // assumes 4-byte buffer

No check is performed to verify that at least sizeof(DWORD) bytes were
allocated, nor that the buffer indeed contains an integer.  If a
malicious IInternetBindInfo implementation (reachable from untrusted
content via pluggable protocols and therefore indirectly from
MapUrlToZone) returns a 1- or 2-byte buffer, the subsequent 4-byte read
accesses memory past the allocation boundary.  The leaked bytes are
then copied into the CINetHttp instance and can later be observed by
the attacker through MapUrlToZone-driven logic, resulting in a process
memory disclosure.

In addition, lifetime of the IInternetBindInfo object was managed
manually.  Any early-return path before the final Release() could leave
the object alive while the buffer had already been freed, amplifying
unexpected memory access scenarios.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch (excerpt)
if (pv) {
    *((BYTE *)this + 1276) = 1;
    *((DWORD *)this + 318) = *(_DWORD *)pv; // unchecked 4-byte read
}
...
CoTaskMemFree(pv);
((void (__fastcall *)(IInternetBindInfo *))v6->lpVtbl->Release)(v6);
```

```c
// after patch (excerpt)
Microsoft::WRL::ComPtr<IInternetBindInfo>::Attach(v11, Ref);
...
pv = nullptr;
hr = v11->GetBindString(26, &pv);
...
CoTaskMemFree(pv);
Microsoft::WRL::ComPtr<IUnknown>::InternalRelease(v11);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Victim application calls MapUrlToZone on an attacker-controlled URL.
2. URLMon creates CINetHttp and calls QuerySameSiteCookieLevel().
3. A hostile pluggable protocol supplies a crafted IInternetBindInfo
   whose GetBindString allocates only 1-2 bytes.
4. QuerySameSiteCookieLevel dereferences 4 bytes -> OOB read.
5. The copied dword is later observable, disclosing adjacent memory.

Attack Vector
--------------------------------------------------------------------
A remote attacker hosting malicious content can register or trigger a
pluggable protocol / MIME handler that implements IInternetBindInfo and
is invoked during MapUrlToZone processing.  By returning a tiny buffer
from GetBindString the attacker causes the victim process to read
outside the allocation and leak memory over the network.

Patch Description
--------------------------------------------------------------------
The patch wraps the IInternetBindInfo pointer in a WRL::ComPtr
(v11) and relies on automatic reference counting to guarantee balanced
AddRef/Release.  All manual Release() calls were removed.  Extra
feature-flag checks were added to avoid executing the fallback path on
certain error codes.

Security Impact
--------------------------------------------------------------------
The uncontrolled 4-byte read allows disclosure of stack or heap data
residing immediately after the attacker-controlled allocation.  In a
network context this can leak sensitive information such as memory
addresses, undermining ASLR and aiding further exploitation.

Fix Effectiveness
--------------------------------------------------------------------
The RAII pattern prevents stale pointer usage and double-release
conditions.  However, the patch still assumes a 4-byte buffer and does
not validate the size returned by GetBindString, leaving a residual
risk.  A full fix would additionally verify pcElFetched or require at
least sizeof(DWORD) bytes before dereferencing.
