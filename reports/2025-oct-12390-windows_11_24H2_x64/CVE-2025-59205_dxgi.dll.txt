{'date': 1763406138.2372856, 'change_count': 43, 'confidence': 0.26, 'cve': 'CVE-2025-59205', 'file': 'dxgi.dll', 'patch_store_uid': '34b39626-9daa-45b1-bd29-09b7df9f027d', 'kb': 'KB5066835'}
--------------------------------------------------------------------
CVE-2025-59205 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Graphics Component (dxgi.dll).  Vulnerable routine is
SREffectRenderPassDx12::CShaderRenderPass::Initialize() which is part
of the Super-Resolution (AutoSR) Upscaling effect implementation.


Vulnerability Class
--------------------------------------------------------------------
Race condition leading to use-after-free / dangling-pointer
(CWE-362 + CWE-416).


Detailed Root Cause Analysis
--------------------------------------------------------------------
Initialize() receives several COM / shared_ptr style objects, keeps
some of them for later use and immediately returns to the caller.  A
member pointer (this[11]) is set to the CSREffectImpl instance passed
in as parameter a7.  In the pre-patch build the code simply performed:

    this[11] = a7;                                     // store ptr
    flag = a7->lpVtbl[3].QueryInterface(…);            // call vtbl

No AddRef was taken on a7, so the function assumed the caller would
keep the object alive for the lifetime of the render-pass object.  If
the caller released a7 (or its owning smart pointer went out of scope)
concurrently with other threads that later dereference this[11], the
pointer could already reference freed memory.  Because the object is a
COM interface the freed memory normally contains a writable vtable
pointer; an attacker with local code execution can create a fake
object and race the release, redirecting execution when the render
pass thread performs the subsequent vtable call.  The condition is a
classic TOCTOU lifetime bug caused by missing inter-thread
synchronisation and incorrect reference counting.

The same pattern existed for the shared_ptr objects in *a5 and *a6; an
interlocked 32-bit increment was applied directly to the control block
but Decref happened before the new pointer assignment, leaving a small
window where the ref-count could drop to zero while the new holder was
not yet visible.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// pre-patch (excerpt)
this[11] = a7;
*((_BYTE *)this + 204) =
    *(_DWORD *)(a7->lpVtbl[3].QueryInterface)(a7, tmp) != 0;

// post-patch (excerpt)
this[11] = a7;
int *p = (int *)(a7->lpVtbl[3].AddRef)(a7, tmp);
int v  = *p;
*((_BYTE *)this + 204) = v != 0;
if (!v ||
    !*(DWORD *)(((IUnknown *)this[11])->lpVtbl[3].AddRef)(this[11],tmp)+20)
    ok = 0;
*((_BYTE *)this + 205) = ok;
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker thread creates CSREffectImpl object and calls
   CShaderRenderPass::Initialize(…, obj, …).
2. Initialize() stores the raw pointer inside the render-pass object
   without AddRef (pre-patch).
3. Attacker releases the last reference to obj from another thread,
   freeing the object.
4. Render-pass code later executes on a worker GPU thread, dereferences
   this[11] and jumps through the stale vtable, executing attacker
   controlled code.


Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker running code that can interact with the
DirectX Super-Resolution effect chain.  No special privileges are
required; the vulnerability is fully exploitable from a low-integrity
application such as a Windows Store app or a sandboxed browser process.


Patch Description
--------------------------------------------------------------------
1. A COM AddRef is now taken on the CSREffectImpl object before it is
   stored (a7->lpVtbl[3].AddRef).
2. The returned ref-count is used to derive two consistency flags that
   are stored in bytes 204 and 205 of the object, guaranteeing the
   object is still valid before further use.
3. Reference management for the shared_ptr parameters was hardened:
   _InterlockedAdd(…,1) replaces _InterlockedIncrement and Decref now
   happens *after* the new pointer is assigned, closing a small window
   where the ref-count could momentarily reach zero.
4. Minor reordering of error codes and variable scoping; functional
   behaviour unchanged.


Security Impact
--------------------------------------------------------------------
A successful race gives the attacker control over a freed COM object
pointer that will be dereferenced in a higher-privileged graphics
worker thread inside dxgi.dll.  This enables local privilege
escalation and potential code execution in the context of the Windows
Graphics system service.


Fix Effectiveness
--------------------------------------------------------------------
The added AddRef guarantees the lifetime of CSREffectImpl for the
entire lifetime of the shader render pass object, removing the use-
after-free window.  Additional tightening of reference counting for
other parameters closes auxiliary holes.  No remaining paths were
found where an un-referenced pointer is stored; mitigation is judged
complete for this routine.
