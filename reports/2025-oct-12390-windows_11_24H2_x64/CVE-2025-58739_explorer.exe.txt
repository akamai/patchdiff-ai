{'file': 'explorer.exe', 'patch_store_uid': '3165bbac-c206-46c7-bab4-8964399b9793', 'confidence': 0.15, 'kb': 'KB5066835', 'cve': 'CVE-2025-58739', 'change_count': 128, 'date': 1763406223.9952266}
--------------------------------------------------------------------
CVE-2025-58739 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows 10/11 File Explorer (explorer.exe) – C++17
std::filesystem helper routine used when Explorer extracts the
filename part of a user-supplied path.

Vulnerability Class
--------------------------------------------------------------------
Uninitialised-variable usage leading to out-of-bounds read and
information disclosure (CWE-200).

Detailed Root Cause Analysis
--------------------------------------------------------------------
The vulnerable routine is the compiler-generated wrapper for
std::filesystem::path::filename() inside explorer.exe.  Its purpose is
to build a new std::filesystem::path that contains only the filename
component of an existing std::wstring path.

Pseudo-register layout before the fix:
  a1 – address of std::filesystem::path (input)
  a2 – address of std::filesystem::path (output)

Local variables (before patch)
  v4  const unsigned short *end_ptr  (initialised)
  v5  const unsigned short *begin_ptr (UNINITIALISED)

Key sequence:
  1. std::wstring::operator basic_string_view() returns a view of the
     underlying wchar buffer (v3).
  2. v4 is set to the address after the last character in that buffer.
  3. v5 is never initialised.
  4. _Find_filename( *path, v4, v5 ) is executed.

std::filesystem::_Find_filename(begin,end) expects its third parameter
(begin) to point inside the same buffer as ‘end’.  Because v5 contains
stack garbage, the helper scans memory outside of the legitimate
wstring.

After _Find_filename() returns, the function computes

    v7[1] = (end_ptr - returned_ptr) >> 1;

and constructs a new std::filesystem::path from that pair.  Whatever
memory range was walked by _Find_filename() becomes observable via the
new path object that Explorer may later log, compare, or expose through
IPC.  Thus random portions of stack/heap memory can be disclosed to an
unprivileged actor.

The bug is entirely due to an uninitialised pointer; no bounds checks
exist to detect the bad state.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – explorer!std::filesystem::path::filename
v3 = std::wstring::operator basic_string_view<unsigned short>(a1, v8);
v4 = (const unsigned __int16 *)(*(_QWORD *)v3 +
      2i64 * *(_QWORD *)(v3 + 8));          // end of string
// v5 is never written
v7[0] = (__int64)std::filesystem::_Find_filename(*(std::filesystem **)v3,
                                                 v4, v5); // UB!
```

```c
// after patch – new implementation no longer calls _Find_filename
*(_OWORD *)a2 = 0;
a2[3] = 7;                  // initialise result string
std::basic_stringbuf<unsigned short>::_Get_buffer_view(a1+24,&v4);
if (v4)
  std::wstring::assign(a2);  // safe copy
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Explorer enumerates a file system object (local path or UNC share).
2. It calls std::filesystem::path::filename() to extract the last
   component.
3. The uninitialised v5 is forwarded into _Find_filename().
4. _Find_filename() walks attacker-controlled memory addresses,
   copies bytes into a new std::wstring.
5. Resulting string may be surfaced via the UI, shell namespace
   extension callbacks, logs, or over the network (spoofing / info
   leak).

Attack Vector
--------------------------------------------------------------------
A remote attacker can place a specially crafted file or directory name
on a SMB/HTTP WebDAV share and lure a victim into browsing that
location with Explorer.  During path parsing the bug is triggered,
causing disclosure of stack/heap data that can be collected through a
side channel (e.g., reflected in the shell window title, tooltip, or
COM IPC message), enabling spoofing of trusted UI elements.

Patch Description
--------------------------------------------------------------------
Microsoft replaced the entire implementation with a safe wrapper:
1. The output path object is fully zero-initialised.
2. The helper _Get_buffer_view() returns a validated view of the source
   buffer, eliminating manual pointer math.
3. Only std::wstring::assign() is used to copy data, so no direct
   pointer arithmetic or custom find routine is needed.
4. The uninitialised variable ‘v5’ and the call to _Find_filename() are
   removed, eliminating the out-of-bounds read.

Security Impact
--------------------------------------------------------------------
Before the fix an attacker could disclose arbitrary portions of process
memory, potentially including NTLM hashes, window handles, or other
sensitive information, and craft misleading filenames to spoof UI
state.  The bug therefore maps to CWE-200 and is addressed in
Microsoft advisory CVE-2025-58739 (Windows File Explorer Spoofing
Vulnerability).

Fix Effectiveness
--------------------------------------------------------------------
The patched code no longer passes uncontrolled pointers to
_Find_filename(); all variables are initialised and bounds are
maintained by the C++ standard library.  No equivalent pathways using
_Find_filename() remain in the modified function, so the specific
information-disclosure vector is closed.  A broader audit of other
filesystem helpers is still advisable but this change appears
sufficient for the identified root cause.
