{'confidence': 0.12, 'kb': 'KB5066835', 'date': 1763407807.2532375, 'patch_store_uid': 'afe9fa6e-0a1c-4325-b44e-2c4e6256a6dd', 'cve': 'CVE-2025-55698', 'file': 'dxgkrnl.sys', 'change_count': 230}
--------------------------------------------------------------------
CVE-2025-55698 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows – dxgkrnl.sys (DirectX graphics kernel).  Faulty
routine: ComputeQueryInterface() which supplies a procedure table to
user-mode display drivers.

Vulnerability Class
--------------------------------------------------------------------
NULL-pointer dereference (CWE-476) leading to a kernel-mode denial of
service.

Detailed Root Cause Analysis
--------------------------------------------------------------------
User-mode display drivers obtain a table of kernel callbacks by
invoking DxgkComputeEscape → ComputeQueryInterface() and passing a
caller-allocated _DXGKCOMPUTE_INTERFACE structure.  Two 16-bit header
fields inside that structure describe
  • Size   (_In_  WORD InterfaceSize)
  • Version(_In_  WORD InterfaceVersion)

The pre-patch implementation tried to validate the pair but the logic
was wrong:

1.  When Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage_25() was
    enabled the code entered a nested if/else chain.
2.  For InterfaceVersion == 3 the function only compared Size against
    624 (expected for v3).  For InterfaceVersion == 2 it compared Size
    against 616.  That was correct – but the error path
    (labelled “LABEL_7”) *never reset the Version field check*.
3.  A crafted structure could therefore reach the success path when
       InterfaceVersion == 3  &&  Size == 616
    or
       InterfaceVersion == 2  &&  Size == 624
    – clearly inconsistent combinations.
4.  After the superficial checks the routine unconditionally filled 78
    QWORD slots beginning at a1+8 with function pointers.  For version
    2 only 76 entries are valid; entries 76-77 were left untouched and
    therefore remained NULL.
5.  Because the routine also returned the *larger* size (624) to the
    caller, user mode trusted the table to hold 78 valid callbacks.  A
    subsequent call into either of the two missing callbacks
    (offsets 76 or 77) made the kernel dereference a NULL function
    pointer and bug-check (typically 0x3B or 0x50).

Attackers only need DEVICE access – the call is reachable from a
sandboxed, low-integrity process and no additional privileges are
required.  The exception is raised in kernel context, resulting in an
immediate system crash (DoS).

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// pre-patch (simplified)
if (FeatureEnabled()) {
    WORD ver  = a1->Version;
    WORD size = a1->Size;
    if (ver == 3)   valid = (size == 624);
    else if (ver == 2) valid = (size == 616);
    if (!valid) goto LABEL_7;   // wrong path keeps ver/size coupled
}
...
// fill 78 callbacks no matter which version
*((QWORD*)a1+76) = ...;
*((QWORD*)a1+77) = FeatureEnabled() && ver==3 ? DxgkQueryStatisticsK
                                            : NULL; // stays NULL
*a2 = size;        // returns 624 even for ver==2 (incorrect)
```

```c
// post-patch
WORD ver  = a1->Version;
WORD size = a1->Size;
if (ver == 3) {
    if (size != 624) goto fail;
} else if (ver == 2) {
    if (size != 616) goto fail;
} else {
    goto fail;
}
// now safe – build table; slot 77 only filled for ver==3
```
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker crafts _DXGKCOMPUTE_INTERFACE with Version = 2 and Size =
   624.
2. Escape ioctl → DxgkComputeEscape → ComputeQueryInterface.
3. Mis-validation returns success; table pointer handed back.
4. Attacker calls callback #77 (index 0x4D) → NULL execution → kernel
   bug-check.

Attack Vector
--------------------------------------------------------------------
Any authenticated local user that can open a DirectX device (e.g.
D3DKMTCreateDevice) can submit the malformed interface structure.  No
admin rights or graphics hardware access is required; the issue is
fully local.

Patch Description
--------------------------------------------------------------------
The update completely rewrote the size/version gate:
•   Removed the convoluted LABEL_7 error path.
•   Performs a strict cross-check:
       (Version==3 && Size==624) OR (Version==2 && Size==616)
•   Any other combination returns STATUS_INVALID_PARAMETER.
•   The returned size (*a2) is now taken from the validated pair, not
    from a mutable local variable.
•   The pointer to DxgkQueryStatisticsK (slot 77) is only assigned when
    Version==3 – older interfaces no longer expose a NULL entry.

Security Impact
--------------------------------------------------------------------
Prior to the fix a non-privileged process could reliably crash the
system, leading to a total denial of service.  There is no information
leak or privilege escalation; availability is the sole impact.

Fix Effectiveness
--------------------------------------------------------------------
The revised check guarantees that an interface’s Size matches the
expected layout for its Version, preventing the creation of partially
initialised procedure tables.  Attempting to pass a mismatched pair
now returns STATUS_INVALID_PARAMETER before any callback table is
exposed, eliminating the NULL dereference vector.
