{'change_count': 76, 'file': 'printworkflowservice.dll', 'date': 1763404432.389121, 'patch_store_uid': 'cfbf7ece-1a89-464d-80de-2d625e11c5f0', 'kb': 'KB5066835', 'confidence': 0.21, 'cve': 'CVE-2025-55690'}
--------------------------------------------------------------------
CVE-2025-55690 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows PrintWorkflowUserSvc – specifically the WRL/WinRT *produce<>
adaptors inside printworkflowservice.dll that expose
IPrintSupport*Session* and related interfaces.


Vulnerability Class
--------------------------------------------------------------------
Use-after-free (CWE-416)


Detailed Root Cause Analysis
--------------------------------------------------------------------
Each WinRT interface that the service returns to user-mode code is
backed by a C++/WinRT *produce<>* adaptor.  Prior to the patch several
getters (e.g.  GetAppInfo, GetTargetStorageFile, get_DocumentTitle,
get_SourceAppName, get_SourcePdlFormat, GetTargetStorageFilePath, …)
were implemented by

  1.  Fetching an internal implementation pointer stored inside the
      session object:  
        v4 = *(_QWORD *)(this + offset);

  2.  Immediately dereferencing fields that live inside that
      implementation object (e.g. +128, +136, +360, +144 bytes…).

  3.  Returning the raw pointer or handle to the caller, sometimes after
      a shallow AddRef on only the field but **never** on the parent
      implementation object that owns the field.

Because the adaptor did **not** AddRef/Release the implementation
object itself, there was no lifetime guarantee between the moment the
pointer was read and the moment the field was dereferenced.  If another
thread (or the same thread via re-entrancy) released the session object
in the small time-window, the memory could be freed and potentially re
allocated with attacker-controlled data.  Any subsequent read or write
performed by the getter therefore operated on freed memory – a classic
use-after-free.  The object that is freed is allocated inside the
PrintWorkflowUserSvc (SYSTEM integrity), so the dangling pointer is
still executed in a privileged context, giving an authorised local
attacker a path to privilege escalation.

The most dangerous path is GetTargetStorageFile.  The original code
reads a COM pointer at *(impl+360) and immediately calls
Microsoft::WRL::ComPtr<IInspectable>::InternalAddRef on it.  If the
parent *impl* was already freed, the vtable of the allegedly valid
IInspectable object can be attacker-controlled, leading to arbitrary
code execution inside the service.

Identical lifetime issues existed in the other property getters listed
above; they all followed the same pattern of
"read-pointer-without-AddRef, dereference, return".


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – GetTargetStorageFile (trimmed)
 v4 = *(_QWORD *)v3;              // grab impl pointer (no AddRef!)
 v5 = *(_QWORD *)v3 + 360i64;     // compute field address
 if (!v4) v5 = 376i64;            // static fallback
 v8 = *(_QWORD *)v5;              // read freed memory -> UAF
 Microsoft::WRL::ComPtr<IInspectable>::InternalAddRef(&v8);
```
```c
// after patch – same getter (trimmed)
 if (FeatureEnabled) {
     SessionInitDataHandler::GetTargetStorageFile(...,&v9); // helper
 } else {
     v7 = v4 + 376;  // same field
     v6 = *(_QWORD *)v7;
     v9 = *(_QWORD *)v7;
     InternalAddRef(&v9);          // still needed but parent lives
 }
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Client obtains a session interface from PrintWorkflowUserSvc.
2. Client calls a getter (e.g. GetTargetStorageFile).
3. Inside the service, the getter executes while holding **no** reference
   to the backing implementation object.
4. A second thread (or re-entrancy through COM callbacks) releases the
   session object, freeing its heap block.
5. Original getter resumes, dereferences the stale pointer and executes
   attacker-controlled memory.


Attack Vector
--------------------------------------------------------------------
Local, authenticated user.  The attacker needs the ability to start a
PrintWorkflow session (any standard user can) and to race/free the
object before or during a property getter call.


Patch Description
--------------------------------------------------------------------
All vulnerable getters were rewritten to eliminate direct field access.
The new code path:

1. Converts the current *this* pointer to the owning implementation via
   `(this - 16) & -(this != 0)`; this expression yields a valid base
   pointer even for projected interfaces.
2. Immediately passes that pointer to a helper such as
   PrintSupportSession::DocumentTitle or
   SessionInitDataHandler::GetTargetStorageFile.  These helpers create
   and return **copies** (hstring clone or new COM reference) of the
   requested data instead of exposing internal storage.
3. Any temporary COM object is properly AddRef'ed, released, and the
   returned handle is zeroed before stack unwind, ensuring no dangling
   pointer remains.
4. In two places the access path is additionally gated behind a WIL
   feature check so that old layouts are avoided when the feature is
   enabled.


Security Impact
--------------------------------------------------------------------
Prior to the fix, an authorised local attacker could achieve arbitrary
code execution in the PrintWorkflowUserSvc (runs as LocalSystem),
thereby elevating privileges to SYSTEM.  The condition is reachable
from a low-integrity sandbox because the vulnerable service accepts
connections from any user account.


Fix Effectiveness
--------------------------------------------------------------------
The patch removes all direct dereferences of potentially freed session
objects and delegates the work to helper routines that either hold a
references or return value copies whose lifetime is independent of the
original object.  No remaining path in the modified code returns
internal pointers without first establishing ownership, so the original
use-after-free condition is closed.

