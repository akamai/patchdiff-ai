{'cve': 'CVE-2025-55679', 'confidence': 0.17, 'kb': 'KB5066835', 'patch_store_uid': '274eabe5-fc63-4dac-bd81-8565d9f02d75', 'change_count': 59, 'date': 1763407931.1393511, 'file': 'win32kfull.sys'}
--------------------------------------------------------------------
CVE-2025-55679 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
win32kfull.sys – DWM composition-attribute helpers
(DwmSyncGetCompositionAttribute / DwmAsyncSetCompositionAttribute)

Vulnerability Class
--------------------------------------------------------------------
CWE-200  : Information disclosure
CWE-20   : Improper input validation

Detailed Root Cause Analysis
--------------------------------------------------------------------
Both helpers build an LPC PORT_MESSAGE that is transmitted to the
user-mode DWM process.  The message body is assembled in a fixed
88-byte stack buffer:
  BYTE  v14[88];  // PORT_MESSAGE + payload       (sync path)
  WORD* v10 = …   // async path (same layout)

Before the patch the header fields were filled with values that are
derived from a per-attribute size table (word_140359C58[ 8 * id ]).
No upper bound is applied:
  WORD1(pm->TotalLength) = WORD6(v14[3]) + 24;   // user-controlled
If an attribute whose advertised size is larger than 48 bytes is
chosen, TotalLength/DataLength becomes > 88 although the backing buffer
is still 88 bytes long.  When LpcSendWaitReceivePort / LpcRequestPort
is called, the kernel copies the amount indicated by TotalLength back
to user mode.  Everything that lies behind the 88-byte buffer on the
kernel stack is therefore disclosed to the caller.

Patch analysis demonstrates three defensive measures:
1.  The stack buffer is zero-initialised immediately after memset().
2.  TotalLength is set to the constant 88 (WORD1 = 88).
3.  When the feature flag 72 is enabled a second clamp guarantees that
    TotalLength is never more than LOWORD + 40, i.e. it can never
    exceed the physical buffer.
Identical clamping logic is applied to the asynchronous helper.

Because the attacker was able to control the over-sized length field,
arbitrary pieces of previous stack content (kernel pointers, object
addresses, etc.) were leaked to a non-privileged process, constituting
an information disclosure primitive that can be used to defeat ASLR or
other mitigation layers.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
memset(v14, 0, 0x58);
*(DWORD *)((char*)v14+2) = -2147483560; // sets Length/DataLength
LOWORD(v14[0]) = WORD6(v14[3]) + 0x18; // user size + 24

// after
memset(v14, 0, sizeof(v14));
WORD1(v14[0]) = 88;                    // fixed total length
LOWORD(v14[0]) = word_140359C58[8*id] + 24;
if (Feature72 && WORD1(v14[0]) > LOWORD(v14[0]) + 40)
    WORD1(v14[0]) = LOWORD(v14[0]) + 40; // clamp
```
(The same pattern is applied to DwmAsyncSetCompositionAttribute.)
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User process calls NtUserSetWindowCompositionAttribute() or
   NtUserGetWindowCompositionAttribute().
2. Kernel thunk calls DwmSyncGetCompositionAttribute or its async
   counterpart.
3. Helper builds PORT_MESSAGE in 88-byte stack buffer.
4. Attribute id supplied by the caller selects an entry in
   word_140359C58 with a Size > 48.
5. Before the patch TotalLength/DataLength in PORT_MESSAGE exceed
   88 => LpcSend… copies excess bytes back to user mode.
6. User mode reads the reply buffer and gains kernel-stack contents.

Attack Vector
--------------------------------------------------------------------
Local, unprivileged user.  A crafted
NtUserSetWindowCompositionAttribute / NtUserGetWindowCompositionAttribute
call with a specially chosen attribute id triggers the oversized length
field and receives the leaked stack memory in the reply.

Patch Description
--------------------------------------------------------------------
• Introduces constant 88-byte TotalLength for both helpers.
• Adds conditional clamp ( if Feature 72 ) to ensure
  TotalLength <= (LOWORD + 40).
• Zero-initialises the full buffer before filling it.
• Reworks Sync path to call SyncLpcCheckNtStatus() for additional
  validation.
• Async path mirrors the same length and clamp logic.

Security Impact
--------------------------------------------------------------------
Prior to the patch an attacker could obtain up to several hundred bytes
of uninitialised kernel stack data per call, reliably leaking kernel
pointers and other sensitive information.  That materially reduces the
entropy of KASLR and aids further exploitation chains.  No privilege
escalation is required.

Fix Effectiveness
--------------------------------------------------------------------
The patched code guarantees that DataLength/TotalLength can no longer
exceed the size of the on-stack buffer and that the buffer is zeroed
before use.  Therefore no uninitialised data can be copied into the
reply message and the information disclosure primitive is removed.  No
alternate paths to influence TotalLength remain; effectiveness is
considered high.

