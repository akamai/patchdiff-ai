{'cve': 'CVE-2025-55681', 'confidence': 0.21, 'date': 1763407705.6438158, 'kb': 'KB5066835', 'change_count': 96, 'patch_store_uid': '9ea31a38-c5d1-473b-b782-3c02fef25a9c', 'file': 'dwmcore.dll'}
--------------------------------------------------------------------
CVE-2025-55681 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Desktop Window Manager (dwmcore.dll)
Function: CBrushRenderingGraphBuilder::AddEffectBrush()
Windows 10/11 – user-mode service running inside the SYSTEM DWM
process.

Vulnerability Class
--------------------------------------------------------------------
CWE-125: Out-of-Bounds Read  
Secondary: CWE-822 Untrusted Pointer Dereference (possible write)

Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  The routine builds an array named SubgraphOutput that contains one
    16-byte element for every compiled-effect sub-graph except the last
    one:
        count = CompiledEffect->GetNumSubGraphs();
        vector.resize(count-1);
    The base pointer of this vector is kept in v16 (old) / v14 (new).

2.  While iterating through every effect input the code asks the
    compiled-effect object for an "intermediate input index":
        index = CompiledEffect->GetIntermediateIndex(g, i);
    The returned *index* is stored in v26 (old) / v24 (new).

3.  Prior to the patch the index was used unchecked:
        ptr = v16 + 16 * index;        // pointer arithmetic
        if (*(DWORD*)ptr != -1)        // read outside vector when
                                       // index >= vector.size()
           CRenderingTechniqueFragment::AddIntermediateInput(...);
        else { ... *(ptr+8) ... }      // write outside vector

    If *index* is larger than (count-1) the calculation steps outside
    the allocated buffer, producing an out-of-bounds read and, in the
    else-path, a write of attacker-controlled data.  The index value is
    entirely controlled by the content of the compiled effect that is
    sent from a lower-privileged client process to DWM.

4.  Because the pointer retrieved from the over-indexed location is
    dereferenced later, arbitrary memory controlled by the attacker is
    read (information disclosure) and may be written, enabling further
    corruption and escalation to SYSTEM inside the DWM service.

5.  The issue is exploitable locally by any user that can create and
    submit a malicious Composition effect graph.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// BEFORE
if (v48)                                  // intermediate input flag
{
    ptr = v16 + 16i64 * v26;              // no bounds check
    if (*(DWORD*)ptr != -1)
        Fragment->AddIntermediateInput(*(DWORD*)ptr);
    else {
        tmp = *(QWORD*)(ptr + 8);         // OOB read
        *(QWORD*)(ptr + 8) = 0;           // OOB write
        ...                               // further dereference
    }
}

// AFTER
if (v42)                                  // intermediate input flag
{
    if (FeatureEnabled &&                 // new guard
        v24 >= ((v54_high - v14) >> 4))   // index >= vector.size()
        wil::FailFast();                  // terminate

    ptr = v14 + 16 * v24;                 // safe
    ...
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Client process creates a malicious Windows::UI::Composition effect
   with a crafted intermediate-input index greater than the real
   sub-graph count.
2. Effect is marshalled to the SYSTEM-level DWM process.
3. DWM calls CBrushRenderingGraphBuilder::AddEffectBrush().
4. Function reads the attacker-controlled index and accesses the
   SubgraphOutput vector out of bounds.
5. Memory beyond the buffer is read / written, enabling information
   disclosure or further corruption leading to elevation of privilege.

Attack Vector
--------------------------------------------------------------------
Local, authenticated user.  Any process that can submit a composition
brush/effect (via UWP, WinUI, XAML, or DirectComposition APIs) can
provide the crafted effect data to DWM.

Patch Description
--------------------------------------------------------------------
• Introduced an explicit bounds check:
      if (index >= vector.size()) FailFast();
  implemented through wil::Feature-gated check before dereferencing the
  SubgraphOutput vector.  
• Added synchronization and cleanup of any pending thread-pool work
  before using the compiled effect.  
• Re-organised local variables but no functional change beyond safety
  check.

Security Impact
--------------------------------------------------------------------
Before the patch a low-privilege application could cause DWM to perform
out-of-bounds memory accesses inside its SYSTEM process context.  The
read discloses memory and the paired write enables memory corruption
that can be turned into arbitrary code execution, ultimately allowing
local elevation of privilege (EoP).

Fix Effectiveness
--------------------------------------------------------------------
The added index-range validation eliminates the OOB condition by
forcing a process-termination (FailFast) whenever a crafted index is
outside the allocated vector.  This prevents both read and write past
the buffer and is therefore considered effective.  No alternative code
paths remain that use the index without the same check, so the fix
appears complete.
