{'patch_store_uid': '67b1359b-3787-4b70-8a1b-2e864ed2399c', 'change_count': 110, 'kb': 'KB5065426', 'file': 'microsoft.bluetooth.service.dll', 'confidence': 0.45, 'date': 1763406143.1713226, 'cve': 'CVE-2025-59290'}
--------------------------------------------------------------------
CVE-2025-59290 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Bluetooth Service  (microsoft.bluetooth.service.dll)
Function  : GattClientDeviceSessionImpl::GetCachedIncludedServiceInternal()
Module    : onecore/drivers/bluetooth/profiles/gatt/client/lib

Vulnerability Class
--------------------------------------------------------------------
Use-After-Free (CWE-416)

Detailed Root Cause Analysis
--------------------------------------------------------------------
The helper GetCachedIncludedServiceInternal() returns a pointer to a
vector that represents the set of included GATT services cached for a
remote device session.  Internally, the vector is produced by
FindOrGeneratePartialIncludedServicesFromCache().  That routine hands
back ownership through a std::unique_ptr that lives only on the stack
of GetCachedIncludedServiceInternal().

In the un-patched version the code performed the steps in the following
order:
 1. Call FindOrGeneratePartialIncludedServicesFromCache(), which
    returns a temporary unique_ptr<uVec> (held at rsp-28h).
 2. Copy the raw pointer stored at offset +8 of that unique_ptr into
    the caller-supplied output parameter (a2 / v6).
 3. Let the unique_ptr go out of scope immediately afterwards.

Because ownership was never released from the unique_ptr, its
destructor freed the vector while the same raw pointer was still
returned to the caller.  Any subsequent access by the caller (or other
threads) therefore used memory that had already been freed, creating a
classic use-after-free window inside the Bluetooth service process.

The affected data structure is a std::vector<
Microsoft::Bluetooth::Profiles::Gatt::GattServiceDefinitionInfo>,
allocated on the heap and referenced through a raw pointer.  The misuse
occurs when *v6 is set to that raw pointer without first disarming the
unique_ptr’s destructor.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable sequence (simplified, before patch)
auto tmp = FindOrGeneratePartialIncludedServicesFromCache(...);
*v6 = *(tmp + 8);          // forward raw pointer to caller
// tmp goes out of scope -> unique_ptr destructor frees vector
```

```c
// patched sequence
auto tmp = FindOrGeneratePartialIncludedServicesFromCache(...);
*v6 = *(tmp + 8);          // forward raw pointer
*(tmp + 8) = 0;            // relinquish ownership so dtor will not free
// unique_ptr destructor now does nothing
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User-mode client invokes a GATT API that requires included-service
   enumeration.
2. microsoft.bluetooth.service.dll calls
   GattClientDeviceSessionImpl::GetCachedIncludedServiceInternal().
3. Function allocates vector via
   FindOrGeneratePartialIncludedServicesFromCache().
4. Raw pointer is returned while the owning unique_ptr is destroyed.
5. Subsequent use of the pointer (any read/write or re-enumeration)
   touches freed memory -> crash or controlled memory reuse.

Attack Vector
--------------------------------------------------------------------
A locally authenticated attacker can repeatedly exercise the affected
GATT API (for example via Bluetooth LE pairing and service discovery)
from a low-privilege process.  By racing or carefully timing requests
the attacker can trigger the use-after-free and execute code in the
context of the Bluetooth service, which runs with higher privileges
(LocalSystem under svchost.exe).

Patch Description
--------------------------------------------------------------------
1. Introduced a feature-gated branch that still uses
   FindOrGeneratePartialIncludedServicesFromCache() but now explicitly
   clears the internal pointer ( *ptr = 0 ) before the unique_ptr goes
   out of scope, effectively transferring ownership to the caller.
2. Added temporary buffers (v19, v20) to hold the unique_ptr instance
   and its destructor call.
3. Replaced trace-GUID constants and routed HRESULT verification
   through wil::verify_hresult(), cosmetic to the fix.

Security Impact
--------------------------------------------------------------------
Freed memory can be reused or overwritten by an attacker, enabling
arbitrary code execution inside the Bluetooth service.  Successful
exploitation therefore provides an elevation of privilege from the
calling user to SYSTEM.

Fix Effectiveness
--------------------------------------------------------------------
The fix correctly nulls the pointer inside the unique_ptr before the
destructor executes, ensuring the buffer’s lifetime is now owned by the
caller.  No additional paths returning the same buffer were observed in
the diff, so the patch appears complete.  Effectiveness is high unless
other call sites expose the same ownership bug (unknown).

