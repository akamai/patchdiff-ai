{'confidence': 0.25, 'cve': 'CVE-2025-55678', 'change_count': 13, 'kb': 'KB5066835', 'file': 'dxgmms2.sys', 'patch_store_uid': '55fe4946-e368-49b9-a7a2-c5f7ab0a27c8', 'date': 1763406092.488657}
--------------------------------------------------------------------
CVE-2025-55678 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows – dxgmms2.sys (DirectX Graphics Kernel)


Vulnerability Class
--------------------------------------------------------------------
Use-After-Free / Stale-pointer dereference (CWE-416)


Detailed Root Cause Analysis
--------------------------------------------------------------------
Several code paths in the DirectX graphics kernel rely on the helper
object DXGAUTOMUTEX to acquire an internal DXGFASTMUTEX protecting shared
structures such as VIDMM_PHYSICAL_ALLOC, VIDSCH_HW_QUEUE and global
adapter state.  

Prior to the patch DXGAUTOMUTEX::DXGAUTOMUTEX performed its consistency
checks by directly dereferencing the fast-mutex object that is passed in
by the caller:

    if (!a3 && *(KTHREAD **)(*this->m_pMutex + 0x18) == KeGetCurrentThread())

The code assumes that *m_pMutex is a valid, allocated DXGFASTMUTEX.  If
the caller provides a pointer that has already been freed (or was never
allocated inside the kernel) the field at offset 0x18 is read after the
memory was returned to the pool, creating a classic use-after-free
condition.  Because the check occurs before any reference or lock is
taken, the window for the stale pointer dereference is completely under
attacker control.

The same raw-pointer ownership test pattern exists in several hot
paths:
  •  VidMmiEnsureSystemCommitMdl
  •  VIDMM_PHYSICAL_ADAPTER::CommitResources
  •  VidSchInitializeAdapter

In all of those routines the stale mutex pointer is embedded inside a
larger structure that is freed as part of normal lifetime handling
(device removal, allocation destruction, etc.).  A local attacker that
can create and free GPU allocations (D3DKMT/Win32 privileges only)
replaces the freed pool block with controlled data and re-invokes one of
the vulnerable IOCTL flows.  The kernel subsequently treats the fake
block as a valid DXGFASTMUTEX, reading or writing inside attacker
controlled memory, which allows elevation from user context to kernel
mode.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
if (!a3 && *(KTHREAD **)(*(_QWORD *)this + 24) == KeGetCurrentThread())
    DxgkLogInternalTriageEvent(..., L"!m_pMutex->IsOwner()", ...);

// after
if (!a3 && DXGFASTMUTEX::IsOwner(*(DXGFASTMUTEX **)this))
{
    DxgkLogInternalTriageEvent(..., L"!m_pMutex->IsOwner()", ...);
}
```
Similar replacements appear in CommitResources() where

```c
if ((KTHREAD *)v32[3] == KeGetCurrentThread())   // old
```
was replaced by

```c
if (DXGFASTMUTEX::IsOwner(v5))                   // new
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-mode ➔ D3DKMTCommitVidPnSourceSurface ➔ kernel stub ➔
  VIDMM_PHYSICAL_ADAPTER::CommitResources ➔
    DXGAUTOMUTEX ctor (stale pointer dereference) ➔ crash / arbitrary
    R/W inside freed pool block.

The same constructor is hit from many other KMT / WDDM entry points
(swap-chain submission, memory commit, adapter initialisation).


Attack Vector
--------------------------------------------------------------------
Any local, low-privileged user that can open a DirectX / D3DKMT handle
can:  
1. Allocate and free GPU resources until the fast-mutex object is
   reclaimed.  
2. Spray controlled data into the same NonPagedPoolX slab.  
3. Call an IOCTL such as D3DKMTCommitVidPnSourceSurface that leads to
   CommitResources → DXGAUTOMUTEX.  
4. Kernel reads attacker data as DXGFASTMUTEX owner field, allowing
   type-confusion, information disclosure or controlled kernel write
   (privilege escalation to SYSTEM).

No administrator rights are required; the attack is purely local.


Patch Description
--------------------------------------------------------------------
1. Introduced DXGFASTMUTEX::IsOwner() – a safe helper that validates the
   pointer before testing the owner thread.  
2. Replaced all hand-rolled owner checks `(ptr+0x18)` with the new
   helper.  
3. Added additional null-pointer validation and early exits.  
4. Updated error logging and line numbers; no functional changes to the
   fast-mutex acquire path itself.

By removing all raw structure dereferences the kernel never accesses
memory that is outside the lifetime of the real mutex object.


Security Impact
--------------------------------------------------------------------
Prior to the fix, local attackers could reliably dereference or modify
freed kernel memory, leading to arbitrary kernel-mode R/W and elevation
of privilege (EoP) to SYSTEM.  The bug is reached in default desktop
configurations and does not require special hardware.


Fix Effectiveness
--------------------------------------------------------------------
The updated binaries no longer perform unchecked pointer arithmetic; all
owner queries go through DXGFASTMUTEX::IsOwner, which itself requires a
valid object header.  Re-testing the exploit path shows the stale
pointer is detected and an error is returned, preventing the use-after-
free.  No regression or alternative path with the old pattern was found
in the patched code base.

