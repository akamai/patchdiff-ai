{'kb': 'KB5066835', 'change_count': 9, 'date': 1763402995.403598, 'patch_store_uid': '7aecb5ec-5226-4c8f-bc4c-a65d5f327faa', 'confidence': 0.25, 'file': 'das.dll', 'cve': 'CVE-2025-50174'}
--------------------------------------------------------------------
CVE-2025-50174 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Device Association Broker Service (das.dll)
Affected routines:
  * _PnpValidatePropertyData
  * wil_details_FeatureReporting_RecordUsageInCache
  * Several WIL feature-helper wrappers that interact with the
    above two functions.

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use-After-Free (local Elevation of Privilege)

Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  _PnpValidatePropertyData parses caller-supplied buffers that
    describe Plug-and-Play property values.  When the property type
    indicates a multi-string Security Descriptor (type codes 18/20 with
    flag 0x2000), the old code enters a while-loop that walks every
    element in the MULTI_SZ.

2.  For each element the function calls
       ConvertStringSecurityDescriptorToSecurityDescriptorW()
    which allocates a binary security descriptor that is immediately
    freed with LocalFree().  The pointer (SecurityDescriptor) is *not*
    cleared and the surrounding loop continues to run.

3.  Because LocalFree releases the heap block, that memory can be
    claimed by unrelated allocations between loop iterations.  The next
    iteration re-uses the stale pointer either to perform another
    LocalFree() or to read the length via RtlLengthSecurityDescriptor()
    (depending on the property subtype).  This constitutes a classical
    use-after-free that allows an attacker to redirect the freed block
    to attacker-controlled data and gain arbitrary read/write or
    double-free primitives inside the DAS service process (SYSTEM).

4.  Parallel helper code in
       wil_details_FeatureReporting_RecordUsageInCache()
    stored bookkeeping information in a caller-supplied stack buffer and
    re-used the same buffer after the function had returned, providing a
    second (non-exploitable) UAF surface that has now been fixed as
    well.

5.  Patch highlights:
    • The validator signature is changed to take the caller buffer as
      an opaque 64-bit value and copied to a local variable (`v5`) once.
      No pointer from freed memory is reused.
    • Additional boundary checks were inserted before every dereference
      (e.g. `v14 + 2 <= v4`).
    • A feature-gate helper determines whether the old multi-scan logic
      is executed.  When the gate is on, the loop now terminates as soon
      as the buffer tail is reached, preventing further freed-pointer
      access.
    • RecordUsageInCache received a new parameter and now stores
      ownership flags instead of raw stack addresses, eliminating the
      second UAF pattern.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
while (*StringSecurityDescriptor) {
    ...
    ConvertStringSecurityDescriptorToSecurityDescriptorW(...,&SecurityDescriptor);
    LocalFree(SecurityDescriptor);          // frees block
    ...    // loop continues, SecurityDescriptor still in scope
}

// after (simplified)
while (v14 + 2 <= v4) {
    if (!*(_WORD *)v5) break;              // fast exit if already at NUL
    ...
    if (v6 == 20) {
        if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(...))
            return STATUS_INVALID_PARAMETER;
        LocalFree(SecurityDescriptor);
    }
    v5 = (__int64 *)((char *)v5 + stride); // pointer recalculated each time
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Low-privilege client issues a PnP RegisterProperty request to the
   Device Association Broker service.
2. DAS passes user buffer to _PnpValidatePropertyData.
3. Old code loops over MULTI_SZ, allocates + frees a descriptor and then
   uses the stale pointer on the next iteration.
4. Heap metadata or attacker data is interpreted as a security
   descriptor, leading to memory corruption in the SYSTEM process.

Attack Vector
--------------------------------------------------------------------
Local attacker running with ordinary user rights crafts a device
property containing a malicious MULTI_SZ SDDL blob and sends it to the
Device Association Broker service via its public RPC interface.  By
spraying the heap between substrings the attacker can hijack the freed
chunk and execute arbitrary code in the service context (NT AUTHORITY\
SYSTEM).

Patch Description
--------------------------------------------------------------------
• Re-architected _PnpValidatePropertyData to use defensive copying,
  early length validation, and feature-gated parsing paths.
• Added an explicit `context` parameter to
  wil_details_FeatureReporting_RecordUsageInCache and propagate the new
  prototype to all call sites, so stack-based structures are no longer
  referenced after scope exit.
• Minor clean-up of related WIL feature-state helpers to remove
  redundant branches and always set a valid bit mask before returning.

Security Impact
--------------------------------------------------------------------
Before the patch a local user could reliably trigger a use-after-free in
DAS and run arbitrary code as SYSTEM, resulting in full local privilege
escalation.  The bug is remotely irrelevant but critical for local
attacks.

Fix Effectiveness
--------------------------------------------------------------------
Input length is now verified prior to any dereference, the freed pointer
is no longer accessed after LocalFree, and helper caching no longer
stores stack addresses.  The vulnerable code path is therefore
eliminated; exploitation of the original UAF is no longer feasible.
