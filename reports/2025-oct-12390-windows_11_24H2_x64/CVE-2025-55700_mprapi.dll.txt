{'date': 1763406222.9240863, 'patch_store_uid': '0f04ab1f-4275-427d-930e-a881574551fc', 'change_count': 37, 'confidence': 0.34, 'kb': 'KB5066835', 'cve': 'CVE-2025-55700', 'file': 'mprapi.dll'}
--------------------------------------------------------------------
CVE-2025-55700 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Routing and Remote Access Service (RRAS) – mprapi.dll, routines
handling RTR_INFO_BLOCK / RAS connection & port thunking (e.g.
MprInfoBlockAdd / Set / Remove, MprThunk*32to64*, ConnectionEnum, etc.).

Vulnerability Class
--------------------------------------------------------------------
CWE-125: Out-of-Bounds Read facilitated by 32-bit integer overflow /
insufficient size validation of user-supplied buffers.

Detailed Root Cause Analysis
--------------------------------------------------------------------
1. RRAS RPC entry points (e.g. MprAdminConnectionEnum,
   MprAdminInterfaceDeviceGetInfo, ConnectionGetInfo) receive network
   data that ultimately arrives as an RTR_INFO_BLOCK header or as a
   32-bit structure array.
2. Prior to the patch, helper routines such as
      • MprInfoBlockAdd / MprInfoBlockSet / MprInfoBlockRemove
      • MprThunkInterface_*32to64_* 0/1/2/3
      • MprThunkPort_*32to64_* 0/1/2
   accepted caller-supplied length fields (dwItemSize, dwItemCount, etc.)
   without verifying that
        (a)   size*count fits into 32 bits
        (b)   the computed end offset is within the enclosing header
              (lpHeader->Size)
3. The code performed arithmetic such as
        newSize = itemCount * itemSize + headerSize + 23;
   while the intermediate values were held in 32-bit registers.  When
   itemCount×itemSize overflowed UINT32, the subsequent memcpy copied
   past the caller-allocated source buffer, causing an out-of-bounds
   read of process memory that is later returned to the remote caller.
4. No structural sanity check on the existing RTR_INFO_BLOCK header was
   performed.  A malformed header with a small rbSize together with a
   large internal offset (OffsetToFirstItem) therefore redirected the
   memcpy source pointer outside the received blob.
5. The patch introduces the new helper ValidateRTRInfoBlockHeader and
   injects it at every entry where an external header is consumed.  The
   patch also changes many arithmetic sequences to 64-bit, adds explicit
   overflow checks (e.g. if (val > 0xFFFFFFFF) return ERROR_NOT_ENOUGH_…)
   and early-outs on mis-matched sizes.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Before – MprInfoBlockAdd (excerpt)
if ((unsigned __int64)(v6 * v7) > 0xFFFFFFFF)
    return 534;                // only after multiplication overflow!!!
memcpy_0(i, lpItemData, v9);
```
```c
// After – first lines
if (!ValidateRTRInfoBlockHeader(lpHeader))
    return ERROR_INVALID_PARAMETER;
...
if ((unsigned __int64)(v6 * v8) > 0xFFFFFFFF)
    return ERROR_NOT_ENOUGH_MEMORY;
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker sends crafted RPC to RRAS endpoint (e.g.
   \PIPE\ROUTER, opnum ConnectionEnum / GetInfo).
2. rpcss → mprapi!ConnectionEnum → internal
   MprThunkConnection_WtoH → *32to64* helpers →
   MprInfoBlockAdd / Set.
3. Malformed size fields cause integer overflow; memcpy reads past end
   of attacker-controlled blob; leaked pile of heap memory returned in
   RPC response.

Attack Vector
--------------------------------------------------------------------
Remote, unauthenticated SMB/RPC access to RRAS named-pipe interfaces; no
local privileges required.  An attacker controlling network traffic to
an RRAS-enabled server can repeatedly request information with malformed
length values and harvest disclosed heap data.

Patch Description
--------------------------------------------------------------------
1. Introduces ValidateRTRInfoBlockHeader() and invokes it in every
   *InfoBlock* routine.
2. Rewrites all size arithmetic to 64-bit, adds explicit checks against
   0xFFFFFFFF and against prior operand before every add / mul.
3. Rejects headers whose computed total length is < minimal structure
   size, or where any internal offset falls outside header size.
4. Refactors thunk helpers to pass explicit buffer length (new
   parameter), validates that caller-provided source length is
   consistent and below protocol maximum before LocalAlloc/memcpy.
5. Propagates new prototypes throughout higher-level RPC stubs to pass
   safe size values, eliminating previous casts that lost precision.

Security Impact
--------------------------------------------------------------------
Prior to the patch an attacker could read arbitrary bytes past the end
of the supplied buffer and receive the data in the RPC reply, leading to
information disclosure from the RRAS service process (SYSTEM).  Although
no code execution is possible directly, leaked heap data can contain
pointers, credentials or ASLR seeds that significantly aid further
exploitation.

Fix Effectiveness
--------------------------------------------------------------------
• All arithmetic is now done in 64-bit and is guarded by overflow
  checks; attempts to exceed UINT32 force ERROR_NOT_ENOUGH_MEMORY (534).
• ValidateRTRInfoBlockHeader guarantees internal offsets never extend
  beyond total header length.
• Every thunk / enum routine now verifies caller-supplied lengths before
  calling LocalAlloc / memcpy.
Given the comprehensive nature of the added checks, the original OOB
read condition can no longer be triggered with attacker-controlled data.

--------------------------------------------------------------------