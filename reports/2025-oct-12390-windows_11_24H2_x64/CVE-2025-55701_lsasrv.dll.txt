{'confidence': 0.14, 'patch_store_uid': 'b152918f-5cdf-4476-a46d-deb61ecd20b3', 'change_count': 30, 'file': 'lsasrv.dll', 'cve': 'CVE-2025-55701', 'kb': 'KB5066835', 'date': 1763407794.4692252}
--------------------------------------------------------------------
CVE-2025-55701 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows LSASS service – lsasrv.dll (Lsar* / Lsap* RPC
interfaces and helper routines)

Vulnerability Class
--------------------------------------------------------------------
Improper input validation / handle-spoofing leading to local
privilege-escalation (CWE-1287 – Improper Validation of Specified Type
of Input)

Detailed Root Cause Analysis
--------------------------------------------------------------------
Many LSASS RPC entry points accepted a caller-supplied LSAPR_HANDLE
(pointer-sized value that should reference an internal LSAP_DB_HANDLE
object) and immediately performed privileged operations on the object
without first verifying that the supplied value actually represented a
valid, in-state LSASS database handle owned by the caller.

Examples before the patch:
• LsarDeleteObject(void **Handle) simply executed
    return LsapDeleteObject(Handle, 1);
• LsarClose(_QWORD *Handle) dereferenced the pointer chain and updated
  reference counts without any sanity-check.
• LsarSetSecurityObject, LsarQuerySecurityObject and several helper
  paths such as LsapBuildAndCreateToken and LsapDoPrivilegeUpdateOn
  Account all trusted the incoming handle.

Because LSASS runs as SYSTEM and the code executed inside the security
context of the process, a low-privileged but authenticated attacker
could craft or recycle an invalid / stale handle value and send it via
LSARPC.  When LSASS dereferenced the fake pointer the code manipulated
arbitrary kernel-managed LSASS structures, enabling:
• deletion of arbitrary LSA objects (secrets, privileges, accounts),
• assignment of SYSTEM security descriptors to attacker-controlled
  objects,
• modification of account privileges or system-access flags,
• reference-count corruption and use-after-free of LSASS objects.

Ultimately these manipulations allow the attacker to obtain or inject a
SYSTEM token, resulting in a complete local privilege escalation.

Affected structures / parameters
• LSAP_DB_HANDLE (referenced by first argument of Lsar* APIs)
• LSAPR_HANDLE values transmitted over MS-LSARPC (opnums involving
  DeleteObject, Close, SetSecurityObject, QuerySecurityObject, etc.)
• Internal reference counts and SystemAccess bits changed via
  LsarGet/SetSystemAccessAccount.

Vulnerability Code Snippets
--------------------------------------------------------------------
Before patch:
```c
__int64 __fastcall LsarDeleteObject(void **a1)
{
    return LsapDeleteObject(a1, 1);   // no validation
}

__int64 __fastcall LsarClose(_QWORD *a1)
{
    ...
    v3 = v2[22];                      // blind dereference
    ...                               // privileged work
}
```
After patch:
```c
if (!wil::details::FeatureImpl<...>::__private_IsEnabled(...))
    return LsapDeleteObject(a1, 1);
result = LsapDbVerifyHandle(*a1, 0, 0, 0); // new sanity check
if ((int)result >= 0)
    return LsapDeleteObject(a1, 1);
return result;                            // STATUS_INVALID_HANDLE
```
Similar `LsapDbVerifyHandle()` calls were added to LsarClose,
LsarSetSecurityObject, LsarQuerySecurityObject and others.  All legacy
call sites were switched from old helpers (LsapCloseHandle,
LsapDeleteObject) to new safe wrappers (LsarClose, LsarDeleteObject).

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker opens an LSARPC connection (\pipe\lsass) using any normal
   account.
2. Attacker forges or re-uses a stale LSAPR_HANDLE value and invokes an
   RPC method such as LsarDeleteObject, LsarSetSecurityObject or
   LsarClose, passing the crafted handle.
3. Pre-patch LSASS dereferences the bogus pointer, manipulating
   arbitrary internal objects (privileges, secrets, reference counts).
4. Crafted state yields SYSTEM privileges (e.g., enable SeDebug, write
   arbitrary secret, or corrupt token structures).

Attack Vector
--------------------------------------------------------------------
Local authenticated user via the LSARPC interface (NT AUTHORITY
Authenticated Users) – no administrative rights required; only the
ability to issue LSA RPC calls.

Patch Description
--------------------------------------------------------------------
1. Introduced central validation routine `LsapDbVerifyHandle()` to
   ensure a handle:
   • points to readable memory,
   • is of the correct object type,
   • has not been closed or revoked.
2. Added new public wrappers (`LsarDeleteObject`, `LsarClose`, etc.)
   that call the verifier before touching the object.
3. Re-wired all call sites to use the new wrappers and replaced direct
   calls to `LsapCloseHandle` / `LsapDeleteObject`.
4. Inserted inline verification inside high-risk paths (e.g.
   LsarSetSecurityObject, LsarQuerySecurityObject) when a feature flag
   is enabled.
5. Updated global flag (`byte_180197744`, formerly 0x70C) and WIL
   feature gates to allow controlled rollout.

Security Impact
--------------------------------------------------------------------
Before the fix a normal domain or local user could elevate to SYSTEM by
supplying a forged LSASS database handle and triggering privileged
operations, bypassing object access checks and corrupting LSASS memory.
Successful exploitation grants full control of the machine and its
secrets.

Fix Effectiveness
--------------------------------------------------------------------
All vulnerable entry points now fail early with STATUS_INVALID_HANDLE
if the supplied handle is not recognised, preventing misuse.  The
validation is centralised and invoked on every sensitive path, closing
the privilege-escalation gap without functional regression for valid
clients.
