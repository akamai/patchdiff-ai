{'change_count': 385, 'file': 'sppsvc.exe', 'confidence': 0.22, 'patch_store_uid': 'e036112f-b556-4011-858d-784aad5eed8e', 'cve': 'CVE-2025-59199', 'kb': 'KB5066835', 'date': 1763407734.2222672}
--------------------------------------------------------------------
CVE-2025-59199 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Software Protection Platform Service (sppsvc.exe)


Vulnerability Class
--------------------------------------------------------------------
Improper Access Control leading to arbitrary 32-bit memory write and
local elevation of privilege (CWE-284 / CWE-123).


Detailed Root Cause Analysis
--------------------------------------------------------------------
Prior to the patch, routines  sub_140103484() and sub_140102274()
accepted raw caller-supplied pointers and modified the memory they
referenced without any provenance or access checks:

1. sub_140103484( … , _QWORD *a2 , … )
   *a2 is blindly overwritten with several flag words that are
   calculated from licence state bits.

2. sub_140102274( volatile signed __int32 *a1 , _QWORD *a2 )
   a1 is treated as the authoritative licence flag word and is updated
   in a lock-free loop using _InterlockedCompareExchange().  Because a1
   is furnished by the caller, the service ends up performing an
   atomic read-modify-write to an arbitrary address in its own address
   space.

The service runs under NT AUTHORITY\SYSTEM.  Any client that can reach
these helpers (through the RPC/COM surface of sppsvc) can therefore
cause the service to write an attacker-controlled 32-bit value to an
arbitrary location inside the privileged process, bypassing the
intended isolation between the caller and internal licence state.

Neither routine validates that the supplied address lies inside the
expected SPP data structure nor that the caller possesses the SeDebug
privilege.  As a consequence an unprivileged user can overwrite
critical data such as vtable entries, function pointers, or security
tokens, ultimately achieving code execution in the SYSTEM context.

Patch 1 (sub_140103484 → sub_140061C60):
• The entire flag-building implementation was deleted.  The new
  function only resolves a per-object vtable pointer from *(a1+0x10)
  and delegates the operation via vtable[10].  The dangerous _QWORD *a2
  parameter is no longer supplied by the caller; instead the target
  buffer address originates from inside the object itself.

Patch 2 (sub_140102274 → sub_140061C10):
• Similar surgical removal: the complex interlocked update loop was
  discarded.  The new wrapper again fetches an internal object pointer
  and calls vtable[4], passing a *value* (unsigned int a2) rather than
  a writable pointer.

Because the caller can no longer provide arbitrary addresses, the write
primitive and the associated privilege-escalation path are eliminated.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – arbitrary pointer used for write
_QWORD *__fastcall sub_140102274(volatile signed __int32 *a1, _QWORD *a2)
{
    *a2 = 0;                 // unchecked write
    _InterlockedCompareExchange(a1, newFlags, oldFlags); // unchecked
}

// after patch – pointer now internal, caller can only pass a value
__int64 __fastcall sub_140061C10(__int64 a1, unsigned int a2)
{
    v2 = *(QWORD *)(a1 + 0x10);
    v4 = *(QWORD *)(*(_QWORD *)v2 + 0x20);
    return v4(v2, a2);       // no external pointer
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
Client RPC/COM call
  → SPP service dispatcher
    → sub_140103484() / sub_140102274()
      → unchecked arbitrary address write
        → corruption of privileged memory
          → attacker-controlled code path / SYSTEM EoP.


Attack Vector
--------------------------------------------------------------------
A local, authenticated user sends a crafted request to the Software
Protection Platform RPC interface, supplying a pointer to a controlled
address in the sppsvc.exe process.  The service, running as SYSTEM,
performs the unchecked write, enabling the attacker to redirect
execution or modify security-sensitive data structures.


Patch Description
--------------------------------------------------------------------
The fix removes the shared global helper logic and replaces it with
thin wrappers that:
1. Retrieve an internal object from *(a1+0x10).
2. Indirect through the object’s read-only vtable.
3. Pass only safe value parameters, never caller-supplied writable
   addresses.

This architectural change prevents external callers from influencing
where the service writes, thereby restoring proper access control.


Security Impact
--------------------------------------------------------------------
Before the update, any local user could gain SYSTEM privileges by
leveraging the arbitrary 4-byte overwrite to hijack execution flow or
alter security sensitive fields.  Post-exploitation impact is full
privileged code execution (EoP).


Fix Effectiveness
--------------------------------------------------------------------
The vulnerable code paths are completely excised; the new entry points
no longer expose writable pointers and all memory updates are confined
inside private objects.  Provided no other interface still exposes the
old helpers, the patch fully mitigates the described write primitive.
--------------------------------------------------------------------