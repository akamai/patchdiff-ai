{'confidence': 0.2, 'file': 'dwm.exe', 'change_count': 10, 'patch_store_uid': '91050652-618e-4355-8ff5-2ed2c31bf876', 'cve': 'CVE-2025-55681', 'kb': 'KB5066835', 'date': 1763407743.6189697}
--------------------------------------------------------------------
CVE-2025-55681 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Desktop Window Manager (dwm.exe) – ALPC client helper class
CPortClient together with CDwmAppHost callers


Vulnerability Class
--------------------------------------------------------------------
CWE-125  Out-of-Bounds Read
(Coupled side effect: untrusted pointer dereference during HeapFree)


Detailed Root Cause Analysis
--------------------------------------------------------------------
Several helper routines in dwm.exe build ALPC request buffers by hand
and then pass them to NtAlpcSendWaitReceivePort.  A _PORT_MESSAGE is
allocated with HeapAlloc( … , 0x38 ), i.e. 56 bytes, but the fields
that represent DataLength / TotalLength are populated with 32-bit
command IDs instead of real sizes:
    v11[1].u1.Length = 0x4000002F  (1073741871)
    v11->u1.Length   = 0x00380020  (3670032)
The values are orders of magnitude larger than the allocation.  When
ALPC validation in the kernel trusts those 16-bit length fields it
copies ‘TotalLength’ bytes from the user buffer, causing the kernel to
read far beyond the 56-byte allocation and into adjacent user-mode
pages.  Because DWM runs with elevated rights inside the session, a
local attacker who can make DWM issue one of the affected calls can
obtain privileged memory contents and pivot to a full elevation.

Affected paths before the patch
• CDwmAppHost::LpcNotifySettingsChange
• CDwmAppHost::LpcSyncFlush
• CDwmAppHost::StartKernelRedirection
• CPortClient::SendComplexSyncRequest
All of them construct the malformed header in the same way.

A secondary flaw aggravated the issue: the CPortClient constructor
stored the heap handle into the object ( this+0x30 ) and the
destructor later performed HeapFree( this[6], … ).  Memory corruption
could therefore turn into an arbitrary free if an attacker was able to
modify that member.

Patch changes
1. Constructor now zeroes the heap-handle slot; destructor always calls
   GetProcessHeap() directly and double-checks a feature flag before
   freeing.
2. All manual _PORT_MESSAGE construction code is replaced by
   CPortClient::Send* helpers that internally calculate correct length
   fields.
3. SendComplexSyncRequest now allocates with GetProcessHeap() and fills
   header fields with sane 16-bit lengths before the call.
4. Message-type masking in the LPC command handler was corrected to
   use only the low-byte ( & 0x00FF ) so unexpected high bits can no
   longer reach dangerous code paths.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
v4 = HeapAlloc(hHeap, 8u, 0x38);
v4[1].u1.Length = 1073741871;   // bogus DataLength
v4->u1.Length   = 3670032;      // bogus TotalLength
NtAlpcSendWaitReceivePort(hPort, 0x10000, v4, ...);

// after
char PortBuf[0x38];
CPortClient::SendComplexAsyncRequest(&Port, 0x4000002F, args, flags);
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker invokes an exported/com interface that eventually calls
   CDwmAppHost::LpcNotifySettingsChange / LpcSyncFlush /
   StartKernelRedirection.
2. Function allocates 56-byte _PORT_MESSAGE.
3. Control-code constant is written into Length fields.
4. NtAlpcSendWaitReceivePort executes; kernel trusts Length fields and
   performs memcpy >56 bytes -> OOB read in kernel context.
5. Leaked kernel data can be re-used for privilege-escalation
   primitives.


Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker sends specially crafted window / COM /
RPC traffic that causes DWM to run the affected LPC helper functions.
No admin rights are needed; exploitation happens within the user
session.


Patch Description
--------------------------------------------------------------------
• Replaced all hand-rolled ALPC buffer construction with
  CPortClient::SendSimple*/SendComplex* helpers that compute correct
  DataLength / TotalLength values.
• Stopped persisting the process-heap handle inside the object; frees
  always use GetProcessHeap(), eliminating the arbitrary-free helper.
• Added optional Wil feature gate and ALPC port-section cleanup in
  Disconnect().
• Tightened command-type masking in s_LpcCommandHandler.


Security Impact
--------------------------------------------------------------------
Before the fix DWM could trick the kernel ALPC layer into reading an
attacker-controlled buffer past its bounds, leaking privileged memory
and providing a reliable local elevation-of-privilege primitive.  The
heap-handle issue also opened a path to arbitrary free/DoS.


Fix Effectiveness
--------------------------------------------------------------------
The new helpers guarantee that _PORT_MESSAGE length fields match the
real allocation size, eliminating the OOB read avenue.  Use of
GetProcessHeap() removes the untrusted pointer dereference.  No new
observable pathways write over-large lengths, so the patch fully
addresses the documented root cause.
