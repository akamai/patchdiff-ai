{'patch_store_uid': '19cf186f-c366-45f0-99fc-3c9896dd206c', 'cve': 'CVE-2025-59209', 'date': 1763406138.266055, 'change_count': 203, 'file': 'wpncore.dll', 'kb': 'KB5066835', 'confidence': 0.12}
--------------------------------------------------------------------
CVE-2025-59209 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Push Notification Core (wpncore.dll), specifically the method
Notification::RuntimeClassInitialize together with the local helper
implementations memcpy_s / memcpy_s_1 / memcpy_s_2 (now replaced by
winrt::hstring::hstring).

Vulnerability Class
--------------------------------------------------------------------
Information disclosure caused by integer-overflow–driven heap buffer
mis-management that allows copying and later returning heap bytes that
were not meant to be exposed (CWE-200 – Exposure of Sensitive
Information to an Unauthorized Actor).

Detailed Root Cause Analysis
--------------------------------------------------------------------
Before the patch RuntimeClassInitialize copied several caller-supplied
UTF-16 strings (Id, Tag, Group, LaunchArgs) into internal
NativeString-backed buffers.  For the long strings the routine tried to
re-allocate the backing buffer with a custom growth algorithm:

1. The desired new capacity was calculated with the expression
     newCap = (oldCap >> 1) + oldCap ;
   and then compared against (len | 7).
2. If either operand exceeded 0x7FFFFFFFFFFFFFFE the code forced the
   requested size to the sentinel value –2 (0xFFFFFFFFFFFFFFFE) and
   called std::_Allocate_manually_vector_aligned(newSize).
3. Because newSize is interpreted unsigned, operator new receives a
   value close to SIZE_MAX and either returns a much smaller buffer
   after internal rounding or fails silently.
4. Regardless of the real allocation result the function proceeds to
   copy     2 * inputLen bytes with memcpy_0 / memmove_0.

When the integer–overflow branch is taken the copy overruns the newly
allocated buffer and writes adjacent heap memory.  The over-written data
is then stored inside the Notification object and can later be obtained
through legitimate WPN database or notification-enumeration APIs,
leaking arbitrary heap content belonging to the elevated notification
host process.

The same flawed size-checking logic existed in three in-module
"safe-copy" helpers (memcpy_s, memcpy_s_1, memcpy_s_2).  The routines
were supposed to zero-out the destination when parameters were invalid,
but several parameter permutations skipped that step and still
performed the copy, making the overrun easier to reach from other call
sites.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – size calculation that can underflow to -2
if ((len | 7) > 0x7FFFFFFFFFFFFFFEi64 ||
    (half = cap >> 1, cap > 0x7FFFFFFFFFFFFFFEi64 - half))
{
    newCap   = 0x7FFFFFFFFFFFFFFEi64;
    allocLen = (unsigned __int64)-2;   // ← passed to allocator
}
...
memcpy_0(buffer, Src, 2 * len);        // ← overflow when allocLen wrong
```
```c
// after patch – one-shot helper that validates everything
v4 = Windows::Internal::NativeString<...>::_Initialize(
         (char*)this + 64,
         *((_QWORD*)a2 + 1),
         -1);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker crafts an Initializer structure with   Tag/Group strings
   whose length triggers the overflow branch (>0x7FFFFFFFFFFFFFFE).
2. Client calls code path that instantiates a Notification object.
3. RuntimeClassInitialize reallocates a tiny buffer but copies
   2 * attackerLen bytes – heap overflow.
4. Attacker later queries the stored Tag/Group via standard push
   notification API and receives heap bytes located after the tiny
   buffer.

Attack Vector
--------------------------------------------------------------------
Local user-mode code running with the same privileges as the Push
Notification consumer passes an oversized UTF-16 string to the WPN
platform (e.g., via CreateToastNotification).  No special privileges are
required beyond the ability to invoke the API.

Patch Description
--------------------------------------------------------------------
1. Entire custom allocation / copy logic removed.
2. All string members are initialised through
   Windows::Internal::NativeString::_Initialize or
   std::wstring::assign, which internally perform strict length checks
   and throw on overflow.
3. Manual AddRef/Release blocks replaced with
   WRL::ComPtr::operator=.
4. The three local memcpy_s* variants have been rewritten to follow the
   C11 Annex K contract – they now refuse to copy on any invalid
   parameter set and always zero the destination when required.

Security Impact
--------------------------------------------------------------------
Before the fix a local attacker could obtain up to several kilobytes of
heap data belonging to the Push Notification Core process, potentially
including other applications' or system secrets processed in the same
address space (e.g., tokens, file paths, or personal data), thereby
bypassing normal data-isolation guarantees.

Fix Effectiveness
--------------------------------------------------------------------
The vulnerable arithmetic and manual copying code paths no longer exist;
all memory management has been delegated to battle-tested STL/WRL and
WinRT helpers.  No integer overflow or unchecked memcpy remains, and the
new memcpy_s variants make it unlikely that similar bugs can be reached
through other call sites.  The patch therefore fully mitigates the
identified information disclosure vector.
