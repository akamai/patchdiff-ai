{'cve': 'CVE-2025-59261', 'change_count': 96, 'file': 'dwmcore.dll', 'patch_store_uid': '9ea31a38-c5d1-473b-b782-3c02fef25a9c', 'kb': 'KB5066835', 'confidence': 0.3, 'date': 1763403391.651491}
--------------------------------------------------------------------
CVE-2025-59261 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Desktop Window Manager (dwmcore.dll) – expression engine that
parses and evaluates UI animation expressions via
CExpression::CalculateValueWorker().


Vulnerability Class
--------------------------------------------------------------------
Time-of-check Time-of-use (TOCTOU) race condition (CWE-367) that leads
to unsynchronised shared-state corruption and ultimately privilege
escalation in the graphics subsystem.


Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  Each DWM thread owns an instance of CExpressionValueStack, used to
    push / pop intermediate values while an XAML / Composition
    expression is evaluated.

2.  When CalculateValueWorker() needs to fetch a stack element outside
    the valid range it returns the address of a **process-wide static
    object**

        CExpressionValueStack::s_emptyValue

    instead of failing.  This pointer is acquired in the original code
    (before patch) at several call sites, for example in the modulo
    (opcode 0x11) and logical-AND (opcode 0x3C) handlers:

        if (index >= StackTop) {
            v79 = &CExpressionValueStack::s_emptyValue; // shared
        }

3.  A few instructions later the same handler **blindly writes** the
    computation result back through that pointer:

        *((DWORD*)v79 + 18) = 18;          // overwrite type tag
        *(float*)v79          = NewValue;  // overwrite data

    Because s_emptyValue is shared by **all** expression evaluations
    running in the process, multiple threads can concurrently read and
    then overwrite the placeholder without any locking.  A classic
    TOCTOU window therefore exists between the range check (TOC) and
    the subsequent write (TOU).

4.  By arranging for two threads with different security contexts to
    enter the same handler simultaneously an attacker can corrupt the
    placeholder while it is being used by a higher-privileged thread,
    causing the latter to operate on attacker-controlled data.  The
    corrupted value is later stored in privileged DWM state objects,
    allowing an elevation of privilege.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – modulo (opcode 0x11) excerpt
if ((unsigned)v75 >= StackCount)
    v79 = &CExpressionValueStack::s_emptyValue; // shared
...
*((DWORD*)v79 + 18) = 18;   // un-protected write
*(float*)v79 = fmodf(a, b); // overwrites global object
```
```c
// after patch – same logic is rewritten
if (idx >= StackCount)
    v5 = &CExpressionValueStack::s_emptyValue; // kept in rbx
...
// but the result is now written to a **new stack slot**
// (rbx is never modified when it equals the static object)
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Low-privilege thread supplies a malformed expression that forces an
   out-of-range stack read.
2. CalculateValueWorker() maps the read to s_emptyValue and marks it
   for writing.
3. Before the write, a second (high-privilege) DWM thread also enters
   the same path and reads the shared placeholder.
4. Low-privilege thread completes first and overwrites the placeholder
   with attacker-controlled data.
5. High-privilege thread resumes, trusts the corrupted placeholder and
   commits the value into its privileged composition state.


Attack Vector
--------------------------------------------------------------------
Any local user that can feed custom expression strings to DWM (e.g.
through XAML Island / WinRT animation APIs) can schedule parallel
evaluations and exploit the race to obtain SYSTEM-level code execution
inside dwm.exe.


Patch Description
--------------------------------------------------------------------
Microsoft completely rewrote the prologue and all opcode handlers:

• Introduced a per-call temporary (rbx) that holds the address of the
  candidate value; before writing the code now *verifies* that the
  pointer is **not** the global s_emptyValue.
• Several handlers that formerly wrote directly through the pointer now
  copy the data into a fresh stack slot and leave s_emptyValue intact.
• Added extra local copies of stack counters (v557/v558) and performs
  range checks immediately before every use, closing the TOCTOU window.
• No functional logic was changed; only memory-safety and
  synchronisation were added.


Security Impact
--------------------------------------------------------------------
Prior to the patch any authenticated user could win the race and
corrupt the global placeholder, leading to arbitrary write in another
thread’s context and privilege escalation to the DWM service account
(LocalSystem).  The issue is rated as Elevation of Privilege.


Fix Effectiveness
--------------------------------------------------------------------
The patched binary no longer writes through the shared static object;
all modifications are applied to thread-local stack storage after a
fresh bounds check.  Because the placeholder is now effectively
read-only the TOCTOU window is removed.  No alternative write paths to
s_emptyValue were observed, so the fix is considered effective.

