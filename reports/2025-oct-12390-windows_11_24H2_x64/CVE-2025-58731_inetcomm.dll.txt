{'kb': 'KB5066835', 'patch_store_uid': '8699c3cd-7b74-419f-a1f1-7c37e23b0056', 'change_count': 5, 'date': 1763407649.3021667, 'file': 'inetcomm.dll', 'confidence': 0.2, 'cve': 'CVE-2025-58731'}
--------------------------------------------------------------------
Unknown-CVE Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
inetcomm.dll  (Windows Inbox COM Objects – Feature Management helper
routines located inside wil::details namespace)

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use-After-Free / Memory corruption caused by writing past the
end of a live object (improper pointer size handling and signature
mismatch).

Detailed Root Cause Analysis
--------------------------------------------------------------------
All affected helpers implement
  wil::details::FeatureImpl<...>::GetCurrentFeatureEnabledState()
  wil::details::FeatureImpl<...>::ReportUsage()

The public prototype that the rest of the product calls is
  GetCurrentFeatureEnabledState(int *pState);
so callers only provide a pointer to a 32-bit buffer.  Inside the
pre-patch implementation the second parameter is treated as
    _QWORD *a2
and the very first operation is
    *a2 = 0i64;          // zero 8 bytes
which blindly stores eight bytes into the caller supplied 4-byte
buffer, corrupting the adjacent stack / heap memory belonging to the
caller.

When the corrupted area contains a C++ object that is later destroyed,
its controlling fields (vtable, ref-count etc.) have already been
clobbered.  The subsequent delete therefore frees a still referenced
object and a classic use-after-free window appears.  Attackers that can
invoke the COM objects (eg. a sandboxed script or a crafted e-mail
message processed by the Inbox) can reliably control the overwritten
area and finally redirect execution.

A second contributing bug is the mismatch between the on-disk
ReportUsage() prototype (expected bool as 2nd parameter) and the way it
was called from GetCurrentFeatureEnabledState.  The extra stack
argument was interpreted as a boolean flag living inside the now
corrupted memory region, extending the corruption into a controlled
use.

Structures / fields affected
  • 32-bit FEATURE_ENABLED_STATE output buffer provided by caller
  • Adjacent 4-byte slot – typically the object instance pointer or a
    vtable pointer on the stack.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// old – TestLabVal::GetCurrentFeatureEnabledState
* a2 = 0i64;                     // 8-byte write into 4-byte buffer
*(_DWORD *)a2 = v7;              // later partially rewritten
```
```c
// old – ReportUsage signature mismatch
__int64 ReportUsage(_DWORD *a1, unsigned __int8 a2, ...);
// called with 64-bit 2nd argument → stack mis-alignment
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Client code allocates a 4-byte variable on stack and calls
   FeatureImpl::GetCurrentFeatureEnabledState(&state);
2. The function executes '*a2 = 0i64;', overwriting the next 4 bytes on
   the caller’s stack frame.
3. Normal execution continues; later the corrupted object is destroyed
   (Release / delete) while still referenced elsewhere → freed but
   alive.
4. Subsequent dereference of the dangling pointer lets the attacker
   execute controlled data as code.

Attack Vector
--------------------------------------------------------------------
Any process that can obtain an interface pointer to the affected Inbox
COM objects and call GetCurrentFeatureEnabledState – for example code
executed by the mail reader while processing a crafted message – can
supply attacker-controlled stack/heap layouts and gain code execution.
No special privileges are required.

Patch Description
--------------------------------------------------------------------
The patch makes the following corrective changes:
1. Changes local variables so the 2nd parameter is treated as a 32-bit
   buffer (v7/v8) and removes the 8-byte store; only 4-byte accesses
   are now performed ( *(_DWORD *)a2 = ... ).
2. Always ORs in the valid-bit ( ... | 1 ) instead of writing the full
   64-bit slot.
3. Fixes ReportUsage prototype – the 2nd parameter is now an __int64
   (ReportingKind); call-sites were updated accordingly, eliminating the
   stack-layout mismatch.

Security Impact
--------------------------------------------------------------------
Pre-patch builds let untrusted input corrupt adjacent memory, leading to
use-after-free and ultimately arbitrary code execution inside the
calling process.  Because the functions reside in a COM component that
is available to low-privilege code, the flaw provides a local privilege
escalation / sandbox escape and, in the e-mail scenario, remote code
execution in the Outlook (or any InetComm-based) process.

Fix Effectiveness
--------------------------------------------------------------------
The updated code confines all writes to the intended 4-byte buffer and
realigns function signatures, removing the memory clobbering that led
to dangling pointers.  No additional unsafe writes are observable in
the patched diff, so the immediate overwrite/UAF vector is closed.  A
full regression of every FeatureImpl instantiation is still advisable
but the specific root cause is addressed.
