{'change_count': 13, 'patch_store_uid': 'd1e9d746-720d-4647-8cb2-ec67327d5cc6', 'confidence': 0.21, 'cve': 'CVE-2025-58732', 'file': 'combase.dll', 'date': 1763407725.8968651, 'kb': 'KB5066835'}
--------------------------------------------------------------------
CVE-2025-58732 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows COM runtime (combase.dll) – class-cache logic in
CClassCache::CClassEntry::{Create,Complete} that manages the global
hash table of CLSID metadata.

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use After Free (dangling pointer dereferenced after the
instance has been destroyed).

Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  Every COM CLSID that is activated is tracked by a CClassEntry
    object and stored in the global hash _ClassEntries.
2.  CClassCache::CClassEntry::Create() first builds a temporary
    CClassEntry via CreateIncomplete(), then finalises it by calling
    Complete().
3.  Complete() may discover that another thread has already
    materialised an identical entry.  In that situation it sets
    *pfLockReleased, releases the cache writer-lock, and returns the
    pointer of the pre-existing entry (v13 in the old listing).
4.  The caller (Create()) frees its own temporary object when the
    duplicate (v13) is found, but then continues to use a local copy
    of the *original* pointer (v14) to:
       • read _dwFlags,
       • build an SMultiGUIDKey structure,
       • possibly insert the entry into the hash table.
    Because the destructor has already executed, v14 now points to
    freed memory – a classic UAF.
5.  An attacker who can force the duplicate-found path (by racing two
    activations of the same CLSID) gains the ability to cause the
    class-cache code to operate on reclaimed memory.  Carefully
    shaping heap contents allows corruption of control data and
    eventually arbitrary code execution in the COM broker process.
6.  A similar dereference of a freed entry existed in the Treat-As
    handling path of CClassEntry::Complete().  Recursive calls could
    free the current object while outer frames continued to use it.

Key internal fields / parameters involved
  _dwFlags            – flag bit 0x10 (SxS hash) and 0x20 (overflow)
  _hashNode           – embedded list links written after free
  pfLockReleased      – signals that the writer lock was dropped
  pCE / v14           – dangling pointer to the freed CClassEntry

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Before patch – CClassEntry::Create()
if ( fLockReleased ) {
    PartitionIDForClassInfo = GetPartitionIDForClassInfo(pCI);
    v13 = CCEHashTable::LookupCE(v21, dwClsHash, rclsid, PartitionID);
}
v14 = *v9;                    // *v9 was already deleted when v13!=0
if ( !v13 ) {
    dwFlags = v14->_dwFlags;  // UAF: object already freed
    ...
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Client (or attacker) activates the same CLSID concurrently on two
   threads / processes.
2. Thread-A: enters Create(), builds entry-A, drops writer lock in
   Complete(), then continues.
3. Thread-B: finishes first, inserts entry-B into hash table.
4. Thread-A: LookupCE() returns non-NULL -> frees entry-A, but still
   dereferences v14 (entry-A) afterwards.
5. Freed memory gets overwritten by attacker-controlled allocations
   -> arbitrary write/execute when cache later processes corrupted
   structures.

Attack Vector
--------------------------------------------------------------------
Local, non-admin attacker executing code that repeatedly and
concurrently CoCreateInstance()’s a vulnerable in-box COM class.
No additional privileges are required; exploitation occurs inside the
combase broker which runs with high integrity.

Patch Description
--------------------------------------------------------------------
1.  Early return if pCI is NULL – eliminates a degenerate path.
2.  Re-organised logic so that the temporary CClassEntry is *never*
    touched after it might have been deleted:
      • destructor is called first
      • subsequent operations use the duplicate pointer (v14) or build
        a new hash entry only when duplicate == NULL.
3.  Added wil feature gating and telemetry asserts to catch unexpected
    lock-drop scenarios.
4.  Introduced helper CompleteTreatAs() which finalises Treat-As
    chains without re-using possibly freed objects.
5.  In Complete(), equality check replaced unsafe pointer arithmetic
    comparison; flow simplified so _dwFlags is cleared only after the
    object is confirmed alive.

Security Impact
--------------------------------------------------------------------
The bug lets unprivileged code trigger a deterministic use-after-free
in the COM runtime.  Because freed memory is immediately reused for
hash-node links, the attacker can gain control of linked-list pointers
and ultimately execute arbitrary code in the context of the COM broker
(process hosting combase.dll), leading to a local elevation of
privilege or code execution with elevated rights.

Fix Effectiveness
--------------------------------------------------------------------
The patched functions no longer dereference the temporary object after
it might have been freed; the destructor is invoked only after all
needed fields have been copied, and alternative paths use the live
entry.  Additional telemetry and feature gates make regressions easy
to detect.  No remaining path that writes to _hashNode or _dwFlags can
execute on a dangling pointer, so the UAF is effectively removed.
