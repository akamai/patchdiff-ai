{'cve': 'CVE-2025-58739', 'kb': 'KB5066835', 'change_count': 296, 'file': 'shell32.dll', 'date': 1763406162.9708438, 'confidence': 0.13, 'patch_store_uid': 'c042dbb5-0201-458e-b362-93dacc33b254'}
--------------------------------------------------------------------
CVE-2025-58739 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Shell component (shell32.dll) – routine
CAppPathReader::_PathToAppPathKeyHandle that translates a file path
into an "App Paths" registry key and opens the key for reading.

Vulnerability Class
--------------------------------------------------------------------
Improper input validation / stack-based buffer overflow (CWE-121).

Detailed Root Cause Analysis
--------------------------------------------------------------------
Prior to the patch the function prototype was

  int _PathToAppPathKeyHandle(CAppPathReader *this,
                              unsigned short *Path,
                              HKEY *OutKey,
                              unsigned int cchBuf)

It allocated a 320-element WCHAR array on the stack (SubKey) and then
called the helper _PathToAppPathKeyBase to build the final registry
subkey.  The helper received the caller-supplied length (cchBuf), but
no subsequent check was performed in _PathToAppPathKeyHandle to verify
that SubKey remained inside its bounds or was NULL-terminated.  After
construction the routine immediately passed SubKey to RegOpenKeyExW.

Because SubKey lives on the stack, any pathname longer than 319
characters (or one that causes _PathToAppPathKeyBase to append “.exe”
without room for it) writes past the end of the local buffer and
trashes adjacent stack variables, including the saved return address.
An attacker who can control the file name processed by
CAppPathReader (e.g. via a crafted shortcut or network share
placement) can therefore corrupt memory inside explorer.exe.

Additional type safety issues existed: the second parameter was typed
as an UTF-16 string but was later cast to an HKEY when calling
RegOpenKeyExW, resulting in type confusion.  This allowed arbitrary
pointer values to be interpreted as registry handles, unintentionally
leaking registry data if the value happened to equal a predefined
handle constant (0x80000000 – 0x80000006).

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Old implementation (simplified)
int __fastcall _PathToAppPathKeyHandle(...,
                                      unsigned __int16 *Path,
                                      HKEY *hKeyOut,
                                      unsigned int cch)
{
    WCHAR SubKey[320];            // fixed-size stack buffer

    // Helper builds "App Paths" subkey; no result length checked
    _PathToAppPathKeyBase(this, Path, SubKey, cch);

    // Path pointer is mis-cast to HKEY
    return RegOpenKeyExW((HKEY)Path, SubKey, 0, 0x20019, hKeyOut);
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User browses to or opens a file whose name length > 319 chars or is
   crafted to defeat internal assumptions.
2. Explorer invokes CAppPathReader to resolve an AppPath entry.
3. _PathToAppPathKeyBase copies the long file name plus “.exe” into the
   320-WCHAR SubKey buffer.
4. SubKey overflows, corrupting stack.
5. The corrupted return address leads to code execution or information
   disclosure when the function returns.

Attack Vector
--------------------------------------------------------------------
Any context that causes Explorer.exe to process an attacker-controlled
file name – for example a malicious LNK located on a remote SMB share,
a ZIP file preview, or a downloaded folder containing overlong file
names – can reach the vulnerable routine without user confirmation.
No special privileges are required.

Patch Description
--------------------------------------------------------------------
The new implementation completely replaces the helper and builds the
subkey using safe routines:
• Uses StringCchPrintfW with an explicit 314-character limit.
• Verifies that the generated string has no extension, then manually
  appends “.exe” only after checking available space.
• Returns ERROR_INSUFFICIENT_BUFFER (0x8007007A) or
  ERROR_INVALID_PARAMETER (0x80070057) instead of writing past the
  array.
• The function signature is corrected: the second argument is now an
  HKEY, removing the earlier type confusion.

Security Impact
--------------------------------------------------------------------
Prior to the fix an attacker could achieve arbitrary code execution in
explorer.exe (current user context) or read registry information by
leveraging the type confusion.  Because explorer.exe is always loaded
in a logon session, exploitation provides a stable privilege-escalation
or information-disclosure primitive.

Fix Effectiveness
--------------------------------------------------------------------
The patch introduces deterministic bounds checks, constant-sized
buffers, correct error propagation, and eliminates the pointer type
confusion; therefore the original overflow and spoofing conditions are
no longer reachable.  No residual paths that write to SubKey without a
length check remain in the updated code, indicating the fix is
adequate.
