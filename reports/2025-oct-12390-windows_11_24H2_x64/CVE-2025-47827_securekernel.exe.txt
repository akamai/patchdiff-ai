{'kb': 'KB5066835', 'file': 'securekernel.exe', 'patch_store_uid': '39f7108f-f9c3-429c-aab6-90422b62deb3', 'date': 1763402993.7577047, 'confidence': 0.33, 'cve': 'CVE-2025-47827', 'change_count': 8}
--------------------------------------------------------------------
CVE-2025-47827 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
securekernel.exe – XSTATE support helpers
  • RtlGetExtendedContextLength2
  • RtlInitializeExtendedContext2
  • RtlpCopyXStateChunk
  • SkmmValidateSecureImagePages (secondary)

Vulnerability Class
--------------------------------------------------------------------
Improper buffer-size calculation leading to out-of-bounds memory
read/write (memory-corruption / privilege-escalation).

Detailed Root Cause Analysis
--------------------------------------------------------------------
The bug lives in the helper that copies an individual extended
processor state (XSTATE) chunk between two user-supplied context
records:

  RtlpCopyXStateChunk(aDstCtx, aSrcCtx, SrcHdr, DstHdr, XferDesc)

Before the patch the function initialised four running offsets with
hard-coded constant 64 instead of the real buffer lengths that are
stored in the context headers (offset +20 and +16):

  v6 = 64;
  v7 = 64;
  v8 = 64;
  v9 = 64;

The very same routine later validates the copy range with

  if (v9 > DstLen || v7 > SrcLen)
      return STATUS_BUFFER_OVERFLOW;

Because v7/v9 grow while iterating over each requested feature bit the
first comparison is performed with the **correct** accumulated size,
whereas the right-hand side (DstLen / SrcLen) still holds the real
size taken from the headers (v28 / v29).  The left-hand side (v7/v9),
however, started at 64 instead of the real base offset.  If the header
advertises a chunk that is <64 bytes long, the check never triggers and
`memmove` is executed with a negative (under-flowed) source or
destination pointer, effectively copying attacker-controlled data past
the end of the destination XSTATE buffer inside securekernel memory.

RtlGetExtendedContextLength2 and RtlInitializeExtendedContext2 reuse
this information.  Their old implementation relied on the buggy helper
`RtlpGetLegacyContextLength`.  For non-legacy feature masks the size
returned was wrong, so callers passed an undersized buffer directly to
RtlpCopyXStateChunk, magnifying the overwrite.

The patch rewrites the size calculator and, more importantly, replaces
all hard-coded constants with values read from the context headers
before each range check.  It walks the mask bits (0–63) and realigns
chunk boundaries when a feature is marked *compacted* in the global
OS bitmap held at [hdr+544].

Affected structures / fields
  CONTEXT_HEADER
     +16  TotalBufferLength   (32-bit)
     +20  ValidBitmapLength   (32-bit)
  XSTATE_COMPACTION_ENABLE   (global @ 0x…03F8)

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
v6 = 64; v7 = 64; v8 = 64; v9 = 64;
...
if (v9 > v28 || v7 > v29)  // v9/v7 start at 64 → bypass
    return STATUS_BUFFER_OVERFLOW;
```
```c
// after
v6 = *(DWORD*)(SrcHdr + 20);   // real size
v7 = 64;                       // running src offset
...
if (runDst > dstLen || runSrc > srcLen)
    return STATUS_BUFFER_OVERFLOW;
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User supplies crafted CONTEXT record to a syscall that eventually
   reaches securekernel (e.g. NtSetContextThreadEx).
2. securekernel → RtlInitializeExtendedContext2 builds an internal
   XSTATE description using the buggy length routine.
3. RtlpCopyXStateChunk is called for every requested feature.
4. Because initial offsets are wrong the bounds check succeeds even
   though the copy exceeds the buffer → memory corruption inside SK.

Attack Vector
--------------------------------------------------------------------
Local user-mode code running on the same machine passes a malicious
XSTATE mask and undersized buffer to the context-manipulation APIs.
No special privileges are needed; the securekernel code path is
reachable from user space.

Patch Description
--------------------------------------------------------------------
1. Introduced a new helper RtlpGetEntireXStateAreaLength2 that walks
   the 64-bit feature mask and calculates the exact layout, including
   compaction handling and 64-byte alignment.
2. Rtl(Get|Initialize)ExtendedContextLength2 now use the new helper and
   no longer rely on obsolete RtlpGetLegacyContextLength.
3. RtlpCopyXStateChunk:
   • Re-initialises running offsets with the true buffer lengths read
     from the context headers.
   • Updates range comparisons accordingly.
   • Cleans up logic for the *no-compaction* fast-path.
4. Additional mask validation adjustments (changed mask from 0x7FFFFC0
   to 0x7FFFF00) prevent illegal feature combinations from reaching the
   copy routine.

Security Impact
--------------------------------------------------------------------
Because securekernel memory is overwritten the attacker can corrupt
control structures that are later executed in SK mode, leading to
arbitrary code execution with VTL-1 privileges.  This breaks the
Hyper-V/Virtual Secure Mode boundary and enables full kernel
compromise and potential credential-guard bypass.

Fix Effectiveness
--------------------------------------------------------------------
The new code:
  • Derives offsets from header fields before each copy.
  • Re-checks compaction alignment per feature.
  • Rejects illegal feature masks much earlier.
This removes the offset underflow and the subsequent out-of-bounds
memmove, fully preventing the overwrite described above.
No remaining paths were found that still trust the constant 64-byte
value, so the patch is assessed as effective.
