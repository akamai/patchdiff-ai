{'kb': 'KB5066835', 'change_count': 8, 'confidence': 0.46, 'patch_store_uid': '0e54175f-9f22-44cd-8cdd-4e0fede69033', 'cve': 'CVE-2025-55326', 'date': 1763402971.2739463, 'file': 'cdpsvc.dll'}
--------------------------------------------------------------------
CVE-2025-55326 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Connected Devices Platform Service (cdpsvc.dll)

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use-After-Free

Detailed Root Cause Analysis
--------------------------------------------------------------------
The vulnerable routine is
  CDPComDevice::DeviceCallback::OnAppTargetListReceived().

1.  The original implementation builds a lambda functor on the stack
    (variable  v6) using the template type
    std::_Func_impl_no_alloc<lambda,…>.  
2.  The lambda captures the *addresses* of three local automatic
    variables (v11, v12, v13) that hold the pointers supplied by the
    caller:  
      •  const ICDPAppId *a2            ->  v11  
      •  const char **a3                ->  v12  
      •  unsigned short  a4             ->  v13
3.  A pointer to that on-stack functor is passed to
       ServiceCallbackNotifier<…>::StoreResult()
    which persists the std::function object for asynchronous execution.
4.  On return from OnAppTargetListReceived the stack frame is destroyed.
    The notifier therefore keeps dangling pointers to freed memory.
5.  When the asynchronous callback later executes, it dereferences the
    invalid captures, resulting in a classic use-after-free.  Because
    cdpsvc runs inside a service process, an attacker can control the
    freed data contents and achieve arbitrary code execution in the
    service context.

No heap cloning or reference counting existed; lifetime of the functor
was incorrectly assumed to match the notifier lifetime.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch (simplified)
v13 = a4;                      // local
v12 = a3;                      // local
v11 = a2;                      // local
*(_QWORD*)&v5 = &v11;          // capture ADDRESS of v11
*((_QWORD*)&v5 + 1) = &v13;    // capture ADDRESS of v13
v6 = &std::_Func_impl_no_alloc<lambda,…>::`vftable'; // functor on stack
ServiceCallbackNotifier::StoreResult(this+32); // stores pointer to v6
// v6 and captured locals destroyed on return -> dangling pointer
```

```c
// after patch (simplified)
char functor[24];              // v6
char funcObj[72];              // v7 (std::function storage)
make_lambda(functor,&v9,&v11,&v10);   // build functor with VALUES
std::function_ctor(funcObj,functor);  // copies functor into object
ServiceCallbackNotifier::StoreResult(this+32);
// StoreResult receives an owning copy, independent of stack
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Network packet -> CDP framework -> Device layer ->
CDPComDevice::DeviceCallback::OnAppTargetListReceived() ->
ServiceCallbackNotifier stores dangling lambda -> asynchronous callback
executes after stack is gone -> UAF

Attack Vector
--------------------------------------------------------------------
A remote, unauthenticated attacker sends crafted Connected Devices
Platform (CDP) traffic that causes cdpsvc to deliver an AppTargetList to
an affected client, thereby invoking OnAppTargetListReceived.  When the
service later processes the stored callback, it dereferences freed
memory, allowing the attacker to corrupt the heap and execute arbitrary
code within the cdpsvc service process.

Patch Description
--------------------------------------------------------------------
• Re-implemented lambda construction so that captured *values* are
  copied, not addresses of stack locals.  
• The functor is first built in a temporary buffer (v6) and then moved
  into a std::function object (v7) whose storage is either inlined or
  heap-allocated and owned by ServiceCallbackNotifier.
• All later accesses therefore refer to valid memory with the correct
  lifetime.
(Additional unrelated clean-ups in FeatureImpl functions were applied but
are not relevant to the UAF fix.)

Security Impact
--------------------------------------------------------------------
Successful exploitation yields arbitrary code execution in the cdpsvc
service, enabling remote code execution with LocalService privileges and
potential privilege escalation depending on subsequent chain.

Fix Effectiveness
--------------------------------------------------------------------
The patched code eliminates dangling captures by ensuring the callback
owns a self-contained copy of the functor.  No stack addresses are
persisted, preventing the original lifetime mismatch.  No residual paths
holding stack references were observed in the diff, so the fix appears
complete for this call site.  Effectiveness for other cdpsvc callbacks
is unknown.

