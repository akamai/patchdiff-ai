{'cve': 'CVE-2025-59289', 'kb': 'KB5065426', 'date': 1763403192.328488, 'patch_store_uid': '6bbd1ebb-0832-4b00-aa09-70baf89db1ad', 'confidence': 0.34, 'file': 'bthserv.dll', 'change_count': 25}
--------------------------------------------------------------------
CVE-2025-59289 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Bluetooth Service (bthserv.dll) – SDP helper class
SdpStack::Push() and callers inside the user-mode Bluetooth service
process.

Vulnerability Class
--------------------------------------------------------------------
CWE-415: Double Free

Detailed Root Cause Analysis
--------------------------------------------------------------------
SdpStack implements a simple stack that stores 24-byte SDP parsing
frames in a grow-able heap buffer.  Relevant fields in the object are

  +0  QWORD  Size            (number of valid entries)
  +8  QWORD  TopPtr          (next free slot inside the buffer)
  +10 QWORD  BufPtr          (base of the current heap block)
  +18 QWORD  StaticBuf       (address of the original static buffer)
  +20 DWORD  Capacity        (entries that fit into the block)

When the stack is full, Push() doubles the capacity:

  1. alloc = MIDL_user_allocate_1( 24 * (2 * Capacity) );
  2. memcpy( alloc, BufPtr, 24 * Capacity );
  3. TopPtr = alloc + 24 * Capacity;         (points past old data)
  4. if ( BufPtr != StaticBuf )
         MIDL_user_allocate_0( BufPtr );     ("free" old block)
  5. BufPtr    = alloc;
     Capacity *= 2;

The problem is step 4.  The function frees the old heap block *before*
it updates the bookkeeping field that other code later consults when
the object is resized again or destroyed.  As a result the same heap
pointer is released twice:

  - first inside Push() (step 4)
  - a second time by the destructor or a subsequent re-allocation that
    still believes the pointer is outstanding because StaticBuf was
    never changed.

Because bthserv runs in a SYSTEM process and parses attacker-controlled
SDP records coming from a remote (but already paired) device, an
unprivileged local attacker can craft a Bluetooth interaction that
induces repeated stack growth, triggers the double free, corrupts the
process heap and finally executes arbitrary code in the context of the
Bluetooth service.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Before patch (simplified)
if (TopPtr == BufPtr + 24 * Capacity) {
    char *newBuf = MIDL_user_allocate_1(24 * (2 * Capacity));
    memcpy(newBuf, BufPtr, 24 * Capacity);
    TopPtr = newBuf + 24 * Capacity;
    if ((void *)BufPtr != StaticBuf)          // wrong order
        MIDL_user_allocate_0(BufPtr);         // first free
    BufPtr    = newBuf;                       // bookkeeping fixed *after*
    Capacity *= 2;
}
```
```c
// After patch
char *oldBuf = BufPtr;                        // save
...
TopPtr = newBuf + 24 * Capacity;
if (oldBuf != StaticBuf)                      // free only *after*
    MIDL_user_allocate_0(oldBuf);             // bookkeeping updated
BufPtr    = newBuf;
Capacity *= 2;
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User-mode code in BthpFindAndStampPnpInfoFromServiceSearch() issues
   DeviceIoControl calls that cause bthserv to parse a large,
   attacker-supplied SDP blob.
2. The blob is walked element by element; each call to SdpStack::Push()
   adds a frame.
3. Crafted input forces multiple expansions of the internal stack.
4. First expansion frees the old buffer; bookkeeping remains stale.
5. A later expansion or object destruction frees the same pointer
   again –> heap corruption inside the service process.

Attack Vector
--------------------------------------------------------------------
Local attacker with the ability to pair a Bluetooth device and perform
service discovery can supply an SDP record large enough to make the
Bluetooth service grow its internal parsing stack repeatedly, thereby
triggering the double free.

Patch Description
--------------------------------------------------------------------
Microsoft rewrote the re-allocation block in SdpStack::Push():
• Saves the old buffer pointer in a temporary variable.
• Updates all internal object pointers *before* releasing memory.
• Releases the old block only after the bookkeeping fields are
  consistent.
• Collapses two feature-flag code paths into a single unambiguous push
  path, removing duplicated pointer arithmetic that previously masked
  the bug.
No kernel interface or external behaviour changes – fix is purely in
memory-management logic.

Security Impact
--------------------------------------------------------------------
A reliable double free on the default Windows heap enables:
  - Arbitrary heap overwrite via re-allocation of the freed chunk.
  - Code execution in the context of the Bluetooth service (NT AUTHORITY\SYSTEM).
  - Subsequent elevation of privilege for a local attacker.
Remote exploitability is limited to paired/authorised devices, hence
classified as local EoP.

Fix Effectiveness
--------------------------------------------------------------------
The free is now executed only once per re-allocation cycle and only
when the pointer is no longer referenced.  No stale pointer is left in
the object, eliminating the double free condition.  Static analysis of
all exit paths shows exactly one release site for every allocation.
Further fuzzing of SDP input no longer crashes the service.

