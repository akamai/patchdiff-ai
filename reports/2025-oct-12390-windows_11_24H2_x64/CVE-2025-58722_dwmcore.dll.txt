{'change_count': 96, 'cve': 'CVE-2025-58722', 'confidence': 0.27, 'kb': 'KB5066835', 'date': 1763403099.5620382, 'patch_store_uid': '9ea31a38-c5d1-473b-b782-3c02fef25a9c', 'file': 'dwmcore.dll'}
--------------------------------------------------------------------
CVE-2025-58722 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Desktop Window Manager (dwmcore.dll)
Function: CBrushRenderingGraphBuilder::AddEffectBrush


Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow (out-of-bounds write)
CWE-122


Detailed Root Cause Analysis
--------------------------------------------------------------------
AddEffectBrush builds a rendering graph for an effect brush.  At run
-time it first queries the compiled effect for the number of subgraphs
("subgraphCount"):

  subgraphCount = vCompiledEffect->GetSubgraphCount();
  if (subgraphCount != 1)
      vector.resize(subgraphCount-1);

The vector (type SubgraphOutput) is therefore allocated for indexes
0‥(subgraphCount-2) and its base pointer is kept in v16 (pre-patch) /
v14 (post-patch).

Later, while iterating every input of every subgraph the code asks the
compiled effect for an *intermediate* producer index:

  idx = vCompiledEffect->GetIntermediateInputIndex(sg, input);
  if (isIntermediate)
      entry = v16 + 16 * idx;   // 16-byte element size
      ... write fields in entry ...

No validation existed to ensure that the returned "idx" is smaller than
subgraphCount-1.  A malicious or corrupted compiled-effect object could
return an arbitrarily large value, causing

  v16 + 16*idx  ==> pointer past the end of the heap block

and the subsequent writes corrupt heap metadata or neighbouring
objects.  Because this code runs inside the DWM service (high
integrity) while processing data that originates from a user session,
heap corruption can be leveraged for privilege-escalation.

Affected structures / variables:
  • std::vector<SubgraphOutput>  (base pointer v16 / v14)
  • idx  (unsigned int, untrusted)
  • 16-byte SubgraphOutput entry written without bounds check


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// BEFORE
idx = vCompiledEffect->GetIntermediateInputIndex(sg, input, &isInter);
if (isInter)
{
    entry = v16 + 16i64 * idx;      // no bounds check
    if (*(DWORD*)entry != -1)
        CRenderingTechniqueFragment::AddIntermediateInput(frag, *(DWORD*)entry);
    else {
        tmp = *(QWORD*)(entry+8);
        *(QWORD*)(entry+8) = 0;     // out-of-bounds write possible
        ...
    }
}

// AFTER
idx = vCompiledEffect->GetIntermediateInputIndex(sg, input, &isInter);
if (isInter)
{
    if (FeatureEnabled && idx >= ((vector_end - v14) >> 4))
        FailFast();                 // new bounds check
    entry = v14 + 16 * idx;         // safe
    ...
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker supplies or controls a Composition effect brush that is
   compiled into a CCompiledEffectTemplate.
2. DWM (high integrity) calls AddEffectBrush when building the visual
   tree.
3. CompiledEffect::GetIntermediateInputIndex returns an oversized
   index.
4. AddEffectBrush writes to vector[oversized] – heap buffer overflow.
5. Corrupted heap allows code execution in DWM, leading to elevation of
   privilege.


Attack Vector
--------------------------------------------------------------------
Local, authenticated user.  By crafting a specially-formed effect brush
(and triggering composition), the user feeds a malicious
CCompiledEffectTemplate to the DWM service, exploiting the unchecked
index.


Patch Description
--------------------------------------------------------------------
The patch introduces a length check before using the returned index:

  if (idx >= vector.size()) FailFast();

The check is wrapped in a wil::Feature gate but ultimately guarantees
that any out-of-range value terminates the process before memory is
modified.  All later writes therefore stay inside the allocated
SubgraphOutput vector.


Security Impact
--------------------------------------------------------------------
Prior to the fix a user-controlled compiled effect could corrupt the
heap in the DWM service, enabling local elevation of privilege up to
SYSTEM.  The issue is classified as a heap-based buffer overflow
(CWE-122).


Fix Effectiveness
--------------------------------------------------------------------
The added bounds check converts a silent out-of-bounds write into an
immediate FailFast, eliminating the overflow.  No residual write paths
bypass the new condition, so the fix is considered effective, assuming
that the guarding feature flag is enabled on all supported Windows
builds.
