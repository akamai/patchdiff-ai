{'kb': 'KB5066835', 'confidence': 0.14, 'change_count': 15, 'date': 1763406161.8281648, 'patch_store_uid': 'dda3686d-f7f1-43d7-8d70-2a4077935f54', 'cve': 'CVE-2025-59190', 'file': 'searchindexer.exe'}
--------------------------------------------------------------------
CVE-2025-59190 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Search Service (searchindexer.exe). Affected routine
is the internal helper now named sub_140081D30 (formerly sub_140080F80)
invoked when resolving an indexer version string for a given catalog
name.

Vulnerability Class
--------------------------------------------------------------------
Improper Input Validation / Use-of-Uninitialised Pointer leading to
NULL/invalid-pointer dereference (Denial-of-Service).

Detailed Root Cause Analysis
--------------------------------------------------------------------
The function is called with three parameters:
  a1 : HKEY registry handle (service context)
  a2 : const WCHAR* CatalogName (user controlled)
  a3 : __int64*      OutVersionHandle

Before the patch the code attempted to block the reserved catalog names
"Windows" and "SystemIndex" with the following check:

    _wcsnicmp(v6, L"Windows", 7)
    _wcsnicmp(a2, L"SystemIndex", 11)

The variable v6 is never initialised prior to this call; it contains a
stack garbage value.  When the execution reaches _wcsnicmp the garbage
pointer is used as the first UNICODE_STRING, causing the CRT routine to
read arbitrary memory.  If v6 is not a valid user-mode pointer the
process raises an access-violation exception and Windows Search Service
terminates.  Because the service runs inside the SCM service host, the
crash results in an immediate stop/restart cycle â€“ a local denial of
service condition.

The bug is reachable because a2 (CatalogName) can be supplied through
public COM interfaces (ISearchCatalogManager::GetCatalog), the Windows
Search protocol handler, or via PowerShell/Explorer search APIs.  No
special privileges are required.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// BEFORE
if (!(_wcsnicmp(v6, L"Windows", 7) ||
      _wcsnicmp(a2, L"SystemIndex", 11))) { ... }

// AFTER
if (!(_wcsnicmp(a2, L"Windows", 7) ||
      _wcsnicmp(a2, L"SystemIndex", 11))) { ... }
```
The sole change is the replacement of the uninitialised variable v6 by
the legitimate parameter a2.

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker calls a public Windows Search API providing an arbitrary
   catalog name.
2. API forwards to searchindexer.exe, eventually reaching
   sub_140080F80.
3. Function compares catalog name to reserved names using uninitialised
   pointer v6 -> invalid memory read.
4. Access violation exception bubbles up; searchindexer.exe terminates;
   the SCM restarts it, denying service during the crash loop.

Attack Vector
--------------------------------------------------------------------
Local, unauthenticated.  Any user able to invoke Windows Search APIs
(COM, WSearch indexer control utility, PowerShell, or shell extensions)
can supply a crafted request and crash the service.

Patch Description
--------------------------------------------------------------------
1. Replaced the first argument of _wcsnicmp from v6 to the validated
   catalog name pointer a2 (correct variable).
2. Added feature-flagged call to sub_1400AA1D8 to sanity-check the
   catalog name before any further processing; returns
   ERROR_INVALID_PARAMETER on failure.
3. Hardened error handling paths and updated global logging/telemetry
   symbols (unk_1400EAD70, byte_1400EAAC1).

Security Impact
--------------------------------------------------------------------
Prior to the fix any local user could repeatedly crash the Windows
Search Service, resulting in loss of indexing functionality and
continual service restart attempts (denial of service).  No elevation
of privilege or information disclosure is implied, but availability is
severely affected.

Fix Effectiveness
--------------------------------------------------------------------
The variable misuse has been completely removed; the comparison now
always receives a valid, caller-supplied pointer.  Additional upfront
validation further guards against malformed catalog names.  Because the
faulting code path is eliminated and new validation is present, the fix
is considered effective against the described DoS condition.
