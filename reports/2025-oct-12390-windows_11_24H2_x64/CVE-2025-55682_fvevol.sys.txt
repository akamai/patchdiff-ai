{'cve': 'CVE-2025-55682', 'date': 1763402986.435249, 'confidence': 0.22, 'change_count': 6, 'patch_store_uid': 'efb29de7-ce28-4d45-a691-32e878d118b2', 'file': 'fvevol.sys', 'kb': 'KB5066835'}
--------------------------------------------------------------------
CVE-2025-55682 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows BitLocker filter driver  (fvevol.sys)  – functions
FveFilterDeviceControl and FvePdcActivatorCallback.


Vulnerability Class
--------------------------------------------------------------------
Improper enforcement of behavioural workflow / state-machine error
(CWE-841).  Practical manifestation: reference-counter underflow that
causes an unexpected release of the global BitLocker driver lock.


Detailed Root Cause Analysis
--------------------------------------------------------------------
Each BitLocker-protected volume owns a device structure (pointed to by
rdi/rbx in the decompilation, here referenced as DevCtx).  Element
DevCtx[1133] is a signed 32-bit reference counter that tracks the
number of successful   IOCTL_FVE_READ_WRITE_DEVICE_INIT (value
0x455610D8)  requests that are currently active.  As long as this
counter is non-zero the driver keeps the global BitLocker lock by
calling FveLockDriver(); when it reaches zero the lock is released via
FveUnlockDriver().

The complementary IOCTL   0x455610DC ( READ_WRITE_DEVICE_CLEANUP )  is
handled in FveFilterDeviceControl.  In the vulnerable build the
sequence is:

1. current = _InterlockedDecrement(&DevCtx[1133]);
2. if (current < 0) KeBugCheckEx(...);   // *checked* builds only
3. FveReadWriteDeviceCleanup();          // performs bookkeeping
4. FveUnlockDriver();                    // releases lock regardless of
                                          // counter value

On retail systems the bug-check is compiled out, therefore an attacker
can send CLEANUP without ever having sent the matching INIT.  The
counter underflows (-1, ‑2 …) yet step 4 unconditionally calls
FveUnlockDriver(), leaving the global BitLocker lock open while the
counter is negative – a state that must never occur in the intended
workflow.

Once the driver has been unlocked early, subsequent unauthorised I/O
(path traversal, raw sector writes, etc.) is accepted even though the
volume was never successfully initialised.  This breaks BitLocker’s
security guarantee and enables a physical attacker to bypass
pre-boot-auth protection.

The second function, FvePdcActivatorCallback, only received cosmetic
trace-id adjustments and does not participate in the defect itself.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Before           (IOCTL 0x455610DC branch)
_InterlockedDecrement((volatile signed __int32 *)v2 + 1133);
...
FveReadWriteDeviceCleanup(v2, 0i64);
FveUnlockDriver(v2);           // always executed
```

```c
// After (simplified)
int new = _InterlockedDecrement((volatile signed __int32 *)v2 + 1133);
if (FeatureEnabled)
{
    if (new < 0)
        WPP_SF_qd(...);        // trace only – no unlock
}
else if (new < 0)
{
    KeBugCheckEx(...);        // legacy path
}
...
if (!FeatureEnabled)          // only when counter valid
    FveUnlockDriver(v2);
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker opens the device   \\Device\\HarddiskVolumeXX\\FVE_vol.
2. Sends IOCTL 0x455610DC (READ_WRITE_DEVICE_CLEANUP) without the
   prior 0x455610D8 INIT.
3. DevCtx[1133] decrements from 0 to -1.
4. In vulnerable code path FveUnlockDriver() is invoked.
5. BitLocker lock released; driver now processes unauthorised requests.


Attack Vector
--------------------------------------------------------------------
Physical attacker (bootable media, DMA cable, or malicious bootloader)
who can talk to the fvevol device during early-boot or from WinPE can
issue the single crafted IOCTL to unlock the driver and access the
encrypted volume in clear.


Patch Description
--------------------------------------------------------------------
1. Saves the result of InterlockedDecrement into a local variable.
2. Introduces a sanity check:
   • If the counter became negative, FveUnlockDriver() is **not**
     executed.
   • In debug/feature builds a trace or bug-check is issued instead.
3. FveUnlockDriver() is now executed only when the reference count
   remains non-negative, preserving the intended workflow.
4. Ancillary: WPP trace-id updates and minor refactorings; no security
   impact.


Security Impact
--------------------------------------------------------------------
Prior to the patch an attacker could force an early unlock of the
BitLocker driver, defeating the encryption boundary and reading or
modifying disk sectors that should have remained protected.  This is a
full security-feature bypass with physical access.


Fix Effectiveness
--------------------------------------------------------------------
The new logic blocks the unlock operation when the reference counter
underflows, thereby ensuring that the global lock can only be
released by a correctly paired INIT/CLEANUP sequence.  State
invariants are preserved, preventing the bypass.  No alternative path
in the patched binary was found that could still reach FveUnlockDriver
with a negative counter, so the fix is considered effective.

