{'date': 1763403252.9752977, 'cve': 'CVE-2025-59187', 'change_count': 222, 'file': 'ntoskrnl.exe', 'kb': 'KB5066835', 'confidence': 0.12, 'patch_store_uid': 'c1b97b38-6328-4043-8cf8-12e6eafee863'}
--------------------------------------------------------------------
CVE-2025-59187 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows NT kernel (ntoskrnl.exe) – Plug-and-Play property helper
routine PnpValidatePropertyData used when user mode asks the
kernel to set or query a device property.

Vulnerability Class
--------------------------------------------------------------------
Improper input validation / out-of-bounds kernel memory access
(CWE-20, CWE-822).

Detailed Root Cause Analysis
--------------------------------------------------------------------
The routine PnpValidatePropertyData is responsible for making sure
that caller-supplied property data matches the DEVPROP_TYPE that is
encoded in the low 16 bits of the a3 argument.  For properties that
represent a Unicode string or a list of Unicode strings the previous
implementation performed its own length checks:

1.  (v8 & 0x2000) == 0   – single string
2.  (v8 & 0x2000) != 0   – MULTI_SZ (string list)

For both cases the code walked the buffer byte-by-byte looking for
a terminating WCHAR 0x0000 and calculated how many bytes were
"consumed" (v19 / v22).  The manually written loops had two major
flaws:

• The loop dereferenced *(_WORD *)SecurityDescriptor without first
  making sure that the word lies inside the caller-supplied buffer;
  if the final NUL was missing the pointer marched past the end of
  the validated region and read uncontrolled kernel memory.

• Size bookkeeping used 32-bit unsigned arithmetic (v23, v24, v26,
  v27) so the running counter could wrap, letting the final
  comparison "v19 == v4" succeed even though the pointer was already
  past the trusted area.

Because the buffer is still mapped from user space, a local attacker
can supply a short, non-terminated string that straddles a valid
user page followed by an unmapped page: when the kernel continues
reading beyond the end of the user allocation, a controlled page
fault is raised in kernel context, allowing elevation via the usual
exception-handling techniques.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – custom scan of MULTI_SZ
while ( *(_WORD *)SecurityDescriptor ) {
    ...                   // length bookkeeping
    SecurityDescriptor += 2 * (v28 >> 1);   // advances pointer
}
// no guarantee pointer is still inside [buf, buf+Length)
```

```c
// after patch – safe helper that never crosses buffer limit
while ( *(_WORD *)psz ) {
    if ( RtlStringCbLengthW((STRSAFE_PCNZWCH)psz,
                            v4 - v20,
                            &pcbLength) < 0 )
        return STATUS_INVALID_PARAMETER;
    ...
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
User mode (e.g. SetupDiSetDeviceProperty) ->
  CM_Set_DevNode_Property_Ex ->
  nt!NtSetValueKey ->
  nt!PnpSetDevicePropertyData ->
  nt!PnpValidatePropertyData (vulnerable) ->
  unchecked read past caller buffer triggers kernel access fault.

Attack Vector
--------------------------------------------------------------------
Any local, non-privileged process that has the standard
DEVICE_QUERY/DEVICE_SET property privileges can pass a crafted
property blob to the Plug-and-Play manager.  By omitting the final
Unicode NUL in a DEVPROP_TYPE_STRING or STRING_LIST value the
attacker forces the kernel to read beyond the supplied buffer.

Patch Description
--------------------------------------------------------------------
1. Function prototype changed from char* to __int64* so that the
   compiler treats the parameter as properly aligned pointer.
2. All manual scanning logic replaced by RtlStringCbLengthW, which
   receives the remaining buffer size and guarantees the read stays
   within bounds.
3. Length accounting now done with size_t/unsigned __int64 variables
   (pcbLength, v20, v21, v22) eliminating 32-bit wrap.
4. Additional short-circuit checks were added before loops and after
   each RtlStringCbLengthW call to reject any error immediately.

Security Impact
--------------------------------------------------------------------
Prior to the fix a user-supplied property value could cause an
out-of-bounds read from kernel mode, leading to a controlled
kernel-mode access fault.  By preparing the faulting address an
attacker can execute code in kernel context and elevate privileges.

Fix Effectiveness
--------------------------------------------------------------------
The new implementation uses well-tested string helpers that respect
buffer length, performs 64-bit size arithmetic, and validates the
result of every helper call.  There are no remaining unbounded
pointer walks, so the original over-read condition is closed.
