{'date': 1763402991.8247757, 'confidence': 0.36, 'change_count': 8, 'kb': 'KB5066835', 'patch_store_uid': '0e54175f-9f22-44cd-8cdd-4e0fede69033', 'cve': 'CVE-2025-59191', 'file': 'cdpsvc.dll'}
--------------------------------------------------------------------
CVE-2025-59191 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Connected Devices Platform Service (cdpsvc.dll) – routine
lambda_7ffd25213cfe03b0af8e887eb5338eb1_::operator(), invoked while
converting CDP application identifiers.

Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow (CWE-122).

Detailed Root Cause Analysis
--------------------------------------------------------------------
The lambda operator receives two structures:
 a1 -> input descriptor
        +0x00  QWORD  **AppIdList
        +0x08  WORD   *AppIdCountPtr   (number of app IDs)
        +0x10  QWORD  **AppIdStrings   (array of char*)
 a2 -> output descriptor
        +0x00  NTSTATUS Status
        +0x08  ...     (other fields)
        +0x40  QWORD   PtrArray        (pointer array allocated here)
        +0x48  WORD    OutCount
        +0x50  ...

Before the patch the code allocated memory for PtrArray with

    size = *AppIdCountPtr;                // WORD count
    PtrArray = CoTaskMemAlloc(size);      // bytes, **NOT** count*8

Later it stored an 8-byte pointer for every element:

    PtrArray[count_index] = CoTaskMemAlloc(len);

Because only <count> bytes were reserved while <count>*8 bytes are
written, the allocator’s bookkeeping region and adjacent heap objects
are overwritten whenever AppIdCount > 1.  The write primitive occurs in
a SYSTEM service context, enabling controlled memory corruption.

Patch code introduces a size calculation that multiplies the element
count by 8 (sizeof(QWORD)) when feature 2578215227 is enabled:

    bytes = count;
    if (FeatureEnabled)
        bytes *= 8;
    PtrArray = CoTaskMemAlloc(bytes);

Thus the allocated buffer now matches the number of 64-bit entries to be
written, removing the overflow.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable allocation (before)
size_t bytes = **(unsigned __int16 **)(a1 + 8); // WORD count
*(_QWORD *)(a2 + 64) = CoTaskMemAlloc(bytes);   // too small

// fixed allocation (after)
SIZE_T bytes = **(unsigned __int16 **)(a1 + 8);
if (wil::FeatureEnabled(...))        // always true on patched systems
    bytes *= 8;                      // adjust for QWORD array
*(_QWORD *)(a2 + 64) = CoTaskMemAlloc(bytes);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Unprivileged client hands a crafted CDP AppId list to cdpsvc via an
   RPC/ALPC surface (exact message unknown).
2. Service calls ComAppIdFromCDPAppId_0(), which in turn invokes the
   lambda operator.
3. Lambda determines AppIdCount, allocates undersized buffer, then writes
   pointers past its end while copying each string.
4. Heap metadata is corrupted; attacker can follow up with additional
   allocations/frees to achieve arbitrary code execution in the service
   process (NT AUTHORITY\SYSTEM).

Attack Vector
--------------------------------------------------------------------
Local.  An authenticated user sends a malformed request to the Connected
Devices Platform Service, supplying an AppIdCount greater than one and
controlled strings.  No special privileges are required beyond the
ability to communicate with cdpsvc.

Patch Description
--------------------------------------------------------------------
The fix recalculates the allocation size for the pointer array:
 • Retrieves WORD AppIdCount (v7).
 • If feature flag 2578215227 is active, multiplies by 8 to account for
   sizeof(QWORD).
 • Abort path added if allocation fails (goto LABEL_11).
Nothing else changes; copy loop logic is untouched.

Security Impact
--------------------------------------------------------------------
Prior to the patch, a local attacker could trigger a heap buffer
overflow in a SYSTEM service, leading to elevation of privilege or
potentially full remote-code execution within the service process.

Fix Effectiveness
--------------------------------------------------------------------
Allocating count*8 bytes aligns the buffer size with written data,
removing the direct overflow condition.  Protection relies on the
feature flag being enabled system-wide; if it were disabled (unknown
configuration), the old behavior would persist.  Apart from that
contingency, the patch fully resolves the described flaw.

