{'change_count': 5, 'date': 1763407839.0170572, 'confidence': 0.23, 'kb': 'KB5066835', 'file': 'ltmdm64.sys', 'cve': 'CVE-2025-24052', 'patch_store_uid': '2ef9587d-d12e-4efa-97f8-9cdcd571719c'}
--------------------------------------------------------------------
CVE-2025-24052 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
ltmdm64.sys  (Agere/Lucent Technologies software-modem kernel driver, 
serial-port emulation path)


Vulnerability Class
--------------------------------------------------------------------
CWE-121: Stack-based Buffer Overflow (leading to arbitrary kernel code 
execution / Elevation of Privilege)


Detailed Root Cause Analysis
--------------------------------------------------------------------
The vulnerable routine is SerialGetConfigDefaults().  During driver
initialisation DriverEntry() calls

    SerialGetConfigDefaults(&driverDefaults);

The callee receives two parameters:
  • Dst – pointer to a 0x78-byte structure that will hold driver
    defaults (supplied by the caller, usually allocated on the stack).
  • a2  – pointer to a UNICODE_STRING-like pair (Length in the first
    WORD, Buffer pointer in the next QWORD).

Root-cause sequence inside the function (before the patch):
 1. The function calculates
        SIZE_T v4 = *(WORD *)a2 + 2;
    and allocates a paged-pool buffer of that size.
 2. memmove_91() copies *(WORD*)a2 bytes from user-controlled
    a2[1] into the freshly allocated buffer without any additional
    validation.
 3. A fixed, compiler-generated RTL_QUERY_REGISTRY_TABLE array
    (QueryTable[9]) lives entirely on the *stack* (0x1C0 bytes).
    SerialGetConfigDefaults() memset()s the array and then writes
    seven entries containing pointers into the attacker-controlled
    paged-pool buffer.  Because the function never sets a hard
    terminator entry (Name==NULL), RtlQueryRegistryValues() continues
    to walk the stack beyond the 9-element array, interpreting stack
    data as additional entries.
 4. Any non-zero QWORD that sits behind QueryTable[8] will be treated
    as an RTL_QUERY_REGISTRY_TABLE element, giving the attacker full
    read/write access to adjacent stack memory.  By crafting an
over-long registry path string the attacker can reliably overwrite
    the saved return address (or the stored security cookie) that is
    located after the array, leading to a classic stack overflow and
    eventual kernel-mode code execution.

Key data that can be influenced by a non-privileged user:
  • The registry path passed via IoCreateDevice / AddDevice.
  • Arbitrary registry values that will be parsed through the overrun
    RTL_QUERY_REGISTRY_TABLE entries.

Because the vulnerable code executes inside DriverEntry(), the bug is
reachable as soon as the binary is loaded (either automatically during
boot or manually through the service control manager).


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// simplified extract from the original code
SIZE_T v4 = *(WORD *)a2 + 2;                 // length comes from user
PVOID Pool = ExAllocatePoolWithTag(PagedPool, v4, 'COMX');
...
memmove_91(Pool, a2[1], *(WORD *)a2);        // no size verification
...
struct _RTL_QUERY_REGISTRY_TABLE QueryTable[9];
memset(QueryTable, 0, sizeof(QueryTable));   // 0x1C0 bytes
// write 7 entries, NO explicit terminator
QueryTable[0].Name = aBreakonentry;          // etc.
// stack beyond QueryTable[8] now interpreted as structure(s)
RtlQueryRegistryValues(HKLM, Pool, QueryTable, NULL, NULL);
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker prepares a registry path containing an excessively long
   string (or crafts AddDevice parameters).
2. The signed in-box driver is loaded (boot or SCM), executing
   DriverEntry().
3. DriverEntry() calls SerialGetConfigDefaults().
4. SerialGetConfigDefaults() overflows its stack when it passes the
   unterminated QueryTable to RtlQueryRegistryValues().
5. The saved return address / security cookie is corrupted, leading to
   arbitrary code execution in kernel context when the function
   returns or when the cookie check runs.


Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker.  Requires the ability to write specific
registry keys or force Windows to load the vulnerable ltmdm64.sys
binary (e.g. by plugging in a fax-modem device that uses the class
GUID).  No administrative privileges are needed to reach the code
path.


Patch Description
--------------------------------------------------------------------
Microsoft removed all exploitable code paths instead of attempting a
partial fix:
  • SerialGetConfigDefaults() was deleted entirely; the symbol now
    points to _security_init_cookie(), a short stub that only checks
    the global cookie and fast-fails if tampered with.
  • DriverEntry_0() (the import-thunk entry point) no longer performs
    cookie initialisation on its own; it calls the new shared helper
    _security_init_cookie().
  • DriverEntry() itself was replaced with a stub that immediately
    returns STATUS_NOT_SUPPORTED (0xC00000BB / -1073740764).
  • __report_gsfailure() now calls __fastfail(2) instead of invoking
    KeBugCheckEx, preventing potential recovery exploits.

These changes effectively disable the driver; any attempt to load it
results in failure, and no reachable attack surface remains.


Security Impact
--------------------------------------------------------------------
Before the patch a non-privileged local attacker could execute
arbitrary code in kernel mode, gaining SYSTEM privileges and rendering
all platform security boundaries moot.  The vulnerability is present
on every supported Windows version that still ships ltmdm64.sys.


Fix Effectiveness
--------------------------------------------------------------------
The vulnerable function is completely removed, and DriverEntry()
returns an error so the driver never attaches to the device stack.
Consequently the offending code cannot be reached any longer.  The
fix therefore fully mitigates the vulnerability, albeit at the cost of
rendering affected modem hardware inoperable.

--------------------------------------------------------------------
