{'change_count': 7, 'kb': 'KB5066835', 'confidence': 0.22, 'cve': 'CVE-2025-49708', 'file': 'dcomp.dll', 'patch_store_uid': '83ca5577-c691-476b-9561-5be237f056bd', 'date': 1763407680.6012664}
--------------------------------------------------------------------
CVE-2025-49708 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Graphics Component (dcomp.dll)
Function: tip2::details::shared_data<0,0,1>::evaluate_and_report

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use After Free

Detailed Root Cause Analysis
--------------------------------------------------------------------
The vulnerable routine processes a shared_data object that carries an
internal state byte located at offset +0xA0 ( *((BYTE*)this + 160) ).
State value 5 represents the "destroyed/finalised" phase.  In the
original build the function continued to execute its full reporting
logic even when the object was already in this terminal state.

Early in the routine the code invokes a virtual callback on the first
field of the structure

    (**(void (__fastcall ***)(_QWORD))*a1)(*a1);

If this callback frees the shared_data instance, the pointer held in
register a1 becomes stale.  Nevertheless, the function subsequently
reads and writes dozens of structure members (for example a1[21],
a1[11], a1+45, etc.) and finally hands those values to TestReport and
other helpers.  Any reuse of the freed memory by the heap allocator can
therefore be coerced into an arbitrary-write or arbitrary-read
primitive.

The defect is purely a logical one: there was no guard that aborted the
routine once the object had progressed to state 5, so dangling pointer
access was guaranteed whenever evaluate_and_report was re-entered after
destruction (e.g. through a queued work item or secondary reference).

Key data involved
• BYTE State            : offset +0xA0, value 5 == Destroyed
• QWORD CallbackObject  : offset +0x00, freed by virtual call
• Multiple QWORD/DWORD  : offsets up to +0xB0 subsequently read

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Old code (simplified)
if (!*((BYTE*)a1 + 160) && evaluate_flags(...))
    (**(void (__fastcall ***)(_QWORD))*a1)(*a1);   // may free a1
v4 = *((BYTE*)a1 + 160);
// No check for v4 == 5 here – execution continues and dereferences a1
```

```c
// Patched code
v4 = *((BYTE*)a1 + 160);
if (v4 != 5)                    // <-- new safety gate
{
    ...                         // original body
    return;                     // explicit return after work
}
// object already destroyed – function now falls through and returns
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker forces shared_data object to reach state 5 (destroyed) but
   keeps or regains a reference that will later invoke
   evaluate_and_report.
2. evaluate_and_report is called.
3. Virtual callback frees the object.
4. Routine proceeds to use fields of the now-freed memory.
5. Heap reuse by attacker results in controlled data being interpreted
   as internal structure members, leading to elevation of privilege.

Attack Vector
--------------------------------------------------------------------
Exact external trigger is not disclosed, but any context that can queue
or directly invoke evaluate_and_report on a previously destroyed
shared_data instance can exploit the issue.  According to Microsoft the
scenario can be reached over the network by an authorised user of the
Graphics subsystem, enabling local privilege escalation.

Patch Description
--------------------------------------------------------------------
1. Added an early exit: `if (state_byte == 5) return;` which prevents
   any further access when the object is in the destroyed phase.
2. Changed the formal parameter from `_QWORD*` to `_DWORD*` and adjusted
   pointer arithmetic (`a1 + 2` instead of `a1 + 1`) to ensure proper
   field alignment.  This is a correctness improvement but the central
   mitigation is the state-check.
3. Converted the function return type from `__int64` to `void`, making
   the early-exit logic straightforward.

Security Impact
--------------------------------------------------------------------
Prior to the patch, a use-after-free allowed an attacker to manipulate
heap contents that would later be accessed as trusted structure fields.
This can be leveraged to gain arbitrary code execution in the context
of the Graphics component service, providing elevation of privilege.

Fix Effectiveness
--------------------------------------------------------------------
The new state check completely bypasses the vulnerable code path once
the object is freed, eliminating the dangling pointer usage.  No other
writes are performed when state == 5, closing the exploit window.  The
change is minimal, easy to audit, and should be fully effective unless
additional states besides 5 can also reference freed memory (unknown).
