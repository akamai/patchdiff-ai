{'date': 1763402993.2758634, 'change_count': 51, 'confidence': 0.23, 'cve': 'CVE-2025-58714', 'file': 'afd.sys', 'patch_store_uid': 'd18657ac-5d16-40b0-bfc8-644001aeac77', 'kb': 'KB5066835'}
--------------------------------------------------------------------
CVE-2025-58714 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Ancillary Function Driver for WinSock (afd.sys) – functions
AfdSanInitEndpoint, AfdTdiCreateAO, WskProIRPGetNameInfo, and
WskProIRPGetAddressInfo.

Vulnerability Class
--------------------------------------------------------------------
Improper Access Control / Arbitrary Kernel Write (privilege
escalation).

Detailed Root Cause Analysis
--------------------------------------------------------------------
The core defect sits in AfdSanInitEndpoint.  Prior to the patch the
routine was declared as
    AfdSanInitEndpoint( _QWORD a1 )
but the compiled body unconditionally dereferenced the registers r9,
r10, rdx and r8 (labelled v1-v5 below) and used them as structure
pointers:
    *(_QWORD *)(r10 + 96)  = r9;   // store caller-supplied ptr
    *(_QWORD *)(r10 + 104) = rdx;  // …
    *(_QWORD *)(r10 + 112) = r8;   // …
Because those registers were never validated, the caller that reaches
AfdSanInitEndpoint could fully control both
  • the destination address (r10 + offset) and
  • the value written (r9/rdx/r8).
This is a classical write-what-where condition inside the kernel and
allows an unprivileged process to overwrite arbitrary kernel memory
(eg. SYSTEM token pointers) and thus elevate its privileges.

The patch changes the prototype to
    AfdSanInitEndpoint( _QWORD Endpoint,
                        _QWORD SanContext,
                        _QWORD Provider )
and re-implements pointer derivation as follows:
  • v3 (the destination buffer) is fetched from *(SanContext+0x18), an
    address that the driver itself previously set up.
  • An _InterlockedIncrement64 on (Endpoint+0x40) ensures the endpoint
    reference count is already >1; otherwise KeBugCheckEx is raised via
    __fastfail(0xE).
  • Subsequent member initialisations use only the verified v3 pointer
    plus constant, in-object offsets.

Therefore user-mode input can no longer select an arbitrary kernel
address, eliminating the write-what-where primitive.

Side routines (AfdTdiCreateAO, WskProIRPGetNameInfo, WskProIRPGetAddressInfo)
were also hardened – replacing direct Afd*ReferenceClient calls with
RoReferenceEx, adding feature-flag based access checks and cleaning up
IRP handling – but these are defence-in-depth; the privilege-escalation
truly stemmed from the unchecked pointer use in AfdSanInitEndpoint.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable (simplified)
AfdSanInitEndpoint(a1)
{
    // r9, r10, rdx, r8 are attacker-controlled
    *(_QWORD *)(r10 + 96)  = r9;
    *(_QWORD *)(r10 + 120) = 0;
    *(_QWORD *)(r10 + 104) = rdx;
    *(_QWORD *)(r10 + 112) = r8;
    ...                     // more writes into r10 region
}

// fixed
AfdSanInitEndpoint(a1, a2, a3)
{
    v3 = *(QWORD*)(a2 + 0x18);      // driver-owned buffer
    if ( _InterlockedIncrement64((QWORD*)(a1 + 0x40)) <= 1 )
        __fastfail(0xE);
    *(QWORD*)(v3 + 0x60)  = a1;     // safe writes inside object
    *(QWORD*)(v3 + 0x68)  = a2;
    *(QWORD*)(v3 + 0x70)  = a3;
    ...
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Unprivileged process sends a crafted IOCTL/WSK request that ends in
   afd!AfdSanInitEndpoint.
2. Because the kernel prototype required only one argument, the extra
   registers (r9/r10/rdx/r8) still contain user-controlled values from
   the earlier call frame.
3. The function writes those values into *(r10+offset) without any
   validation.
4. Arbitrary kernel memory is overwritten, allowing privilege
   escalation.

Attack Vector
--------------------------------------------------------------------
Local: any low-privilege user that can create or manipulate AF_UNIX
(AFDSAN) sockets or issue specific AFD IOCTLs can trigger the routine
and supply the malicious register values.

Patch Description
--------------------------------------------------------------------
• Corrected function prototype to include the missing parameters.
• Destination pointer now obtained from a trusted field inside the SAN
  context (a2+0x18).
• Added _InterlockedIncrement64 + __fastfail to ensure valid endpoint
  lifetime and avoid under-flowed reference counts.
• Replaced blind pointer stores with bounded writes to (v3 + constant).
• Ancillary functions now use new reference helpers and gated feature
  checks, reducing future misuse.

Security Impact
--------------------------------------------------------------------
Before the fix a local attacker could perform an arbitrary 8-byte write
anywhere in kernel memory, leading to full SYSTEM compromise
(elevation of privilege).  No user interaction is required beyond
running exploit code.

Fix Effectiveness
--------------------------------------------------------------------
Pointer destinations are now derived exclusively from internal
structures, and the additional reference-count + fast-fail logic
provides runtime enforcement.  No further uncontrolled offset writes
are visible in the patched code path, so the specific arbitrary write
primitive is eliminated.  A full audit of all callers is still
recommended, but the patch appears to close the identified hole.
