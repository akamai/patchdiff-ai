{'change_count': 8, 'kb': 'KB5066835', 'patch_store_uid': '0e54175f-9f22-44cd-8cdd-4e0fede69033', 'cve': 'CVE-2025-58727', 'date': 1763403034.082913, 'confidence': 0.25, 'file': 'cdpsvc.dll'}
--------------------------------------------------------------------
CVE-2025-58727 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Connected Devices Platform Service (cdpsvc.dll) â€“ specifically
code that handles the "App Target List" reply inside
CDPComDevice::DeviceCallback::OnAppTargetListReceived().

Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow caused by incorrect size computation during
heap allocation (CWE-122).  Although the vendor advisory labels it as a
race condition (CWE-362), the patched code shows the immediate root
problem is an undersized allocation that leads to memory corruption.

Detailed Root Cause Analysis
--------------------------------------------------------------------
1. OnAppTargetListReceived() builds a std::function that ultimately
   invokes lambda_dde3f900c43be7a54739f39c59f549c9_::operator() (pre-
   patch).

2. The lambda receives:
     a1 -> context structure containing
            +0x08 : WORD *TargetCountPtr   (number of strings)
            +0x10 : QWORD *TargetArrayPtr  (array of char* received
                                            from the device)
     a2 -> output buffer whose field
            +0x40 : QWORD  PointerArray    (to be filled by lambda)

3. Pre-patch allocation logic:
        count = **(WORD **)(a1+8);           // number of targets
        buf   = CoTaskMemAlloc(count);       // ALLOCATES <count> BYTES
        *(QWORD *)(a2+0x40) = buf;           // stores the base pointer

   The code *assumes* that the buffer now holds an array of QWORDs and
   proceeds to write one 8-byte pointer per target:
        *(QWORD *)(buf + 8*index) = CoTaskMemAlloc(strLen);

4. When count > 0 the first write already exceeds the allocated size
   unless count >= 8.  For typical inputs (count 1-4) this corrupts the
   adjacent heap metadata (8-byte write vs 1-4 bytes allocated).

5. Subsequent strcpy_s() calls copy user-supplied strings into the
   newly allocated per-string buffers, providing attacker-controlled
   data that can overwrite freed-list pointers or neighboring objects.

6. cdpsvc runs as NT AUTHORITY\SYSTEM.  A local attacker able to make a
   crafted Connected-Device RPC call can therefore obtain arbitrary
   read/write within the service process and elevate privileges.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Pre-patch (lambda operator)
size  = **(unsigned __int16 **)(a1 + 8);   // number of items
ptr   = CoTaskMemAlloc(size);              // alloc <count> bytes
*(QWORD *)(a2 + 64) = ptr;
...
*(QWORD *)(ptr + 8 * v4) = CoTaskMemAlloc(v8); // 8-byte write
```
```c
// Post-patch
count = **(unsigned __int16 **)(a1 + 8);
size  = count;
if (FeatureEnabled)
    size *= 8;                             // allocate count*8 bytes
ptr   = CoTaskMemAlloc(size);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Client request (ICDP) -> cdpsvc!CDPComDevice::DeviceCallback::
OnAppTargetListReceived()
    -> constructs std::function wrapper
        -> invokes lambda operator()
            -> mis-sizes CoTaskMemAlloc()
            -> heap overflow while storing per-string pointers

Attack Vector
--------------------------------------------------------------------
A local, authenticated user can interact with the Connected Devices
Platform IPC interface and supply an App Target List containing an
arbitrary number of strings.  By specifying more than one target the
service allocates an undersized buffer and overwrites heap metadata,
allowing crafted data to pivot execution to attacker-controlled code
inside the SYSTEM service.

Patch Description
--------------------------------------------------------------------
The fix introduces:
1. A size computation that multiplies the target count by sizeof(QWORD)
   (8) before calling CoTaskMemAlloc().  This guarantees adequate space
   for the pointer array.
2. A feature flag gate (wil::FeatureImpl) so the change can be
   conditionally enabled.
3. Updated caller (OnAppTargetListReceived) to reference the new lambda
   symbol and modern std::function wrapper, but functional change is
   the corrected allocation size.

Security Impact
--------------------------------------------------------------------
Prior to the patch a non-privileged user could reliably corrupt the heap
in a SYSTEM process, leading to elevation of privilege or service
crash.  Exploitation is local-only and requires the attacker to issue a
crafted AppTargetList message.

Fix Effectiveness
--------------------------------------------------------------------
Allocating count*8 bytes eliminates the immediate overflow.  As long as
Feature_2578215227 is enabled on all supported systems the issue is
resolved.  If the flag is disabled or reverted, the vulnerability could
re-appear.  No additional synchronisation issues were addressed; none
were observed in the diff.
