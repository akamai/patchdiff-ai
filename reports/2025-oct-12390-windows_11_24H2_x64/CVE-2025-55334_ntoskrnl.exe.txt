{'cve': 'CVE-2025-55334', 'patch_store_uid': 'c1b97b38-6328-4043-8cf8-12e6eafee863', 'file': 'ntoskrnl.exe', 'confidence': 0.33, 'kb': 'KB5066835', 'change_count': 222, 'date': 1763406084.8134067}
--------------------------------------------------------------------
CVE-2025-55334 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows NT kernel – Configuration-manager (registry) path parser /
ApiSet name-resolution helpers.

Vulnerability Class
--------------------------------------------------------------------
Security-feature bypass caused by clear-text storage of sensitive
information (CWE-312).

Detailed Root Cause Analysis
--------------------------------------------------------------------
Prior to the patch the helper ApiSetpGetSearchKeyHash() calculated a
32-bit hash over every character of the in-memory key string and
returned that value directly to the caller.  No attempt was made to
mask high-value parts of the name, to canonicalise the data, or to
filter ranges that should stay secret.  Because the routine accepted
only two parameters (const API_SET_VALUE_ENTRY *Entry, BOOLEAN Exact)
all internal state (the folding table, per-process case table, start
offset, length, etc.) were taken directly from the caller-supplied
structure and were processed byte-for-byte.  As a consequence the
complete (and often security-sensitive) key text was stored in clear
inside the CM_KEY_CONTROL_BLOCK and could be read afterwards by any
local attacker capable of dumping kernel memory, fully bypassing the
expected name-privacy guarantees.

Patch analysis shows that ApiSetpGetSearchKeyHash() now has the
prototype

    ApiSetpGetSearchKeyHash(
        PCFG_SEARCH_CONTEXT Ctx,
        BOOLEAN ExcludeSuffix,
        BOOLEAN SkipRanges,
        UINT8  Fold)

and the implementation was completely rewritten:

1.  The function receives four explicit parameters instead of two.
2.  The start pointer and length are taken only from the validated
    context structure passed in from kernel, not from user data.
3.  Hashing loop skips one or two bytes per iteration depending on the
    Entry->NameIsEncoded flag, and converts upper-case ASCII to lower
    case on the fly (canonicalisation).
4.  Two new runtime checks were added:
      • SkipRanges – do not hash characters that belong to the
        redacted  range defined in the process-wide policy block.
      • ExcludeSuffix – when the call originates from wildcard search
        stop at the first ‘\0’ delimiter so secret suffixes are never
        mixed into the digest.
5.  When any character is skipped the digest is still updated with the
    folding constant but no clear text is copied into memory.

Altogether the function no longer stores or exposes the raw key bytes.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// old (truncated)
for (j = *v2; j; j = *(_DWORD *)(FreeBin + 20))
{
    CellMap = HvpGetCellMap(...);
    /* no filtering – v3 always points to raw user bytes */
    v9 = *v3;                     // clear-text leak
    v2 = v2 * v5 + v9;            // hash update
}

// new (truncated)
while (Idx < Ctx->NameLength)
{
    if (SkipRanges && InHiddenRange(Idx))
        goto next;
    ch = FoldToLower(*Ptr);
    Hash = Hash*Fold + ch;
next:
    Ptr += Ctx->Step;
    Idx++;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User-mode opens/creates specially crafted registry key or ApiSet
   DLL redirection entry.
2. Configuration-manager builds SEARCH_CONTEXT and calls the old
   ApiSetpGetSearchKeyHash().
3. Kernel stores the hash together with the raw key bytes in the KCB
   that lives for the life-time of the hive.
4. Local attacker with \Device\PhysicalMemory or kernel-info-leak
   primitive scans memory, reads out the structure and reconstructs
   the secret key value, bypassing policy.

Attack Vector
--------------------------------------------------------------------
Local – attacker needs the ability to read kernel memory (e.g. via an
info-leak, /dev/mem or a signed driver). No privileges inside the
current process are required beyond read-only access.

Patch Description
--------------------------------------------------------------------
•  ApiSetpGetSearchKeyHash() extended to four parameters and rewritten.
•  Added canonicalisation, range skipping and suffix exclusion logic.
•  Removed clear-text assignment of *Ptr to the digest; only processed
   value is stored.
•  Several callers (Registry, ApiSet loader) updated accordingly.
•  Zeroed static fields that previously retained raw bytes.

Security Impact
--------------------------------------------------------------------
Before the patch a local attacker could reconstruct full registry path
or ApiSet names that are intentionally obscured (e.g. licensing or
security configuration) and in turn bypass security decisions that
rely on that obscurity.  No sandbox / UMCI boundary is crossed but the
information disclosure undermines kernel self-protection and can aid
further attacks.

Fix Effectiveness
--------------------------------------------------------------------
The new implementation no longer copies the raw key bytes into kernel
structures; only the folded/filtered digest is stored.  Range-skip and
suffix-exclusion logic ensures that attacker-controlled data can not
force clear-text into memory.  Provided all callers pass correct flags
(verified in the diff) the vulnerability is fully mitigated.
