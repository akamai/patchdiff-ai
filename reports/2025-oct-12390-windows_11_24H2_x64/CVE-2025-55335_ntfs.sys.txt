{'cve': 'CVE-2025-55335', 'date': 1763403111.0202768, 'patch_store_uid': '8bc0026a-7877-4902-9e12-b9429032ed34', 'file': 'ntfs.sys', 'kb': 'KB5066835', 'change_count': 69, 'confidence': 0.24}
--------------------------------------------------------------------
CVE-2025-55335 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows NTFS file-system driver (ntfs.sys) – shared security
handling code (FCB.SharedSecurity, offset +0x208) and related helper
routines.

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use-After-Free combined with CWE-362: race condition / missing
inter-thread synchronisation.

Detailed Root Cause Analysis
--------------------------------------------------------------------
Each FCB keeps a cached pointer to a shared security descriptor at
offset +0x208 (FCB->SharedSecurity).  The object is reference counted
(1st long of the allocation).  Many code paths (NtfsQuerySecurity,
NtfsUpgradeFileSecurity, NtfsModifySecurity, TxfDoModifySecurityWork,
NtfsPurgeSharedSecurity, NtfsRepairStandardInformationSecurityId …)
read, write, dereference or replace that pointer.

Before the patch:
  •  Callers accessed FCB->SharedSecurity without any lock.
  •  No reference was taken when the pointer was read; code used the
     embedded SECURITY_DESCRIPTOR directly and later called
     NtfsDereferenceSharedSecurity() unconditionally.
  •  Concurrent threads could meanwhile free the same block (e.g. in
     NtfsModifySecurity, NtfsDeleteFromAttributeList, …).  This left a
     dangling pointer that was still being dereferenced by the first
     thread – classic UAF.
  •  The only implicit protection was that FCB->MainResource had to be
     acquired for some operations, but many fast-path query helpers ran
     without it, so a race window remained.

Patch changes (all guarded by new feature flag
Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage):
  •  Introduces a dedicated push-lock at FCB+0x216 to protect the
     SharedSecurity field.
  •  Readers now acquire the lock in shared mode, increment the ref-
     count using _InterlockedIncrement(), and release the lock.
  •  Writers (e.g. NtfsModifySecurity / NtfsUpgradeFileSecurity)
     acquire the same push-lock exclusively before swapping the
     pointer, guaranteeing mutual exclusion with readers.
  •  Dereference paths were updated to perform
     _InterlockedExchangeAdd() and free the block only when the count
     hits zero.
  •  All affected functions were updated to the new contract; several
     fast-paths that previously returned VOID now return NTSTATUS so
     that failure can be propagated.

Result: the SharedSecurity object can no longer be freed while still in
use – the UAF is removed.

Vulnerability Code Snippets
--------------------------------------------------------------------
Old (NtfsQuerySecurity):
```c
ObjectsSecurityDescriptor =
    (PSECURITY_DESCRIPTOR)(*(_QWORD *)(a3 + 208) + 28);
SeQuerySecurityDescriptorInfo(...,&ObjectsSecurityDescriptor);
/* later */
if (v9) NtfsDereferenceSharedSecurity(&v15);
```
No locking, no refcount.

New:
```c
ExAcquirePushLockSharedEx(a3 + 216, 0);
v9 = *(volatile signed __int32 **)(a3 + 208);
P  = v9;
_InterlockedIncrement(v9);      // take reference
ExReleasePushLockEx(a3 + 216,0);
ObjectsSecurityDescriptor = (PSECURITY_DESCRIPTOR)(v9 + 7);
...
v13 = _InterlockedExchangeAdd(v9, 0xFFFFFFFF);
if (v13 <= 1) ExFreePoolWithTag(v9,0);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Thread-A: NtfsQuerySecurity() reads FCB->SharedSecurity without lock.
2. Thread-B: NtfsModifySecurity() frees and replaces the same pointer.
3. Original allocation is returned to pool – memory can be
   re-allocated.
4. Thread-A continues, uses freed SECURITY_DESCRIPTOR, leading to
   arbitrary kernel memory misuse.

Attack Vector
--------------------------------------------------------------------
Local attacker needs the ability to create two concurrent I/O paths to
the same NTFS file – e.g. one thread repeatedly querying security (FSCTL
or IRP_MJ_QUERY_SECURITY) while another thread changes the file’s
security descriptor or deletes the file.  No privileges beyond normal
file access are required.

Patch Description
--------------------------------------------------------------------
• Added per-FCB push-lock (+0x216) protecting SharedSecurity.
• Added proper reference counting using Interlocked* APIs.
• All functions that access the field now:
    – acquire the lock (shared or exclusive),
    – take / drop a reference safely,
    – release the lock.
• Writers update FCB->280 / 208 consistently.
• Affected call-sites were changed to return NTSTATUS and to propagate
  errors.

Security Impact
--------------------------------------------------------------------
Unauthenticated local users could trigger a race causing use-after-free
of a kernel-mode object, leading to memory corruption, elevation of
privilege, and potential arbitrary code execution in kernel context.
A system crash is also possible.

Fix Effectiveness
--------------------------------------------------------------------
All entry points now serialise access via the new push-lock and honour
reference counts.  The SharedSecurity block cannot be freed while held,
and free is guaranteed to happen exactly once.  The original race
condition and UAF are therefore eliminated.
