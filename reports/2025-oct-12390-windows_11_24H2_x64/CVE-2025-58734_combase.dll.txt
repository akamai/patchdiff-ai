{'cve': 'CVE-2025-58734', 'change_count': 13, 'date': 1763407789.965682, 'file': 'combase.dll', 'patch_store_uid': 'd1e9d746-720d-4647-8cb2-ec67327d5cc6', 'confidence': 0.34, 'kb': 'KB5066835'}
--------------------------------------------------------------------
CVE-2025-58734 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows COM run-time (combase.dll) – channel / marshaling
helpers, primarily NdrExtpProxyInitialize and related RPC proxy
helpers that manage IRpcChannelBuffer reference counting.

Vulnerability Class
--------------------------------------------------------------------
Use After Free (CWE-416)

Detailed Root Cause Analysis
--------------------------------------------------------------------
NdrExtpProxyInitialize is executed by every generated COM proxy stub
before the first remote call.  Its job is to copy the caller supplied
IRpcChannelBuffer* (held in pThis[3]) into the per-call _MIDL_STUB_
MESSAGE structure and take a reference so that the channel object
remains alive for the duration of the call.  The relevant excerpt is
reproduced in the next section.

The routine recovers the AddRef function pointer from the channel
vtable (v8->AddRef).  It then performs a dubious equality test:

  if (AddRef == &CClientChannel::AddRef)
        CClientChannel::AddRef(v8);
  else
        AddRef();                  // <-- no parameter passed

On x64 the this-pointer must be delivered in RCX.  The indirect call
made through AddRef() in the else branch passes *no* argument, so RCX
contains whatever value happened to be in the register at that moment
(routinely a stale stack pointer).  Any channel object whose AddRef
implementation is *not* exactly CClientChannel::AddRef therefore
executes with an invalid this-pointer.  Results are undefined but most
commonly:

1. The real object never has its reference count incremented.
2. When the proxy later issues NdrExtpProxySendReceive, the channel
   object may already have been released and freed.
3. The freed memory is then used as an IRpcChannelBuffer, yielding a
   classic use-after-free that an attacker can exploit by re-allocating
   controlled data in the same region.

Because the bug is hit during proxy initialisation it is reachable
from *any* marshalled interface pointer and requires no special
privileges – the attacker only needs to arrange for a crafted channel
class (or any non-CClientChannel implementation) to be supplied to the
proxy.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// combase!NdrExtpProxyInitialize  (before patch)
...
v8 = (IRpcChannelBuffer *)pThis[3];
...
AddRef = (void (*)(void))v8->AddRef;
if ((char *)AddRef == (char *)CClientChannel::AddRef)
    CClientChannel::AddRef(v8);      // correct: passes v8 in RCX
else
    AddRef();                        // WRONG: RCX not initialised
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Client receives a marshalled interface pointer.
2. CoUnmarshalInterface -> proxy stub -> NdrExtpProxyInitialize.
3. Proxy holds reference to supplied IRpcChannelBuffer.
4. AddRef executed without this-pointer – no refcount increment.
5. Reference released elsewhere, channel buffer freed.
6. First method call on proxy -> NdrExtpProxySendReceive uses freed
   buffer, leading to memory corruption and potential code execution.

Attack Vector
--------------------------------------------------------------------
Local or remote attacker supplies a crafted COM object or marshalled
stream that results in a proxy holding a non-CClientChannel channel
implementation.  Typical delivery vectors:

• Malicious document/installer that embeds a custom channel object.
• Any medium integrity process interacting with an elevated COM
  service (lateral privilege escalation).

Patch Description
--------------------------------------------------------------------
Not available in the supplied diff.  (The after-patch listings were
omitted, so the exact code change is unknown.)

Security Impact
--------------------------------------------------------------------
A successful attacker gains the ability to execute arbitrary code in
the context of the process that unmarshals the interface pointer.
When that process runs with elevated privileges (e.g., SYSTEM service
or admin UI), full privilege escalation is possible.  The condition is
triggered before any application-level checks, so authentication or
package identity does not mitigate it.

Fix Effectiveness
--------------------------------------------------------------------
No post-patch code was provided; therefore correcteness of the fix
cannot be verified.  A complete mitigation would require ensuring that
AddRef is always invoked with a valid this-pointer (for example
`v8->AddRef(v8);` or `IUnknown::AddRef(v8)`) regardless of the concrete
channel implementation, and auditing all similar call sites.
