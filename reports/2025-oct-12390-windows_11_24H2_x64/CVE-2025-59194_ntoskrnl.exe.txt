{'date': 1763406313.3691475, 'kb': 'KB5066835', 'change_count': 222, 'patch_store_uid': 'c1b97b38-6328-4043-8cf8-12e6eafee863', 'cve': 'CVE-2025-59194', 'file': 'ntoskrnl.exe', 'confidence': 0.37}
--------------------------------------------------------------------
CVE-2025-59194 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows kernel, ntoskrnl.exe, Configuration-Manager routine
CmpInitializeThreadInfo (affinity bookkeeping for the current
thread).

Vulnerability Class
--------------------------------------------------------------------
Use of uninitialized resource / variable (CWE-908).

Detailed Root Cause Analysis
--------------------------------------------------------------------
CmpInitializeThreadInfo receives a caller-supplied _KAFFINITY_EX
structure pointer (a1) and synchronises it with the threadâ€™s cached
user affinity block stored at CurrentThread[1].UserAffinity ("result")

Code path when a per-thread affinity block already exists:
    * first 16 bytes (Count, Size, Reserved, Bitmap[0]) are copied with
      a 128-bit move
    * pointer to the source block is then written into a1 so caller can
      reach the original object

Missing step (pre-patch): the second static bitmap quadword
StaticBitmap[1] (offset +20h of _KAFFINITY_EX on x64) was NOT copied.
Therefore a1->StaticBitmap[1] contained whatever happened to be in the
caller-supplied memory.  The value is then assigned back to
CurrentThread[1].UserAffinity, so any later scheduler or registry code
that reads the affinity mask consumes uninitialised kernel data.

Code path when no previous block exists also failed to clear the same
field, leaving stale stack/heap bytes in StaticBitmap[1].

Because scheduler and configuration-manager helpers treat the full mask
as trusted, the stale contents propagate and may:
  - leak previous kernel memory to user mode (information disclosure)
  - create malformed affinity masks that steer subsequent pointer maths
    or bitmap walks, leading to out-of-bounds accesses and elevation of
    privilege.

Parameters / structures involved
  _KAFFINITY_EX
     +0  USHORT Count
     +2  USHORT Size
     +4  ULONG  Reserved
     +8  ULONG64 StaticBitmap[2]  <-- first two bitmap qwords
             StaticBitmap[0] duplicated at Bitmap[0]
             StaticBitmap[1] left uninitialised pre-patch
  KTHREAD.UserAffinity -> pointer to the above structure

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
if (result) {
    *(_OWORD *)&a1->Count = *(_OWORD *)&result->Count; // copies 16 B
+   a1->StaticBitmap[1]  = result->StaticBitmap[1];    // added patch
    *(_QWORD *)&a1->Count = result;
} else {
    a1->Bitmap[0] = 0i64;
+   a1->StaticBitmap[1] = 0i64;                        // added patch
    *(_QWORD *)&a1->Count = 0i64;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User-mode code performs an operation that creates a registry worker
   thread (exact call path unknown).
2. Kernel calls CmpInitializeThreadInfo with a caller-allocated
   _KAFFINITY_EX on the thread stack/heap.
3. If the thread already has a UserAffinity block, the function copies
   only the first quadword, leaves StaticBitmap[1] untouched.
4. The partially initialised object is re-assigned to
   CurrentThread[1].UserAffinity and later consumed by scheduler / CMP
   helpers, exposing or mis-using the uninitialised field.

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker able to run code and trigger registry or
scheduler operations that repeatedly invoke CmpInitializeThreadInfo
while controlling the memory backing the _KAFFINITY_EX parameter.  No
special privileges are required beyond the ability to execute code on
an affected system.

Patch Description
--------------------------------------------------------------------
The fix adds explicit initialisation of the second bitmap quadword in
both code paths:
  * When a previous affinity block exists, copy StaticBitmap[1] from the
    source structure.
  * When no block exists, zero StaticBitmap[1].
This guarantees that the full 128-bit affinity mask is initialised
before the pointer is exposed to the rest of the kernel.

Security Impact
--------------------------------------------------------------------
Leaving StaticBitmap[1] uninitialised allows leakage of 8 bytes of
kernel memory per call and may corrupt scheduler affinity logic.  An
attacker can exploit the memory leak to bypass KASLR or groom kernel
heap state, ultimately elevating privileges from user to SYSTEM.

Fix Effectiveness
--------------------------------------------------------------------
The patch fully addresses the identified field by copying/zeroing it in
all paths, eliminating the specific uninitialised use.  No functional
regression expected.  A cursory audit of similar memcpy patterns inside
ntoskrnl is advised to ensure no other bitmap elements are omitted.
