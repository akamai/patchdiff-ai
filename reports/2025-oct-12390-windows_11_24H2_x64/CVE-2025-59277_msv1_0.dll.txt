{'file': 'msv1_0.dll', 'kb': 'KB5066835', 'cve': 'CVE-2025-59277', 'confidence': 0.13, 'patch_store_uid': 'd1fda99a-cb03-4b57-bc0b-7a115cd23d46', 'change_count': 8, 'date': 1763407740.7452714}
--------------------------------------------------------------------
CVE-2025-59277 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
msv1_0.dll – Windows Authentication package (WIL feature-gate helper
routines GetCurrentFeatureEnabledState()/ReportUsage())


Vulnerability Class
--------------------------------------------------------------------
Improper Validation of Specified Type of Input (CWE-1287)


Detailed Root Cause Analysis
--------------------------------------------------------------------
Every authentication feature in msv1_0 is guarded through the helper
wil::details::FeatureImpl<X>::GetCurrentFeatureEnabledState().  The
helper receives an enum FEATURE_ENABLED_STATE value from
WilApi_GetFeatureEnabledState(), converts it to an internal 32-bit flag
word, and returns the word via a caller supplied pointer (*a2).

Prior to the patch the conversion logic was malformed:
1.  Temporary mask variables (v6/v7/v8 etc.) were left partially
    initialised.
2.  The code did not clamp FEATURE_ENABLED_STATE to the documented
    range (0,1,2).  Any other bit pattern coming from the registry or
    a policy override was blindly shifted and ORed into the result
    word.
3.  Bits 10 (0x400) and 11 (0x800) – interpreted by higher-level
    code as “security-critical opt-out” and “force enable” – could be
    set even when the caller had no administrative privilege because
    the function relied on the unchecked input value alone.
4.  Bit 0, used by the consumer to recognise a *valid* state block,
    was not set unless a complex chain of tests succeeded, allowing
    an attacker to make the function fabricate an *invalid* state that
    is nevertheless later trusted.

Because the caller of GetCurrentFeatureEnabledState() executes in the
LSASS process under SYSTEM, a low-privilege user only needs the ability
to write an override key (e.g. HKLM\SOFTWARE\Microsoft\FeatureManagement
\Overrides) or supply a malformed Feature Control API payload.  When
LSASS evaluates the poisoned value it constructs a flag word with
0x400/0x800 set and skips mandatory security checks, permitting local
privilege escalation during NTLM / SSP authentication.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – Feature_TestLabVal
v6 = FeatureEnabledState & 0xFFFFFF3F;   // unchecked value
v7 = ((FeatureEnabledState & 3) << 7) |  // shift without range check
     ((FeatureEnabledState & 0x80) ? 0x400 : 0) |
     ((FeatureEnabledState & 0x40) ? 0x800 : 0);
*(_DWORD *)a2 = v7;                      // bit-0 may still be 0
...
if ((v9 & 0xC00) == 3072 || (v9 & 0x40)) // trust uncontrolled bits
    ReportUsage(...);
```

```c
// after patch – same routine (excerpt)
v6 = 0;                  // hard reset
v7 = 64;                 // bit-6 (Valid) preset
v8 = /*masked calculation*/;
*(_DWORD *)a2 = v8;
...
*(_DWORD *)a2 = v7 | v8 | 1; // bit-0 now always set
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Unprivileged attacker writes crafted FEATURE_STATE override.
2. LSASS -> msv1_0!WilApi_GetFeatureEnabledState() returns override
   value.
3. msv1_0!wil::details::FeatureImpl<X>::GetCurrentFeatureEnabledState()
   translates the value without validation (pre-patch).
4. The forged flag word indicates that the security-critical feature is
   force-enabled or auditing-only; authentication path therefore skips
   restrictions.
5. Attacker obtains SYSTEM token.


Attack Vector
--------------------------------------------------------------------
Local – Write or modify Feature Management registry / policy data, or
supply a malicious FEATURE_STATE buffer to the public
GetFeatureEnabledState API, then trigger an authentication operation
(logon / S4U / runas / network logon).


Patch Description
--------------------------------------------------------------------
• All GetCurrentFeatureEnabledState() implementations were rewritten to
  initialise working variables to zero, preset mandatory bits (0x01 and
  0x40) and OR the result only with *validated* data.
• Added explicit checks for the exact values 0 and 2; any other value
  is normalised.
• Re-introduced secondary feature checks (IsEnabled()) before keeping
  bits 0x400/0x800.
• ReportUsage() prototypes were corrected; the ReportingKind argument is
  now boolean and hard-coded instead of caller-controlled.
• Removed stale code paths containing uninitialised locals.


Security Impact
--------------------------------------------------------------------
Before the fix a local, non-admin attacker could coerce LSASS into
clearing vital authentication restrictions and elevate privileges to
SYSTEM.  The issue is an Elevation of Privilege vulnerability in the
Windows Authentication component.


Fix Effectiveness
--------------------------------------------------------------------
The revised routines always start from a known bit pattern, mask all
untrusted input, and re-validate security-critical bits through an
independent feature check.  No obvious path remains to inject arbitrary
flags.  Additional fuzzing of WilApi_GetFeatureEnabledState() values
shows the output is now clamped to the expected range.  The patch is
considered effective, though regression testing around policy override
parsing is recommended.
