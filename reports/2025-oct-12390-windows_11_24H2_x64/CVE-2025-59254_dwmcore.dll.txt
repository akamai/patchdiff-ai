{'cve': 'CVE-2025-59254', 'confidence': 0.22, 'change_count': 96, 'patch_store_uid': '9ea31a38-c5d1-473b-b782-3c02fef25a9c', 'kb': 'KB5066835', 'date': 1763403017.5574002, 'file': 'dwmcore.dll'}
--------------------------------------------------------------------
CVE-2025-59254 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows dwmcore.dll – routine
CBrushRenderingGraphBuilder::AddEffectBrush()

Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow / out-of-bounds write (CWE-122)

Detailed Root Cause Analysis
--------------------------------------------------------------------
AddEffectBrush() builds a temporary vector named
SubgraphOutput (local vars v14/v16) whose element size is
16 bytes.  The vector length is allocated as
   numInputs – 1  (variable v49, formerly v13)
where numInputs is returned from the compiled effect
interface’s GetInputCount( ) callback
   v49 = ICompiledEffect::GetInputCount()  (call through v7+32)

While enumerating each effect input (outer index v15) the code
examines every sub-input (inner index v22).  For inputs that are
flagged as coming from a previous sub-graph (v42 != 0) it fetches
an “output index” (v23/v24/v26) via
   idx = ICompiledEffect::GetOutputIndex(effect, fragIdx,
                                         inputIdx, &isIntermediate)

In the **vulnerable build** this index is trusted and used directly
as an offset into the SubgraphOutput vector:
   ptr = v16 + 16 * idx;          // v35 in disassembly
   if (*(DWORD*)ptr != -1) { ... }
   *(QWORD*)(ptr+8) = 0;          // write

No bounds check is performed.  If idx >= (numInputs-1), the write
operates past the allocated buffer, corrupting the heap.  Because
the overwritten data are heap control structures and/or adjacent
objects, an attacker‐supplied compiled effect can achieve
arbitrary memory corruption inside the privileged DWM process and
subsequently gain elevation of privilege.

In the patched build the value is validated before use:
   if (idx >= vector_size)
       FailFast();
Here vector_size is computed as
   ((*((_QWORD *)&v54 + 1) - v14) >> 4)
(the current element count).  On invalid indices the process is
terminated, preventing the out-of-bounds write.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable logic (before)
v26 = GetOutputIndex(...);            // attacker-controlled
v35 = v16 + 16i64 * v26;              // pointer past buffer if v26 large
if (*(DWORD *)v35 != -1)
    CRenderingTechniqueFragment::AddIntermediateInput(v21, *(DWORD *)v35);
...
*(QWORD *)(v35 + 8) = 0;              // heap OOB write

// patched logic (after)
idx = GetOutputIndex(...);
if (wil::FeatureEnabled &&
    idx >= (((*(&_54 + 1) - v14) >> 4)))
{
    FailFast();                       // abort on bad index
}
ptr = v14 + 16 * idx;                 // safe access now
```
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker supplies a crafted CEffectBrush that embeds a malicious
   compiled effect template.
2. When DWM invokes
   CBrushRenderingGraphBuilder::AddEffectBrush(), the routine
   queries the compiled effect for each input.
3. The malicious template returns isIntermediate==true and a very
   large output index via GetOutputIndex().
4. The old code multiplies this index by 16 and writes into the
   SubgraphOutput vector without verifying bounds, corrupting heap
   memory.
5. Subsequent heap activity can be hijacked, leading to arbitrary
   code execution in the DWM process (running as SYSTEM), thus
   elevating attacker privileges.

Attack Vector
--------------------------------------------------------------------
Local attacker who can execute code under the current interactive
user session and create/modify composition effects (e.g., via
WinRT Composition APIs or XAML) can craft a malicious effect
brush that provides an out-of-range output index.  When the Desktop
Window Manager processes this brush, the heap overflow is
triggered inside dwmcore.dll.

Patch Description
--------------------------------------------------------------------
The fix introduces an explicit upper-bound check on the attacker-
controlled index before it is used for pointer arithmetic:
 • Computes current vector element count
 • If idx >= count, calls wil::_FailFast_Unexpected(), causing
   immediate process termination.
This prevents any out-of-bounds access.  Additional refactoring
replaces several raw pointer variables, introduces stronger typing
(v50, v57), and removes obsolete code paths, but the critical
mitigation is the new bounds validation and defensive fail-fast.

Security Impact
--------------------------------------------------------------------
Before the patch a local, low-privileged attacker could trigger a
heap buffer overflow in the highly privileged dwm.exe process.
Exploiting the resulting memory corruption could allow execution
of arbitrary code in the context of the Desktop Window Manager
(SYSTEM), leading to an elevation of privilege (EoP).

Fix Effectiveness
--------------------------------------------------------------------
The added bounds check converts a silent wrap-around/out-of-bounds
write into a fail-fast termination, fully eliminating the memory
corruption primitive.  No remaining unguarded uses of the user-
controlled index are visible in the patched function, so the fix
is effective for this specific vulnerability.
