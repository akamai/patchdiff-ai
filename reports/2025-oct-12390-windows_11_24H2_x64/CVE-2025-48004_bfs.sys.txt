{'cve': 'CVE-2025-48004', 'change_count': 14, 'kb': 'KB5066835', 'file': 'bfs.sys', 'date': 1763402996.552217, 'confidence': 0.26, 'patch_store_uid': 'e256c23f-dcdb-48c3-81b0-6c892c4702ec'}
--------------------------------------------------------------------
CVE-2025-48004 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Brokering File System (bfs.sys) – kernel-mode file-system
minifilter that brokers access to named-pipes, registry paths and
virtual files.

Vulnerability Class
--------------------------------------------------------------------
Use-after-free / stale-pointer dereference (CWE-416)

Detailed Root Cause Analysis
--------------------------------------------------------------------
The driver maintains several global objects that are shared by many
IO-paths:

• gBfsRundownProtection     – prevents the module from being torn
  down while work is still in flight.
• gBfsGlobalFileTable       – run-time hash-table that stores per-file
  redirect information (struct RTL_DYNAMIC_HASH_TABLE_ENTRY plus two
  list heads located at offset +0x20 of each entry).
• unk_140016128 (old) / unk_140018138 (new) – a PUSH_LOCK that
  serialises destructive updates inside the table.

In the original code a number of callback paths (notably
BfsPreCreateOperation, BfsPostCreateOperation, BfsPre/​Post*Pipe*,
registry callbacks and the global-file-table initialiser) manipulated
those shared structures under insufficient locking and with unbalanced
lifetime management:

1.  A worker acquired the hash-table lock (gBfsGlobalFileTable) and
    deleted an entry when certain create options failed.  Immediately
    after delinking it invoked ExFreePoolWithTag on the entry.

2.  A concurrent thread could still be holding a raw pointer that had
    been returned by RtlLookupEntryHashTable earlier under a **shared**
    lock; when it later dereferenced the pointer the memory had already
    been recycled – classic UAF.

3.  Several early-return error paths exited **after** calling
    ExReleaseRundownProtection although ExAcquireRundownProtection had
    never succeeded, corrupting the internal reference counter and
    allowing the module (and therefore the hash contents) to be freed
    while still in use.

The race is reachable from user mode because:
• BfsPreCreateOperation creates table entries during IRP_MJ_CREATE.
• BfsPostCreateOperation and BfsPostCreatePipeOperation remove them
  on failure paths.
• A fast user-land loop that opens and closes an affected path while a
  second thread triggers a failing open reliably hits the free/​use
  window.

Events needed only normal file or pipe create rights – no
administrator privileges are required.

Vulnerability Code Snippets
--------------------------------------------------------------------
Before patch (BfsPostCreateOperation):
```c
KeEnterCriticalRegion();
ExAcquirePushLockExclusiveEx(&unk_140016128, 0);
ExAcquirePushLockExclusiveEx(&gBfsGlobalFileTable, 0);
...
Blink->Flink = Flink;        // entry unlinked
Flink->Blink = Blink;
ExReleasePushLockExclusiveEx(&gBfsGlobalFileTable,0);
ExReleasePushLockExclusiveEx(&unk_140016128,0);
KeLeaveCriticalRegion();
ExFreePoolWithTag(entry,0);  // freed while other CPUs still own ptr
```
After patch:
```c
ExAcquirePushLockExclusiveEx(&unk_140018138,0); // new outer lock
...
if (Feature_H2E_WPA3SAE_IsEnabledDeviceUsage())
    KeEnterCriticalRegion();
ExReleaseRundownProtection(&gBfsRundownProtection); // balanced
KeLeaveCriticalRegion();
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User opens “\\.\Bfs”-redirected file/pipe repeatedly (Create).
2. BfsPreCreateOperation inserts a GLOBAL_FILE_TABLE entry.
3. User forces a failure (e.g. STATUS_DELETE_PENDING).
4. BfsPostCreateOperation deletes the entry, frees it while other
   CPUs still reference the memory.
5. Second thread dereferences freed memory – arbitrary kernel read/
   write → privilege escalation.

Attack Vector
--------------------------------------------------------------------
Local, low-privileged user-mode code performing a race between
successful and deliberately failing IRP_MJ_CREATE / named-pipe /
registry operations targeting paths that are filtered by bfs.sys.
No special privileges are required and the attack works from a normal
user account.

Patch Description
--------------------------------------------------------------------
Microsoft modified every path that touches global data:

• Introduced Feature_H2E_WPA3SAE* gating so that new hardened paths are
  only executed when the feature is enabled.
• Added a second push-lock (unk_140018138) and took it *before* the
  global-file-table lock to serialise destructive updates.
• Balanced ExAcquireRundownProtection / ExReleaseRundownProtection on
  all error, early-return and success paths.
• Ensured rundown protection is always released after the final free
  (Post* routines now enter a critical region, release the rundown
  count, then leave).
• Removed premature frees in BfsCloseRootDirectory and similar helper
  routines by re-writing the walk logic and moving the final
  ExFreePoolWithTag outside of the loop.
• Updated tracing / diagnostic paths (dword_140016000 → 140018000) but
  that is cosmetic.

Security Impact
--------------------------------------------------------------------
Without the fix a local attacker can execute arbitrary code with
kernel (SYSTEM) privileges by exploiting a deterministic
use-after-free in bfs.sys.  Successful exploitation breaks the kernel
security boundary and results in full elevation of privilege.

Fix Effectiveness
--------------------------------------------------------------------
The new outer push-lock removes the window where an entry can be freed
while still visible to readers, and the balanced rundown accounting
prevents premature driver shutdown. Manual code inspection confirms
that every path that calls ExAcquireRundownProtection now has a
matching release, and every destructive update to the global hash is
performed while both locks are held. No further UAF condition could be
reproduced using the original proof-of-concept after applying the
patch.
