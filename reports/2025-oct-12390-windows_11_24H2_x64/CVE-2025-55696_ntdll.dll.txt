{'change_count': 38, 'confidence': 0.19, 'patch_store_uid': 'b14e8e60-c1b7-44d3-9673-95c544b337a0', 'kb': 'KB5066835', 'date': 1763407777.2180753, 'file': 'ntdll.dll', 'cve': 'CVE-2025-55696'}
--------------------------------------------------------------------
CVE-2025-55696 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
ntdll!RtlVirtualUnwind, ntdll!RtlVirtualUnwind2 and
ntdll!RtlpUnwindPrologue – user-mode x64 unwinder helpers that parse
and manipulate CONTEXT/XSTATE records while walking a thread’s call
stack.


Vulnerability Class
--------------------------------------------------------------------
Untrusted pointer / structure dereference leading to out-of-bounds
read-write (aka memory corruption).  Closest CWEs: CWE-822 and
CWE-787.


Detailed Root Cause Analysis
--------------------------------------------------------------------
The three routines consume a caller-supplied CONTEXT structure.  If
the CONTEXT advertises extended state (bit 0x40 –
CONTEXT_XSTATE/CONTEXT_EXCEPTION_ACTIVE) the code expects a second
embedded header (CONTEXT[1]) to describe the size and offset of the
XSTATE area:
  P1Home      – size of the legacy CONTEXT
  P3Home      – size of the XSTATE data
  P2Home.hi   – supposed to be 1232 (sizeof(CONTEXT))
  P2Home.lo   – byte offset from CONTEXT to the XSTATE buffer

Before the patch the functions tried to validate the caller’s
ContextFlags with hand-rolled bit-tests and a few range checks.  The
logic contained several gaps:
1. A single failing test immediately fell through to normal
   processing, so many illegal flag combinations were accepted.
2. Negative return paths were not taken for STATUS_INVALID_PARAMETER
   (0xC000000D, value ‑1073741811).  This allowed a crafted set of
   flags to bypass the check entirely.
3. If the (partial) check passed, the code used the attacker-controlled
   P2Home offset to compute pointers such as
     (char *)&Context[1] + P2Home
   and later wrote register values and shadow-stack data through those
   pointers without further bounds checking.  A tiny offset or integer
   underflow therefore redirected the write outside the allocated
   buffer, corrupting adjacent memory.
4. RtlpUnwindPrologue repeated the same pattern when it tried to locate
   the Extended Feature 0x0B (machine-frame continuation) inside the
   XSTATE area; the location was calculated manually and trusted.

Because all three helpers run inside ntdll (mapped at fixed addresses
in every process) an unprivileged process could craft a CONTEXT/XSTATE
pair and call RtlVirtualUnwind* (directly or indirectly via C++ EH or
unwind-helper APIs).  When the unwinder executed it would overwrite
controlled process memory, enabling arbitrary code execution in the
context of the current process and, through subsequent attacks against
system services, local privilege escalation.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// pre-patch (RtlVirtualUnwind)
if ((ContextFlags & 0x100040) == 0x100040) {
    P1Home = Context[1].P1Home;
    P3Home = Context[1].P3Home;
    ...
    if ( ... ||
         (struct _CONTEXT *)((char *)&Context[1] +
                             SLODWORD(Context[1].P2Home)) != Context ) {
        Context->ContextFlags &= 0xFFFFFFBF;   // but pointer already
                                              // dereferenced above
    }
}
```
```c
// post-patch
status = RtlpValidateContextFlags(Context->ContextFlags, 0);
if (status < 0) {
    Context->ContextFlags = 0x10000B;   // sanitize and bail
    ...
}
...
status_ok:
if ((Context->ContextFlags & 0x100040) == 0x100040) {
    ...
    if (bad_range)
        Context->ContextFlags &= ~0x40; // mask XSTATE, *before* use
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker builds fake CONTEXT with:
   • ContextFlags = 0x100040 (CONTROL|XSTATE)
   • Context[1].P2Home = small/negative offset
   • Context[1].{P1Home,P3Home} adjusted to satisfy minimal range test
2. Attacker calls any API that eventually executes RtlVirtualUnwind*
   while processing the crafted CONTEXT.
3. Manual validation accepts the flags path; pointer arithmetic yields
   address outside the buffer.
4. Subsequent unwinder write corrupts memory → arbitrary code exec.


Attack Vector
--------------------------------------------------------------------
Local.  Any user-mode code able to supply a forged CONTEXT/XSTATE to an
unwind helper (e.g. through RtlUnwindEx, RaiseException with hijacked
stack, or custom SEH frames) can hit the vulnerable path.  No special
privileges are required.


Patch Description
--------------------------------------------------------------------
1. Introduced common helper RtlpValidateContextFlags() and replaced all
   ad-hoc flag screens with this routine.
2. Treats STATUS_INVALID_PARAMETER (-1073741811) as fatal – caller’s
   CONTEXT is forcibly converted to a minimal safe set (0x10000B).
3. When the XSTATE bit is present additional size/offset checks are
   preserved but now executed *before* any pointer use; failing them
   clears bit 0x40 so extended state is ignored.
4. RtlpUnwindPrologue now calls RtlLocateExtendedFeature() instead of
   recomputing the pointer by hand and updates machine-frame bookkeeping
   only if the located feature header is present and marked valid.
5. Multiple index variables were changed from signed to unsigned to
   remove wrap-around corner cases.


Security Impact
--------------------------------------------------------------------
Pre-patch an attacker could achieve memory corruption in ntdll’s data
segment or on the application stack, leading to process compromise and
potential elevation of privilege via crafted CONTEXT records.  Post
patch the CONTEXT is strictly validated and invalid combinations are
rejected or neutered, closing the write-what-where primitive.


Fix Effectiveness
--------------------------------------------------------------------
The centralisation of validation logic and elimination of manual
pointer maths comprehensively blocks the previously exploitable paths.
No remaining untrusted dereferences were observed in the patched code.
A negative status from RtlpValidateContextFlags halts further
processing, preventing misuse even if new flag combinations emerge.

