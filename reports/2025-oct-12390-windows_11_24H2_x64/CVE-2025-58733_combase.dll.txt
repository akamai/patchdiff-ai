{'file': 'combase.dll', 'confidence': 0.33, 'patch_store_uid': 'd1e9d746-720d-4647-8cb2-ec67327d5cc6', 'change_count': 13, 'kb': 'KB5066835', 'cve': 'CVE-2025-58733', 'date': 1763406148.6111574}
--------------------------------------------------------------------
CVE-2025-58733 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft COM base (combase.dll) – class–activation cache
(CClassCache) logic, specifically the functions
CClassCache::CClassEntry::Create and
CClassCache::CClassEntry::Complete.

Vulnerability Class
--------------------------------------------------------------------
Use-After-Free / stale pointer following a lock release
(CWE-416).

Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  During COM activation the runtime creates a new cache entry
    by calling
       CClassEntry::Create(rclsid, dwClsHash, pCI, … , &pCE)
    while holding the global writer lock _mxs.

2.  In order to obtain Treat-As information, Create() calls
       CClassEntry::Complete(pCE, treatAsClsid, &fLockReleased)
    which may temporarily release the writer lock.  When the lock
    is dropped another thread can insert a fully-initialised entry
    for the same CLSID into the global hash table and destroy the
    incomplete one that *this* thread is still holding through the
    **pCE** output parameter.

3.  On return, the old implementation trusted the pointer stored in
    *pCE (variables v11 / v14) even when the function signalled that
    the lock had been released (fLockReleased == 1).  It immediately
    dereferenced fields such as
        v14->_dwFlags
        v14->_hashNode
        v14->_guids
    to decide whether to link the entry into
    CClassCache::_ClassEntries or to free it.  If another thread had
    already freed the object, these reads operated on reclaimed
    memory, resulting in a classic use-after-free.

4.  A similar pattern existed in CClassEntry::Complete where, after
    releasing and re-acquiring the writer lock, the code re-used the
    stale *this pointer when building the Treat-As list, again
    without re-validating that the entry was still live.

5.  The corrupted cache entry resides in process-wide global memory
    and is later reachable through normal COM activation paths,
    allowing an attacker to obtain control over a freed object that
    is subsequently reused by the system.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – stale pointer dereferenced after lock drop
if (fLockReleased) {
    v13 = CCEHashTable::LookupCE(v21, dwClsHash, rclsid, partId);
}
v14 = *v9;                    // v14 may already be freed
if (!v13) {
    dwFlags = v14->_dwFlags;  // UAF read
    key.aGUID = v14->_guids;  // UAF read
    ...                       // further use
}
```

```c
// after patch – re-lookup or bail out before dereference
if (fLockReleased) {
    v14 = LookupCE(...);
}
if (FeatureEnabled && ((*pCE)->_dwFlags & 0x40)) {
    if (!v14) {               // duplicate disappeared – unexpected
        MicrosoftTelemetryAssertTriggeredNoArgs();
        goto safe_exit;
    }
} else if (!v14) {
    // safe path that still owns *pCE
    ...
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Client thread A
  CoCreateInstance(EXE/COM object)          
    -> activates CLSID X                    
    -> CClassEntry::Create (allocates entry
       and later releases lock in Complete)

Concurrent thread B
  Performs the same activation while A’s
  lock is released, inserts its own entry
  for CLSID X and frees the incomplete one
  that A still references.

Thread A resumes and dereferences freed
memory, leading to UAF.

Attack Vector
--------------------------------------------------------------------
A local, low-privileged attacker spawns two or more concurrent COM
activations for the same CLSID that is not yet present in the class
cache.  Carefully timing the requests causes the race window during
which the target thread dereferences the freed entry.  Because the
object memory is under the global heap, an attacker can groom the
heap to obtain control of the freed slot, achieving arbitrary code
execution in the caller’s context (often SYSTEM for service hosts).

Patch Description
--------------------------------------------------------------------
1.  Early NULL-parameter guard was added.
2.  After relocking, the code now:
    • Re-looks up the CLSID and uses the new pointer, or
    • Verifies a feature flag (bit 0x40 in _dwFlags) and aborts with
      telemetry if the pointer disappeared.
3.  The code that inserts the entry into the global hash table
    (CHashTable::Add) now uses a freshly validated pointer that is
    known to be still owned by the current thread.
4.  Similar safety logic and a helper
       CClassEntry::CompleteTreatAs
    were added to Complete(), preventing reuse of an invalid *this
    when building Treat-As lists.
5.  Multiple calls to MicrosoftTelemetryAssertTriggeredNoArgs() were
    inserted to record unexpected states.

Security Impact
--------------------------------------------------------------------
Exploiting the race gives an attacker a dangling COM cache entry
that they can overlap with controlled data.  Subsequent activation
can lead to arbitrary code execution inside any process that uses
COM (including elevated service processes), turning the issue into
local privilege escalation or, via DCOM, remote code execution.

Fix Effectiveness
--------------------------------------------------------------------
The patch removes all dereferences of cache entries that are not
re-validated after a lock drop, thereby closing the fundamental
use-after-free window.  Additional telemetry ensures unexpected
states are detected in production.  Unless another, independent
path manipulates _pTreatAsList without holding the lock, the fix
appears complete; no residual UAF scenario was observed in the
patched logic.
