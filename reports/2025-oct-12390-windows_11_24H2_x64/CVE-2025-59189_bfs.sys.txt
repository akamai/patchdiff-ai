{'date': 1763402991.0459373, 'patch_store_uid': 'e256c23f-dcdb-48c3-81b0-6c892c4702ec', 'kb': 'KB5066835', 'file': 'bfs.sys', 'confidence': 0.22, 'change_count': 14, 'cve': 'CVE-2025-59189'}
--------------------------------------------------------------------
CVE-2025-59189 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Brokering File System kernel driver (bfs.sys), numerous
callback entry points such as BfsIdleCheckWorkitemRoutine,
BfsPreCreatePipeOperation / BfsPreCreateOperation,
BfsRegistry{Pre,Post}CreateCallback and the corresponding *Post* paths.


Vulnerability Class
--------------------------------------------------------------------
Use After Free – CWE-416


Detailed Root Cause Analysis
--------------------------------------------------------------------
The driver maintains several global objects that are lazily destroyed
when the driver is torn down or when policy state changes:

 • gBfsRundownProtection – EX_RUNDOWN_REF used to guard global data
 • gBfsGlobalFileTable     – RTL_DYNAMIC_HASH_TABLE containing policy
   entries
 • gBfsPipeMappingTable    – mapping table for named pipes

Before the patch many call-backs accessed those objects without holding
an active rundown reference or released the reference too early.  The
most visible paths were:

 1. BfsIdleCheckWorkitemRoutine()
    – called in a worker thread that frees policy structures.
 2. I/O pre-operation callbacks (BfsPreCreatePipeOperation,
    BfsPreCreateOperation) that run in the context of the calling user
    thread and dereference the same tables.
 3. Registry filter callbacks (BfsRegistryPreCreateCallback /
    BfsRegistryPostCreateCallback).
 4. Post-operation paths that free allocations and then continue to
    touch the global tables.

Because there was no reliable ExAcquireRundownProtection() around those
critical sections, the following race was possible:

 Thread-A (idle work-item)
     ExAcquirePushLockExclusive()               
     // free policy hash entries
     ExFreePool(..)                             
     ExReleasePushLockExclusive()               

 Thread-B (CreateFile on protected path)
     uses pointer retrieved from gBfsGlobalFileTable -> **freed pool**
     => pool-use-after-free in kernel mode.

Depending on heap layout the attacker can obtain arbitrary kernel pool
write primitives and elevate privileges locally.

A related lifetime bug existed in PostCreate* code paths: memory was
freed (ExFreePoolWithTag) and only afterwards was the rundown reference
released, giving a window in which a new thread could reuse the freed
chunk while the old pointer was still reachable.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// pre-patch  (BfsIdleCheckWorkitemRoutine)
KeEnterCriticalRegion();
if (ExAcquireRundownProtection(&gBfsRundownProtection))
{
    BfsCheckAndReleaseIdlePolicy(Context);   // may free globals
    ExReleaseRundownProtection(&gBfsRundownProtection);
}
KeLeaveCriticalRegion();
IoFreeWorkItem(IoWorkItem);                  // rundown dropped *after*
                                             // free ; other paths had
                                             // no rundown at all
```
```c
// patched
v5 = ExAcquireRundownProtection(&gBfsRundownProtection);
if (!Feature_IsEnabled() ) {           // gate for hot-patch roll-out
    if (!v5) goto leave;
}
...
BfsCheckAndReleaseIdlePolicy(Context);
if (Feature_IsEnabled()) KeEnterCriticalRegion();
ExReleaseRundownProtection(&gBfsRundownProtection);
```
Similar rundown-acquire / release blocks were added to every touched
callback and all error/early-return paths.
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker opens / creates many files, pipes or registry keys to force
   bfs.sys into its callback paths.
2. In parallel the attacker causes the idle work-item to run (power-
   transition, filter unload, Feature flag toggle) which frees policy
   tables.
3. Lack of proper rundown in the I/O callback lets it dereference a
   pointer that has just been freed.
4. Crafted pool layout gives attacker control of freed chunk -> kernel
   memory corruption and privilege escalation.


Attack Vector
--------------------------------------------------------------------
Local, unprivileged user code.  No special privileges are required –
issued NtCreateFile / NtCreateNamedPipe or RegCreateKeyEx calls while
another thread triggers the policy idle path.


Patch Description
--------------------------------------------------------------------
1. Systematically adds ExAcquireRundownProtection(&gBfsRundownProtection)
   at the start of every entry point that touches global state, and
   guarantees ExReleaseRundownProtection on every exit path, including
   all error jumps.
2. Where hash tables are modified, a complementary push-lock discipline
   (ExAcquirePushLock{Shared,Exclusive}Ex) is now employed.
3. Rundown release is performed *before* freeing pool memory, removing
   the dangling-pointer window.
4. ETW logging constants updated; debug logging now uses new
   (&unk_140015C91) GUID, signalling code churn only.
5. New Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage* gates allow
   Microsoft to enable or disable the hardened path at run-time.


Security Impact
--------------------------------------------------------------------
The bug permitted kernel-mode use-after-free, enabling local attackers
to execute arbitrary code in kernel context or crash the system.
Microsoft rates the issue as Elevation of Privilege (EoP).


Fix Effectiveness
--------------------------------------------------------------------
All observed code paths now hold a rundown reference for the entire
lifetime of pointers retrieved from shared global tables, and release
that reference before the memory is returned to the pool.  Provided all
entry/exit paths are covered – which the diff suggests – the fix fully
mitigates the UAF condition.  No residual unsafe dereferences were
observed in the patched routines.

