{'cve': 'CVE-2025-59230', 'patch_store_uid': 'bc1cc484-4563-4790-8a5b-0e5cab8c0ab1', 'file': 'rasman.dll', 'kb': 'KB5066835', 'confidence': 0.26, 'change_count': 2, 'date': 1763406118.1799448}
--------------------------------------------------------------------
CVE-2025-59230 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Remote Access Connection Manager (rasman.dll) – client-side RPC helper
routine RpcConnect and the auxiliary string helper PrepareServerSPN
(removed by the patch).

Vulnerability Class
--------------------------------------------------------------------
Improper Access Control / Missing RPC mutual-authentication that leads
to Local Privilege Escalation (CWE-284).

Detailed Root Cause Analysis
--------------------------------------------------------------------
The helper RpcConnect() is used by user-mode callers to obtain an
RPC_BINDING_HANDLE to the SYSTEM-running RasMan service.  Prior to the
patch the function built the binding in the following way:
  • For local connections it always chose the endpoint pair
    (protocol:"ncalrpc", endpoint:"RasmanLrpc").
  • It configured RPC_SECURITY_QOS.Version = 1 and
    ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE but *left
    Capabilities at 0* and did not provide a caller SID.

With those defaults the client never requested mutual authentication
(RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH) nor the newer local-machine auth
flag (RPC_C_QOS_CAPABILITIES_LOCAL_MA).  Any local user therefore could
create a malicious LRPC port named "RasmanLrpc" before the service had
been started.  Subsequent calls to RasMan APIs in the same process (or
in any other process that re-uses the global g_hBinding handle) would
silently connect to the attacker-controlled port.  Because the service
side runs as LocalSystem and many RasMan RPC methods perform caller
impersonation, the attacker could escalate to SYSTEM.

The absence of Capabilities and SID fields constitutes the root cause –
RPC did not verify that the server end of the LRPC connection was owned
by LocalSystem, and no mutual authentication token was exchanged.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// pre-patch (simplified)
RPC_STATUS sts = RpcBindingSetAuthInfoExW(*h, NULL, 6,
                                         RPC_C_AUTHN_WINNT,
                                         NULL, 0, SecurityQOS);
// SecurityQOS->Capabilities == 0, ->Sid == NULL
```
```c
// patched
AllocateAndInitializeSid(&NT_AUTHORITY, 1, SECURITY_LOCAL_SYSTEM_RID,
                          ... , &pSid);
SecurityQOS->Capabilities = 0x11;           // LOCAL_MA | MUTUAL_AUTH
SecurityQOS->Sid          = pSid;
sts = RpcBindingSetAuthInfoExW(*h, NULL, 6,
                               RPC_C_AUTHN_WINNT,
                               NULL, 0, SecurityQOS);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Low-privilege process calls any RasMan API that ends up in
   RpcConnect().
2. Attacker has already created a fake LRPC endpoint named
   "RasmanLrpc" owned by the low-privilege user.
3. RpcConnect() composes the binding string and establishes the handle
   without mutual authentication.
4. Client now talks to the attacker instead of the legitimate service.
5. Service-level operations executed by the attacker yield SYSTEM
   privileges.

Attack Vector
--------------------------------------------------------------------
Local.  The attacker must be able to create or hijack the LRPC port
name "RasmanLrpc" before any privileged client connects.

Patch Description
--------------------------------------------------------------------
1. Deleted PrepareServerSPN() helper and folded its limited use directly
   into RpcConnect().
2. Added Feature_817320250__private_IsEnabledDeviceUsageNoInline() – a
   kill-switch controlling the hardened path.
3. RpcConnect() extended signature now receives the caller-supplied
   RPC_SECURITY_QOS block by pointer (a10).
4. For local LRPC connections:
   • Dynamically allocates SID S-1-5-18 (LocalSystem).
   • Sets SecurityQOS->Capabilities to 0x11
     (RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH | RPC_C_QOS_CAPABILITIES_LOCAL_MA).
   • Stores the LocalSystem SID in SecurityQOS->Sid.
   • Keeps the binding handle only when RpcBindingSetAuthInfoExW
     succeeds.
5. Reference counting and binding caching unchanged – but now guarded by
   the mutual-auth check.

Security Impact
--------------------------------------------------------------------
Before the fix any authenticated local user could impersonate the
RasMan service and execute privileged RPC operations, achieving full
LocalSystem privileges.  After enforcing LOCAL_MA + MUTUAL_AUTH and the
explicit LocalSystem SID, only a server running under LocalSystem and
owned by the kernel can complete the security handshake, blocking the
privilege-escalation path.

Fix Effectiveness
--------------------------------------------------------------------
The patch changes only client-side code but uses standard RPC
capabilities that are enforced in the RPC runtime.  LOCAL_MA requires
an ALPC security attribute present only for kernel-created ports;
unprivileged users cannot satisfy it, so binding to a spoofed LRPC port
now fails.  The added mutual-auth and SID checks mitigate the
vulnerability comprehensively.  No residual caller-controlled paths are
visible in the diff; therefore the fix is considered effective.
