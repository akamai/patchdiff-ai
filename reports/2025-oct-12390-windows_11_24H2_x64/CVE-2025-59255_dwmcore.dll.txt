{'cve': 'CVE-2025-59255', 'patch_store_uid': '9ea31a38-c5d1-473b-b782-3c02fef25a9c', 'change_count': 96, 'date': 1763406124.7782278, 'file': 'dwmcore.dll', 'kb': 'KB5066835', 'confidence': 0.3}
--------------------------------------------------------------------
CVE-2025-59255 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Desktop Window Manager (DWM) core library – dwmcore.dll,  
method CBrushRenderingGraphBuilder::AddEffectBrush().


Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow / out-of-bounds write (CWE-122).


Detailed Root Cause Analysis
--------------------------------------------------------------------
At the start of AddEffectBrush() the routine queries the compiled  
effect template for the number of fragment outputs (v49) and allocates  
a std::vector<CBrushRenderingGraphBuilder::SubgraphOutput> whose size  
is (v49-1).  The base address of this vector is stored in v14/v54 and  
its logical element count in v49.

Later, while iterating over each fragment input, the code asks the  
compiled effect for the index of the *intermediate* sub-graph output  
that should be wired to the current input:

    v23 = GetOutputIndex( compiledEffect, fragIdx, inputIdx, &isInter );
    v26 = v23;                    // "before" version names it v26

If the returned flag (isInter / v48) is non-zero the index is treated  
as referring to a previously created SubgraphOutput entry.  The vector  
entry is then accessed with:

    v35 = v16 + 16 * v26;         // v16 == vector base
    if (*(_DWORD*)v35 == -1)
        ... use *(QWORD*)(v35+8) as stored pointer ...
    else
        CRenderingTechniqueFragment::AddIntermediateInput(...);

In the original logic **no bounds check** is performed on v26.  A  
malicious compiled effect can therefore return an index that is equal  
to or larger than (v49-1) causing v35 to point *past the end* of the  
allocated vector.  Subsequent writes to *v35 or *(v35+8) corrupt  
adjacent heap memory, creating a classic heap-buffer overflow inside  
DWM.EXE.

Because the data (compiled effect) originates from the client process,  
a low-privileged application can craft an arbitrary index and trigger  
controlled corruption inside the privileged DWM process, leading to  
Elevation of Privilege.

Affected data structures / parameters:
  • std::vector<CBrushRenderingGraphBuilder::SubgraphOutput>  
    (element size 0x10, created via _Resize_reallocate).
  • Index value v26 obtained through ICompiledEffect::GetInput() (VFT  
    slot +0x48).


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// BEFORE
v26 = GetOutputIndex(v9, v17, v24, &v48);     // attacker-controlled
v35 = v16 + 16i64 * v26;                      // no bounds check
if (*(_DWORD*)v35 != -1)
    CRenderingTechniqueFragment::AddIntermediateInput(v21,*(_DWORD*)v35);
// … writes through v35 and v37   
```

```c
// AFTER
v23 = GetOutputIndex(v50, v15, v22, &v42);
if (v42) {
    if (v24 >= ((*((QWORD*)&v54+1) - v14) >> 4))   // new bound check
        _FailFast_Unexpected(...);                // terminates safely
    v25 = v14 + 16 * v24;                         // now guaranteed safe
    ...                                           
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Client process creates a Composition effect graph with a malicious  
   compiled effect template.
2. DWM calls CBrushRenderingGraphBuilder::AddEffectBrush().
3. addEffectBrush queries compiledEffect->GetInput() which returns a  
   crafted large index (v26).
4. Function writes to vector element v16 + 16*v26 without verifying the  
   index, overflowing heap memory.
5. Memory corruption occurs inside the DWM process; attacker gains code  
   execution in the DWM security context.


Attack Vector
--------------------------------------------------------------------
Local.  Any application capable of creating and submitting a crafted  
Composition effect brush to the Desktop Window Manager can supply a  
malicious compiled effect that returns an out-of-range intermediate  
index, triggering the overflow during normal composition processing.


Patch Description
--------------------------------------------------------------------
The update inserts a defensive bounds check directly after retrieving  
the intermediate index:

    if (index >= vector_size) FailFast();

The size is computed as (vectorEnd-vectorBase)/sizeof(Element).  When  
the condition is true the process terminates via wil::FailFast,  
preventing any out-of-bounds access.  No other logic paths that access  
the vector are modified, guaranteeing the same protection for all  
subsequent writes.

Additional cleanup code (WaitForThreadpoolWorkCallbacks,  
CloseThreadpoolWork) is unrelated to the vulnerability but was added  
for robustness.


Security Impact
--------------------------------------------------------------------
Prior to the patch a low-privileged user could corrupt heap structures  
in the privileged DWM process, potentially achieving arbitrary code  
execution and elevating privileges (Elevation of Privilege).  The flaw  
was classified as a heap-based buffer overflow (CWE-122).


Fix Effectiveness
--------------------------------------------------------------------
The explicit upper-bound check eliminates the possibility of writing  
outside the allocated vector, thereby fully addressing the identified  
heap overflow.  Provided that the FailFast path is compiled into all  
shipping builds (feature gating is present but defaults to enabled),  
the fix is considered effective.
