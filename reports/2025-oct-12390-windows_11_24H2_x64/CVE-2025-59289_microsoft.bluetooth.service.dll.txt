{'file': 'microsoft.bluetooth.service.dll', 'cve': 'CVE-2025-59289', 'change_count': 110, 'confidence': 0.32, 'patch_store_uid': '67b1359b-3787-4b70-8a1b-2e864ed2399c', 'kb': 'KB5065426', 'date': 1763403111.4790337}
--------------------------------------------------------------------
CVE-2025-59289 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Bluetooth Service â€“ dll: microsoft.bluetooth.service.dll, 
function: SdpStack::Push(_SDP_NODE *,ULONG,_LIST_ENTRY *)


Vulnerability Class
--------------------------------------------------------------------
CWE-415: Double Free (use-after-free triggered by second call to the 
free routine on the same heap pointer).


Detailed Root Cause Analysis
--------------------------------------------------------------------
SdpStack is the in-memory implementation of the Bluetooth Service 
Discovery Protocol (SDP) parsing stack.  The class is backed by a grow-
able array where each stack element is 24 bytes.  Three internal raw
pointers are relevant:
  offset 0   : element count (qword)
  offset 8   : current insertion pointer (qword)
  offset 16  : base pointer of the allocation (qword)
  offset 24  : "staticBuffer" pointer used when the stack is very small

When the stack becomes full the Push routine allocates a new buffer of
double size with MIDL_user_allocate_1(), copies the existing elements
and then frees the previous buffer with MIDL_user_allocate_0().  The
free is guarded by a comparison so that the service does not release
staticBuffer:
    if (oldBase != this[3])
        free(oldBase);

The bug is that field 3 (this[3]) is **not** updated to the newly
allocated buffer before the function returns.  Consequently the object
still keeps a dangling pointer to memory that has already been freed.
A subsequent stack growth or the object destructor will enter the same
code path and pass the very same pointer to MIDL_user_allocate_0() a
second time, triggering a double free in the Bluetooth service process.

Because the service runs under LocalSystem, the condition leads to
memory corruption inside a privileged process and can be turned into
local elevation of privilege.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable code (before patch)
memcpy_0(v8, this[2], 24 * this->Capacity);
oldBase = (void*)this[2];
this[1] = &v8[24 * this->Capacity];
if (oldBase != this[3])                // guard against static buffer
    MIDL_user_allocate_0(oldBase);     // FIRST free
this[2]  = v8;                         // <--- this[3] never updated
...
// later, same pointer is freed again  // SECOND free
```
```c
// fixed code (after patch)
oldBase = this->Base;
this->Current = newBuf + (24 * this->Capacity);
if (oldBase != this->StaticBuf)
{
    MIDL_user_allocate_0(oldBase);     // single free
    /* staticBuf left unchanged but no longer references oldBase */
}
this->Base = newBuf;                   // structure now owns new buffer
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Client sends a crafted series of SDP requests that forces the
   service to build a large nested SDP structure.
2. SdpStack::Push is called repeatedly until the internal array is
   exactly full.
3. One more Push causes a resize: old buffer is freed but pointer in
   the object is not cleared.
4. Another resize or object destruction frees the same pointer again,
   corrupting the process heap.


Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker.  By opening a Bluetooth socket to the
local BthServ service and sending a sequence of SDP packets the
attacker can deterministically trigger consecutive resizes of the SDP
stack and hit the double-free condition.


Patch Description
--------------------------------------------------------------------
The update makes three key corrections:
1. Uses a real SdpStack * type so the compiler enforces correct field
   accesses instead of raw pointer arithmetic.
2. After allocating the larger buffer the code stores the new pointer
   into **both** Base (offset 16) and Current (offset 8) before any
   early exits, guaranteeing that no live field references freed
   memory.
3. Redundant feature-flag dependent write blocks were merged, removing
   duplicated code that complicated state tracking.


Security Impact
--------------------------------------------------------------------
Prior to the patch a local attacker could cause a double free in the
Bluetooth service running as LocalSystem.  Reliable exploitation would
lead to elevation of privilege (EoP) to SYSTEM.  The crash is also a
potential DoS vector against Bluetooth functionality.


Fix Effectiveness
--------------------------------------------------------------------
The corrected implementation no longer keeps dangling pointers after a
resize; subsequent frees operate on the new, valid buffer.  A code
review shows each unique allocation is matched by exactly one free.
No alternative path to free the same pointer twice was identified,
indicating the fix fully addresses the vulnerability.
