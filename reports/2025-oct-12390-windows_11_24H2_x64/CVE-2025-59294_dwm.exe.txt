{'date': 1763402977.1910508, 'kb': 'KB5066835', 'cve': 'CVE-2025-59294', 'change_count': 10, 'confidence': 0.15, 'file': 'dwm.exe', 'patch_store_uid': '91050652-618e-4355-8ff5-2ed2c31bf876'}
--------------------------------------------------------------------
CVE-2025-59294 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Desktop Window Manager (dwm.exe) – CPortClient class and all call sites
that allocate or free memory for ALPC messages (e.g.  SendComplex­Sync
Request, destructor, etc.).

Vulnerability Class
--------------------------------------------------------------------
Improper pointer / handle management resulting in arbitrary-heap free
(memory corruption).  A writable field inside CPortClient is used as a
heap handle without validation.

Detailed Root Cause Analysis
--------------------------------------------------------------------
The CPortClient object contains a pointer-sized member located at index
+6 (hereafter called m_hHeap).

1.  In the pre-patch constructor the member was initialised to the
    process heap handle:
        *((_QWORD*)this + 6) = GetProcessHeap();

2.  Several helper routines later passed this field directly to
    HeapAlloc / HeapFree:
        HeapAlloc(this[6], ...);
        HeapFree(this[6], 0, ptr);

3.  The destructor also used the same stored handle when freeing the
    dynamically allocated transmit buffer stored in this[5].  No check
    was performed to ensure that the field still contained a valid
    handle.

Because the value of m_hHeap lives in normal writable object memory it
can be modified at any time by an out-of-bounds write, use-after-free or
any other memory-corruption primitive.  If an attacker manages to write
an arbitrary value to that slot before the next HeapAlloc / HeapFree
call, DWM will attempt the operation on an attacker-controlled handle.

Consequences:
• Passing an invalid value causes an immediate crash (DoS).
• Passing the handle of a different heap enables cross-heap corruption
  or information disclosure.
• Supplying a crafted ALPC section handle could be leveraged for
  elevation of privilege.

Nothing in the original implementation verified that m_hHeap pointed to
GetProcessHeap() or to a kernel-validated heap object.  The whole class
implicitly trusted the field.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Destructor – before patch
v2 = this[5];
if (v2) {
    HeapFree(this[6], 0, v2);   // arbitrary handle
    this[5] = 0i64;
}

// SendComplexSyncRequest – before patch
msg = HeapAlloc(this[6], 8, 0x38);
...
HeapFree(this[6], 0, msg);
```

```c
// After patch
ProcessHeap = GetProcessHeap();
msg = HeapAlloc(ProcessHeap, 8, 0x38);
...
HeapFree(ProcessHeap, 0, msg);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Any call path that creates a CPortClient object
   (e.g. CDwmAppHost::StartKernelRedirection, LpcSyncFlush, etc.).
2. An attacker gains a write primitive and overwrites *(this+0x30) with
   an arbitrary value.
3. Later, the same object executes HeapFree/HeapAlloc through
   SendComplexSyncRequest or the destructor.
4. Heap API is invoked with the attacker-controlled handle, leading to
   memory corruption or information disclosure.

Attack Vector
--------------------------------------------------------------------
Requires the ability to corrupt heap memory inside dwm.exe – for
instance through another bug in the DWM ALPC message parser or graphics
stack.  No authentication is required once the process memory is under
attacker influence.

Patch Description
--------------------------------------------------------------------
• The constructor now zeros the m_hHeap field instead of storing a heap
  handle.
• All allocation / free sites were changed to call GetProcessHeap()
  immediately before the operation; the stored field is never used.
• The destructor obtains the heap handle via GetProcessHeap() and also
  guards the operation behind a feature flag.
• Disconnect() was hardened with an additional check and ALPC section
  cleanup.

Security Impact
--------------------------------------------------------------------
Before the fix, an attacker who could overwrite 8 bytes in a
CPortClient object could redirect HeapAlloc/HeapFree to an arbitrary
address, allowing:
  - Process crash (denial of service)
  - Corruption or disclosure of memory belonging to other heaps
  - Potential elevation of privilege through further exploitation of
    corrupted heap structures.

Fix Effectiveness
--------------------------------------------------------------------
Eliminating the cached heap handle removes the trust boundary violation;
heap APIs are now executed only with a verified handle returned by the
system.  No remaining code paths use the writable field, so the specific
arbitrary-heap-free primitive is closed.  Overall, the patch fully
mitigates the identified vulnerability.
