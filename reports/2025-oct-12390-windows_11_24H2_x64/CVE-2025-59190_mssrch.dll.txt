{'kb': 'KB5066835', 'date': 1763406131.7154503, 'confidence': 0.22, 'change_count': 64, 'file': 'mssrch.dll', 'cve': 'CVE-2025-59190', 'patch_store_uid': '6a66212c-b557-4770-bf02-18bf20cc194a'}
--------------------------------------------------------------------
CVE-2025-59190 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Search Service (mssrch.dll).  Affected code is the
priority-queue bookkeeping inside CPriorityQueue::MarkAllPassesCompleted
ForIndexedItem, part of the indexing pipeline that tracks which
processing passes have already been completed for an item.

Vulnerability Class
--------------------------------------------------------------------
Improper input validation leading to out-of-bounds write / denial of
service (CWE-20 / CWE-787).

Detailed Root Cause Analysis
--------------------------------------------------------------------
The old implementation of
CPriorityQueue::MarkAllPassesCompletedForIndexedItem(this,UINT index)
manually manages a two-level sparse bitset.  The algorithm divides the
32-bit caller-supplied index into a page number (v4) and an in-page bit
position:

  page   = index >> this->PageShift        (DWORD read at *(this+133)+20)
  bitPos = index & 0x3F                    (low 6 bits)
  wordIx = PageMask & (index >> 6)         (mask value read at *(bitset)+16)

No range validation is performed on wordIx before it is multiplied by
8 and added to the page base pointer:

  qword *word = *(pageBase + 8*wordIx);

If the caller supplies an index that, after the mask operation, yields
a wordIx that is larger than the number of qwords actually allocated in
the page, the calculation walks past the end of the 8-byte-aligned page
buffer.  Subsequent read-modify-write of the target bit corrupts
adjacent memory and commonly raises an access-violation that terminates
the Search service process.

Because the public Search APIs allow unprivileged local code to trigger
re-indexing of arbitrary user-controlled items, a local attacker can
feed a crafted item identifier with a large numeric key to force the
out-of-range index.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// old code (simplified)
unsigned __int64 page   = a2 >> *(_DWORD *)(*((_QWORD *)this + 133) + 0x14);
...
unsigned __int64 wordIx = *(unsigned int *)(*(_QWORD *)v2 + 0x10) & (a2 >> 6);
__int64 oldBits         = *(_QWORD *)(*pagePtr + 8*wordIx); // OOB if wordIx
                                                            // too big
if ((oldBits & (1ULL << bitPos)) == 0)
    *(_QWORD *)(*pagePtr + 8*wordIx) = oldBits | (1ULL << bitPos);
```
The variable wordIx is never checked against the real length of the
allocated page (v7[6] qwords).

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User-supplied item added to the indexer.
2. Indexer calls CPriorityQueue::MarkAllPassesCompletedForIndexedItem.
3. Function derives page/word/bit without validating wordIx.
4. Memory past the allocated bitset page is accessed.
5. Access violation propagates, causing SearchIndexer.exe crash.

Attack Vector
--------------------------------------------------------------------
A local, unprivileged attacker issues Search API calls (e.g. IRowset,
ISearchCatalogManager, or by placing specially crafted metadata into NTFS
alternate data streams) that force the indexer to process an item with a
large 32-bit ID.  When the indexer marks that item as having completed a
pass, the out-of-bounds write is triggered and the Search service
terminates, resulting in denial of service for all users on the machine.

Patch Description
--------------------------------------------------------------------
The vulnerable routine was deleted entirely.  A new method
CTransactionHashEntry::RequiredOriginalTransactionPasses simply delegates
processing to TransactionPass::LoadFromTransactionExtendedFlags, which
returns a constant list of required passes.  No manual sparse bit
management remains, removing the faulty index calculations and the
entire attack surface.

Security Impact
--------------------------------------------------------------------
Before the patch, malformed indices could crash SearchIndexer.exe,
disrupting desktop, Outlook and Cortana search.  Because the memory
corruption occurs in a write operation, exploitation for elevation of
privilege cannot be ruled out, but no evidence of such exploitation is
known.  The primary, confirmed impact is denial of service.

Fix Effectiveness
--------------------------------------------------------------------
The dangerous code path has been replaced, eliminating the unchecked
word index arithmetic.  Provided that
TransactionPass::LoadFromTransactionExtendedFlags does not re-introduce
similar unchecked array operations, the patch fully mitigates the issue.
Regression tests around extremely large item IDs are recommended to
confirm there are no residual edge cases.
