{'confidence': 0.25, 'change_count': 482, 'kb': 'KB5066835', 'cve': 'CVE-2025-59199', 'date': 1763407724.605311, 'patch_store_uid': 'edc3df02-857f-43ce-8a05-593ebe4cd1ca', 'file': 'sppobjs.dll'}
--------------------------------------------------------------------
CVE-2025-59199 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows 10/11 – Software Protection Platform (sppobjs.dll).
Vulnerable routine originally named sub_1800C6EF0 (pre-patch) and
renamed to sub_1800BB45C after the security update.


Vulnerability Class
--------------------------------------------------------------------
Improper Access Control / Privilege-escalation via unchecked pointer
manipulation (CWE-284).


Detailed Root Cause Analysis
--------------------------------------------------------------------
The legacy implementation expected the caller to pass a pointer (a1)
that referenced an internal SPP object.  Instead of using documented
structure offsets the code walked *backwards* from the supplied base
pointer:

    v2 = *(a1 - 3);            // read 24 bytes before a1

The value obtained (v2) is treated as a fully-formed C++ object whose
first QWORD is a v-table pointer.  Multiple virtual functions are then
invoked through that table, e.g.:

    v3 = *(QWORD*)v2 + 0x30;   // method #6
    v3(v2, L"SppBindingAppId", &v63);

Because no provenance or range checks are performed on (a1) an
unprivileged caller who can reach this code path may supply an arbitrary
pointer.  By placing a forged object with a controlled v-table in user
memory the attacker gains the ability to redirect the kernel-mode call
to chosen code locations, thereby executing with SYSTEM privileges.

Additional issues discovered during analysis:
  • No validation that internal stream pointer (v77) is NULL before use.
  • No upper-bound on index parameter (now called a2) – could be larger
    than the backing array and corrupt adjacent object fields.

The cumulative effect is an elevation-of-privilege condition inside the
Software Protection Platform service.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// pre-patch (sub_1800C6EF0)
    v2 = *(a1 - 3);
    v3 = *(__int64 (__fastcall **)(__int64,...))(*(_QWORD *)v2 + 0x30);
    _guard_check_icall_fptr(v3);
    v3(v2, L"SppBindingAppId", &v63);   // attacker-controlled call
```
```c
// post-patch (sub_1800BB45C)
    if (!*(_QWORD *)(a1 + 0x100))     // null-ptr gate
        __int2c();                    // fast-fail
    if (a2 >= 0x100)                  // bounds check on index
        __int2c();
```
The new body no longer dereferences *(a1-3) and only accesses positive
structure offsets, thereby removing the out-of-bounds object access.


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Low-privilege client calls an exposed COM/RPC method that eventually
   executes sub_1800C6EF0 in the SPP service process.
2. Caller supplies a crafted pointer as the first argument.
3. Function subtracts three QWORDs, interprets that memory as an object,
   and performs virtual calls through a caller-controlled v-table.
4. Arbitrary code executes inside the Software Protection Platform
   service running as LocalSystem.


Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker.  By invoking the public Software
Protection Platform COM interface and passing a fake pointer (for
instance via specially crafted marshalled parameters) the attacker
triggers the out-of-bounds object access and hijacks the v-table.


Patch Description
--------------------------------------------------------------------
1. Rewrote the routine; the new function signature is
      __int64 sub_1800BB45C(__int64 a1, int a2)
   eliminating the _QWORD* interface that allowed negative indexing.
2. Added hard null check on *(a1+0x100) and a fast-fail (INT2C) if
   violated.
3. Added upper-bound check (a2 < 256) before a2 is used as an array
   index.
4. Removed all reads to *(a1-3) and any dependent v-table dereferences.
5. Introduced structured cleanup and centralised error reporting via
   sub_18006A958 / sub_18006A62C.


Security Impact
--------------------------------------------------------------------
Before the fix a local attacker could execute arbitrary code in the
context of the Software Protection Platform service (SYSTEM), achieving
full elevation of privilege.


Fix Effectiveness
--------------------------------------------------------------------
The vulnerable pointer arithmetic has been removed and replaced with
explicit null and boundary checks.  No code paths remain that derefer­
ence memory preceding the supplied base pointer, closing the privilege
escalation hole.  Unless the attacker can bypass the new INT2C fast-
fail or subvert the a2 < 256 test, the issue is resolved.  Full defence
relies on all other callees honouring these invariants, but no residual
vuln is observable in the patched diff.
