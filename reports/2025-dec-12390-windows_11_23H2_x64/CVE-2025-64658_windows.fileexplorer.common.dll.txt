{'patch_store_uid': '58ff3214-ba2c-4d2b-b338-22819a5da8e6', 'confidence': 0.31, 'kb': 'KB5071417', 'date': 1765358438.0034933, 'cve': 'CVE-2025-64658', 'file': 'windows.fileexplorer.common.dll', 'change_count': 4}
--------------------------------------------------------------------
CVE-2025-64658 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows File Explorer   â€“   windows.fileexplorer.common.dll
Class CImpWorkerWndProc, helper class used by CSkyDriveNetworkStatesSSO
for background (worker) window message processing.

Vulnerability Class
--------------------------------------------------------------------
CWE-362: Race condition leading to use-after-free / double free and
subsequent local elevation of privilege.

Detailed Root Cause Analysis
--------------------------------------------------------------------
Each background job hosted by CSkyDriveNetworkStatesSSO creates a worker
window.  The pointer to the CImpWorkerWndProc instance that owns this
window is stored in GWLP_USERDATA (index 0) with SetWindowLongPtrW().

Before the patch CImpWorkerWndProc::s_WndProc() executed the following
sequence:
1. ptr = (CImpWorkerWndProc*)GetWindowLongPtrW(hWnd,0);
2. call ptr->WndProc(...);                      // virtual dispatch
3. if (Msg == WM_NCDESTROY) {
       SetWindowLongPtrW(hWnd,0,null);
       ptr[1] = 0;                              // clear back-pointer
   }
4. return result;

No lifetime management existed between step 1 and step 4.  If the object
was released by another thread (or re-entered message) while the current
thread was still executing, the pointer became dangling.  Any access
(step 2 or the write in step 3) could therefore operate on freed memory.

Because CImpWorkerWndProc lives inside the CSkyDriveNetworkStatesSSO
object, freeing that parent object also frees the worker-window helper.
An attacker controlling Explorer-hosted shell extensions can race the
window destruction against message delivery, causing a use-after-free
that allows controlled memory corruption in the explorer.exe process,
which runs with elevated privileges compared to the extension process.

Key affected data members / parameters:
- CImpWorkerWndProc *this      : taken from GWLP_USERDATA.
- *this+0x08 ("v9[1]")         : back-pointer cleared during WM_NCDESTROY.
- HWND message parameter hWnd  : window that can be destroyed from other
                                 threads.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
ptr = (CImpWorkerWndProc*)GetWindowLongPtrW(hWnd,0);
if (!ptr) return DefWindowProcW(...);
result = (**ptr)(ptr,hWnd,Msg,wParam,lParam);   // virtual call
if (Msg == WM_NCDESTROY) {
    SetWindowLongPtrW(hWnd,0,0);
    ptr[1] = 0;                                 // dangling write
}
return result;
```
```c
// after (excerpt)
ptr = (CImpWorkerWndProc*)GetWindowLongPtrW(hWnd,0);
if (ptr) {
    CImpWorkerWndProc::AddWndRef(ptr);          // ++ref
    result = ptr->WndProc(...);
    if (Msg == WM_NCDESTROY) {
        SetWindowLongPtrW(hWnd,0,0);
        *(QWORD*)(ptr+8) = 0;
        if (ptr->m_bWaitingForDestroy)
            SetEvent(ptr->m_hDestroyEvent);
    }
    CImpWorkerWndProc::ReleaseWndRef(ptr);      // --ref, free late
    return result;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker obtains a handle to the worker window created by Explorer.
2. Attacker posts or sends specially timed messages that force
   destruction of the window (e.g., WM_CLOSE) on a helper thread while
   another message is being processed.
3. Original thread enters s_WndProc(), retrieves pointer, but before the
   virtual call returns the object is freed.
4. Subsequent memory access in s_WndProc() uses freed memory -> memory
   corruption / code execution inside explorer.exe.

Attack Vector
--------------------------------------------------------------------
Local low-privileged attacker loading a shell extension or COM object
into explorer.exe can post crafted window messages or spawn threads that
race the lifetime of the worker window, leading to code execution with
Explorer privileges (medium IL -> high IL or admin depending on token
broker).

Patch Description
--------------------------------------------------------------------
1. Introduced explicit reference counting:
   CImpWorkerWndProc::AddWndRef() and ReleaseWndRef() are called before
   and after every dispatch, guaranteeing the object outlives the call.
2. On WM_NCDESTROY the code now signals an event and releases an extra
   reference so final deletion happens outside the window procedure.
3. CSkyDriveNetworkStatesSSO now embeds a CImpWorkerWndProc sub-object
   (offset changes visible in ctor/dtor) and uses
   CImpWorkerWndProc::CreateWorkerWindow() instead of raw
   SHCreateWorkerWindowW().  Notification handles were shifted to new
   indices (this+11 etc.).
4. All changes are feature-flag gated, allowing gradual rollout.

Security Impact
--------------------------------------------------------------------
Prior to the fix, a malicious local user could exploit the race to gain
use-after-free control in explorer.exe, resulting in arbitrary code
execution in the context of the logged-in user but potentially at a
higher integrity level, thus constituting an Elevation of Privilege.

Fix Effectiveness
--------------------------------------------------------------------
The added reference counting removes the window-lifetime race by
preventing object destruction while it is in active use.  The event
mechanism ensures orderly teardown after WM_NCDESTROY.  Assuming the
feature flag is enabled on the target system, the patch fully mitigates
the identified race condition.  No residual unsafe accesses to the
pointer remain in the modified paths.
