{'patch_store_uid': '1276c09b-6c98-4a33-9e0b-24cde08e6f59', 'date': 1765357613.9151802, 'change_count': 2, 'confidence': 0.23, 'file': 'clfs.sys', 'kb': 'KB5071417', 'cve': 'CVE-2025-62470'}
--------------------------------------------------------------------
CVE-2025-62470 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Common Log-File System (CLFS) kernel driver
(clfs.sys) – functions CClfsRequest::ReserveAndAppendLog() and
CClfsRequest::WriteRestart().


Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow / improper buffer-size calculation (CWE-122).


Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  When CLFS services an IRP that finally reaches
    CClfsRequest::ReserveAndAppendLog() or
    CClfsRequest::WriteRestart(), the caller supplies the length of a
    user-mode buffer that will later be filled by the driver.

2.  Before the patch both routines forwarded the *original* caller
    supplied length directly to ClfsProbeAndAllocateMdl() when they
    created a non-paged-pool MDL for the target buffer:
        • ReserveAndAppendLog – variable  v41   (DWORD Length)
        • WriteRestart          – *((DWORD*)this + 66)

3.  The subsequent CLFS lower-layer write helpers round the size up to
    the physical log page / sector size (0x200-byte alignment) or a
    larger implementation-specific alignment.  The lower layer therefore
    can copy up to the *rounded-up* number of bytes into the buffer that
    was only allocated for the *unrounded* length.

4.  If the caller supplies a length that is smaller than the next
    alignment boundary ( e.g. 0x201 – 0x3FF ), the MDL describes a heap
    buffer that is too small.  When the lower layer performs the copy it
    overruns the allocation by as much as 0x1FF bytes, corrupting
    adjacent pool memory.  Because the code runs in the kernel, this is
    an exploitable heap overflow that can be used to elevate privileges.

5.  The vulnerability is reachable from user mode by opening a CLFS log
    file (CreateFileA("\\.\C:...")) and issuing IOCTLs that lead to the
    affected request paths with attacker-controlled length and buffer
    pointers.  No special privileges beyond the ability to open a log
    are required, therefore the issue yields a local Elevation of
    Privilege (EoP).


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// ReserveAndAppendLog – BEFORE
v21 = *(_QWORD *)(*(_QWORD *)v37 + 112i64);
...
v22 = ClfsProbeAndAllocateMdl(v12, v21, (v41 + 511) & 0xFFFFFE00);
```

```c
// ReserveAndAppendLog – AFTER
AlignedBufferSize = (Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage())
                   ? CClfsRequest::GetAlignedBufferSize(this, v20)
                   : (v20 + 511) & 0xFFFFFE00;
...
v24 = ClfsProbeAndAllocateMdl(v21, v23, AlignedBufferSize);
```

```c
// WriteRestart – BEFORE
v2 = ClfsProbeAndAllocateMdl(p_Mdl,
                             v9,                      // buffer VA
                             *((unsigned int *)this + 66)); // *raw* len
```

```c
// WriteRestart – AFTER
AlignedBufferSize = *((unsigned int *)this + 66);
if (Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage())
    AlignedBufferSize = CClfsRequest::GetAlignedBufferSize(this,
                                                          AlignedBufferSize);
...
v2 = ClfsProbeAndAllocateMdl(p_Mdl,
                             *(_QWORD *)(*(_QWORD *)v3 + 112i64),
                             AlignedBufferSize);
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User-mode opens / creates a CLFS log and submits an IOCTL or FSCTL
   that causes the kernel to allocate and initialise a CClfsRequest
   object.
2. The request path invokes either ReserveAndAppendLog() or
   WriteRestart().
3. The caller-supplied buffer pointer and length are copied from
   user-space and validated with ProbeForRead/Write only for the *exact*
   caller length.
4. The driver allocates a non-paged MDL of size <caller_length> via
   ClfsProbeAndAllocateMdl().
5. CLFS core helper (vtable +120 or +152) is called; it rounds the length
   up to the internal log page/sector size (typically 0x200) and copies
   that many bytes into the MDL backing buffer.
6. Because the buffer is smaller than the amount copied, pool memory
   located after the allocation is overwritten, leading to heap
   corruption.


Attack Vector
--------------------------------------------------------------------
A local attacker running in an un-privileged context opens a CLFS log
file (or creates a temporary one), crafts a structure whose Length field
is just below 0x200 or another alignment boundary, and issues the
corresponding FSCTL so that the kernel executes ReserveAndAppendLog() or
WriteRestart().  When the lower CLFS layer performs the aligned write
(0x200 bytes), the driver overruns the heap buffer, allowing the
attacker to corrupt adjacent pool objects and ultimately execute
arbitrary code in kernel context, thereby gaining SYSTEM privileges.


Patch Description
--------------------------------------------------------------------
1. Introduced helper CClfsRequest::GetAlignedBufferSize() that returns a
   size rounded **up** to the required alignment.
2. Both vulnerable functions now calculate the "AlignedBufferSize"
   before calling ClfsProbeAndAllocateMdl(), passing this larger value
   instead of the raw caller length.
3. Legacy fallback path ( (len+511)&~0x1FF ) kept for systems where the
   new feature flag is disabled, but the critical path now guarantees
   that the MDL is always large enough.
4. Additional bookkeeping fields (v19[] array) were widened to 64-bit to
   prevent truncation of returned byte-counts.


Security Impact
--------------------------------------------------------------------
Before the fix, an authenticated local user could trigger a heap buffer
overflow inside the CLFS kernel driver, leading to memory corruption.  A
skilled attacker could leverage the corruption to execute arbitrary code
in kernel mode and thus escalate privileges to SYSTEM.  The issue is
tracked as CVE-2025-62470 and is rated Elevation of Privilege.


Fix Effectiveness
--------------------------------------------------------------------
The patched code guarantees that the size supplied to
ClfsProbeAndAllocateMdl() is correctly rounded up via
GetAlignedBufferSize(), ensuring that the MDL (and therefore the heap
allocation) is at least as large as the number of bytes the lower CLFS
layer may copy.  This removes the size mismatch and eliminates the
possibility of overflowing the heap buffer through these request paths.
Barring additional undiscovered paths that bypass the new helper, the
fix is considered effective.
