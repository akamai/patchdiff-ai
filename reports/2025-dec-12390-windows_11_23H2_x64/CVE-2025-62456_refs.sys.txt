{'date': 1765357674.9208095, 'cve': 'CVE-2025-62456', 'kb': 'KB5071417', 'patch_store_uid': '519d01b2-a8d6-41b7-846d-5644330bd522', 'file': 'refs.sys', 'change_count': 5, 'confidence': 0.19}
--------------------------------------------------------------------
CVE-2025-62456 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Resilient File System (refs.sys)
 • RefsPrepareMdlWriteA
 • RefsCopyWriteA
 • RefsCommonWrite
 • RefsCheckStreamSnapshotManagementBuffers
 • RefsCommonCreate
These routines service IRP-based read/write / FSCTL paths inside the
kernel‐mode ReFS driver.


Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow caused by missing integer / range validation
(CWE-122 + CWE-190).


Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  In the original RefsPrepareMdlWriteA and RefsCopyWriteA the caller
    supplied:
      • a2 – pointer to LARGE_INTEGER holding the starting VBO (file
        offset) coming directly from the IRP stack location.
      • a3 – byte count (Length) taken from the IRP.
2.  The functions performed only this computation:
         FileOffset = *a2;              // start VBO
         End = FileOffset + a3;         // may wrap / overflow
      but the result (End) was never validated and was **not** passed to
      lower helpers.  The code then unconditionally called
      RefsCopyWriteInternal( … , a5 , a6 ) which ultimately allocates an
      MDL or copies user data according to the untrusted Length.
3.  If the attacker sets a3 so that (offset + length) overflows the
   64-bit addition or otherwise defines a range that exceeds the actual
   valid volume byte offset (VBO) space, ReFS allocates a smaller buffer
   than intended and performs a kernel copy that overruns the heap
   buffer, corrupting adjacent memory.
4.  RefsCommonWrite contained identical logic when handling cached and
   non-cached writes: it only compared End > Start but **did not** check
   for wrap-around; negative or out-of-range values therefore slipped
   through, leading to the same corruption later in the data-movement
   pipeline.
5.  RefsCheckStreamSnapshotManagementBuffers suffered similar
   under-validated length / count checks for snapshot management IOCTL
   buffers.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// refs.sys : RefsPrepareMdlWriteA  (before)
FileOffset = *a2;
v8 = FileOffset.QuadPart + a3;   // potential 64-bit overflow ignored
return RefsCopyWriteInternal(a1,&FileOffset,1u,0i64,a5,a6);
```

```c
// refs.sys : RefsPrepareMdlWriteA  (after)
FileOffset = *a2;
v10 = a3;
v9  = FileOffset.QuadPart + a3;
if ( !(Feature_IsEnabled() ) ||
     REFS_VBO_RANGE::IsValid((REFS_VBO_RANGE *)&FileOffset) )
    return RefsCopyWriteInternal(...);
return 0;
```

```c
// refs.sys : RefsCommonWrite (after – truncated)
...
IsValid = REFS_VBO_RANGE::IsValid((REFS_VBO_RANGE *)FileOffset);
if (!IsValid) {
    RefsCompleteWriteRequest(...);
    return;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Remote / local client issues a crafted IRP_MJ_WRITE (or
   FSCTL/IRP_MJ_*) targeting a file on an ReFS volume.
2. Kernel path:  I/O Manager -> refs.sys
   IoCallDriver → RefsFsdWrite → RefsCommonWrite
3. RefsCommonWrite invokes RefsPrepareMdlWriteA / RefsCopyWriteA when it
   decides to satisfy the request via MDL/copy write.
4. Pre-patch functions add Offset + Length without overflow or range
   checks; negative / wrapped values propagate.
5. RefsCopyWriteInternal allocates an MDL / heap buffer based on the
   *truncated* length, then copies the caller’s data, corrupting heap
   memory beyond the allocation and allowing arbitrary kernel code
   execution.

Attack Vector
--------------------------------------------------------------------
An authenticated attacker controlling a write operation to an ReFS
volume (e.g. over SMB, iSCSI, or local low-privilege code) supplies a
large Length together with a crafted starting offset such that
Offset + Length wraps around 64 bits or exceeds the volume boundary.
This leads to a heap buffer overflow in the kernel, enabling remote code
execution in the context of the kernel.


Patch Description
--------------------------------------------------------------------
1. Introduced REFS_VBO_RANGE::IsValid and invoked it from
   RefsPrepareMdlWriteA, RefsCopyWriteA and RefsCommonWrite.
   • Verifies that 0 <= Offset <= Offset+Length ≤ MAX_VBO, preventing
     wrap-around and over-end conditions.
2. Added early-return logic – if the range is invalid the helpers now
   bail out with STATUS_SUCCESS (0) and no data movement occurs.
3. Additional size and boundary checks were inserted into
   RefsCheckStreamSnapshotManagementBuffers to clamp sub-structure sizes
   to 0x1FD bytes and to verify alignment.
4. RefsCommonCreate gained a defensive JUMPOUT after an internal error
   path to avoid executing code after a raised exception.
5. All new checks are conditionally compiled behind
   Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage_* gates, enabling
   gradual rollout.

Security Impact
--------------------------------------------------------------------
Prior to the fix a malicious or buggy caller could trigger a 64-bit
integer overflow that leads to an undersized heap allocation followed by
a large memcpy/MDL operation.  This permits arbitrary kernel memory
overwrite and therefore enables remote or local escalation to kernel
code execution (RCE/LPE).  Successful exploitation compromises the
kernel and fully subverts the operating system.

Fix Effectiveness
--------------------------------------------------------------------
The added REFS_VBO_RANGE::IsValid() gate ensures that only monotonically
increasing, non-wrapping VBO ranges are accepted.  By rejecting requests
where Offset + Length exceeds the 64-bit limit or the volume boundary,
the immediate overflow avenue is closed.  Because identical validation
is now present in all entry points (MDL write, copy write, common
write), the vulnerable code path is no longer reachable when the feature
flag is enabled.  The robustness of the fix depends on comprehensive use
of IsValid in **all** similar paths; no further issues are visible in
the provided diffs, but untested call-sites or a disabled feature flag
could still permit exploitation.  Overall, the patch correctly addresses
the demonstrated flaw.
