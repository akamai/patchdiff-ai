{'kb': 'KB5071417', 'file': 'win32kbase.sys', 'change_count': 290, 'cve': 'CVE-2025-62458', 'confidence': 0.36, 'patch_store_uid': '8bbc19ca-11ea-4f5c-a888-15dc4ad7c65d', 'date': 1765357811.8239346}
--------------------------------------------------------------------
CVE-2025-62458 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
win32kbase.sys – helper routine StringCchCopyW used by multiple GDI/
window-manager code paths inside the Windows kernel (GRFX family).


Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow caused by mismatched function prototype /
parameter confusion (CWE-122: Heap-based Buffer Overflow).


Detailed Root Cause Analysis
--------------------------------------------------------------------
Prior to the patch the kernel copy wrapper was compiled with the
following prototype:

  HRESULT StringCchCopyW(ushort *pszDest,
                         size_t  cchDest,
                         size_t *pszSrc)      // WRONG TYPE

The implementation immediately forwarded the three arguments to the
internal StrSafe helper:

  StringCopyWorkerW(pszDest,
                    cchDest,
                    pszSrc,              // 3rd param should be **output**
                    (PCNZWCH)pszSrc,     // 4th param is real source string
                    0x7FFFFFFE);

In the official StrSafe header the 3rd argument of StringCopyWorkerW is
`STRSAFE_LPWSTR *ppszDestEnd` – a writable pointer that receives the
address of the string terminator.  By passing the *source* buffer in
this slot the kernel forces StringCopyWorkerW to write one machine word
(pointer sized) into attacker-controlled heap memory (the beginning of
the source string).  If the source string is allocated exactly, this
write lands past the end of the allocation, corrupting the adjacent pool
chunk.  Because the function runs in kernel mode, the corruption occurs
in kernel heap memory, giving the attacker a powerful primitive for
further exploitation (e.g. pool metadata smash, fake object pointer,
etc.).

Boundary validation on `cchDest` still existed, but it protected only the
destination buffer; the inadvertent write to the source buffer was
completely unchecked.  Any caller that passes a user-controlled UNICODE
string to win32k (for example via window class registration, menu APIs,
Clipboard formats, etc.) can trigger the overflow in the privileged
context that processes the request.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Before
HRESULT __fastcall StringCchCopyW(ushort *a1, size_t a2, size_t *a3)
{
    if (a2 - 1 <= 0x7FFFFFFE)
        return StringCopyWorkerW(a1,        // dest
                                 a2,        // dest size
                                 a3,        // WRONG – writable output
                                 (PCNZWCH)a3, // actual src
                                 0x7FFFFFFE);
    ...
}

// After – fully rewritten, passes no writable pointer into src memory
HRESULT __stdcall StringCchCopyW(LPWSTR pszDest,
                                 size_t cchDest,
                                 LPCWSTR pszSrc)
{
    ... // explicit guarded copy loop
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-mode caller
  -> win32k.sys API receiving UNICODE_STRING (exact API unknown)
      -> internal helper builds heap string and calls
         win32kbase!StringCchCopyW
           -> StringCopyWorkerW overwrites memory in source buffer
              (heap chunk), leading to pool corruption.


Attack Vector
--------------------------------------------------------------------
A local authenticated attacker provides a crafted UNICODE source string
(of controllable length and pool layout) to any kernel path that ends up
invoking StringCchCopyW.  Because win32k operates on user-supplied
window titles, class names, atom strings, etc., several reachable
attack surfaces exist from a low-privilege process.


Patch Description
--------------------------------------------------------------------
Microsoft replaced the wrapper with an in-line, bounds-checked copy
routine and corrected the prototype to:

  StringCchCopyW(LPWSTR pszDest, size_t cchDest, LPCWSTR pszSrc);

No writable pointer is forwarded to StrSafe anymore; instead the routine
performs its own guarded copy and always terminates the string.  When
the destination buffer is too small it now fails with
HRESULT 0x8007007A (STRSAFE_E_INSUFFICIENT_BUFFER) without corrupting
memory.


Security Impact
--------------------------------------------------------------------
Prior to the fix an attacker could perform an arbitrary 8-byte (on x64)
heap overwrite inside the Windows kernel, enabling pool grooming to
achieve controlled EIP/RIP or object pointer hijacking and therefore
local privilege escalation to SYSTEM.  The vulnerability is reliably
triggerable from a sandboxed or low-integrity process.


Fix Effectiveness
--------------------------------------------------------------------
The new implementation eliminates the parameter mismatch and the
unintended write to the source buffer.  All writes are now confined to
the destination buffer and are guarded by explicit `cchDest` checks.
Assuming no other call sites rely on the old prototype, the patch fully
neutralizes the identified overflow condition.
