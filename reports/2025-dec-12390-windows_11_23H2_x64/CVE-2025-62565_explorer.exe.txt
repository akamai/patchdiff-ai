{'confidence': 0.2, 'date': 1765357717.243655, 'kb': 'KB5071417', 'file': 'explorer.exe', 'change_count': 10, 'cve': 'CVE-2025-62565', 'patch_store_uid': '78402265-3655-4e8d-b3c1-1862a7d9c7e9'}
--------------------------------------------------------------------
CVE-2025-62565 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Shell – explorer.exe.  Affected sub-module is the secondary
Taskbar ("SecondaryTaskBand") worker window implementation contained
in CImpWorkerWndProc, CSecondaryTaskBand and the helper routine that
stores the object pointer in window user-data.


Vulnerability Class
--------------------------------------------------------------------
Use After Free (CWE-416).


Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  Each SecondaryTaskBand instance creates an invisible worker window.
    The CImpWorkerWndProc::s_WndProc dispatch routine associates the
    CImpWorkerWndProc object with the window by calling
    SetWindowLongPtrW(hWnd, 0, pObj).

2.  Before the patch the message handler retrieved the pointer with
    GetWindowLongPtrW and immediately executed the virtual callback:
        obj->WndProc(obj, hWnd, Msg, wParam, lParam);
    No lifetime protection was applied.

3.  When WM_NCDESTROY (value 130) is received, the same routine
    executed:
        SetWindowLongPtrW(hWnd, 0, 0);
        obj->m_hWnd = 0;               // v9[1] = 0
    The object could subsequently self-destruct (directly or through
    reference counting in OnWindowDestroyed) while the local variable
    still held the stale pointer.  Any re-entrancy, timer, subclass or
    asynchronous callback that used that pointer after the free led to
    a classic UAF.

4.  The destructor of CSecondaryTaskBand also had the wrong field
    layout and did not invoke the base CImpWorkerWndProc dtor, leaving
    additional dangling references.

5.  Because explorer.exe runs with the user’s shell privileges, a
    malicious local process that can induce the destruction sequence
    (e.g. by rapidly creating / destroying secondary taskbars or by
    sending crafted messages once it owns the worker window) can cause
    controlled memory corruption inside the explorer process and
    escalate to the associated integrity level.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Before
WindowLongPtrW = (PVOID)GetWindowLongPtrW(hWnd, 0);
if (!WindowLongPtrW)
    return DefWindowProcW(...);
ret = WindowLongPtrW->WndProc(...);
if (Msg == WM_NCDESTROY) {
    SetWindowLongPtrW(hWnd, 0, 0);
    WindowLongPtrW[1] = 0;   // object may be freed here
}
// No refcount held – stale pointer
```
```c
// After
pObj = (CImpWorkerWndProc*)GetWindowLongPtrW(a1, 0);
if (pObj) {
    CImpWorkerWndProc::AddWndRef(pObj);   // hold reference
    ret = pObj->WndProc(...);
    if (Msg == WM_NCDESTROY) {
        SetWindowPtr(a1, 0, 0);           // clears user data
        pObj->OnWindowDestroyed();
    }
    CImpWorkerWndProc::ReleaseWndRef(pObj);  // safe release
    return ret;
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker forces creation of a SecondaryTaskBand worker window.
2. Attacker causes window destruction (e.g. DestroyWindow or monitor
   removal) -> WM_NCDESTROY.
3. Explorer’s s_WndProc zeroes user data then frees the object while
   still executing inside the same routine.
4. Any subsequently posted or re-entered message dereferences the now
   freed memory, leading to memory corruption.


Attack Vector
--------------------------------------------------------------------
Local.  A normal user can interact with Explorer’s secondary taskbar
features or send crafted window messages via the Win32 messaging
system to trigger the vulnerable destruction path.


Patch Description
--------------------------------------------------------------------
1. Introduced a tiny wrapper SetWindowPtr that only forwards to
   SetWindowLongPtrW, removing the earlier complex lambda that could
   re-enter shell code while holding no references.
2. Added explicit AddWndRef / ReleaseWndRef around every message
   dispatch to hold a stable reference for the duration of processing.
3. Added OnWindowDestroyed to perform final cleanup after the window
   pointer is cleared.
4. Re-ordered and extended CSecondaryTaskBand’s members; constructor
   zero-initialises new fields and destructor now invokes
   CImpWorkerWndProc dtor, ensuring that all window-related resources
   are released before the object memory is freed.


Security Impact
--------------------------------------------------------------------
Prior to the fix a local attacker could execute code in the context of
explorer.exe by exploiting the UAF, thereby gaining elevation of
privilege to the current shell integrity level (typically medium or
higher).  The flaw is exploitable because the freed VFT pointer is
invoked without validation.


Fix Effectiveness
--------------------------------------------------------------------
The added reference counting guarantees the object remains alive for
all message processing paths, and OnWindowDestroyed releases the final
reference only after the window data is cleared.  Because every access
now goes through AddWndRef / ReleaseWndRef, post-free dereferences are
prevented.  No remaining code paths to the freed memory were observed
in the supplied diff, indicating the patch fully mitigates the UAF.

