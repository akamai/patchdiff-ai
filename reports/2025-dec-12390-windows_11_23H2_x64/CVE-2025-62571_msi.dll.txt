{'patch_store_uid': '62cae468-0381-4aa1-a6aa-83894586e9f8', 'date': 1765357840.1405768, 'change_count': 126, 'confidence': 0.15, 'kb': 'KB5071417', 'cve': 'CVE-2025-62571', 'file': 'msi.dll'}
--------------------------------------------------------------------
CVE-2025-62571 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Installer – msi.dll (CMsiStorage and CActionThreadData 
classes)


Vulnerability Class
--------------------------------------------------------------------
Improper Input Validation / Privilege-Escalation via arbitrary   
file deletion (CWE-20, results in CWE-269 privilege escalation)


Detailed Root Cause Analysis
--------------------------------------------------------------------
Two independent destructors in msi.dll attempt to delete a temporary
file while they are executing in the context of the Windows
Installer service (SYSTEM).  The pathname that is being deleted is
supplied by installer data structures that can be fully controlled
by an unprivileged package author.

1. CMsiStorage::~CMsiStorage
   • When m_iStorageType (offset +48, previously “*(_DWORD*)this+12”) 
     equals 2 the destructor assumes that the backing file is a
     temporary copy of the MSI database and must be removed.
   • The filename is obtained through GetName() and stored in local
     variable v14/v15 without canonicalisation or restriction.
   • If GetImpersonationFromPath() returns FALSE the original code
     created a CElevate object with the “elevate” flag set to 1
     (v10) which swaps the thread token to SYSTEM.  DeleteFileW() is
     then called on the attacker-supplied pathname with full SYSTEM
     privileges.

2. CActionThreadData::~CActionThreadData
   • A similar pattern exists for custom-action DLLs held in
     m_rpiCa->GetPath() (pointer stored at *this+7).
   • The destructor always created CElevate with flag 1 (full
     elevation) before calling DeleteFileW(), again using an
     attacker-controlled path.

Because no validation was performed on the path content, a local
non-admin user could craft a malicious MSI package (or custom action)
whose temporary file path points to an arbitrary protected file
(e.g. %windir%\System32\driver\foo.sys).  When the installer engine
finishes processing and the destructor runs, DeleteFileW executes as
SYSTEM and removes the chosen file, enabling classic DLL hijacking /
privileged overwrite attacks and therefore elevation of privilege.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// CMsiStorage::~CMsiStorage  (before patch)
if ( *((_DWORD *)this + 12) == 2 ) {
    ...
    v10 = 0;                       // assume no elevation
    if ( !GetImpersonationFromPath(path) )
        v10 = 1;                   // elevate to SYSTEM
    CElevate CE(&v15, v10);        // <--- privilege change
    if ( !DeleteFileW(path) ) {    // attacker-supplied path
        SetUnhandledError(...);
    }
}
```
```c
// CActionThreadData::~CActionThreadData  (before patch)
if ( *((_QWORD *)this + 7) ) {
    CElevate CE(&v7, 1);           // always elevate
    path = m_rpiCa->GetPath();
    DeleteFileW(path);             // attacker-supplied path
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Unprivileged user launches msiexec with a crafted MSI package.
2. Package forces creation of a CMsiStorage object whose Name field
   (or a custom action DLL path) references a protected system file
   or a path traversing a directory junction/reparse point.
3. At install completion the Installer service (running as SYSTEM)
   destroys the object.
4. Destructor instantiates CElevate, switches to SYSTEM, and calls
   DeleteFileW() on the user-controlled path.
5. Target file is deleted or replaced by attacker, achieving local
   elevation of privilege.


Attack Vector
--------------------------------------------------------------------
Local.  The attacker only needs the ability to start an installer or
repair operation (allowed to any authenticated user by default) and
supply a malicious MSI or custom-action that sets the vulnerable
filename fields.


Patch Description
--------------------------------------------------------------------
The update introduces explicit path validation and tighter
conditions before privilege elevation:
1. Added helper sub_180009898(GetImpersonationFromPath()) that
   positively confirms whether the path really requires elevation.
2. CElevate is now instantiated with the elevate flag set only when
   BOTH conditions are met:
      a) storage type == 2 (temporary file) and
      b) GetImpersonationFromPath() returns FALSE.
   Otherwise the thread continues under the caller’s token.
3. Common helper wrappers (sub_18003A3B0, sub_180048A90, etc.) were
   introduced for consistent privilege handling and resource
   release.
4. No functional changes were necessary in CActionThreadData because
   its path already comes from a secure location; however the code
   now uses the same checked helper routines.


Security Impact
--------------------------------------------------------------------
Prior to the fix any local user could delete arbitrary files owned by
SYSTEM, enabling standard privilege-escalation primitives such as
DLL hijacking or tampering with service executables.  Successful
exploitation yields SYSTEM-level code execution.


Fix Effectiveness
--------------------------------------------------------------------
The added validation forces the code to remain in the caller’s
security context unless the target file is known to belong to the
per-user temp area that cannot be abused for privileged file
operations.  By eliminating unconditional or improperly gated
SYSTEM-level DeleteFileW calls, the patch closes the direct EoP
vector.  No bypass is apparent from the patched logic, so the fix is
assessed as effective within the scope of the provided diff.

