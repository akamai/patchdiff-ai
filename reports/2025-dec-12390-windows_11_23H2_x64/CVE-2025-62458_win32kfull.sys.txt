{'cve': 'CVE-2025-62458', 'patch_store_uid': '85098c92-3fb5-4431-a895-9bcbae1ce4e5', 'date': 1765357901.192001, 'file': 'win32kfull.sys', 'change_count': 138, 'kb': 'KB5071417', 'confidence': 0.28}
--------------------------------------------------------------------
CVE-2025-62458 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows kernel graphics subsystem (win32kfull.sys).  The
faulting routine is GreGradientFill; auxiliary fixes are visible in
GreDrawEscape() and GreDrawStream().

Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow caused by signed/unsigned integer overflow
in pool-size calculations (CWE-190 + CWE-122).

Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  User-mode code calls the documented GDI API GradientFill().  The
    system service stubs land in NtGdiGradientFill → GreGradientFill().

2.  GreGradientFill receives three user-controlled counters:
      a3 – number of TRIVERTEX structures
      a5 – number of mesh elements (GRADIENTTRIANGLE / GRADIENTRECT)
      a6 – mode (triangle = 2, rectangle = 1)

3.  The pre-patch function performs several size checks, but all of the
    intermediate variables are 32-bit:
       v29 = 2 * a5;                     // 32-bit
       v30 = 12 * v29;                   // 32-bit
       v31 = v9 + 2 * a5;                // v9 == (UINT)a3
       v32 = 16 * v31;                   // 32-bit
       v33 = v32 + v30;                  // 32-bit

    If a3 or a5 are large enough, the 32-bit multiplications wrap and
    v33 becomes far smaller than the real memory requirement.

4.  Win32AllocPool() then allocates only v33 bytes.  Immediately after
    that a tight copy loop writes 16 bytes for every vertex and 12 bytes
    for every mesh element into the new buffer:
       do { *dst = *src; … } while(--count);

    Because the buffer is undersized, the loop overruns the pool
    allocation, corrupting the session heap.

5.  The corrupted heap memory is in the kernel address space; an
    attacker can shape the surrounding allocations to gain arbitrary
    read/write primitives and eventually execute code with Ring-0
    privileges, resulting in a local elevation of privilege.

6.  The accompanying changes in GreDrawEscape() and GreDrawStream()
    perform the same 64-bit-safe arithmetic and type tightening, but no
    overflow was demonstrated there.  They were patched pre-emptively
    to avoid identical issues.

Vulnerability Code Snippets
--------------------------------------------------------------------
Pre-patch excerpt (32-bit arithmetic):
```c
v29 = 2 * a5;                 // may overflow
v30 = 12 * (unsigned int)v29; // may overflow
v31 = v9 + 2 * a5;            // v9 = (UINT)a3
v32 = 16 * v31;               // may overflow
v33 = v32 + v30;              // final pool size (32-bit)
...
ptr = Win32AllocPool(v33, TAG);
// copy loop blindly writes 16*vertex + 12*mesh bytes
```

Post-patch excerpt (64-bit arithmetic + range checks):
```c
v25 = 2i64 * a5;
if (v25 > 0xFFFFFFFF) fail;
v26 = 12i64 * (unsigned int)v25;
...
v28 = 16i64 * v27;
...
if (v29 <= 0x2710000) ptr = Win32AllocPool(v29, TAG);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User process → gdi32!GradientFill()
2. NtGdiGradientFill (syscall)
3. win32kfull!GreGradientFill()
4. Integer overflow in size maths ⇒ undersized buffer
5. memcpy-style loop overruns allocation ⇒ heap corruption
6. Corrupted session heap ⇒ controlled write in kernel ⇒ privilege
   escalation.

Attack Vector
--------------------------------------------------------------------
Any local, sandboxed or low-privilege process that can call GDI APIs
can supply crafted a3/a5 values to GradientFill(), causing the kernel to
perform the overflow.  No special privileges are required beyond the
ability to open a device context.

Patch Description
--------------------------------------------------------------------
• The third GreGradientFill parameter was changed from 64-bit to
  strictly unsigned 32-bit, clarifying its domain.
• All size computations were converted to 64-bit (unsigned __int64)
  variables.
• Each multiplication/addition is now followed by an explicit overflow
  test against 0xFFFFFFFF and the global 0x2710000 (40 MB) allocation
  limit.
• Identical hardened arithmetic was applied to GreDrawEscape() and
  GreDrawStream().

Security Impact
--------------------------------------------------------------------
Before the fix, a malicious local user could corrupt kernel heap memory
and execute arbitrary code in kernel mode, leading to a full Elevation
of Privilege (EoP).  The issue is rated Important/High.

Fix Effectiveness
--------------------------------------------------------------------
The new 64-bit calculations eliminate integer wrap-around; combined with
strict upper-bound checks the pool can no longer be under-allocated, so
the overflowing copy is impossible.  Fuzzing with maximal vertex/mesh
counts and boundary values is recommended, but no bypass is evident
from the diff.
