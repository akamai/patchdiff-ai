{'kb': 'KB5071417', 'cve': 'CVE-2025-62565', 'change_count': 1, 'file': 'windows.ui.fileexplorer.dll', 'date': 1765357712.6919427, 'confidence': 0.27, 'patch_store_uid': 'bc9e2309-a73f-467a-b6c8-1c76829f5b43'}
--------------------------------------------------------------------
CVE-2025-62565 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Shell (File Explorer) – XamlExplorerChildWindowFlyout object
constructed in windows.ui.fileexplorer.dll.

Vulnerability Class
--------------------------------------------------------------------
Use-After-Free (CWE-416)

Detailed Root Cause Analysis
--------------------------------------------------------------------
The helper routine
std::_Ref_count_obj2<XamlExplorerChildWindowFlyout>::_Ref_count_obj2
builds a XamlExplorerChildWindowFlyout instance and forwards a
winrt::param::hstring to the internal constructor of
XamlExplorerHostChildWindow_WASDK.

In the vulnerable build the hstring wrapper is assembled on the stack
as follows:
  • v11[0] stores the HSTRING reference-count tag (1)
  • v11[1] stores the character count
  • v12 holds a pointer to the literal String1
  • v10 is a *pointer* that is set to v11

The code then passes **&v10** (i.e. a pointer to a stack pointer) to
XamlExplorerHostChildWindow_WASDK.  That routine keeps the supplied
pointer for later use.  Once _Ref_count_obj2() returns the stack frame
is destroyed, leaving the child-window object with a dangling pointer.
Subsequent dereference of that pointer results in a use-after-free of
freed stack memory.

Because the contents of the vacated stack region can be influenced by
later function calls, an attacker able to trigger creation of a
XamlExplorerChildWindowFlyout can force controlled data to be treated
as a live hstring object, leading to out-of-bounds reads/writes and
ultimately elevation of privilege in the Shell process.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable implementation
int *v10;            // pointer holder
int v11[4];          // stack buffer for hstring
...
v11[0] = 1;          // ref tag
v11[1] = v5;         // length
v12      = &String1; // payload pointer
v10      = v11;      // v10 -> stack buffer
...
XamlExplorerHostChildWindow_WASDK( v4, (UINT64)v3,
    (const winrt::param::hstring *)&v10 ); // &v10 survives past return
```
```c
// fixed implementation
__int128 v10;        // hstring stored inline (16 bytes)
...
DWORD2(v10)  = 1;    // ref tag
HIDWORD(v10) = v5;   // length
v11          = &String1;
*(QWORD *)&v10 = (char *)&v10 + 8; // internal pointer within v10
```
The new code passes the address of v10, whose internal pointer now
references memory *inside* the same 128-bit object.  Therefore the
callee receives a complete, self-contained hstring value that it can
copy, instead of a pointer to ephemeral stack memory.

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User or attacker code requests a XamlExplorer fly-out in File
   Explorer.
2. windows.ui.fileexplorer.dll calls
   _Ref_count_obj2<XamlExplorerChildWindowFlyout>().
3. Vulnerable path passes &v10 to
   XamlExplorerHostChildWindow_WASDK and returns.
4. Later Shell/UI code dereferences the stored hstring -> UAF.

Attack Vector
--------------------------------------------------------------------
Local.  A low-privileged process can invoke the relevant Shell COM/WINRT
APIs to create a XamlExplorerChildWindowFlyout, then cause subsequent
operations (e.g., Bounds(), FlowDirection()) that access the dangling
hstring pointer, permitting arbitrary memory manipulation in the
high-integrity File Explorer process.

Patch Description
--------------------------------------------------------------------
1. Replaced the pair <int *v10, int v11[4]> with a single 128-bit
   variable storing the complete hstring structure in-place.
2. Built the hstring so that its internal buffer pointer refers to the
   second quad-word inside v10, avoiding references to separate stack
   arrays.
3. Added feature-flag gated cleanup of v10 before a secondary Bounds()
   call, ensuring no stale contents remain.

Security Impact
--------------------------------------------------------------------
The dangling pointer allowed arbitrary read/write of Explorer process
memory, making it possible for an authenticated local attacker to
execute code in the context of the File Explorer (typically running
with higher integrity), resulting in privilege escalation.

Fix Effectiveness
--------------------------------------------------------------------
By embedding the complete hstring in a single stack object and passing
its address, the callee receives a valid, self-contained copy that it
can immediately duplicate.  No external or dangling stack pointers are
exposed, eliminating the lifetime mismatch that led to the
use-after-free.  The additional zeroing of the variable before the
Bounds() call further reduces residual risk.  No remaining code paths
expose pointers to transient stack memory, therefore the patch is
considered effective.
