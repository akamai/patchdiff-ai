{'change_count': 8, 'patch_store_uid': 'f4d037e3-9a75-4e46-9415-c72a6e461ab3', 'kb': 'KB5071417', 'confidence': 0.12, 'cve': 'CVE-2025-62567', 'file': 'vmswitch.sys', 'date': 1765358438.643125}
--------------------------------------------------------------------
CVE-2025-62567 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Hyper-V virtual-switch kernel driver (vmswitch.sys),
particularly the helper routine pair RtlAcquireWriteLock (exported) and
its internal twin at 0x1C01ADC6C used by several switch sub-components
(e.g. VmsDriverUnload, VmsEtw, VmsCdp, QoS, VMQ, RSS, etc.).  The driver
implements a private reader/writer synchronisation primitive whose data
structure starts with a spin-lock followed by a 32-bit reader reference
count.


Vulnerability Class
--------------------------------------------------------------------
CWE-191: Integer Underflow / Wrap-around leading to incorrect bounds /
status validation and logic error, ultimately allowing a denial of
service (system crash / hang).


Detailed Root Cause Analysis
--------------------------------------------------------------------
1. The vmswitch driver exposes an auxiliary function named
   RtlAcquireWriteLock( lock *, KLOCK_QUEUE_HANDLE * ).  The routine is
   supposed to obtain an exclusive (writer) lock by:
      a. Taking the spin-lock embedded in the supplied lock structure
         (first 8 bytes at "lock"), and
      b. Spinning until the reader-count field at offset +8 becomes 0.
2. In the vulnerable build the code is:
      KeAcquireInStackQueuedSpinLock(&VmsEtwFilterLock, Handle);
      do
          count = dword_1C0230408;   // **global** variable
      while (dword_1C0230408);
   Instead of using the caller-supplied lock, the function pins a *global*
   spin-lock (VmsEtwFilterLock) and polls a *global* counter
   (dword_1C0230408).
3. Because each logical reader/writer lock instance maintains its own
   per-object counter at (lock+8), the exported writer routine is now
   synchronising against the wrong variable:
      • If readers acquire their lock they increment *(lock+8).
      • The writer, however, waits while dword_1C0230408 != 0.  This
        global counter is unrelated and normally remains 0.
4. Resulting failure modes:
      a. Writer may believe no readers exist and enter the critical
         section while readers are still active, corrupting shared state
         and ultimately crashing the host (BUGCHECK 0x109 / 0x3B etc.).
      b. Conversely, heavy reader activity on multiple locks can
         decrement the *wrong* counter, causing an underflow from 0 to
         0xFFFFFFFF.  The writer then spins forever because the value is
         never able to return to 0, leading to a CPU hang and system‐
         wide denial of service.
5. The issue is reachable from multiple guest-controllable code paths
   (e.g., VMSwitch handling of NDIS OIDs, port properties, or packet
   processing) because they eventually invoke RtlAcquireWriteLock(), so
   an authenticated guest can trigger the race repeatedly until the host
   crashes or becomes unresponsive.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable vmswitch.sys (before)
__int64 __fastcall RtlAcquireWriteLock(__int64 a1, KLOCK_QUEUE_HANDLE *a2)
{
    KeAcquireInStackQueuedSpinLock(&VmsEtwFilterLock, a2); // WRONG LOCK
    do                                   // poll wrong counter
        result = (unsigned int)dword_1C0230408;           // global
    while (dword_1C0230408);
    return result;
}
```

```c
// fixed vmswitch.sys (after)
__int64 __fastcall RtlAcquireWriteLock(__int64 a1, KLOCK_QUEUE_HANDLE *a2)
{
    KeAcquireInStackQueuedSpinLockAtDpcLevel((PKSPIN_LOCK)a1, a2); // right lock
    do
        result = *(unsigned int *)(a1 + 8);   // per-lock reader count
    while ((DWORD)result);
    return result;
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. An authenticated guest issues network/NDIS operations (e.g., VMQ,
   RSS, QoS, port-property or control IOCTL).
2. vmswitch.sys processes the request (e.g., VmsCdpDeviceControl ->
   RtlAcquireWriteLock_0, VmsVmqDoVmqOperation -> RtlAcquireWriteLock).
3. Multiple guest-triggered reader acquisitions increment the *correct*
   per-lock counter (lock+8) but leave the global dword_1C0230408 at 0.
4. A parallel code path requests the writer lock; the buggy
   RtlAcquireWriteLock observes dword_1C0230408 == 0, exits the spin
   loop immediately, and enters the critical section while readers are
   active, corrupting internal structures and crashing the host.
   Alternatively, if the wrong global counter wraps to 0 after an
   underflow, the writer spins indefinitely, hanging a CPU and causing
   a system-wide DoS.


Attack Vector
--------------------------------------------------------------------
A malicious or compromised guest VM that is allowed to issue standard
Hyper-V switch control or network configuration operations (NDIS OID
requests, port property changes, or PD-related operations) can flood the
hypervisor with concurrent reader activities followed by a writer
operation, exploiting the incorrect counter to induce memory corruption
or an infinite spin loop, resulting in a denial of service of the
Hyper-V host.


Patch Description
--------------------------------------------------------------------
1. Corrected the writer-lock acquisition routine:
   • Replaced the hard-coded use of the global spin-lock
     (VmsEtwFilterLock) with the caller-supplied lock pointer.
   • The spin wait now observes the reader count stored in the lock
     object (*(lock+8)) instead of the unrelated global counter.
2. The old, incorrect implementation was renamed (sub_1C01ADC6C) and is
   now used solely for a single global lock that really *does* employ
   qword_1C0230400 / dword_1C0230408.
3. Additional hardening changes were applied (e.g., stricter GS cookie
   check with __fastfail, refactoring of WPP tracing helpers), but the
   core security fix is the corrected lock implementation.


Security Impact
--------------------------------------------------------------------
Because the writer lock could be granted while readers were still
holding the resource, internal shared data structures of the Hyper-V
virtual switch could be concurrently modified, leading to memory
corruption and immediate bugcheck (CRITICAL_STRUCTURE_CORRUPTION) or to
an endless tight spin loop that locks a CPU.  Either outcome results in
kernel crash or system hang, allowing an authenticated attacker within a
VM to force a denial of service of the entire Hyper-V host (CVE-2025-
62567).


Fix Effectiveness
--------------------------------------------------------------------
The patched build now uses the correct per-lock spin-lock and reader
count, fully eliminating the possibility of an integer wrap-around or
mismatch between reader and writer accounting.  The erroneous global
variable usage is confined to a dedicated helper that is only used with
that specific global lock, preventing cross-lock interference.
Therefore the vulnerability is effectively mitigated.
