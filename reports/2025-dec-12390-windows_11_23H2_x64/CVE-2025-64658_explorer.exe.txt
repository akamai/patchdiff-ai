{'cve': 'CVE-2025-64658', 'kb': 'KB5071417', 'file': 'explorer.exe', 'confidence': 0.32, 'date': 1765358421.4604774, 'patch_store_uid': '78402265-3655-4e8d-b3c1-1862a7d9c7e9', 'change_count': 10}
--------------------------------------------------------------------
CVE-2025-64658 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Shell (explorer.exe) – worker-window infrastructure handled by
CImpWorkerWndProc, SetWindowPtr helper and Secondary Task Band support
objects.

Vulnerability Class
--------------------------------------------------------------------
Race condition / use-after-free leading to local elevation of privilege
(CWE-362, CWE-416).

Detailed Root Cause Analysis
--------------------------------------------------------------------
A CImpWorkerWndProc instance is associated with a helper HWND. The
instance pointer is stored in the window’s extra bytes (index 0) through
SetWindowLongPtrW and is later fetched with GetWindowLongPtrW inside the
static window procedure CImpWorkerWndProc::s_WndProc.

Before the patch the flow was:
1. s_WndProc obtains the raw pointer with
   GetWindowLongPtrW(hWnd,0) and immediately treats it as a valid
   CImpWorkerWndProc object (vtable dereference).
2. The virtual window-specific procedure is invoked.
3. When a WM_NCDESTROY (message 130) is seen, the code clears the extra
   bytes with SetWindowLongPtrW(hWnd,0,0) and zeroes the secondary field
   v9[1] = 0, effectively detaching the C++ object from the window.
4. **No reference counting or synchronisation** protects the object’s
   lifetime while messages are still being processed on the window’s
   thread or while other threads can concurrently send messages to the
   same HWND.

Because WM_NCDESTROY can be triggered by an attacker-controlled thread
(PostMessage), the following race exists:
• Thread-A: enters s_WndProc, reads object pointer P.
• Thread-B: sends WM_NCDESTROY, s_WndProc removes P and the object is
  destroyed (Release()).
• Thread-A resumes and dereferences P (now freed memory).  This produces
  a use-after-free with attacker-controlled timing and partial control
  over the freed memory contents.

Explorer runs with the logged-in user’s integrity level, but the worker
object methods eventually call privileged shell APIs. By shaping the
freed memory, an attacker can hijack the vtable pointer and redirect
execution to attacker-controlled code, achieving local elevation of
privilege.

The vulnerable data path involves:
  – HWND extra memory slot 0
  – CImpWorkerWndProc object (first QWORD is the vtable, second QWORD is
    a back-pointer used by the code, cleared on destroy)
  – Window messages (especially WM_NCDESTROY, value 0x82)

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// BEFORE
WindowLongPtrW = (void**)GetWindowLongPtrW(hWnd, 0);
if (!WindowLongPtrW)
    return DefWindowProcW(...);
ret = (**WindowLongPtrW)(WindowLongPtrW, hWnd, Msg, wParam, lParam);
if (Msg == 130) {
    SetWindowLongPtrW(hWnd, 0, 0);
    WindowLongPtrW[1] = 0;   // object now free, no ref held
}
```
```c
// AFTER
WindowLongPtrW = (CImpWorkerWndProc*)GetWindowLongPtrW(a1, 0);
if (WindowLongPtrW) {
    CImpWorkerWndProc::AddWndRef(WindowLongPtrW);   // ++ref
    ret = WindowLongPtrW->WndProc(...);
    if (Msg == 130) {
        SetWindowPtr(a1, v10, 0);                   // helper wrapper
        WindowLongPtrW->m_pSelf = nullptr;
        CImpWorkerWndProc::OnWindowDestroyed(...);
    }
    CImpWorkerWndProc::ReleaseWndRef(WindowLongPtrW); // --ref
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker locates or creates a secondary task-band worker window
   belonging to explorer.exe and obtains its HWND.
2. Thread-A (explorer UI thread) is busy processing messages.
3. Attacker posts WM_NCDESTROY to the HWND from a helper thread (or
   forces the window to be destroyed).
4. Race:
   a. Thread-A enters s_WndProc for another message, reads object ptr P.
   b. Thread-B’s WM_NCDESTROY is processed first, object is deleted.
   c. Thread-A resumes, calls P->vtable – use-after-free.
5. Crafted heap spraying replaces freed memory, hijacking execution and
   elevating privileges.

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker. Requires the ability to post window
messages to explorer’s GUI thread, which any same-desktop process can
perform.

Patch Description
--------------------------------------------------------------------
1. Introduced SetWindowPtr() wrapper that simply forwards to
   SetWindowLongPtrW, easing future auditing.
2. Added reference-count helpers AddWndRef / ReleaseWndRef and ensured
   the object reference count is incremented before dispatch and
   decremented afterwards, preventing premature destruction.
3. On WM_NCDESTROY the code now also calls
   CImpWorkerWndProc::OnWindowDestroyed and releases internal state only
   after ref-count logic.
4. New feature flag 2337501498 gates the hardened path.  Old unsafeguard
   branch kept only for legacy but now hidden behind the feature switch.
5. SecondaryTaskBand constructor now zero-initialises critical members to
   avoid stale pointers during early failure paths.

Security Impact
--------------------------------------------------------------------
Before the fix an attacker could reliably trigger a use-after-free in the
high-integrity explorer process and gain arbitrary code execution in the
context of the logged-on user, thereby elevating privileges, escaping UI
security boundaries and potentially bypassing UAC.

Fix Effectiveness
--------------------------------------------------------------------
The added reference counting guarantees the CImpWorkerWndProc object is
alive for the entire duration of message processing, eliminating the
race.  Clearing of the window pointer now happens through a dedicated
helper and only after OnWindowDestroyed, with balanced Release.  No
remaining unguarded dereferences were observed in the patched diff,
therefore the fix is considered effective.
