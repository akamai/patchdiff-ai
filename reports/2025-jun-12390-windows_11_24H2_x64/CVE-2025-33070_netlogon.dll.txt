{'kb': 'KB5060842', 'date': 1763415594.61646, 'change_count': 46, 'confidence': 0.33, 'patch_store_uid': '77729ec0-6d71-4d12-ac3e-650525e5c1b2', 'file': 'netlogon.dll', 'cve': 'CVE-2025-33070'}
--------------------------------------------------------------------
CVE-2025-33070 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows – Netlogon service (netlogon.dll)

Vulnerability Class
--------------------------------------------------------------------
Use of Un-initialised Resource / unchecked-return-value leading to
privilege-elevation (CWE-908)

Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  Netlogon calculates authentication credentials through the internal
    helper NlComputeCredentials().  The routine can fail at several
    points (BCryptGetProperty, BCryptGenerateSymmetricKey, BCryptEncrypt
    or SystemFunction001) and returns the NTSTATUS error code.

2.  Prior to the patch the callers (e.g.  NlBuildAuthenticator(),
    NlUpdateSeed(), NlCheckAuthenticator(), NlpUserValidateHigher(),
    etc.) completely ignored this return value.  They continued to use
    the output buffers (pbOutput / Authenticator / Seed) even when the
    function had aborted and the data were never initialised.  Those
    buffers therefore contained predictable all-zero data.

3.  The unchecked path was taken for both the classic RC4 as well as
    the modern AES credential path (flag 0x0100 0000).  An attacker who
    can force any of the failure conditions (for example by disturbing
    the CNG provider so that BCryptGetProperty(…ObjectLength…) fails)
    receives a session where:
      • the server’s seed is incremented,
      • the server builds its authenticator from zeroed credential data,
      • AccessCheck on the resulting RPC call succeeds because the
        authenticator comparison also uses the same zero buffer.

4.  Because Netlogon runs in LSASS, successful authenticator acceptance
    yields an authenticated (and signed/sealed) channel.  This provides
    the remote, unauthenticated attacker with machine-account level
    privileges (EoP over the network).

5.  The same unchecked pattern existed in the reverse direction
    (NlUpdateSeed / server->client).

6.  Additional damage: NetpAccessCheck2() accepted an uninitialised
    GENERIC_MAPPING parameter provided by the caller.  When that caller
    supplied garbage, AccessCheck() operated on undefined masks and
    could grant full access.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// pre-patch – NlComputeCredentials return value ignored
NlComputeCredentials(pbInput, pbOutput, pbIV, a4);   // status lost
...
return NlpDumpBuffer(...);

// post-patch – callers now verify status
status = NlComputeCredentials(...);
if (status < 0) {
    NlPrintRoutine(...);
    return status;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker sends crafted RPC to any Netlogon endpoint.
2. NetrLogon* entry point → NlBuildAuthenticator() / NlUpdateSeed().
3. NlComputeCredentials() fails – returns NTSTATUS ≠ 0
4. Caller (pre-patch) ignores failure → uses zeroed buffers.
5. Server compares zeroed authenticator with attacker supplied one –
   they match → authentication accepted.
6. LSASS grants attacker machine-account privileges.

Attack Vector
--------------------------------------------------------------------
Unauthenticated network access to the Netlogon RPC interface over the
Domain-joined network (TCP / SMB named-pipe or DCERPC).

Patch Description
--------------------------------------------------------------------
• Converted NlComputeCredentials() and companion helpers to return a
  64-bit NTSTATUS and changed calling convention so that every caller
  must check the result.
• Added comprehensive error handling and early-exit paths in
  NlBuildAuthenticator(), NlUpdateSeed(), NlCheckAuthenticator(),
  NlpUserValidateHigher(), NlDnsSendRemoteUpdate(), etc.
• Filled output buffers with zeros only after successful crypto
  operations.
• Removed externally supplied GENERIC_MAPPING from NetpAccessCheck2()
  and NetpCreateSecurityObject(); the functions now use the fully
  initialised internal mapping (NlGlobalNetlogonInfoMapping).
• Hardened NetpAccessCheck2() signature and all its call-sites.

Security Impact
--------------------------------------------------------------------
Prior to the fix an unauthenticated attacker could:
• Obtain a signed Netlogon secure channel using an all-zero
  authenticator,
• Execute privileged Netlogon RPCs,
• Ultimately elevate privileges to Domain Admin / SYSTEM.

Fix Effectiveness
--------------------------------------------------------------------
Returning NTSTATUS and enforcing rigorous propagation of failure codes
eliminates the use of un-initialised credential buffers.  The
additional sanity checks in NetpAccessCheck2() prevent misuse of an
uninitialised GENERIC_MAPPING.  No path remains where authentication
continues after a cryptographic failure; therefore the vulnerability is
considered fully remediated.
