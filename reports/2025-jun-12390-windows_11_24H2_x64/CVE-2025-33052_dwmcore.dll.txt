{'kb': 'KB5060842', 'cve': 'CVE-2025-33052', 'date': 1763415703.437426, 'change_count': 308, 'patch_store_uid': 'ff8301e1-1581-4c7a-b44e-2f26e83d0637', 'file': 'dwmcore.dll', 'confidence': 0.21}
--------------------------------------------------------------------
CVE-2025-33052 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Desktop Window Manager Core Library (dwmcore.dll)


Vulnerability Class
--------------------------------------------------------------------
CWE-908: Use of Uninitialized Resource (leads to information
leakage)


Detailed Root Cause Analysis
--------------------------------------------------------------------
Several helper routines that manipulate animation "expression
values" and key-frame data assumed that internal buffers were already
fully initialised and that the element count they derived from the
value-type field was trustworthy.  The critical field is stored at
offset +0x48 (decimal 72) inside a CExpressionValue object and
encodes the data type in the low nibble and the element count in the
high nibble (count = Type >> 4).

1.  CExpressionValue::CopyIntoFloatArray()
    • Before the patch the routine copied
      sizeof(float)*Count bytes from the value object into a caller
      supplied buffer without validating Count.
    • If the caller supplied an object whose Type field referenced a
      multi-component format (e.g. vector or matrix) but only the
      first component had been initialised, the remaining bytes came
      from uninitialised heap memory and were therefore disclosed to
      the caller.

2.  CKeyframeAnimation::SampleStartingValue()
    • The function tried to cache the starting value of an animation
      in the member located at (this+0x170) when that cache entry was
      empty ( *(_QWORD *)(this+0x170) == 0 ).
    • The original code allocated memory for the cache but did **not**
      verify that the returned buffer was successfully allocated nor
      that the resolved resource actually matched the expected byte
      size for the expression type.
    • Subsequently the routine copied the raw contents of that
      partially initialised structure into the notification channel,
      giving user-mode readers access to stale heap data.

3.  CKeyframeAnimation::SetKeyFrameData()
    • The old implementation created a new KeyframeSequence and then
      branched through a deeply nested switch to set a coordinate
      space value (v9).  Several error cases were not handled, which
      meant the member (this+0x210) could stay uninitialised while
      still being used by later code paths that eventually reach
      SampleStartingValue().

In all three cases the missing initialisation and/or size validation
allowed kernel-mode heap data to be copied into caller-controlled
buffers and, through the composition notification channel, returned
to user-mode.  No memory corruption occurs; the issue is restricted to
information disclosure.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// (Before) CExpressionValue::CopyIntoFloatArray
v6 = *(_DWORD *)(this + 72);          // type & count
v7 = v6 >> 4;                         // element count (NO VALIDATION)
memcpy(dest, src, 4 * v7);            // copies uninitialised bytes
```

```c
// (After) – added checks
v7 = v6 >> 4;
if ( v7 > 0x10 )
    FailFast(...);
memcpy(dest, src, 4 * v7);
```

```c
// (Before) SampleStartingValue()
if ( *(_DWORD *)cachePtr )   // cachePtr = this+0x170
    goto done;               // assume fully initialised
...
memcpy(cachePtr+8, v18, size); // may copy uninitialised data
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker calls public compositor API to create or update a
   KeyframeAnimation object.
2. He supplies a crafted ExpressionValue whose Type field advertises
   a large component count but only initialises the first float.
3. Application requests the value through the compositor, which
   invokes CopyIntoFloatArray(); the routine copies Count*4 bytes
   into the user buffer, leaking heap data.
4. Alternatively, attacker forces an animation to sample its starting
   value.  The uninitialised cache buffer is allocated, later
   transmitted to user-mode via notification callbacks.


Attack Vector
--------------------------------------------------------------------
Local, authorised caller that can create or manipulate
Composition/DirectComposition objects (e.g. Win32 or UWP process).
No elevated privileges are required; the attack occurs entirely in
user context, leaking kernel memory back to that same process.


Patch Description
--------------------------------------------------------------------
The security update introduces strict input validation and memory
initialisation:

• CopyIntoFloatArray now
  – sets the destination buffer to zero,
  – validates that the value actually exists (HasValue()),
  – restricts the element count to <= 0x10, and
  – bails out with an error code if the check fails.

• SetKeyFrameData was rewritten to use
  DetermineCoordinateSpace(), unique_ptr wrappers, and fail-fast
  allocation helpers that guarantee the member buffers are always
  initialised.

• SampleStartingValue now
  – verifies the cache pointer before use,
  – zeros temporary storage, allocates with MIDL_user_allocate_0,
  – copies only the exact byte size returned by
    GetExpressionTypeByteSize(), and
  – releases COM pointers safely on every exit path.

Collectively these changes prevent any uninitialised bytes from being
read or propagated to user-mode.


Security Impact
--------------------------------------------------------------------
Prior to the patch a local attacker could obtain up to 64 bytes of
uninitialised kernel-mode heap or stack data per call, which may
contain pointers or other sensitive information.  Repeated leakage
facilitates ASLR bypass or other memory disclosure attacks inside the
Windows compositor process.


Fix Effectiveness
--------------------------------------------------------------------
The added guards eliminate all paths where an uninitialised buffer
could be read:
• Element count is clamped to a safe maximum.
• All allocations are zero-initialised and failure-checked.
• Cache pointers are validated before dereference.
Therefore the vulnerability is fully mitigated; no further
information disclosure vectors are observable in the patched code.
