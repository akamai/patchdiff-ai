{'file': 'storport.sys', 'change_count': 39, 'confidence': 0.12, 'cve': 'CVE-2025-24068', 'patch_store_uid': '9630d929-42b0-4925-a299-159065ed4c3d', 'date': 1763415905.2834125, 'kb': 'KB5060842'}
--------------------------------------------------------------------
CVE-2025-24068 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Storport mini-port interface – diagnostic IOCTL
handlers  RaUnitStorageDiagnosticIoctl()  and
RaidAdapterDiagnosticIoctl()  in storport.sys (Storage Port Driver).
These routines service IOCTL_STORAGE_DIAGNOSTIC / SCSI_MINIPORT
requests that allow a user process to query a storage controller or
unit for vendor specific diagnostic data.

Vulnerability Class
--------------------------------------------------------------------
Buffer Over-read / Information Disclosure (CWE-126)

Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  The handlers build a temporary non-paged-pool buffer ("P") by
    calling   RaBuildDiagnosticBufferForMiniport().  The size of this
    allocation is returned in the variable  AllocSize  (v43 / v56).

2.  The contents of this buffer are interpreted as the following
    structure (offsets in bytes):
       +0x00 DWORD    Signature
       +0x0C DWORD    Opcode
       +0x3C DWORD    DataLength  ( *((DWORD *)P + 15) )
       +0x44 BYTE[ ]  Variable data supplied by the mini-port driver

3.  Before the patch the copy that returns the mini-port data to the
    caller was executed as
         vLen = *((DWORD *)P + 15);              // DataLength
         if (vLen >= UserOutLen - 0x20)          // cap **only** to the
             vLen = UserOutLen - 0x20;           // user buffer size
         memmove(UserBuf+0x20+0x08, P+0x44, vLen);

    There is **no validation that 0x44 + vLen is still inside the pool
    allocation P**.  A malicious or buggy mini-port can therefore set
    DataLength to a value larger than AllocSize-0x44 yet still smaller
    than the user buffer.  The subsequent memmove() reads past the end
    of P and copies arbitrary kernel memory into the user supplied
    output buffer.

4.  The same un-validated reads are performed while building ETW trace
    events: the code walks a list of variable-length descriptors
    located inside P (loop that uses v49 / v34 etc.) and dereferences
    fields such as  v25[12]  and  v25[13]  before it has proved that
    the descriptor lies completely inside P, producing additional
    out-of-bounds reads.

5.  Because the copied data is returned to the calling process through
    the IRP output buffer, arbitrary portions of kernel non-paged
    memory become visible to user mode, defeating KASLR and helping in
    further exploitation.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – RaUnitStorageDiagnosticIoctl
vLen = *((DWORD *)v6 + 15);          // length is fully controlled
if (vLen >= (int)UserOut - 32)       // capped only to USER buffer
    vLen = UserOut - 32;             // NOT to internal pool buffer
memmove(UserBuf + 8, v6 + 0x44, vLen);   // kernel over-read
```

```c
// after patch (simplified)
if (Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage()) {
    if (!RaidCallerIsAdmin() || CurrentThread!=Irp->Tail.Overlay...) {
        return STATUS_PRIVILEGE_NOT_HELD;
    }
}
// additional descriptor-length checks were added before every read
// and lengths are re-validated against the allocation size.
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User process opens a Storport controlled device (eg. \\.
   PhysicalDriveX).
2. DeviceIoControl(…, IOCTL_STORAGE_DIAGNOSTIC, …) is issued with a
   crafted input buffer.
3. storport.sys receives IRP_MJ_DEVICE_CONTROL and calls
   RaUnitStorageDiagnosticIoctl() or RaidAdapterDiagnosticIoctl().
4. Function allocates buffer P, mini-port fills it.
5. Malicious DataLength in P causes memmove() to over-read kernel
   memory and copy it into the caller’s output buffer.

Attack Vector
--------------------------------------------------------------------
Any local user that can send IOCTL_STORAGE_DIAGNOSTIC (or the SCSI
mini-port equivalent) to a Storport device can exploit the flaw.  On
many systems this requires only a handle to a physical drive or RAID
adapter, which is often obtainable by non-administrators.

Patch Description
--------------------------------------------------------------------
1. Introduced an optional policy gate: if the new
   Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage() flag is active
   the caller must be running in an administrator context and on the
   issuing thread; otherwise the request is rejected with
   STATUS_PRIVILEGE_NOT_HELD.

2. Re-worked descriptor parsing loops: every offset that is taken from
   the untrusted mini-port buffer is now compared with the total buffer
   size before it is dereferenced (added checks against  v42 / Size[0]
   etc.).  If the check fails the code abandons the parse path.

3. The same size checks are applied before copying data back to user
   mode, ensuring that the copy length can never exceed the
   mini-port-supplied buffer size.

Security Impact
--------------------------------------------------------------------
Prior to the patch an attacker could obtain arbitrary non-paged kernel
memory contents, including pointers and pool metadata.  These leaked
values defeat KASLR and can be used to mount subsequent elevation-of-
privilege attacks.  No code execution is achieved directly, but the
information disclosure materially lowers the bar for other exploits.

Fix Effectiveness
--------------------------------------------------------------------
The added privilege check removes the attack surface for non-admin
users, and the new bounds-checking logic guarantees that every read
and every memmove() stays within the allocated diagnostic buffer.
Therefore the over-read condition can no longer be triggered and the
information disclosure is remediated.
