{'change_count': 5, 'file': 'mrxsmb.sys', 'patch_store_uid': '238e095d-a913-4a7d-b7e3-94a2acac5569', 'confidence': 0.18, 'date': 1763417337.1348724, 'kb': 'KB5060842', 'cve': 'CVE-2025-33073'}
--------------------------------------------------------------------
CVE-2025-33073 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows SMB client kernel driver (mrxsmb.sys).  The faulty
code resides in the helper routines that prepare SMB packets for
transport:
  • RxCeEncryptData()
  • RxCeCompressData()
  • SmbCeCreateSrvCall()
These functions run in kernel-mode and manipulate attacker-influenced
lengths while building encrypted / compressed messages and while
creating a server connection.


Vulnerability Class
--------------------------------------------------------------------
Integer overflow / buffer under-allocation that leads to out-of-bounds
write (memory corruption) and therefore to local elevation of
privilege.  Classified under CWE-284 (improper access control) but the
technical core is an unchecked arithmetic operation followed by kernel
pool overwrite.


Detailed Root Cause Analysis
--------------------------------------------------------------------
1. RxCeEncryptData
   • Caller supplies parameter a4 = PlainTextLength.
   • Old code blindly computed TotalAlloc = a4 + 132 and allocated that
     much non-paged pool (ExAllocatePool2 tag ‘SmBf’).
   • It then set outBuffer = Pool + 80, wrote a 52-byte header, and
     copied/encrypted a4 bytes into outBuffer+52.
   • If a4 is very large (>= 0xFFFFFFED) the 64-bit addition wraps and
     TotalAlloc becomes smaller than 80+52+a4, leaving the copy and the
     encrypt routine writing past the end of pool memory.
   • If a4 is very small the function can return *a6 = 52 (minimum
     header) while IoAllocateMdl() is later called with a size that is
     smaller than required, again leading to pool corruption when the
     buffer is used by the network stack.

2. RxCeCompressData
   • Similar pattern: required size was calculated as
       Needed = a4 + (a5 ? 96 : 16)
     without overflow checking.
   • Small or overflowed ‘a4’ values made Required < HeaderLength,
     causing a later memmove()/SmbCompression*() to overrun the
     allocation.

3. SmbCeCreateSrvCall
   • The server-call constructor eventually feeds user-controlled
     lengths to the two helpers above.  Patch adds early rejection via
     CredUnmarshalTargetInfo() and SmbCeQueryServerAvailability() as
     well as the same feature-flagged size sanity checks.

Corrupted pool memory originates from attacker-controlled network
traffic, ultimately allowing code execution in the kernel context of
SYSTEM and giving full local privilege escalation.

Structures / fields affected
  RXCE_ENCRYPT_HEADER  (52 bytes) – written past allocation.
  SMB_COMPRESSION_HDR  (variable) – same.
  MDL.Size             – MDL created for undersized backing buffer.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Old RxCeEncryptData
*a6 = a4 + 52;                     // length returned to caller
Pool = ExAllocatePool2(NonPaged, a4 + 132, 'SmBf'); // no checks
out   = Pool + 80;                 // start of header
RtlCopyMdlToBuffer(..., Pool + 132, a4, ...); // may overrun
```
```c
// Patch
v9  = a4 + 52;
if (FeatureFlag && v9 < 0x34) { *a6 = -1; return STATUS_INVALID; }
...
v10 = v9 + 80;
if (v10 < 0x50) return STATUS_INVALID_PARAMETER;
Pool = ExAllocatePool2(NonPaged, v10, 'SmBf');
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Malicious SMB server sends crafted packet inducing the client to
   call SmbCeCreateSrvCall(), leading to RxCeEncryptData()/
   RxCeCompressData() with attacker-controlled length (a4).
2. Length chosen so that (a4 + constant) wraps below the required
   space (e.g., 0xFFFFFFF0).
3. Kernel allocates undersized pool.
4. Subsequent copy/encrypt/compress writes beyond buffer boundary.
5. Pool metadata or adjacent objects are corrupted; attacker sprays
   data and gains arbitrary code execution, elevating to SYSTEM.


Attack Vector
--------------------------------------------------------------------
Remote, unauthenticated SMB server or man-in-the-middle that returns
crafted length fields in SMB2 TRANSFORM or COMPRESSION responses.  No
local privileges are required on the client machine; only outbound
SMB connection is necessary.


Patch Description
--------------------------------------------------------------------
1. Added explicit integer-overflow / size-minimum checks before every
   arithmetic that computes a pool allocation size.
2. Rejects any request when (size + header) wraps or is below the
   smallest legal frame (0x34 / 0x50 bytes).
3. Returns STATUS_INVALID_PARAMETER (0xC000000D) instead of proceeding.
4. Introduced helper Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage_*()
   as a gate so the extra validation can be toggled but is on by
   default.
5. In SmbCeCreateSrvCall additional credential parsing and
   SmbCeQueryServerAvailability() verification stops the path earlier
   if malformed input is detected.


Security Impact
--------------------------------------------------------------------
Prior to the fix, a remote attacker could corrupt kernel non-paged pool
from a low-privilege client context, leading to arbitrary code
execution in kernel mode.  Successful exploitation yields full system
privileges (EoP) and potentially allows sandbox escape or security
boundary bypass over the network.


Fix Effectiveness
--------------------------------------------------------------------
The added arithmetic checks guarantee that every buffer allocated is at
least as large as the subsequent header + payload writes and that
integer wrap-around is impossible on 32/64-bit builds.  All dangerous
paths are now gated by the same validation logic; no write occurs
unless the allocation succeeds with a verified size.  Therefore the
original out-of-bounds condition is removed.

