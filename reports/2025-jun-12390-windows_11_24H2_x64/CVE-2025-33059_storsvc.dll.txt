{'kb': 'KB5060842', 'file': 'storsvc.dll', 'change_count': 17, 'cve': 'CVE-2025-33059', 'patch_store_uid': 'e357b706-c599-45dd-b928-3b319eb9aed7', 'confidence': 0.19, 'date': 1763417225.4989386}
--------------------------------------------------------------------
CVE-2025-33059 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Storage Management Provider (storsvc.dll) – routine
ScValidateProvisioning() that validates the user-supplied
SP_PROVISIONING_INFO structure received through storage management
IOCTLs.

Vulnerability Class
--------------------------------------------------------------------
Out-of-bounds read / inadequate input validation (CWE-125).

Detailed Root Cause Analysis
--------------------------------------------------------------------
SP_PROVISIONING_INFO is a variable-length structure that contains
several 32-bit counters describing provisioning tier ranges.  The
fields relevant to this flaw are (zero-based DWORD indices):
  5 – RangeMin
  6 – RangeMid
  7 – RangeMax
Valid values are expected to be in the inclusive range 1-5 and must
respect the ordering RangeMin <= RangeMid <= RangeMax.

Prior to the patch ScValidateProvisioning() validated only indices 5
and 6:
  if (RangeMin ‑ 1 > 4)                // Range 1-5 check
      fail;
  if (RangeMid ‑ 1 > 4 || RangeMin > RangeMid)
      fail;
No checks were performed on index 7 (RangeMax).  Therefore an attacker
could supply an arbitrary 32-bit value for RangeMax, including zero or
any number larger than 5, without the validator rejecting the
structure.  Down-stream code (not shown in the diff but located in the
same module) uses RangeMax to index arrays that hold per-tier policy
records.  When RangeMax is outside the legal interval, subsequent
iterations read past the end of the allocation, copying kernel memory
from unrelated objects into an output buffer ultimately returned to
the caller.  This produces an information disclosure.

The vulnerability is purely a read: the surrounding loops only copy
from the internal array into the caller buffer; no writes beyond the
array bounds occur.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
/* Before */
if (v7 - 1 > 4)
    return STATUS_INVALID_PARAMETER;
v8 = *((DWORD *)a1 + 6);
if (v8 - 1 > 4 || v7 > v8)
    return STATUS_INVALID_PARAMETER;   // NO CHECK FOR +7
```

```c
/* After */
if ((DWORD)(*((DWORD *)a1 + 5) - 1) > 4)
    return STATUS_INVALID_PARAMETER;
...
if (Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage()) {
    v8 = *((DWORD *)a1 + 6);
    if (v8) {
        if (v8 - 1 > 4 || *((DWORD *)a1 + 5) > v8 ||
            v8 >= *((DWORD *)a1 + 7))
            return STATUS_INVALID_PARAMETER;  // new check
    }
}
v9 = *((DWORD *)a1 + 7);
if (v9 - 1 > 4 || *((DWORD *)a1 + 5) > v9)
    return STATUS_INVALID_PARAMETER;      // new check
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker opens a handle to the Storage Service (Win32 API or WMI).
2. Crafts SP_PROVISIONING_INFO with:
     – RangeMin   = 1
     – RangeMid   = 1
     – RangeMax   = 0xFFFFFFFF (or 0)
3. Sends structure via IOCTL to the service.
4. Service runs ScValidateProvisioning(); because RangeMax is not
   checked, the structure is accepted.
5. Subsequent code iterates up to RangeMax copying tier descriptors
   into the response buffer, reading past the legitimate array and
   leaking memory contents to user mode.

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker with the ability to send storage
management IOCTLs (no administrative privileges required according to
Microsoft advisory).  The flaw cannot be triggered remotely.

Patch Description
--------------------------------------------------------------------
The update adds two groups of boundary checks:
1. A conditional block (gated by the internal feature flag
   Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage) that validates
   RangeMid against RangeMax and ensures RangeMax is greater than
   RangeMid when RangeMid is present.
2. An unconditional block that validates RangeMax itself:
     – RangeMax in 1-5
     – RangeMin <= RangeMax
Any violation now results in STATUS_INVALID_PARAMETER.

Security Impact
--------------------------------------------------------------------
Without the patch an attacker can read uninitialized or previously
freed kernel pool memory, disclosing sensitive kernel data such as
pointers, heap cookies, or other process information.  This
information disclosure can be chained with other vulnerabilities to
bypass KASLR or strengthen local privilege-escalation exploits.

Fix Effectiveness
--------------------------------------------------------------------
The new explicit validation of element 7 together with the cross-field
ordering checks closes the gap that allowed the over-read.  No residual
code paths that use RangeMax without validation were observed inside
ScValidateProvisioning().  Effectiveness is therefore judged
sufficient, provided all callers rely exclusively on this routine for
validation.
