{'change_count': 1, 'date': 1763415493.3541098, 'cve': 'CVE-2025-32718', 'confidence': 0.18, 'kb': 'KB5060842', 'patch_store_uid': '17962b99-8d67-4355-a10e-0dc627626a42', 'file': 'mrxsmb20.sys'}
--------------------------------------------------------------------
CVE-2025-32718 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows mrxsmb20.sys (SMB2 redirector) – routine
Smb2Fsctl_Finalize, responsible for post-processing the result of a
SMB2 FSCTL request that originated from user mode (DeviceIoControl).


Vulnerability Class
--------------------------------------------------------------------
Integer overflow / insufficient size validation leading to heap-based
buffer overflow (CWE-190, CWE-122).


Detailed Root Cause Analysis
--------------------------------------------------------------------
Smb2Fsctl_Finalize finalises several SMB-specific FSCTL operations.  At
offset 0x20C (decimal 590468) of the RxContext (v4+524) the routine
handles a particular FSCTL code (exact symbolic name not present in the
diff; hereafter called TARGET_FSCTL).  Prior to the patch the function
executed the following sequence when TARGET_FSCTL completed with an
error status (NTSTATUS < 0 or == STATUS_BUFFER_OVERFLOW, i.e.
0xC0000000|any or 0x80000005):

 1. The redirector copied the server’s output size to *(v4+184).
 2. The caller-supplied output buffer pointer is stored at *(a1+1992).
 3. No verification was performed that *(v4+184) fits into the caller
    buffer or that internal arithmetic on that length does not wrap.
 4. Down-stream routines (memmove, Smb copy helpers, cache fill, etc.)
    use that length to perform pool allocations, copies, and to update
    cache metadata.

Because the server can set *(v4+184) to an arbitrary 32-bit value, a
local attacker controlling the SMB connection can force the redirector
into

 • allocating too small a buffer (integer truncation) and then copying a
   larger amount of data (heap-based buffer overflow), or
 • performing size calculations that wrap around 0 causing pool
   allocations of size 0, later overwritten, corrupting pool metadata.

Any subsequent kernel-mode operation that dereferences, copies, or frees
this corrupted pool region can be hijacked, ultimately leading to local
privilege escalation.

The bug only occurs when the RxContext->MajorFunction is TARGET_FSCTL
(590468) and the final status is an error; other FSCTLs already had
explicit validation (e.g., GET_REPARSE_POINT: FsRtlValidateReparsePoint
was present before the patch).

Structures/fields involved
• RxContext (v4)
    +0xB8  LowIoContext
    +0xB8+0x20  [524]  ControlCode (matches 590468)
    +0xB8+0x0  [184]  ReturnedLength (server controlled)
• SMB2_FSCNTL_STATUS_BLOCK (user buffer) – pointer held in *(a1+1992)


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// BEFORE
if (*(DWORD *)(v4 + 524) == 590468 &&
    ((int)(v2 + 0x80000000) < 0 || v2 == -2147483643))
{
    // No validation of *(v4+184) against user buffer.
}

// AFTER
if (*(DWORD *)(v4 + 524) == 590468 &&
    (((v2 + 0x80000000) & 0x80000000) != 0 ||
      v2 == -2147483643))
{
    v2 = FsRtlValidateFileRegionOutputBuffer(
            v4 + 184,                 // size returned by server
            *(unsigned int *)(a1+2000),// original user buffer length
            *(_QWORD *)(a1+1992),      // user buffer pointer
            v2);                       // status
}
```
The new FsRtlValidateFileRegionOutputBuffer call ensures that the
returned length is sane and that arithmetic on it cannot wrap.


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User-mode process opens an SMB path (eg. \\127.0.0.1\share\file).
2. Calls DeviceIoControl with TARGET_FSCTL (590468) providing a small
   output buffer.
3. Malicious SMB server (local loopback or remote) replies with
   STATUS_BUFFER_OVERFLOW and sets a huge length field (>4 GB).
4. Control returns to Smb2Fsctl_Finalize.
5. Pre-patch code stores huge length, allocates/copies using it – pool
   overflow – arbitrary kernel memory overwrite – escalation.


Attack Vector
--------------------------------------------------------------------
Local, authenticated user running in user mode.  Requires the ability to
issue FSCTL requests to the SMB redirector (CreateFile on an SMB path is
sufficient).  No administrative privileges are needed; the redirector
runs in kernel context.


Patch Description
--------------------------------------------------------------------
1. Added feature gate call
   Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage_0() to ensure the
   new validation is only executed when the feature is enabled.
2. Introduced a new conditional branch for control code 590468 that
   invokes FsRtlValidateFileRegionOutputBuffer.  This helper performs:
   • size sanity checks              (no negative/wrap-around sizes)
   • buffer length vs. structure min (prevents truncation)
   • integer overflow detection in internal calculations.
3. Modernised some status tests to use bitmask rather than
   signed-compare to avoid undefined behaviour.
4. Numerous refactors/rename of variables – no functional security
   impact.


Security Impact
--------------------------------------------------------------------
Prior to the patch any authenticated local user could craft an SMB
connection that forces the kernel to overflow a pool buffer, leading to
arbitrary kernel memory corruption and therefore elevation of privilege
(from standard user to SYSTEM).  Remote exploitation over SMB is
possible but requires user interaction (user accesses malicious share).


Fix Effectiveness
--------------------------------------------------------------------
The added FsRtlValidateFileRegionOutputBuffer call centralises all size
validation for the affected FSCTL before any allocation or memmove
occurs.  Provided FsRtlValidateFileRegionOutputBuffer itself is correct,
the original integer overflow and subsequent heap overwrite paths are
eliminated.  No remaining path in Smb2Fsctl_Finalize uses *(v4+184)
without first passing through either FsRtlValidateReparsePointBufferEx
or the new validation helper, therefore the fix is complete for the
identified issue.

