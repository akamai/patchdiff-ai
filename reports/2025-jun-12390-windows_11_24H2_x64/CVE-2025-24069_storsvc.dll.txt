{'change_count': 17, 'cve': 'CVE-2025-24069', 'patch_store_uid': 'e357b706-c599-45dd-b928-3b319eb9aed7', 'date': 1763417266.138925, 'confidence': 0.35, 'file': 'storsvc.dll', 'kb': 'KB5060842'}
--------------------------------------------------------------------
CVE-2025-24069 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Storage Service (storsvc.dll) – routine responsible for
persisting per-volume state when a new storage card is discovered.

Vulnerability Class
--------------------------------------------------------------------
Out-of-bounds Read / Memory-disclosure (CWE-125)

Detailed Root Cause Analysis
--------------------------------------------------------------------
Prior to the patch, function
StorageService::DeterminePersistentVolumeState() accepted four user
supplied parameters:
  a1  – StorageService instance (this)
  a2  – WCHAR* path to the volume
  a3  – _STORAGE_DEVICE_TYPE (indexed as integer)
  a4  – volume ordinal (unsigned int)

The routine called itself recursively and, on success, wrote the
returned DWORD into an internal per-volume cache using the following
calculation:

  *(_DWORD*)( *((QWORD*)a1 + a3 + 5) + 1112*a4 + 1104 ) = v10[0];

The code assumed that ‘a3’ and ‘a4’ were inside the ranges of the
StorageService object’s internal arrays, but **no validation was
performed**.  Supplying values that exceed the real number of device
types or volumes caused the inner pointer arithmetic to refer past the
end of the containing allocation.

Because the pointer is then forwarded to the caller by subsequent
functions, a crafted client can coerce storsvc (running as SYSTEM) to
read and later disclose arbitrary kernel heap contents belonging to the
process.  The issue is purely an out-of-bounds *read*; the 32-bit value
is copied into user-observable structures but never written back to the
out-of-range address, keeping integrity intact yet leaking confidential
information.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch (simplified)
unsigned int v10[6];
...
StorageService::DeterminePersistentVolumeState(a1, a2, v10);
if (v7 >= 0) {
    *(_DWORD *)(*((_QWORD *)a1 + a3 + 5) + 1112 * a4 + 1104) = v10[0];
    return 0;
}
```

```c
// after patch – entire body replaced
if ((Feature_Servicing_RackLevelNestedMirror__private_featureState & 0x10) != 0)
    return Feature_Servicing_RackLevelNestedMirror__private_featureState & 1;
else
    return Feature_Servicing_RackLevelNestedMirror__private_IsEnabledFallback(...);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Client invokes StorageService::ProcessNewStorageCard()
2. ProcessNewStorageCard() calls DeterminePersistentVolumeState() with
   user-controlled ‘a3’ (device type) and ‘a4’ (volume index).
3. DeterminePersistentVolumeState() dereferences a1 + a3 + 5 and then
   applies 1112*a4 offset – no bounds check.
4. Out-of-range read value is later returned to user, disclosing kernel
   memory.

Attack Vector
--------------------------------------------------------------------
A local, authenticated attacker can issue IOCTLs / WMI calls that
request Storage Service to enumerate or mount a forged storage card.
By providing crafted device-type and disk-number parameters the service
is tricked into executing the out-of-bounds access.

Patch Description
--------------------------------------------------------------------
Microsoft removed the vulnerable logic entirely. The old helper is no
longer used; instead, a new, small wrapper (Feature_H2E_WPA3SAE__
private_IsEnabledDeviceUsage) returns a feature-flag value and delegates
to a safe fallback routine.  All pointer arithmetic that accessed the
per-volume array has been deleted, so no untrusted indices reach the
internal cache.

Security Impact
--------------------------------------------------------------------
Successful exploitation discloses up to 4 bytes of arbitrary kernel
heap memory per request, enabling information leaks that may aid in
further privilege-escalation or ASLR bypass attacks.

Fix Effectiveness
--------------------------------------------------------------------
The vulnerable function body is removed; no memory index calculation is
left.  Because the replacement routine performs only flag checks and
uses constant addresses, there is no longer a path that accepts attacker
controlled indices.  Therefore the out-of-bounds read is fully
mitigated.
