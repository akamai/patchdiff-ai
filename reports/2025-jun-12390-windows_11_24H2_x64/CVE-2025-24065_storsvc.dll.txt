{'kb': 'KB5060842', 'patch_store_uid': 'e357b706-c599-45dd-b928-3b319eb9aed7', 'confidence': 0.13, 'file': 'storsvc.dll', 'cve': 'CVE-2025-24065', 'date': 1763417624.8217874, 'change_count': 17}
--------------------------------------------------------------------
CVE-2025-24065 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Storage Service (storsvc.dll) – routines that validate user
controlled SP_PROVISIONING_INFO data supplied through the Storage
Management Provider.

Vulnerability Class
--------------------------------------------------------------------
Out-of-Bounds Read / Insufficient Input Validation (CWE-125).

Detailed Root Cause Analysis
--------------------------------------------------------------------
The kernel-mode Storage Service exposes management IOCTLs that accept
an _SP_PROVISIONING_INFO structure originating in user space.  Routine
ScValidateProvisioning() is the sole gatekeeper that is invoked before
the caller-supplied buffer is further processed.

Before the patch the function verified only three fields:
  • ProvisioningAction (DWORD 0) was limited to 0 or 1
  • If ProvisioningAction==1, flag a4 had to be set
  • RangeCount  (DWORD 4) had to be <=5
  • RangeStart (DWORD 5) 1–4 and RangeStart<=RangeEnd
  • RangeEnd   (DWORD 6) 1–4 and RangeStart<=RangeEnd

No check whatsoever was performed for the next DWORD in the structure
(offset +28, i.e. *((DWORD*)a1+7)).  Later code uses this value as a
boundary while iterating internal range arrays.  A crafted buffer with
a7 set beyond the actual array size therefore causes the kernel to
read outside the allocated memory region, returning uninitialised
kernel data to user land – an information disclosure condition.

The defect is purely a logic error: the author assumed a6 (RangeEnd)
was the last boundary value and forgot to clamp a7.  Because the
structure is received directly from user space via DeviceIoControl, no
additional mitigation exists.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
v7 = *((DWORD*)a1 + 5);           // RangeStart
if ( v7 - 1 > 4 ) return ERR;
v8 = *((DWORD*)a1 + 6);           // RangeEnd
if ( v8 - 1 > 4 || v7 > v8 )      // no test for DWORD 7 !
    return ERR;
...
// after
if ( (DWORD)(*((DWORD*)a1+5)-1) > 4 ) return ERR;
if ( Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage() ) {
    v8 = *((DWORD*)a1+6);
    if ( v8 && (v8-1>4 || *((DWORD*)a1+5)>v8 ||
                 v8 >= *((DWORD*)a1+7)) )      // new bound check
         return ERR;
}
v9 = *((DWORD*)a1+7);             // NEW – always checked
if ( v9-1 > 4 || *((DWORD*)a1+5) > v9 )
    return ERR;
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User application issues a Storage Management Provider IOCTL with a
   crafted _SP_PROVISIONING_INFO buffer.
2. The kernel dispatches to ScValidateProvisioning().
3. Because DWORD 7 is unchecked, the malicious value passes validation.
4. Subsequent code in the Storage Service trusts the value and indexes
   internal arrays past their end.
5. Kernel memory following the array is read and copied back to the
   caller, disclosing sensitive information.

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker (or sandbox escape) sending a malformed
SP_PROVISIONING_INFO buffer to the Storage Management Provider through
DeviceIoControl.  No admin rights are required – only the ability to
open the device interface that is ordinarily accessible to normal
users.

Patch Description
--------------------------------------------------------------------
The update inserts two complementary validations:
1. When the H2E_WPA3SAE feature flag is enabled, DWORD 6 (RangeEnd)
   must be   1–4, non-zero, RangeStart<=RangeEnd, and strictly less
   than DWORD 7.
2. DWORD 7 is now always range-checked (1–4) and enforced to be >=
   RangeStart.
The function returns error 0xC03A0011 when any of these tests fail.
All error paths are executed before the structure is used.

Security Impact
--------------------------------------------------------------------
Prior to the fix, arbitrary kernel memory could be disclosed to the
caller, potentially leaking kernel addresses, secrets or credential
material.  This breaks KASLR and can be chained with other
vulnerabilities for privilege escalation.  Patch eliminates the leak
path and converts it into a safe failure.

Fix Effectiveness
--------------------------------------------------------------------
The added checks cover the previously uncontrolled field and guarantee
that no index above 4 or below 1 is accepted, and that all ordering
constraints hold.  As the validation occurs before any further use of
the buffer, the out-of-bounds read path is removed.  No remaining code
paths referencing the field without validation were observed in the
diffs, indicating the fix is complete, although runtime paths gated by
undisclosed feature flags remain "unknown".
