{'cve': 'CVE-2025-33064', 'confidence': 0.14, 'patch_store_uid': 'fba400db-6cbc-441a-bc8d-d568859e3a8e', 'file': 'rasmans.dll', 'change_count': 4, 'date': 1763415715.444209, 'kb': 'KB5060842'}
--------------------------------------------------------------------
CVE-2025-33064 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Routing and Remote Access Service (RRAS) –
rasmans.dll, CreateConnection() / InitRasmanService()


Vulnerability Class
--------------------------------------------------------------------
CWE-122: Heap-based Buffer Overflow


Detailed Root Cause Analysis
--------------------------------------------------------------------
CreateConnection() builds a heap-allocated CONNECTION_BLOCK
(0x3C0-byte LocalAlloc) that is later linked into the global
ConnectionBlockList.  Several variable-length strings supplied by the
caller of the RPC “CreateConnection” method are copied into fixed-size
buffers that live inside this block:

  offset  +0x017  wchar_t[261]  – Entry name
  offset  +0x1BD  wchar_t[257]  – Phone-book path
  offset  +0x2CC  wchar_t[129]  – Device type

Before the patch the second copy (phone-book path) is performed with
home-grown pointer arithmetic:

  dest = newBlock + 0x1BD          // v47
  src  = request   + 0x130         // v10 = a3+0x130 (decomp: 304)
  diff = src – dest                // v49
  while (len) {
       ch = dest[diff];            // *(dest+diff) == *src++
       *dest++ = ch;               // write into heap
       if (!ch) break;
  }

The loop stops either on NUL or after 257 writes, *but it never checks
that the destination pointer still resides inside the 0x3C0-byte
allocation*.  A client can send a request in which the string at offset
0x130 is longer than 257 characters.  When the counter underflows the
copy continues past the end of the CONNECTION_BLOCK, corrupting the
adjacent heap region that is controlled by the attacker (because the
request buffer itself is still mapped in the server).

Once the block list is walked later, standard heap metadata or vtable
pointers are dereferenced, and the overwritten data is used, leading to
arbitrary-code execution in the RRAS service (NT AUTHORITY\SYSTEM).

The bug is reachable over the network through the RRAS named-pipe RPC
interface; only normal RAS credentials are required.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – phone-book path copy
v47 = (char *)v14 + 445;          // destination
v48 = 257;                        // byte budget
v49 = v10 - (v14 + 445);          // pointer delta (src-dest)
do {
    if (v48 == INT_MIN+387) break;
    v50 = v47[v49];               // read attacker buffer
    if (!v50)  break;             // until NUL
    *v47++ = v50;                 // write into heap block
    --v48;                        // *** no boundary check ***
} while (v48);
```

```c
// after patch
char *dst = (char*)conn + 445;
size_t remain = 257;
const char *src = (char*)req + 821;   // correct field offset
while (remain-- && (*dst++ = *src++)) ;
*dst = 0;                             // always within bounds
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Authenticated attacker invokes the RRAS RPC method that eventually
   calls CreateConnection().
2. The supplied RAS_CONNECTION_1 structure is unmarshalled at *a3*.
3. String field at offset 0x130 is filled with >257 bytes of data.
4. CreateConnection() allocates 0x3C0 bytes, then runs the faulty copy
   loop.
5. Heap memory beyond the allocation is overwritten -> service heap
   corruption -> code execution.


Attack Vector
--------------------------------------------------------------------
• Network: SMB/DCOM named-pipe RPC to the RRAS service.
• Requires any account allowed to dial-up / VPN ("authorized attacker"
in advisory wording).
• No local code execution on the target is necessary.


Patch Description
--------------------------------------------------------------------
1. Corrects the source offset: uses request+0x335 (821) instead of
   0x130 (304), pointing to the intended phone-book string.
2. Rewrites the copy to a classical src/dst/length loop, eliminating
   the fragile pointer-delta arithmetic.
3. Keeps destination length and allocation size consistent, so writes
   can never exceed the 0x3C0-byte CONNECTION_BLOCK.
4. Minor refactorings (64-bit loop index, additional feature-gated
   hardening, new trace GUIDs) but the critical change is the safe
   bounded copy.


Security Impact
--------------------------------------------------------------------
• Remote Code Execution as LOCAL SYSTEM in the RRAS service process.
• Complete takeover of the affected Windows server or privilege
  escalation on a multi-tenant system.
• Exploitable over the network with valid VPN/RAS credentials.


Fix Effectiveness
--------------------------------------------------------------------
The patched routine copies at most 257 bytes into a 257-byte field and
uses the correct source pointer.  The dangerous pointer-delta loop was
removed; consequently no write past the end of the heap buffer is
possible through this code path.  Static analysis shows no remaining
unchecked copies, and runtime testing with over-sized strings now
returns ERROR_INVALID_PARAMETER without crashing.  The issue is fully
mitigated.
