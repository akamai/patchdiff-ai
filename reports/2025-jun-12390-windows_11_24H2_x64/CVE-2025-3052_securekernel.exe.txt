{'date': 1763415539.2983875, 'kb': 'KB5060842', 'cve': 'CVE-2025-3052', 'change_count': 14, 'file': 'securekernel.exe', 'patch_store_uid': 'bc997d55-eb24-42a5-8f63-beadfbb4d7ef', 'confidence': 0.15}
--------------------------------------------------------------------
CVE-2025-3052 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
securekernel.exe – early-boot processor-identification helpers
(RtlGetProcessorSignature, RtlGetCpuVendor, friends)

Vulnerability Class
--------------------------------------------------------------------
Untrusted Pointer Dereference / Arbitrary Kernel Write
(CWE-822)

Detailed Root Cause Analysis
--------------------------------------------------------------------
The helper routine RtlGetProcessorSignature originally accepted up to
five caller-supplied pointer arguments that were always blindly
written:
  *a1 = vendor ;
  *a2 = family ;
  *a3 = model  ;
  *a4 = stepping;
  *a5 = extID  ;

No validation was performed – the addresses could be NULL or point
anywhere in kernel or even user space.  Because the function executes
very early in Secure Kernel initialisation (and is also reused by
later runtime paths such as SkiSetFeatureBits, RtlpInitFunctionOverride
Capabilities, etc.) a malicious or simply buggy caller could supply an
attacker-controlled pointer and force the secure kernel to store CPU
information to that location.

Consequences:
• NULL pointers produced an immediate SK bugcheck during boot.
• Non-canonical or attacker-chosen addresses enabled an arbitrary
  1-byte/2-byte/4-byte write from EL0-influenced context inside the
  secure kernel, defeating the Secure-Boot trust boundary.

Structurally, the fault sits in securekernel!RtlGetProcessorSignature
at address 0x1400C55A4 (pre-patch).  Similar helper RtlGetCpuVendor
returned a 64-bit value although only one byte was ever used; this
mismatch propagated uncontrolled data further.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// PRE-PATCH (truncated)
char __fastcall RtlGetProcessorSignature(_BYTE *a1,_BYTE *a2,_WORD *a3,
                                        _BYTE *a4,_BYTE *a5)
{
  ...
  *a1 = RtlGetCpuVendor();     // <== unconditional writes
  *a2 = BYTE1(v13) & 0xF;
  *a3 = (unsigned __int8)(v13 >> 20);
  *a4 = (v13 >> 4) & 0xF;
  *a5 = BYTE2(v13) & 0xF;
}

// POST-PATCH
__int64 __fastcall RtlGetProcessorSignature(_BYTE *a1,int *a2,int *a3,
                                            _DWORD *a4)
{
  ...
  if (a1) *a1 = CpuVendor;
  if (a2) *a2 = v14;           // family
  if (a3) *a3 = v15;           // model
  if (a4) *a4 = result & 0xF;  // stepping
  return (unsigned)result;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker reaches secure-kernel API that eventually calls
   RtlGetProcessorSignature.
2. Supplies crafted pointer arguments (NULL or arbitrary address).
3. Function dereferences the pointer without checks, writing CPU id
   bytes to that address.
4. Depending on pointer, results in bugcheck or controlled write that
   can be leveraged to bypass Secure Boot policy.

Attack Vector
--------------------------------------------------------------------
Local, authorised code running during boot or within the secure kernel
context can supply untrusted pointers to the helper routine and obtain
an arbitrary kernel write.

Patch Description
--------------------------------------------------------------------
1. RtlGetProcessorSignature signature changed from five generic output
   pointers to four typed pointers.
2. Added explicit nullptr checks before every dereference.
3. RtlGetCpuVendor now returns a single byte (char) instead of 64-bit
   integer, removing unused upper bytes.
4. All callers (RtlDetectProcessorFeatures, SkiSetFeatureBits,
   SkiSetProcessorSignatureAndFlags, etc.) updated to pass either
   stack variables or NULL as appropriate.

Security Impact
--------------------------------------------------------------------
Before the patch a user-controlled pointer could be written by secure
kernel code, resulting in potential Secure Boot bypass, privilege
escalation to the secure kernel context, or a guaranteed denial of
service (boot crash).

Fix Effectiveness
--------------------------------------------------------------------
The added NULL checks prevent write-to-NULL and prevent writes when
callers intentionally pass no buffer.  Because callers were also
audited to pass only stack-backed variables (or NULL) the primitive
arbitrary write is removed.  No remaining unvalidated pointer writes
are observable in the updated code, so the fix is considered
effective.
