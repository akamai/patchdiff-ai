{'kb': 'KB5060842', 'patch_store_uid': 'fba400db-6cbc-441a-bc8d-d568859e3a8e', 'cve': 'CVE-2025-33066', 'date': 1763416964.4559507, 'confidence': 0.17, 'file': 'rasmans.dll', 'change_count': 4}
--------------------------------------------------------------------
CVE-2025-33066 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Routing and Remote Access Service (RRAS) – rasmans.dll
functions CreateConnection() and InitRasmanService().  These routines
run inside the Remote-Access Connection Manager (RasMan) Windows
service (NT-AUTHORITY\SYSTEM).


Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow (CWE-122).


Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  When a remote RPC client calls the RasMan  CreateConnection  RPC
    method, rasmans!CreateConnection allocates a 0x3C0-byte
    CONNECTION_BLOCK on the process heap ( LocalAlloc() ).

2.  The routine then copies several user–controlled ASCIZ strings out
    of the incoming REQUEST structure (pointer a3):
       • a3+44   → connection name
       • a3+304  → **wrong** device name  (patched to a3+821)
       • a3+1104 → user realm

3.  The copy is done with a hand-rolled loop that uses a length counter
    (v43 / v48 / v53).  The loop copies exactly N bytes (261 / 257 /
    129) and afterwards *always* writes a final NUL character:

       *vDestEnd = 0;

    If the source string length equals the hard-coded limit, the loop
    exits with the counter at 0 and the NUL write lands one byte past
    the end of the destination field, corrupting the following heap
    data (pointers, flags, list links …) inside the same
    CONNECTION_BLOCK.

4.  Because the second field was taken from the wrong offset
    (a3+304) the calculated source-to-destination delta is unpredictable
    and can be made negative.  This allows a remote caller to craft a
    request that makes the copy loop walk *forward* over the just
    allocated buffer, turning the off-by-one defect into an arbitrary
    heap overwrite.

5.  Corrupted pointers are later dereferenced (e.g. the list linkage
    at +0 / +8 and several function pointers stored after the string
    area).  An attacker who controls their contents can achieve code
    execution in the RasMan service context.

6.  The service is reachable over the network through
    MS-RRAS/RPC (port 135/NCACN_IP_TCP), therefore the flaw enables
    unauthenticated remote code execution.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
v47 = (char *)v14 + 445;          // dest (257 bytes)
v48 = 257;                        // counter
v49 = v10 - ((char*)v14 + 445);   // v10 == a3 + 304  (wrong field)
...
*v51 = 0;                         // NUL written when v48 may be 0

// after (excerpt)
char *v49 = (char *)v15 + 445;
__int64 count = 257;
__int64 delta = (char*)(a3 + 821) - v49;  // correct source offset
...
if (count) *(v49-1) = 0;           // stays inside the buffer
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker sends crafted MS-RRAS RPC request that reaches
   RasRpcServer ⇒ CreateConnection().
2. CreateConnection allocates heap buffer and copies attacker strings.
3. Off-by-one + wrong-offset logic writes beyond buffer end.
4. Heap metadata / pointers inside CONNECTION_BLOCK are smashed.
5. Subsequent RasMan operations dereference corrupt data ⇒ RIP / RCE.


Attack Vector
--------------------------------------------------------------------
Unauthenticated network attacker sends a specially crafted
CreateConnection RPC request (over ncacn_ip_tcp or other RPC transports)
containing strings of exact length 257/261/129 and a manipulated block
layout so that the second string is located at a malicious offset.


Patch Description
--------------------------------------------------------------------
Microsoft rewrote the fragile copy logic:
1. Uses the correct source pointer (a3+821) for the second string.
2. Ensures the terminating NUL is written only when the counter is
   still positive, eliminating the off-by-one.
3. Introduces additional hardening – the service unconditionally
   enables Heap-Terminate-on-Corruption via
   SetProcessMitigationPolicy() during startup.
4. Minor refactors (type safety, new trace GUIDs) – no impact on fix.


Security Impact
--------------------------------------------------------------------
Prior to the patch an unauthenticated attacker could corrupt heap data
inside the RasMan service and hijack control flow, achieving remote
code execution as SYSTEM.  Successful exploitation compromises the
entire Windows host.


Fix Effectiveness
--------------------------------------------------------------------
• Off-by-one condition removed – NUL write stays within bounds.
• Correct source offset prevents attacker-controlled delta values.
• Additional heap-termination mitigation reduces exploitability even
  if a similar logic error is reintroduced.
The patch fully addresses the identified overflow; no alternate
reachable path to the corrupted write remains observable in the fixed
build.

