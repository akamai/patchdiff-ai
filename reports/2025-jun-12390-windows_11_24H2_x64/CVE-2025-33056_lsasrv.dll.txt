{'patch_store_uid': '8fc2a2dd-410f-42d8-a947-1bc9775b11bc', 'file': 'lsasrv.dll', 'kb': 'KB5060842', 'date': 1763416968.2650466, 'confidence': 0.24, 'cve': 'CVE-2025-33056', 'change_count': 73}
--------------------------------------------------------------------
CVE-2025-33056 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Local Security Authority Server (lsasrv.dll) –
authentication-server RPC routines that manipulate LSA objects
(LsarSetSecurityObject, LsarQueryInformationAccount and
LsapSetSystemAccessAccount).

Vulnerability Class
--------------------------------------------------------------------
Improper Access Control / Authorisation-bypass that allows a remote
caller to set security information without holding the required
access rights, leading to denial of service (CWE-284).

Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  The server-side RPC entry LsarSetSecurityObject is responsible for
    updating the security descriptor of an LSA database object that a
    caller previously opened through LSARPC.

2.  Before the patch the routine performed its access check by calling

        LsapDbReferenceObject( Handle, 9 );

    The hard-coded value 9 (0x00000009) is a very small access mask
    that maps to POLICY_VIEW & POLICY_LOOKUP.  It does *not* include
    any of the rights that are actually required to change a security
    descriptor:
        WRITE_DAC  (0x00040000)
        WRITE_OWNER(0x00080000)
        ACCESS_SYS_SECURITY (0x01000000)

3.  The function therefore accepted a handle that was opened with only
    read-like permissions but still honoured SECURITY_INFORMATION flags
    that request the modification of Owner, DACL, SACL, etc.  A normal
    network user that can obtain a policy handle (POLICY_LOOKUP is
    granted to Authenticated Users by default) can invoke
    LsarSetSecurityObject and write an arbitrary SD to critical LSA
    objects, for example one that denies all access.  Subsequent LSA
    operations fail and LSASS terminates, yielding a system-wide
    denial-of-service.

4.  The patch introduces a correct mapping from the caller-supplied
    SecurityInformation flags to the corresponding access mask:

        SetSecurityAccessMask( SecurityInformation, &DesiredAccess );

    or a manual fallback that sets
        WRITE_OWNER  if OWNER_SECURITY_INFORMATION  is requested,
        WRITE_DAC    if DACL_SECURITY_INFORMATION   is requested,
        ACC_SYS_SEC  if SACL_SECURITY_INFORMATION   is requested.

5.  The computed DesiredAccess value is later provided to
    LsapDbReferenceObject (code not shown in the excerpt), forcing the
    LSA runtime to verify that the caller’s handle really owns the
    rights that correspond to the requested security operation.  This
    removes the authorisation bypass and prevents the DoS.

6.  Additional hardening was added to the related account-management
    paths (LsarQueryInformationAccount and LsapSetSystemAccessAccount):
       • output pointer initialisation ( *a3 = 0 ) to avoid
         uninitialised-pointer faults,
       • refactoring to a single information query helper, and
       • use of new feature-gated account-cache helpers.  These changes
         are defensive and do not alter the root bug.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
Attribute = LsapDbReferenceObject(a1, 9);    // always 0x9 access mask
```
```c
// after (first lines of new function)
SetSecurityAccessMask(SecurityInformation, &DesiredAccess); // or manual
...
Attribute = LsapDbReferenceObject(a1, DesiredAccess);       // full check
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker (network user) binds to LSARPC named pipe.
2. Opens policy handle with POLICY_LOOKUP access.
3. Crafts SECURITY_DESCRIPTOR that denies everyone & sets
   SECURITY_INFORMATION = OWNER|DACL|SACL.
4. Issues LsarSetSecurityObject(Handle, flags, &SD).
5. Server accepts call because hard-coded access mask (9) passes.
6. SD is written, LSASS can no longer access its own objects.
7. Subsequent LSA operations fail, the service exits – DoS.

Attack Vector
--------------------------------------------------------------------
Remote, authenticated (low-privilege) RPC call to LSARPC
(LsarSetSecurityObject).  No local code execution on the target is
necessary; only network reachability of lsass.exe is required.

Patch Description
--------------------------------------------------------------------
• Added calculation of the correct DesiredAccess mask from
  SecurityInformation via SetSecurityAccessMask or manual mapping.
• Uses the computed mask when referencing the object, ensuring that
  WRITE_DAC/WRITE_OWNER/ACCESS_SYS_SECURITY are enforced.
• Initialises out-parameters in other account APIs to NULL for
  additional robustness.
• Re-points ETW trace GUIDs and factors feature-flag based paths –
  cosmetic.

Security Impact
--------------------------------------------------------------------
Prior to the patch any authenticated network user could change the
security descriptor of LSA database objects without the necessary
permissions.  By denying access or otherwise corrupting the SD the
attacker drove LSASS into an unrecoverable state, resulting in process
termination and therefore system reboot (denial of service).

Fix Effectiveness
--------------------------------------------------------------------
The updated code ensures that the required access mask exactly matches
what the caller wants to modify.  Without WRITE_DAC / WRITE_OWNER /
ACCESS_SYSTEM_SECURITY the reference call now fails with
STATUS_ACCESS_DENIED and no write takes place.  Because the core
access check is performed inside the existing reference routine the
fix is effective and regression risk is minimal.

