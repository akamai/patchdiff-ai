{'cve': 'CVE-2025-32724', 'patch_store_uid': '8fc2a2dd-410f-42d8-a947-1bc9775b11bc', 'confidence': 0.11, 'file': 'lsasrv.dll', 'change_count': 73, 'kb': 'KB5060842', 'date': 1763417049.0405278}
--------------------------------------------------------------------
CVE-2025-32724 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Local Security Authority Subsystem Service (lsasrv.dll)
Function involved: LsapSetSystemAccessAccount

Vulnerability Class
--------------------------------------------------------------------
CWE-400: Uncontrolled Resource Consumption (Denial-of-Service)

Detailed Root Cause Analysis
--------------------------------------------------------------------
LsapSetSystemAccessAccount is invoked by several LSARPC APIs that can be
reached over the network.  At function exit the routine releases the
SUB-provider state by calling

    LsapSubProv_FreeRoutine(SubProvCtx, Buffer)

In the original build the second argument (named  v8  in the listing) is
never initialised by the function itself; it still carries the value of
register RDX that holds the *caller-supplied* SystemAccess bit-mask
(a2).  Consequently the LSASS process ends up passing an *attacker
controlled 32-bit integer that is not a valid heap pointer* to the
free-routine.  The free-routine treats the value as a buffer address and
attempts to walk / free it.  Touching unmapped or otherwise invalid
memory aborts LSASS, which in turn causes a system reboot because LSASS
is a critical subsystem.

Because the faulty pointer comes directly from every network request,
an attacker can repeat the operation indefinitely, reliably crashing
LSASS and producing a persistent denial-of-service condition.  No
special privileges are required; the request only has to reach the
LSARPC endpoint.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable (before)
...
  if (v41)
      LsapSubProv_FreeRoutine(v41, v8);   // v8 == caller controlled a2
...

// fixed (after)
  if (v41)
      LsapSubProv_FreeRoutine(v41, v7);   // v7 now cleared / guaranteed
                                          // to hold a benign value
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Remote client calls an LSARPC method that eventually executes
   LsapSetSystemAccessAccount.
2. Client places an arbitrary 32-bit value in the SystemAccess field
   (second RPC parameter, mapped to a2 / RDX).
3. Function reaches the epilogue, finds SubProvCtx non-NULL and calls
   LsapSubProv_FreeRoutine with the tainted value as Buffer.
4. Free-routine dereferences the bogus address; LSASS AVs and the
   operating system restarts.

Attack Vector
--------------------------------------------------------------------
Unauthenticated network access to LSARPC (TCP port 445 or 135 via SMB/DCOM)
allows an attacker to supply the crafted SystemAccess value that becomes
an invalid buffer pointer.

Patch Description
--------------------------------------------------------------------
The update introduces a new local variable ( Buffer / v13 ) that stores
only the address returned by LsapQueryClientInfo.  The call to
LsapSubProv_FreeRoutine now passes this verified pointer instead of the
caller-supplied register value.  The argument type for SystemAccess was
also switched from signed *int* to *unsigned int*, and additional
feature-gate checks were added, but these are defensive hardening rather
than the core fix.

Security Impact
--------------------------------------------------------------------
Before the patch an unauthenticated attacker could crash LSASS on every
call, forcing a Blue Screen or automatic reboot and thereby causing a
full denial-of-service on the target host.

Fix Effectiveness
--------------------------------------------------------------------
The modified build ensures that LsapSubProv_FreeRoutine only receives a
pointer that originates from LsapQueryClientInfo (or NULL).  Because the
attacker-controlled value is no longer forwarded, the invalid pointer
dereference and subsequent crash are eliminated.  No residual code path
was found that still passes untrusted data to the free-routine; thus the
patch is considered effective against the described issue.
