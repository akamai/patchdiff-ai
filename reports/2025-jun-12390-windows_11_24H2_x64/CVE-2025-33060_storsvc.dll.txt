{'change_count': 17, 'file': 'storsvc.dll', 'confidence': 0.26, 'cve': 'CVE-2025-33060', 'patch_store_uid': 'e357b706-c599-45dd-b928-3b319eb9aed7', 'kb': 'KB5060842', 'date': 1763415454.0498383}
--------------------------------------------------------------------
CVE-2025-33060 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Storage Management Provider (storsvc.dll).  Vulnerable routine
is ScValidateProvisioning(), which validates user-supplied
_SP_PROVISIONING_INFO structures before they are consumed by the
storage service.


Vulnerability Class
--------------------------------------------------------------------
Out-of-bounds Read (CWE-125) that can lead to local information
leakage.


Detailed Root Cause Analysis
--------------------------------------------------------------------
_SP_PROVISIONING_INFO is a caller-controlled structure that contains
several 32-bit index fields starting at offset 0x14 (array element 5
in the decompiled view).  These fields are later used as indices into
fixed-size internal tables (size <= 5).  Prior to the patch,
ScValidateProvisioning() only sanity-checked two of the three index
fields:
  • a1[5]   ("StartIndex") – had to be in range 1..5
  • a1[6]   ("MiddleIndex") – had to be in range 1..5 and >= StartIndex

The last index field
  • a1[7]   ("EndIndex")
was never validated.  A caller could therefore supply a value greater
than the table length (>=6) or smaller than StartIndex, causing later
code that iterates over [StartIndex, EndIndex] to read beyond the end
of the internal array.  Because the table is adjacent to other service
state, arbitrary kernel memory after the array is disclosed to the
caller.

When feature flag H2E_WPA3SAE is enabled the service also expects
MiddleIndex to be non-zero and strictly less than EndIndex; those
constraints were likewise missing.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – no check for a1[7]
  v7 = *((_DWORD *)a1 + 5);        // StartIndex
  if ( v7 - 1 > 4 )                // 1..5 OK
    return STATUS_INVALID_PARAMETER;
  v8 = *((_DWORD *)a1 + 6);        // MiddleIndex
  if ( v8 - 1 > 4 || v7 > v8 )     // 1..5 and Start<=Middle
    return STATUS_INVALID_PARAMETER;
// a1[7] (EndIndex) is never examined
```
```c
// after patch – added validation for a1[6] and a1[7]
  if ( Feature_H2E_WPA3SAE__IsEnabledDeviceUsage() )
  {
      v8 = *((_DWORD *)a1 + 6);    // MiddleIndex
      if ( v8 && (v8 - 1 > 4 || v7 > v8 || v8 >= *((_DWORD *)a1 + 7)) )
          return STATUS_INVALID_PARAMETER;
  }
  v9 = *((_DWORD *)a1 + 7);        // EndIndex
  if ( v9 - 1 > 4 || v7 > v9 )
      return STATUS_INVALID_PARAMETER;
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker calls a public Storage Management API (or corresponding
   IOCTL) that ultimately passes user data to storsvc.
2. The API packages user-controlled values into an
   _SP_PROVISIONING_INFO structure.
3. storsvc.dll receives the struct and calls
   ScValidateProvisioning().
4. Prior to the patch, an oversized EndIndex passes the incomplete
   validation.
5. Subsequent code iterates from StartIndex to EndIndex, reading past
   the 5-element internal table and returning uninitialized kernel
   memory to user mode.


Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker supplies a crafted provisioning request
(e.g., via PowerShell Storage module, WMI, or direct DeviceIoControl)
containing out-of-range index values.  No additional privileges beyond
those required to manage storage (normally granted to local
administrators) are needed.


Patch Description
--------------------------------------------------------------------
The fix adds two groups of boundary checks:
1. When the H2E_WPA3SAE feature is active, MiddleIndex (a1[6]) must be
   non-zero, within 1..5, not less than StartIndex, and strictly less
   than EndIndex.
2. EndIndex (a1[7]) must also be within 1..5 and not less than
   StartIndex.
All failing cases return error 0xC13A0021 (-1058603007).


Security Impact
--------------------------------------------------------------------
A malformed provisioning structure could make the storage service read
memory beyond a fixed array, leaking up to dozens of bytes of
uninitialized kernel memory to user mode.  The disclosure could help
an attacker bypass KASLR or obtain sensitive system data.


Fix Effectiveness
--------------------------------------------------------------------
The added comparisons ensure that each caller-controlled index is
bounded to the valid table size and that the indices are ordered
logically.  Because the function now rejects every out-of-range or
inconsistent set of indices, the out-of-bounds read path is removed.
No bypass is evident in the patched logic, so the fix is considered
complete.
