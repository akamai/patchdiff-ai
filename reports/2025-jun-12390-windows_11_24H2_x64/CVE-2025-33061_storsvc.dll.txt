{'change_count': 17, 'date': 1763417591.3883731, 'file': 'storsvc.dll', 'patch_store_uid': 'e357b706-c599-45dd-b928-3b319eb9aed7', 'confidence': 0.21, 'cve': 'CVE-2025-33061', 'kb': 'KB5060842'}
--------------------------------------------------------------------
CVE-2025-33061 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Storage Service (storsvc.dll / Storage Management Provider)
responsible for validating user-supplied provisioning data and other
volume-management parameters.

Vulnerability Class
--------------------------------------------------------------------
Out-of-bounds read (CWE-125) leading to local information disclosure.

Detailed Root Cause Analysis
--------------------------------------------------------------------
Function ScValidateProvisioning(_SP_PROVISIONING_INFO*, …) validates a
caller-supplied _SP_PROVISIONING_INFO structure before it is consumed by
lower-level volume-management code.

The structure contains several 32-bit fields representing provisioning
ranges:
  offset 5 – Minimum tier index (MinTier)
  offset 6 – Maximum tier index (MaxTier)
  offset 7 – Desired tier index (DesiredTier)
Internal tier tables contain only five entries (legal values 1-5).

Before the patch the code verified MinTier and MaxTier but **never
checked DesiredTier (field 7)**.  If the caller set DesiredTier to an
out-of-range value ( >5 or <1 ) the later logic indexed directly into
the tier table, causing an out-of-bounds read of one to many DWORDs from
adjacent kernel memory.  Because the memory is later returned through
management APIs, an authorised local attacker could obtain the
uninitialised data.

Additional corner case:
  • If MaxTier was zero the old validation accepted the structure even
    though subsequent code assumed a non-zero upper bound.  This could
    also lead to OOB access when MinTier > MaxTier.

The issue is purely in input sanitation; the memory layout of the
target table is correct, but an invalid index is allowed to propagate
into the array dereference path.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
v7 = *((_DWORD *)a1 + 5);          // MinTier  (checked)
...
v8 = *((_DWORD *)a1 + 6);          // MaxTier  (checked)
if (v8 - 1 > 4 || v7 > v8)
    return ERROR;
//  *** DesiredTier ( *(a1+7) ) NOT VALIDATED ***
```

```c
// after
if ((unsigned int)Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage()) {
    v8 = *((_DWORD *)a1 + 6);      // MaxTier only accepted when feature
    if (v8 && (v8 - 1 > 4 || *((_DWORD *)a1 + 5) > v8 ||
               v8 >= *((_DWORD *)a1 + 7)))    // new cross-check
        return ERROR;
}

v9 = *((_DWORD *)a1 + 7);          // DesiredTier
if (v9 - 1 > 4 || *((_DWORD *)a1 + 5) > v9)
    return ERROR;                  // new hard bound for DesiredTier
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Client sends crafted provisioning request (IOCTL / WMI / API).
2. StorageService::ProcessNewStorageCard(...) ->
3. ScValidateProvisioning(...)
4. Invalid DesiredTier bypasses old check, function returns success.
5. Subsequent tier-handling code indexes TierTable[DesiredTier-1].
6. Out-of-range index discloses neighbouring kernel memory to caller.

Attack Vector
--------------------------------------------------------------------
A locally authenticated attacker invokes Storage Management interfaces
(e.g., VDS, WMI MSFT_StoragePool, or the public IOCTL layer) supplying a
malicious _SP_PROVISIONING_INFO structure with DesiredTier > 5.  No
additional privileges are required beyond the ability to create a pool
or virtual disk, making the attack feasible from a sandboxed or
restricted context.

Patch Description
--------------------------------------------------------------------
• Added helper Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage() and
  used it to gate new validation logic.
• Introduced explicit bounds check for field 7 (DesiredTier).
• Ensured MinTier <= DesiredTier <= 5 and, when the feature is enabled,
  MaxTier obeys the same constraint.
• Refactored related code paths (ProcessNewStorageCard, SiCreateReadCache)
  to call the new helper and to propagate the validated values safely.

Security Impact
--------------------------------------------------------------------
Before the fix an attacker could read up to several DWORDs of kernel
memory, potentially leaking addresses or other sensitive information
needed for further exploitation (e.g., KASLR bypass).  No code execution
is possible through this bug alone, but it weakens overall kernel
protection.

Fix Effectiveness
--------------------------------------------------------------------
The new validation rejects any provisioning structure whose DesiredTier
is outside the legal 1-5 range or violates ordering constraints.  Array
access now occurs only after successful bounds checks, eliminating the
OOB read condition.  No remaining unchecked indices are observable in
the patched diff, so the fix appears complete for this code path.
