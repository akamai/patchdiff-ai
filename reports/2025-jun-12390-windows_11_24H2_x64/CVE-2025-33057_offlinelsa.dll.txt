{'patch_store_uid': 'b7ba37ee-16d7-4e4c-95f4-2b90577c1fdd', 'date': 1763415440.6180155, 'cve': 'CVE-2025-33057', 'confidence': 0.27, 'change_count': 3, 'kb': 'KB5060842', 'file': 'offlinelsa.dll'}
--------------------------------------------------------------------
CVE-2025-33057 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
OfflineLSA (offlinelsa.dll) – routines implementing AES-256 helper
functions: aeskey(), LspAES256DecryptData(), and
LspAES256EncryptData().


Vulnerability Class
--------------------------------------------------------------------
NULL Pointer Dereference (CWE-476) leading to denial-of-service in
the Local Security Authority (LSA) process.


Detailed Root Cause Analysis
--------------------------------------------------------------------
The in-house AES wrapper expected callers to supply a structure of the
form

    struct _LSP_ENCRYPTION_KEY {
        DWORD  KeyLength;   // must be 32 for AES-256
        PUCHAR KeyBuffer;   // pointer to 32-byte material
    };

In both LspAES256EncryptData() and LspAES256DecryptData() the original
code performed only one check:

    if (KeyLength == 32)
        aeskey(stackSched, KeyBuffer);   // <- no NULL test

No verification was made that KeyBuffer was non-NULL or actually
addressable inside the LSA process.  aeskey() immediately copied 32
bytes from the supplied pointer while building the round-key schedule
on the stack.  If KeyBuffer was NULL (0x0) or otherwise invalid the
read dereferenced address 0x0, raising STATUS_ACCESS_VIOLATION and
terminating lsass.exe.  Because the helper routines are reachable
through multiple network authentication code paths, an authenticated
remote user could supply a crafted _LSP_ENCRYPTION_KEY containing
KeyLength == 32 and a NULL (or unmapped) KeyBuffer, reliably crashing
LSA and causing an availability loss on the target host.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// offlinelsa.dll – before patch
// LspAES256DecryptData()
memset_0(v14, 0, 0x1E4);
if (*(_DWORD *)a1 == 32)            // KeyLength check only
{
    aeskey((__int64)v14, *((_QWORD *)a1 + 1)); // KeyBuffer used here
    ...                               // NULL pointer possible
}

// aeskey()
*(_DWORD *)a1 = 14;
rijndaelKeySched(a2, a1 + 4);        // unguarded read of a2 (KeyBuffer)
```

```c
// after patch
if (*(_DWORD *)a1 == 32 && a2 >= 0x10)
{
    status = BCryptGenerateSymmetricKey(hAlg,
                                        &hKey,
                                        NULL,0,
                                        a1[1],   // Key material
                                        0x20,0);
    if (status < 0) goto cleanup;
    ...                               // Key handled by CNG, no deref
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Remote (authenticated) client sends data that eventually reaches an
   LSA mechanism using offlinelsa!LspAES256[En|De]cryptData().
2. _LSP_ENCRYPTION_KEY structure is produced with KeyLength == 32 and
   KeyBuffer == NULL.
3. Function passes NULL pointer into aeskey().
4. aeskey() executes `rijndaelKeySched(NULL, ...)` which dereferences
   address 0x0.
5. lsass.exe raises an access violation and terminates – service is
   denied.


Attack Vector
--------------------------------------------------------------------
An authenticated attacker able to trigger LSP encryption routines (for
example via remote authentication protocols using OfflineLSA helpers)
can provide a crafted key descriptor with a NULL buffer pointer,
causing lsass.exe to crash and restart.  This results in a denial of
service on the target machine.


Patch Description
--------------------------------------------------------------------
Microsoft removed the bespoke AES implementation and replaced it with
Cryptography Next Generation (CNG) primitives:

1. aeskey() has been deleted; its body is now only a destructor that
   conditionally calls BCryptDestroyKey().
2. LspAES256DecryptData() and LspAES256EncryptData() now: 
   • Treat the second field as an inline 32-byte key (not a pointer).
   • Validate that KeyLength == 32, ciphertext/plaintext size is
     sensible (>=16 bytes, buffer length fits, etc.).
   • Call BCryptGenerateSymmetricKey() and BCrypt[En|De]crypt() which
     protect against NULL key material.
3. Both functions use wil::unique_storage to guarantee the key handle
   is destroyed even on error paths.


Security Impact
--------------------------------------------------------------------
Before the fix any code path that supplied a NULL (or otherwise
invalid) key pointer caused an immediate crash of lsass.exe,
rendering the system unable to authenticate users until the service
restarted.  The patch eliminates the crash, preventing denial-of-
service.


Fix Effectiveness
--------------------------------------------------------------------
The new parameter checks ensure that key material is present in-place
and never NULL.  All cryptographic operations are offloaded to the
well-tested CNG API, and wil::unique_storage guarantees clean teardown.
No remaining NULL dereference is observable from the provided diff,
indicating the patch fully addresses the identified flaw.
