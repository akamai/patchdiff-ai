{'change_count': 3, 'patch_store_uid': '6cd4119d-6eb0-427c-ac5a-466792602588', 'cve': 'CVE-2025-29828', 'kb': 'KB5060842', 'date': 1763415487.922896, 'confidence': 0.22, 'file': 'schannel.dll'}
--------------------------------------------------------------------
CVE-2025-29828 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Schannel â€“ schannel.dll
Function: CTls13ServerContext::DowngradeServerToSsl3Tls

Vulnerability Class
--------------------------------------------------------------------
CWE-401: Missing release of memory after effective lifetime
(Resource-management error that can be leveraged for remote code
execution)

Detailed Root Cause Analysis
--------------------------------------------------------------------
The routine DowngradeServerToSsl3Tls is reachable during a TLS 1.3
handshake whenever the server elects to fall back to an earlier
SSL3/TLS protocol version.  In the original implementation the
function performed the following sequence:

1. Always invoked CSslContextManager::AllocateServerContext() to
   obtain a fresh CSslParentContext object (returned in local "v3").
2. If the call succeeded, it unconditionally overwrote the pointer
   located at *(this + 231)->+24 with the newly returned context
   pointer (v3+2).
3. No attempt was made to free or reference-count the previous object
   already stored in that field.  As a consequence every additional
   downgrade attempt leaked one CSslParentContext instance.
4. The field *(this + 232) was ORed with 0x40000, signalling that the
   downgrade had been completed, but this flag did not prevent the
   function from being entered again later in the handshake.

Because the downgrade helper can be triggered more than once during a
single network session (e.g. by manipulating the handshake message
sequence or by starting several renegotiations), an unauthenticated
remote attacker can force an unbounded number of allocations.  The
leaked objects remain permanently unreachable, causing uncontrolled
heap growth inside the LSASS process that hosts Schannel.  When the
allocator finally reuses the exhausted region, pointer corruption may
occur, enabling remote code execution in the context of the process.

Key object layout (offsets are 8-byte indices into *this):
  +231 -> CTls13SecurityParameters
          +24  PVOID  pServerContext   (overwritten, never released)
  +232 -> DWORD64 ContextFlags        (bit 0x40000 set on downgrade)
  +273 -> PVOID   pExistingDowngrade  (non-zero when a context exists)

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch
v3 = 0;
result = CSslContextManager::AllocateServerContext(&g_SslContextManager,
                                                   this, &v3);
if (!result) {
    result = 1359;                             // ERROR_UNKNOWN
    *((QWORD*)(*((QWORD*)this + 231)) + 3) = *((QWORD*)v3 + 2);
    *((QWORD*)this + 232) |= 0x40000;          // mark downgraded
}
```
```c
// after patch (excerpt)
if ( FeatureEnabled() && *((QWORD*)this + 273) ) {
    TraceDowngradeDenied();
    return 0x80090332;        // SEC_E_UNSUPPORTED_FUNCTION
}
// old leak-prone logic kept under the else-branch
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Network packet  ->  Schannel handshake parser
                 ->  CTls13ServerContext::ProcessClientHello
                 ->  DowngradeServerToSsl3Tls (called repeatedly)
                 ->  Multiple allocations without release

Attack Vector
--------------------------------------------------------------------
An unauthenticated attacker sends a crafted TLS 1.3 handshake followed
by renegotiation messages that repeatedly force the server to downgrade
its security context.  Every renegotiation re-enters
DowngradeServerToSsl3Tls, leaking memory inside the Schannel service.
No local access is required; exploitation is entirely over the network
on any service that uses Schannel (e.g. IIS, RDP).

Patch Description
--------------------------------------------------------------------
The fix adds a guard clause:
1. A feature flag check using the Windows Feature gating mechanism.
2. If the feature is enabled *and* *(this + 273) is non-null (meaning a
   downgrade context is already present), the function aborts early and
   returns SEC_E_UNSUPPORTED_FUNCTION (0x80090332).
3. Optional WPP tracing is performed for diagnostics.

This prevents repeated allocations and therefore eliminates the memory
leak.

Security Impact
--------------------------------------------------------------------
Prior to the patch an attacker could carry out a persistent heap leak
that eventually leads to memory exhaustion or to re-allocation of stale
objects in freed regions, enabling arbitrary code execution under the
LocalSystem account that hosts LSASS.  Successful exploitation grants
full control of the target machine over the network.

Fix Effectiveness
--------------------------------------------------------------------
The added predicate ensures that the potentially leaking code path can
run at most once per connection, completely blocking the unbounded leak
scenario.  No additional memory handling changes were required, so the
patch adequately addresses the root cause.  No bypass is evident from
the diff.

