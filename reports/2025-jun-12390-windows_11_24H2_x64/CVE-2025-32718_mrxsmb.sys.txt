{'cve': 'CVE-2025-32718', 'kb': 'KB5060842', 'patch_store_uid': '238e095d-a913-4a7d-b7e3-94a2acac5569', 'change_count': 5, 'confidence': 0.3, 'file': 'mrxsmb.sys', 'date': 1763415486.9759088}
--------------------------------------------------------------------
CVE-2025-32718 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
MRxSmb.sys – Windows kernel-mode SMB (redirector) client driver.
Affected helper routines:
 • SmbCeCreateSrvCall
 • RxCeEncryptData
 • RxCeCompressData


Vulnerability Class
--------------------------------------------------------------------
Integer overflow / heap-based buffer overflow (CWE-190, CWE-122).


Detailed Root Cause Analysis
--------------------------------------------------------------------
Two data-path helper routines allocate a pool buffer whose size is
calculated as  
    requested_data_length + constant_offset
and then copy ‘requested_data_length’ bytes into this buffer.

1. RxCeEncryptData
   • Original code stores `total = a4 + 132` and allocates that many
     bytes with ExAllocatePool2.
   • No verification is made that the 32-bit user-controlled value
     `a4` can be safely added to 132.
   • If a4 is close to 0xFFFFFFFF, the 32-bit addition wraps, leading
     to a much smaller allocation while the subsequent call to
     RtlCopyMdlToBuffer writes the full (large) amount starting at
     offset 132 (Pool2+132).  Heap memory behind the allocation is
     overwritten.
   • The same buffer is later handed to IoAllocateMdl, extending the
     corruption to MDL handling structures.

2. RxCeCompressData (both compression and legacy paths)
   • `alloc_size = a4 + (a5?96:16)` is computed with 32-bit arithmetic
     and used for ExAllocatePool2.  No overflow check exists.
   • The function then copies/encodes up to `a4` bytes plus protocol
     headers into the buffer, again overrunning the heap allocation if
     the addition wrapped.

3. SmbCeCreateSrvCall
   • The routine itself is not the overflow source, but it later
     references the corrupted buffers and can propagate the corrupted
     pointers, making exploitation paths easier.

The attacker controls `a4` because it is derived from remote SMB
payload length fields that the client parses when it encrypts or
compresses outgoing data or when loop-back operations are performed.
Because the routines execute in kernel context, any heap corruption
occurs in the kernel NonPagedPool, enabling elevation of privilege.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// RxCeEncryptData – vulnerable
*a6 = a4 + 52;                 // length for MDL
Pool2 = ExAllocatePool2(66, a4 + 132, 'SmBf');
...
RtlCopyMdlToBuffer(a3, 0, Pool2 + 132, a4, &BytesCopied); // overflow
```

```c
// RxCeCompressData – vulnerable
unsigned int alloc = a4 + (a5 ? 96 : 16);
Pool2 = ExAllocatePool2(66, alloc, 'SmBf');
...
SmbCompressionLegacyCompress(... , alloc_buffer + 16, &outLen);
```

```c
// Patch – added overflow check
if (Feature_IsEnabled() && (a4 + 52) < 0x34) {
    *a6 = -1;                 // fail – integer wrapped / too small
    return STATUS_INTEGER_OVERFLOW;
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. A user-mode process or malicious SMB server supplies a crafted SMB
   message that requires encryption/compression with a huge `Length`
   field (`a4`).
2. MRxSmb.sys calls RxCeEncryptData / RxCeCompressData with that length.
3. Addition overflows; ExAllocatePool2 returns a small buffer.
4. RtlCopyMdlToBuffer / compression helpers write past the end of the
   buffer into adjacent NonPagedPool memory.
5. Corrupted heap metadata or adjacent objects allow arbitrary kernel
   memory overwrite → elevation of privilege.


Attack Vector
--------------------------------------------------------------------
Local: an attacker running in user space can trigger the SMB client to
send a crafted buffer (e.g., via SMB loopback share) or exploit a
privileged service that uses the SMB client.  Remote: a malicious SMB
server can return a response that causes the client to execute the
vulnerable paths during encryption/compression setup.


Patch Description
--------------------------------------------------------------------
1. Added explicit overflow detection before size arithmetic: the code
   now checks that `requested + header` does not wrap and meets minimum
   header sizes.  On failure it returns STATUS_INVALID_BUFFER_SIZE
   (0xC000009B).
2. Re-ordered structure layout: new constant 80-byte header, pointer
   arithmetic updated (`buffer+80`, `buffer+132`) to ensure alignment.
3. Early exit paths added so allocation and copy are skipped when the
   size is invalid.
4. In SmbCeCreateSrvCall, related clean-up paths were hardened but the
   core fix is the size validation in the helper routines above.


Security Impact
--------------------------------------------------------------------
Before the patch a local or remote attacker could trigger a controlled
heap overflow in kernel mode, allowing execution of arbitrary code in
the Windows kernel (privilege escalation) or a kernel crash.


Fix Effectiveness
--------------------------------------------------------------------
The patch introduces deterministic checks that abort the operation when
integer addition would overflow or produce an undersized buffer.  The
allocation size is validated before pool allocation and the same value
is reused for subsequent operations, removing the mismatch.  No further
paths that use unchecked `length + constant` arithmetic remain in the
modified functions, therefore the fix is effective for the reported
vectors. Further audit of other SMB helper routines is recommended.
