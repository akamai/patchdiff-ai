{'date': 1763417346.3399146, 'change_count': 158, 'file': 'win32kfull.sys', 'confidence': 0.05, 'kb': 'KB5058411', 'patch_store_uid': '62dac484-f3bc-4d07-9dfd-85240e9d509e', 'cve': 'CVE-2025-47969'}
--------------------------------------------------------------------
CVE-2025-47969 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
win32kfull.sys – several UI-kernel entry points:
  • NtUserGetWindowProcessHandle / GetWindowProcessHandleUnsafe
  • xxxWrapRealDefWindowProc / CheckProcessIdentity
  • NtUserPrintWindow, NtUserSetProcessWin32Capabilities
  • Misc. mouse-queue, DC and PDEV helpers
All are part of the Win32k (USER/GDI) subsystem responsible for
UI-privilege isolation (UIPI) and cross-process window messaging.

Vulnerability Class
--------------------------------------------------------------------
Improper access-control / information disclosure (CWE-200).  A local
non-privileged process could obtain a live PROCESS handle to a higher
integrity process, bypassing UIPI / VBS policy, and subsequently query
memory or other sensitive data.

Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  The key helper GetWindowProcessHandleUnsafe() is used by
    NtUserGetWindowProcessHandle and several message-wrappers.  In the
    pre-patch routine only the following checks were enforced:
       • Same session.
       • If UIPrivilegeIsolation::Enforced()==TRUE then call
         CheckAccess(); otherwise fall back to a weak token SID match.
       • Special cases for WM_* messages  and IsShellProcess().

2.  When UIPrivilegeIsolation::Enforced() returned FALSE the code path
    marked “!(unsigned __int8)Enforced()” was taken.  This path relied
    solely on token LOGON SID equality (fields 772/776) and therefore
    allowed a Medium IL process to request a PROCESS_QUERY_INFORMATION
    (0x78) or PROCESS_DUP_HANDLE (0x1000) handle to any window owned by
    a High or System IL process in the same desktop/session.

3.  No comparison of the window’s UIPI level (tagUIPI_INFO) was made in
    that branch, nor was UIAccess or VBS isolation honoured.

4.  Down-stream wrappers (xxxWrapRealDefWindowProc, CheckProcessIdentity
    etc.) replicated the same logic and called CheckAccess() only when
    Enforced()==TRUE, enabling cross-IL window messaging and handle
    acquisition.

5.  An attacker just needs a valid HWND belonging to a privileged
    process (e.g. Windows Hello / LogonUI).  Calling
       NtUserGetWindowProcessHandle(hwnd, PROCESS_QUERY_LIMITED_INFO)
    returns a kernel-created handle to the target EPROCESS that can be
    abused with NtQueryInformationProcess / ReadProcessMemory (through
    duplicated handles) to leak credential or VBS protected state.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch (GetWindowProcessHandleUnsafe)
if (!(unsigned __int8)Enforced()) {
    if ((_BYTE)v18) {
        // telemetry only
    }
    if (*(DWORD *)(v17+772) != v18[193] ||
        *(DWORD *)(v17+776) != v18[194])
        goto access_denied;   // SID mismatch only!
    // opens handle with ObOpenObjectByPointer(...)
}

// after patch
if (Feature_IsEnabledDeviceUsage_17())
    targetUipi = (tagUIPI_INFO *)(v12 + 0x368); // 872
else
    targetUipi = fallbackBuildUipiFromSid(...);

if (!UIPrivilegeIsolation::CheckAccess(callerUipi, targetUipi, NULL))
    deny;
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker obtains HWND of privileged window (EnumWindows / child walk).
2. Calls NtUserGetWindowProcessHandle(hwnd, 0x78).
3. Function enters GetWindowProcessHandleUnsafe.
4. Old code falls into !(Enforced) branch, passes weak SID check.
5. ObOpenObjectByPointer returns live process handle into caller.
6. Attacker leaks memory or token information of high IL process.

Attack Vector
--------------------------------------------------------------------
Local, user-mode – requires the ability to execute code in any session.
No additional privileges are needed; only a HWND that belongs to the
victim process.

Patch Description
--------------------------------------------------------------------
• Introduced hard UIPrivilegeIsolation::CheckAccess() calls in every
  relevant code path.
• Replaced legacy CheckAccess() with UIPI aware versions that use
  tagUIPI_INFO structures.
• Added feature-flag gates (DeviceUsage_17/21/52) but *all* fall through
  to UIPI checks.
• Added IsProcessDwm() and IsEnabledDeviceUsage_52() guards to block
  special-case bypasses.
• Strengthened NtUserGetWindowProcessHandle to reject requests when
  access mask is not one of the two whitelisted values.
• Similar fixes applied to xxxWrapRealDefWindowProc, CheckProcessIdentity
  and NtUserPrintWindow to ensure messages/handles obey UIPI.

Security Impact
--------------------------------------------------------------------
Prior to the patch any medium-integrity process could acquire process
handles to high-privilege UI processes, bypassing VBS memory isolation
and potentially disclosing credential or biometric data managed by
Windows Hello.  The issue is classified as an information-disclosure
vulnerability (CVE-2025-47969).

Fix Effectiveness
--------------------------------------------------------------------
The new code path unconditionally verifies UIPI via
UIPrivilegeIsolation::CheckAccess before a handle is opened or a message
is forwarded.  The vulnerable Enforced()==FALSE shortcut no longer leads
to success; attempts now fail with ERROR_ACCESS_DENIED (5).  All caller
sites were updated, and additional DWM/DESKTOP feature flags close the
previous gaps.  No obvious alternative path remains, indicating the
patch is effective.
