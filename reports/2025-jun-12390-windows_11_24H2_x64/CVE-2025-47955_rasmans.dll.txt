{'change_count': 2, 'confidence': 0.34, 'patch_store_uid': 'c5dda83d-c37f-4c8a-9af4-4fc30307b972', 'file': 'rasmans.dll', 'kb': 'KB5058411', 'date': 1763415427.2747135, 'cve': 'CVE-2025-47955'}
--------------------------------------------------------------------
CVE-2025-47955 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
rasmans.dll – function SetCachedCredentials (Windows Remote Access
Connection Manager service)

Vulnerability Class
--------------------------------------------------------------------
Stack-based buffer overflow leading to local privilege escalation
(CWE-121) – originally reported as Improper Privilege Management
(CWE-269) because the overflow occurs in a SYSTEM service callable by
normal users.

Detailed Root Cause Analysis
--------------------------------------------------------------------
SetCachedCredentials converts three caller-supplied ANSI strings
(username, domain and password) into Unicode using
RtlAnsiStringToUnicodeString().  Prior to the patch the destination
buffers were defined as single-byte stack variables:

  char v21;   // username
  char v22;   // domain
  char v23;   // password

Immediately before the conversion the code sets
UNICODE_STRING.MaximumLength to twice the caller-supplied length plus
the UTF-16 terminator, but still points Buffer to the 1-byte local
variable:

  v16.MaximumLength = 2 * (inputLen + 1);
  v16.Buffer        = (PWSTR)&v21;   // size = 1 byte !
  RtlAnsiStringToUnicodeString(&v16,&AnsiName,FALSE);

Because MaximumLength is far larger than the actual allocation,
RtlAnsiStringToUnicodeString blindly writes the converted string and
terminator well past the end of the stack variable, corrupting the
stack frame (saved RIP, frame pointer, locals, SEH chain, etc.).  The
same pattern is repeated for v22 and v23.

The function executes inside the Remote Access Connection Manager
(rasman) service, running as LocalSystem.  Any authenticated user can
reach this code path by calling RasSetCredentials or any higher-level
API that stores cached dial-up/VPN credentials.  A crafted long string
(over 1 byte) therefore lets the attacker overwrite the stack and gain
code execution in the SYSTEM context.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable code (before patch)
char v21;               // 1 byte buffer
UNICODE_STRING v16;
...
v16.Length = 0;
v16.MaximumLength = 2 * (LOWORD(DestinationString[1]) + 1);
v16.Buffer = (PWSTR)&v21;              // <-- points to 1 byte
RtlAnsiStringToUnicodeString(&v16,     // overflows stack
                             (PCANSI_STRING)&DestinationString[1],
                             0);
```

```c
// fixed code (after patch)
wchar_t Source[257];    // 514 bytes (inclusive NUL)
UNICODE_STRING v19;
...
v19.Length = 0;
v19.MaximumLength = 2 * (LOWORD(DestinationString[1]) + 1);
v19.Buffer = Source;                   // correctly sized buffer
RtlAnsiStringToUnicodeString(&v19,
                             (PCANSI_STRING)&DestinationString[1],
                             0);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Low-privilege client calls RasSetCredentials() with an over-long
   user name/domain/password.
2. RPC reaches RasRpcSetCachedCredentials() inside rasman service.
3. RasRpcSetCachedCredentials invokes SetCachedCredentials().
4. Function allocates 1-byte stack buffers v21/v22/v23.
5. RtlAnsiStringToUnicodeString copies attacker data past buffer end.
6. Stack is corrupted; attacker controls return address; SYSTEM
   execution achieved.

Attack Vector
--------------------------------------------------------------------
Local, authenticated user.  Supply oversized credential strings (e.g.
>260 characters) through any Windows RAS credential API that ultimately
calls SetCachedCredentials.

Patch Description
--------------------------------------------------------------------
1. Replaced 1-byte destination buffers with appropriately sized static
   arrays:
      wchar_t Source[257];
      wchar_t v25[16];
      char    v26;
2. UNICODE_STRING.Buffer now points to these arrays, eliminating the
   overflow.
3. Added ValidateAccountDomain() call and feature-flag guard before
   actually calling LsaCallAuthenticationPackage().
4. Updated WPP tracing IDs (cosmetic).

Security Impact
--------------------------------------------------------------------
Before the patch any local user could execute arbitrary code in the
context of the Remote Access Connection Manager service (NT AUTHORITY\
SYSTEM), resulting in full privilege escalation.

Fix Effectiveness
--------------------------------------------------------------------
The destination buffers are now sized at least as large as the maximum
length computed for UNICODE_STRING, preventing overwriting of adjacent
stack memory.  No residual overflow paths were observed in the modified
function, so the patch appears effective.  Effectiveness outside of
this routine is unknown.

