{'confidence': 0.22, 'date': 1763417439.3351953, 'cve': 'CVE-2025-47969', 'file': 'win32kbase.sys', 'kb': 'KB5058411', 'patch_store_uid': '1556b61b-6e12-44f3-988f-2e5fbc78c3dd', 'change_count': 264}
--------------------------------------------------------------------
CVE-2025-47969 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
win32kbase.sys – kernel-mode Win32k privilege/permission helper
routines (IsPrivileged, HasTcbPrivilege, *Screen/Surface*AccessCheck,
SetProcessType, UIPrivilegeIsolation::CheckAccessEx, xxxInitProcessInfo
and callers).

Vulnerability Class
--------------------------------------------------------------------
Improper access-control / privilege–check bypass (logical flaw).

Detailed Root Cause Analysis
--------------------------------------------------------------------
The core helper that decides whether the caller owns a required
privilege is IsPrivileged().  In the vulnerable build the routine
contained a feature-gated fast path:

  if ( Feature_IsEnabled() )
      return IsPrivilegedEx( PsGetCurrentProcess(), Required );

PsGetCurrentProcess() returns the KPROCESS object representing the
*process* token only; it deliberately ignores any client/thread
impersonation token, restricted token or S4U logon token which may be
active on the current thread.  Consequently, if the process token
carries the privilege (e.g. SeTcbPrivilege) but the *thread* token does
not, SePrivilegeCheck should fail – yet the above shortcut returned
success.  SeCaptureSubjectContext / SeLockSubjectContext were also
skipped, so auditing and mandatory policy were never evaluated.

Whenever the internal feature flag
  Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage_N
resolved to TRUE, every call site that ended up in IsPrivileged() –
including HasTcbPrivilege(), UserSurfaceAccessCheck(),
UserScreenAccessCheck(), SetProcessType(), xxxInitProcessInfo() and
UIPrivilegeIsolation::CheckAccessEx() – silently accepted an
unauthorised caller.

That loophole allowed a normal local process (or even a low integrity
AppContainer if running inside the affected feature configuration) to
pass tests that were expected to be guarded by SeTcbPrivilege and
related high-integrity checks, and thus to read or influence protected
session/window state, disclosing information intended only for SYSTEM
context.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// win32kbase!IsPrivileged  (vulnerable)
if ( (unsigned int)Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage_9() )
{
    CurrentProcess = (struct _KPROCESS *)PsGetCurrentProcess();
    return IsPrivilegedEx(CurrentProcess, RequiredPrivileges);
}
// … normal SePrivilegeCheck path never reached when feature on.
```

```c
// win32kbase!IsPrivileged  (patched)
memset(&SubjectContext, 0, sizeof(SubjectContext));
SeCaptureSubjectContext(&SubjectContext);
SeLockSubjectContext(&SubjectContext);
v2 = SePrivilegeCheck(RequiredPrivileges, &SubjectContext, 1);
// no more feature-dependent shortcut
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Unprivileged user mode → win32k syscall that eventually calls
HasTcbPrivilege() → IsPrivileged() → (feature enabled) shortcut uses
process token → privilege check erroneously succeeds → protected data
returned to caller (e.g. through UserSurfaceAccessCheck → Shared surface
handles, or xxxInitProcessInfo leaking integrity/UIAccess state).

Attack Vector
--------------------------------------------------------------------
Local authorised user executes crafted code on the same host while the
internal *H2E_WPA3SAE* feature bit is set (device class / A/B flight
configuration).  By invoking any win32k API that relies on the affected
helper, the user gains read access to otherwise restricted GUI/session
information that belongs to higher-privilege principals.

Patch Description
--------------------------------------------------------------------
1. Removed the entire feature-dependent fast path from IsPrivileged().
   The function now always captures and validates the full security
   subject context (thread, token, impersonation) via SeCaptureSubject-
   Context / SePrivilegeCheck.
2. HasTcbPrivilege() changed: when the feature is *on* it now passes the
   current KPROCESS explicitly to IsPrivilegedEx(), but because the fast
   path in IsPrivileged() is gone the earlier bypass no longer exists.
3. Multiple higher-level helpers (UserSurfaceAccessCheck,
   UserScreenAccessCheck, UIPrivilegeIsolation::CheckAccessEx,
   SetProcessType, xxxInitProcessInfo) were refactored to rely on the
   corrected privilege evaluation and to drop redundant shortcuts.
   Audit/trace instrumentation was also updated.

Security Impact
--------------------------------------------------------------------
Prior to the fix, a non-privileged local attacker could pass SeTcb-
Privilege (and related) checks, obtaining GUI session details and other
protected information belonging to SYSTEM or higher-integrity
processes.  The issue therefore constitutes an Information Disclosure
vulnerability (CWE-200) with a potential privilege escalation follow-up
if the leaked data is further abused.

Fix Effectiveness
--------------------------------------------------------------------
The shortcut that ignored thread impersonation has been completely
removed, and all callers now funnel through the standard SePrivilege-
Check machinery.  No alternative path that still uses the old logic is
visible in the diff, so the patch is technically sound and should fully
mitigate the bypass.
