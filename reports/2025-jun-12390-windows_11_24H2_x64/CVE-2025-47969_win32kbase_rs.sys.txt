{'cve': 'CVE-2025-47969', 'confidence': 0.18, 'date': 1763417257.5230262, 'kb': 'KB5058411', 'file': 'win32kbase_rs.sys', 'patch_store_uid': '28ec5c4d-9ef9-41ef-84f9-5ba25976b62c', 'change_count': 3}
--------------------------------------------------------------------
CVE-2025-47969 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
win32kbase_rs.sys – Rust-based GDI region code (RegionCore) handling
scan-line uploads and flood-fill bounding-box generation.


Vulnerability Class
--------------------------------------------------------------------
Out-of-bounds read / kernel information disclosure (CWE-200).


Detailed Root Cause Analysis
--------------------------------------------------------------------
RegionCore receives region data from user-mode through two entry
points that end up in Rust functions translated to native code:

  1. RegionCore::upload_for_floodfill(..)
  2. RegionCore::upload(..)
  3. RegionCore::insert_scanline(..) – internal helper

The user buffer (int *a2, length a3) is expected to contain at least
one Y coordinate and one (left,right) X pair – a minimum of 3 dwords.
In the vulnerable build the following held:

  • upload_for_floodfill() rejects buffers smaller than 2 dwords but
    still accepts a3 == 2 or a3 == 3 under some paths.
  • When a3 < 3, unsigned arithmetic (v8 = a3-3, later used as element
    count) under-flows, so insert_scanline() is invoked with an element
    count that is either zero or a huge 64-bit value.
  • insert_scanline() trusts this count, walks past the caller supplied
    array and reads arbitrary kernel memory while trying to splice the
    scan data into the region’s internal Vec<dword>.

Even for larger, but malformed, buffers the old code did not maintain a
valid bounding box; *a1+28 (left) and +36 (right) could be left
un-initialised and later copied to user space by GDI queries, leaking
stack/heap words previously occupying those fields.

Because the whole logic sits in win32k, the attacker only needs the
ability to call GDI region APIs from a local session – no additional
privilege is required.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// upload_for_floodfill – vulnerable cut-down version
if (a3 < 2)
    panic_bounds_check(...);
// a3 == 2 still reaches here
v7 = a2[1];
if (v7 + 1 == a2[2] && (v8 = a3-3, 2 * *a2 == v8))
    return insert_scanline(a1, v7, a2+3, v8, ...);
```

```c
// patched
if (FeatureFlagEnabled() && a3 < 3)
    return ERROR_INVALID_PARAMETER;
...
return insert_scanline(a1, v9, (int)a2 + 12, v11, ...);
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-mode → NtGdiCombineRgn/ExtFloodFill →
 gdi_rust::region::from_path_mut() → RegionCore_set_from_path() →
  RegionCore::upload_for_floodfill() → insert_scanline()

A crafted path buffer with fewer than three integers, or with
inconsistent left/right counts, passes the old checks, causing
insert_scanline() to walk off the end of the array and disclose kernel
memory.


Attack Vector
--------------------------------------------------------------------
Local, from user space.  Any process that can call win32k region APIs
can feed a malformed scan buffer to win32kbase_rs.sys and obtain kernel
memory bytes via subsequent GDI queries or by examining the side
channel the read data creates.


Patch Description
--------------------------------------------------------------------
1. Added feature-gated length check in upload_for_floodfill():
   • If the Win32kRSFloodFillBoundingBox feature is enabled and a3<3,
     immediately return ERROR_INVALID_PARAMETER (87).
2. upload(): added an early panic for a3<2 and pervasive range checks.
   Introduced logic to track min/max X while building the region; these
   fields are only written once the buffer has been fully validated.
3. insert_scanline():
   • Massive restructuring; bounding-box updates are now executed only
     when the feature flag indicates the new code path or when a4>0.
   • All splice-in operations are preceded by explicit bounds checks;
     failure now returns 14 (STATUS_NO_MEMORY) instead of touching
     memory out of range.

Overall, the patch converts several implicit unsigned wraps into
explicit comparisons and refuses dangerous buffers earlier.


Security Impact
--------------------------------------------------------------------
An unprivileged local attacker could leak uninitialised kernel memory
or previous heap/stack contents from the win32kbase_rs.sys address
space.  Such information can be used to defeat KASLR, leak pointers, or
further other kernel-space exploits.


Fix Effectiveness
--------------------------------------------------------------------
The new guards guarantee that:

  • No code path reaches insert_scanline() with element count smaller
    than the required minimum.
  • All arithmetic that could previously under-flow is replaced with
    signed/size-checked logic.
  • Bounding-box fields are only written after successful validation.

The changes remove the immediate out-of-bounds reads confirmed in the
original diff; no remaining unchecked arithmetic on the user-supplied
length is observable, so the fix is considered effective.
