{'confidence': 0.28, 'patch_store_uid': 'c5fef1ce-956a-46a6-9de6-e1a3a9b1e657', 'file': 'wldp.dll', 'date': 1763415480.8774858, 'cve': 'CVE-2025-33069', 'kb': 'KB5060842', 'change_count': 78}
--------------------------------------------------------------------
CVE-2025-33069 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Lock-down Policy (WLDP) – signature trust helpers in
wldp.dll (WldpIs*SignatureTrusted*, NewProviderData, etc.).

Vulnerability Class
--------------------------------------------------------------------
Out-of-bounds write / structure size confusion that causes an
improper verification of cryptographic signatures (CWE-119 +
CWE-347).

Detailed Root Cause Analysis
--------------------------------------------------------------------
The WDAC run-time uses an internal structure named
CONFIG_CI_PROV_INFO_RESULT2 ("provider result") to receive the output
from WinVerifyTrust.  The first DWORD of the buffer is a size field
(cbStruct) that WinVerifyTrust echoes back before filling the rest of
the structure.

• Before the patch NewProviderData() allocated only 0xA8 (168) bytes
  and initialised cbStruct to 168.
• Starting with newer OS builds the provider needs 0xD0 (208) bytes;
  WinVerifyTrust therefore writes 208 bytes regardless of the smaller
  allocation.

All higher-level helpers (WldpIsDetachedSignatureTrusted,
WldpIsEmbedSignatureTrusted, WldpIsCatalogSignatureTrusted and the
vector wrapper WldpIsFileWithDetachedSignatureTrusted) passed this
undersized buffer directly to WinVerifyTrust.  When the latter wrote
the extra 0x28 bytes the memory directly following the allocation was
clobbered:

1. Stack locals such as v29/v30 in WldpIsDetachedSignatureTrusted were
   over-written.
2. Corrupted locals were later interpreted as policy flags and return
   codes, making untrusted files appear trusted.
3. Because the overflow happens in kernel address space (wldp.dll is
   loaded into every protected process) it may also lead to memory
   corruption and potential code execution.

In effect, the signature result is accepted without the mandatory
fields ever being verified – a direct security-feature bypass.

Structures/parameters involved
• CONFIG_CI_PROV_INFO_RESULT2 (old size 0xA8, new size 0xD0)
• cbStruct (offset 0)
• WinVerifyTrust(WTD_GENERIC_CERT_POLICY)
• Call stacks beginning at WldpIs*SignatureTrusted helpers.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// old – allocates too little (0xA8) and sets size to 168
_QWORD *__fastcall NewProviderData(_QWORD *a1) {
    _DWORD *p = LocalAlloc(0x40u, 0xA8ui64);
    if (p) { *p = 168; *a1 = p; }
}

// new – allocates correct size (0xD0) and sets size to 208
_QWORD *__fastcall NewLegacyProviderData(_QWORD *a1) {
    _DWORD *p = LocalAlloc(0x40u, 0xD0ui64);
    if (p) { *p = 208; *a1 = p; }
}

// old call-site (excerpt)
WinVerifyTrust(HWND_MESSAGE|0x2, &stru_1800420A8, &pWVTData);
// pWVTData points to 0xA8-byte buffer.

// new call-site (excerpt)
_OWORD v40[13];               // 13*16 = 0xD0 bytes
LODWORD(v40[0]) = 208;
WinVerifyTrust(HWND_MESSAGE|0x2, &stru_18004B658, &pWVTData);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User supplies a file with a detached/embedded/catalog signature.
2. WDAC calls WldpIsFileWithDetachedSignatureTrusted().
3. That invokes WldpIsDetachedSignatureTrusted() or its variants.
4. NewProviderData() allocates 0xA8 bytes and passes it to
   WinVerifyTrust().
5. WinVerifyTrust writes 0xD0 bytes – overflow.
6. Overwritten locals make the helper believe the signature is valid;
   caller receives STATUS_SUCCESS even for an invalid or malicious
   signature.

Attack Vector
--------------------------------------------------------------------
A local attacker places a file (script, PE, catalog) with a crafted
signature on the system and causes any WDAC-protected component to
perform a signature check.  No elevated privileges are needed because
the overflow occurs inside the signature-checking routine itself.

Patch Description
--------------------------------------------------------------------
1. Introduced NewLegacyProviderData() that allocates 0xD0 bytes and
   sets cbStruct to 208.
2. All WldpIs*SignatureTrusted helpers were rewritten to
   a. use an on-stack 0xD0-byte buffer when interacting with
      WinVerifyTrust;
   b. treat the result parameter as _OWORD[13] (208-byte) instead of a
      raw pointer;
   c. call WTConfigCiFreePrivateData() to zero/free the buffer.
3. GUIDs updated (stru_18004B658) to reference the correct provider
   action.
4. Added extensive memset() calls to wipe residual data.

Security Impact
--------------------------------------------------------------------
Prior to the patch a malicious file could pass WDAC signature checks,
allowing execution of code that should have been blocked (Security
Feature Bypass).  Because the bug is an out-of-bounds write in kernel
address space, it also opened the door for reliability issues and
potential privilege escalation via memory corruption.

Fix Effectiveness
--------------------------------------------------------------------
The new code allocates/initialises the full 0xD0-byte structure and
never hands an undersized buffer to WinVerifyTrust, eliminating the
overflow and restoring correct signature verification.  All call
sites were updated, and provider data is now zeroed after use,
mitigating information-leak vectors.  No residual paths using the old
0xA8 allocation were observed, so the fix appears complete.
