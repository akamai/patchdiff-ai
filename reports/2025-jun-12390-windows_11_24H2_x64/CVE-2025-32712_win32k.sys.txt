{'confidence': 0.26, 'patch_store_uid': 'ed1ea283-2bd8-4b7d-8cde-f996a3252e08', 'file': 'win32k.sys', 'date': 1763417324.8764412, 'cve': 'CVE-2025-32712', 'change_count': 3, 'kb': 'KB5060842'}
--------------------------------------------------------------------
CVE-2025-32712 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
win32k.sys  – ApiSet resolver code path (ApiSetResolveToHost, 
ApiSetResolveToHost_V7 and ApiSetpSearchForSectionIndex_V7).

Vulnerability Class
--------------------------------------------------------------------
Use-After-Free / stale-pointer dereference caused by 64-bit-to-32-bit 
pointer truncation (CWE-416).

Detailed Root Cause Analysis
--------------------------------------------------------------------
ApiSetResolveToHost receives a pointer (a1) that references an ApiSet
mapping header located in kernel virtual memory.  On x64 builds the
pointer is 64 bits.  In the pre-patch routine the following logic is
executed when the first byte of the header indicates schema version 7:

    if (*a1 == 7)
        return ApiSetResolveToHost_V7((_DWORD)a1, ...);

The cast to _DWORD truncates the upper 32 bits of the pointer before it
is forwarded to ApiSetResolveToHost_V7.  If the original allocation
resides above the 4 GB boundary (normal on modern systems) the truncated
value now points to an unrelated location in the lower address space –
often memory that has already been freed and possibly re-allocated for a
completely different purpose.  ApiSetResolveToHost_V7 then treats that
stale address as a live ApiSetV7 structure, dereferences multiple inner
pointers and finally writes a host-string descriptor into a caller
supplied buffer (a5).  All of those accesses operate on attacker
controlled memory, resulting in a classic use-after-free inside the
kernel.

Attacker influence
• The attacker controls where the ApiSet blob is allocated; by forcing a
  high address it guarantees pointer truncation.
• After the legitimate blob is freed, the attacker can reclaim the low
  4 GB address space with controlled data that masquerades as an ApiSet
  structure, steering subsequent kernel reads/writes.

Consequences
• Arbitrary kernel read/write through forged internal offsets.
• Elevation of privilege from an unprivileged local context to SYSTEM.

Patch changes
1. Function prototype changed to use a 64-bit parameter
   ( __int64 a1 ) and the call to ApiSetResolveToHost_V7 now passes the
   unmodified 64-bit value, eliminating truncation.
2. The original base pointer is kept in a local variable (v6) and is
   consistently used for all offset calculations, preventing
   mis-calculations when a nested V7 header is encountered.
3. Additional sanity for version-6-with-embedded-V7 headers was added.
4. ApiSetpSearchForSectionIndex_V7 was rewritten to use relative offsets
   that account for the 16-bit base stored in the ApiSet header and now
   relies on RtlCompareUnicodeStrings instead of a home-grown loop.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// --- pre-patch ---
if (*a1 == 7)
    return ApiSetResolveToHost_V7((_DWORD)a1, (_DWORD)a2, a3,
                                  (_DWORD)a4, a5); // 32-bit truncation

// --- fixed ---
if (*(_BYTE *)a1 == 7)
    return ApiSetResolveToHost_V7(a1, a2, a3, a4, (_OWORD *)a5); // full ptr
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User process causes win32k to load/construct an ApiSet mapping that
   resides above 0xFFFFFFFF.
2. Kernel enters ApiSetResolveToHost via CreatePerSessionWin32kCall.
3. *a1 == 7 branch taken –> pointer truncated -> ApiSetResolveToHost_V7.
4. ApiSetResolveToHost_V7 interprets attacker-controlled fake header at
   the truncated address and performs arbitrary memory operations.
5. Crafted data redirects execution / corrupts kernel state, yielding
   SYSTEM privileges.

Attack Vector
--------------------------------------------------------------------
Local authenticated attacker.  By manipulating per-session ApiSet
section allocation and heap reuse, the attacker positions a controlled
buffer at the truncated 32-bit address, then invokes a win32k API that
ultimately calls ApiSetResolveToHost.

Patch Description
--------------------------------------------------------------------
• Replaced all 32-bit casts with native 64-bit pointer handling.
• Added support for version-6 headers that embed a version-7 header
  (guards and correct offset adjustments).
• Re-implemented index search and string comparison routines to work
  with relative offsets and validated lengths.
• All internal pointer arithmetic now begins with the original base
  pointer, removing the possibility of stale or mis-aligned accesses.

Security Impact
--------------------------------------------------------------------
Before the patch a local attacker could trigger kernel use-after-free and
obtain arbitrary kernel read/write, resulting in elevation of privilege
(EoP) to SYSTEM.  Scope of impact: full compromise of the OS kernel.

Fix Effectiveness
--------------------------------------------------------------------
The fundamental issue – pointer truncation – has been removed, and every
code path now carries the intact 64-bit address.  Calculations that
formerly relied on a possibly shifted pointer now reference the stored
base, closing the use-after-free avenue. No residual truncations are
present in the modified code, so the fix is considered effective.
