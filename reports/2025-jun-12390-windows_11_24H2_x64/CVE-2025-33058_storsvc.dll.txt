{'cve': 'CVE-2025-33058', 'confidence': 0.32, 'patch_store_uid': 'e357b706-c599-45dd-b928-3b319eb9aed7', 'date': 1763416878.1161478, 'kb': 'KB5060842', 'file': 'storsvc.dll', 'change_count': 17}
--------------------------------------------------------------------
CVE-2025-33058 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Storage Management Provider (storsvc.dll) 
function ScValidateProvisioning.

Vulnerability Class
--------------------------------------------------------------------
CWE-125: Out-of-bounds Read / Information Disclosure.

Detailed Root Cause Analysis
--------------------------------------------------------------------
ScValidateProvisioning is the central parameter-validation routine for
user-supplied SP_PROVISIONING_INFO structures.

The structure layout (in 32-bit addressable units) that is validated in
this function is:
  +0  DWORD ProvisioningType          (values 0,1,2)
  +8  QWORD SizeOrLBACount            (used later by storage stack)
  +16 DWORD StructureVersion         (must be <=5)
  +20 DWORD MinTier                  (index 5 in code)
  +24 DWORD OptTier                  (index 6)
  +28 DWORD MaxTier                  (index 7)

Only the first two tier fields were range checked in the original
implementation:
  * MinTier  had to be in [1,5].
  * OptTier  had to be in [1,5] and >= MinTier.

MaxTier (field 7) was **never validated**.  If the caller supplied a
value larger than 5 the function still returned STATUS_SUCCESS (0),
although all three tier fields are later used as indexes into a fixed
length (5-element) dispatch table.  When MaxTier >= 6 subsequent
processing reads beyond the bounds of that table, leaking kernel stack
or pool bytes to user space via status buffers or WMI output.

The defective logic was reachable only when:
  * StructureVersion <= 5, and
  * ProvisioningType is 0 or 2, and
  * SizeOrLBACount passes the alignment tests shown in the listing.
All of those conditions can be met by an ordinary local user because
Storage Spaces management APIs forward the raw caller-supplied buffer
to storsvc.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
/* Original (vulnerable) code */
if (*((int *)a1 + 4) <= 5) {
    v7 = *((_DWORD *)a1 + 5);       // MinTier  (checked)
    if (v7 - 1 > 4)
        return ERROR;
    v8 = *((_DWORD *)a1 + 6);       // OptTier  (checked)
    if (v8 - 1 > 4 || v7 > v8)
        return ERROR;
    // *** field +28 (MaxTier) is NOT validated ***
}
```
```c
/* Patched code */
if (*((int *)a1 + 4) <= 5) {
    if ((unsigned int)(*((_DWORD *)a1 + 5) - 1) > 4)
        return ERROR;

    if (Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage()) {
        v8 = *((_DWORD *)a1 + 6);
        if (v8) {
            if (v8 - 1 > 4 || *((_DWORD *)a1 + 5) > v8 ||
                v8 >= *((_DWORD *)a1 + 7))
                return ERROR;
        }
    }
    v9 = *((_DWORD *)a1 + 7);       // MaxTier  (now validated)
    if (v9 - 1 > 4 || *((_DWORD *)a1 + 5) > v9)
        return ERROR;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User process calls a storage-management API (e.g., WMI
   MSFT_StoragePool.PutInstance or IOCTL_STORAGE_MANAGE_DATA).
2. RPC/WMI marshals an SP_PROVISIONING_INFO blob and passes it to
   storsvc in the LocalService context.
3. storsvc calls ScValidateProvisioning(..) with the attacker-controlled
   buffer.
4. Field +28 (MaxTier) is larger than 5.  Original code returns success.
5. Later code indexes a 5-element table with MaxTier, causing an
   out-of-bounds read.
6. Kernel data residing next to the table is copied back to user space,
   disclosing memory contents.

Attack Vector
--------------------------------------------------------------------
Local, authenticated.  The attacker only needs the ability to issue
Storage Management Provider calls (granted to regular users by default
through WMI/RPC).  No elevated privileges are required to reach the
vulnerable code path.

Patch Description
--------------------------------------------------------------------
The patch augments the validation logic:
1. Adds explicit range checks for the third tier field (index 7).
   Acceptable values are now strictly 1..5.
2. Ensures that MinTier <= MaxTier and, when a feature flag is active,
   that OptTier < MaxTier.
3. Uses unsigned comparisons throughout to avoid sign issues.
4. Keeps earlier alignment and version checks intact.

Security Impact
--------------------------------------------------------------------
Prior to the fix a crafted SP_PROVISIONING_INFO could bypass validation
and force storsvc to read beyond a 5-element internal table.  The leaked
bytes can include uninitialized kernel stack or pool memory, enabling an
attacker to infer kernel layout, bypass KASLR, or harvest sensitive
information such as pointer values.  The flaw does not allow direct
code execution but constitutes a high-quality information disclosure
primitive inside the kernel.

Fix Effectiveness
--------------------------------------------------------------------
The additional checks block every path where MaxTier is out of range or
not monotonically ordered with the previous fields, exactly preventing
the original condition that led to table over-indexing.  Because the
final unconditional validation of field +28 is executed regardless of
feature flag state, the OOB read can no longer be triggered.  No
automatic bypass is apparent; therefore the patch is effective.
