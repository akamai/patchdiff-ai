{'file': 'clfs.sys', 'cve': 'CVE-2025-32713', 'kb': 'KB5060842', 'date': 1751957929.8085032, 'change_count': 2, 'confidence': 0.22, 'patch_store_uid': '25426e49-c7fc-4032-9c22-9634c901b910'}
--------------------------------------------------------------------
CVE-2025-32713 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Common Log File System Driver (clfs.sys) – routine
CClfsLogFcbPhysical::ReadLogBlock()


Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow  (CWE-122)


Detailed Root Cause Analysis
--------------------------------------------------------------------
ReadLogBlock() copies data from a log container into a caller supplied
_CLFS_READ_BUFFER (parameter a5).  The caller also supplies the maximum
buffer size in a6 and optional control flags in a4/a8.

1.  The function computes the number of bytes that will be copied in the
    local variable v27 (renamed v28 in the patched file).  If the call
    is the first iteration of a physical read ( (a4 & 1) != 0  and
    *a10 == 0 ) the original code unconditionally rounds this length up
    to the CLFS log-page size stored in v48:

        v27 = v48;              // page size (typically 0x1000)

    This assignment is made without verifying that v27 is
    (a)  a multiple of the underlying sector size, or
    (b)  smaller than or equal to the caller supplied buffer length a6.

2.  Later, two different paths move v27 bytes into the user buffer:
      •  CClfsLogFcbPhysical::ReadLog(..., v27 >> 9) – async path
      •  CcCopyRead() / memset()                          – cache path

    Because v27 may now be larger than a6, both paths write past the end
    of the heap allocation returned by _CLFS_READ_BUFFER::GetAddress(),
    corrupting pool memory in the kernel.  The overrun can be triggered
    from user mode because both the buffer size (a6) and the control
    flags (a4 / a8) are caller-controlled parameters that travel through
    the public CLFS API (e.g. ClfsReadLogRecord()).

3.  In addition, nothing ensured that v27 was sector-aligned.  A value
    that is not a multiple of the physical sector size is later divided
    by 512 ( v27 >> 9 ) when building the request for ReadLog(), causing
    a second length mismatch between what the disk read returns and what
    is later copied/memset – another source of overflow.

The combined lack of size and alignment validation therefore allows a
local attacker to overflow a kernel heap buffer and execute arbitrary
code in kernel context.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// pre-patch (first iteration, flag 0x1 set)
if ( (v73 & 1) != 0 )            // physical read flag
{
    if ( !*a10 )                 // first chunk
    {
        v27 = v48;               // force page size (0x1000)
        v47 = v48;
        v28 = 1;
    }
}
// later – copy v27 bytes into user buffer v51
CcCopyRead(a2, &FileOffset, v27, 1u, v51, &IoStatus);
```

```c
// post-patch – new validation
if ( Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage_4() &&
     (v28 % v48) )               // not page aligned?
{
    v12 = STATUS_INVALID_PARAMETER;
    goto fail;
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-mode                NtCreateFile -> CreateLogFile() …
CLFS API                 ClfsReadLogRecord( … small_buffer … )
clfs.sys                 CClfsReadIoctl() -> ReadLogBlock()
ReadLogBlock()           length rounded up to v48 (0x1000)
                         CcCopyRead/ReadLog overwrite a6-byte heap
                         buffer => overflow


Attack Vector
--------------------------------------------------------------------
A local, authenticated attacker opens or creates a CLFS log file and
issues a CLFS read request with:
  • buffer length (a6) < log page size, and
  • CLFS_READ_FLAG_PHYSICAL (bit 0) set.
No special privileges are required beyond the ability to open the file.


Patch Description
--------------------------------------------------------------------
The update inserts multiple defensive checks:
1.  Reject any requested length that is not an integer multiple of the
    log page size:
        if (FeatureEnabled && len % PageSize) return STATUS_INVALID_PARAMETER;
2.  During the cached read path, additionally verify that
        FileOffset + len <= LogFileSize   and
        RemainingBuffer >= len
    before performing CcCopyRead().
3.  Early-exit paths were re-structured so that failures unwind with the
    resource lock always released.
No changes are made to memory allocations; the fix is purely validation
logic that prevents inconsistent length calculations.


Security Impact
--------------------------------------------------------------------
Prior to the patch an attacker could cause a controlled heap based
overflow inside clfs.sys, allowing escalation from user to kernel
privileges.  Successful exploitation yields arbitrary code execution in
ring-0, compromising the entire operating system.


Fix Effectiveness
--------------------------------------------------------------------
The added alignment and bounds checks block all paths that previously
produced an over-length copy.  Because the size is now validated before
any I/O, the vulnerable memcpy/CcCopyRead cannot be reached with an
oversized value.  No bypass is apparent in the modified logic, making
the fix effective for the identified issue.
