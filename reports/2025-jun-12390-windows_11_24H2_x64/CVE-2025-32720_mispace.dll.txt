{'change_count': 67, 'date': 1763415573.60058, 'patch_store_uid': 'fc8f3bd4-dcdd-48c9-ad3f-47132b7cc84f', 'file': 'mispace.dll', 'confidence': 0.25, 'kb': 'KB5060842', 'cve': 'CVE-2025-32720'}
--------------------------------------------------------------------
CVE-2025-32720 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Storage Management Provider (mispace.dll) – several handler
routines that parse user-supplied parameter buffers, most notably
CPmEnumerationFilter::Extract and the high-level PmcControlDispatch
IOCTL dispatcher.


Vulnerability Class
--------------------------------------------------------------------
Out-of-Bounds Read / Information Disclosure (CWE-125)


Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  Incoming control requests (IOCTL-like Storage Mgmt “control codes”)
    reach PmcControlDispatch().  The routine expects an input buffer of
    at least 0x30 (48) bytes that begins with an
    _SP_CREATEVOLUME_PARAMS / enumeration-filter header.

2.  PmcControlDispatch() blindly forwards the caller-supplied buffer
    and its declared total length (a2) to
    CPmEnumerationFilter::Extract().  No preliminary size or offset
    validation is carried out (only a2 >= 0x30 is enforced).

3.  CPmEnumerationFilter::Extract() copies the first 0x30-byte header
    into a local heap buffer (v12 / v14) and immediately trusts the
    6th DWORD of that header (v12[6]) as an *offset* to a trailing
    UTF-16 string inside the original caller buffer.

4.  In the unpatched version the function only verifies that
    header.Size (v12[2]) <= 0x30.  It never checks that
      •  the string offset is at least 0x2C (end of the header),
      •  the offset is within the total caller buffer (a2), or
      •  that offset + terminating NUL is still in bounds.

5.  PmCopyStringFromBufferOffset() is then invoked with the unchecked
    offset.  If the attacker supplies an offset that lies *before* the
    start of the user buffer or far *beyond* its end, the copy helper
    reads arbitrary kernel memory.  Because the Storage Management
    Provider returns that copied string in its reply, sensitive kernel
    data are disclosed to the caller.

6.  Numerous higher-level verbs processed by PmcControlDispatch()
    (e.g. Pmc_Disk_* , Pmc_Volume_* etc.) rely on the same filter
    extraction, so the flaw is reachable through many control codes by
    an authenticated local user that has access to the WMI / WSP
    provider interface.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
if ( a2 >= 0x30 ) {
    v12 = operator new[](0x30);
    ...                    // copy header
    v15 = v12[6];          // **untrusted offset**
    if ( !v15 || (v8 = PmCopyStringFromBufferOffset(a3,a2,v15,this)) )
        ...                // string copied without bound check
}

// after (simplified)
if ( a2 < 0x30 ) error;
v12 = new char[0x30];
...
if ( v12[2] > 0x30 ) error;            // header size check
if ( v12[6] && (v12[6] < 0x2C ||       // offset >= header
                v12[6] > v12[3] ||     // offset <= total size
                !offset_fits_string) ) // StringCbLengthW guard
    error;
status = PmCopyStringFromBufferOffset(...);
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
User-controlled buffer
  ↓
PmcControlDispatch(..., a3, a4, ...)
  ↓  (passes a3/a4 to parser)
CPmEnumerationFilter::Extract(buf,len,...)
  ↓
PmCopyStringFromBufferOffset(buf,len, unchecked_offset)
  ↓
Kernel reads outside the provided buffer → information disclosure
  ↓
Leaked data returned to caller in output buffer prepared by
PmcControlDispatch()


Attack Vector
--------------------------------------------------------------------
A local, authenticated attacker sends a crafted Storage Management
Provider control request (e.g. via WMI / WinRM or the IOCTL interface)
containing:
 • Declared input length ≥ 0x30
 • Header with Size ≤ 0x30
 • String offset field (at +0x18) pointing outside the supplied buffer
The provider parses the request in kernel context and copies memory
from the calculated (out-of-bounds) address into its response, which is
then returned to user land, disclosing arbitrary kernel memory.


Patch Description
--------------------------------------------------------------------
The update introduces comprehensive defensive validation across all
parsing routines:
1.  CPmEnumerationFilter::Extract()
    • Added checks that the total buffer length is at least 0x2C.
    • Verifies that the string offset is   – not zero,   – ≥ 0x2C,   –
      ≤ header.TotalSize, and   – within caller-supplied length.
    • Guarded by a feature-flag but defaults to enabled.
2.  Numerous caller functions (PmcControlDispatch, Get*Params, *Write*
   etc.) now perform length/offset sanity checks before invoking the
   extractor.
3.  StringCbLengthW() re-implemented to take explicit cbMax and return
   proper error codes, preventing over-reads when determining string
   length.
4.  Error paths now set ERROR_INVALID_PARAMETER (0x57) and abort on bad
   input, preventing the out-of-bounds read.


Security Impact
--------------------------------------------------------------------
Prior to the fix an attacker with access to Storage Management Provider
APIs could obtain arbitrary kernel memory contents, potentially
including sensitive data or addresses useful for further exploitation
(ASLR bypass).  The flaw therefore constitutes an Information
Disclosure vulnerability (CWE-125) rated as CVE-2025-32720.


Fix Effectiveness
--------------------------------------------------------------------
The added length & offset checks, combined with the hardened
StringCbLengthW implementation, ensure that any offset used to access
strings is guaranteed to reside within the caller-supplied buffer.  Bad
inputs now fail with ERROR_INVALID_PARAMETER before any memory access
occurs.  Consequently the out-of-bounds read avenue is effectively
closed, preventing further information disclosure.
