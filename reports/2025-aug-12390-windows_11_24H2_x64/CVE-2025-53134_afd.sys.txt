{'kb': 'KB5063878', 'confidence': 0.29, 'patch_store_uid': '230e7c66-244b-4041-b166-2157fff153a1', 'change_count': 8, 'file': 'afd.sys', 'cve': 'CVE-2025-53134', 'date': 1755086279.5741298}
--------------------------------------------------------------------
CVE-2025-53134 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Ancillary Function Driver for WinSock (afd.sys)


Vulnerability Class
--------------------------------------------------------------------
CWE-367: Time-of-check Time-of-use (TOCTOU) race condition leading to
privilege-escalation / information-disclosure from kernel memory.


Detailed Root Cause Analysis
--------------------------------------------------------------------
Two companion routines manage the per-socket "connect data" that can be
returned to user mode through the WSASendMsg path.

1.  AfdSetConnectData() (ioctl 0x1202B, etc.)
    • Allocates or reallocates an internal buffer pointed to by the
      AFD_ENDPOINT field at offset 0xA8 ( *v19 ).
    • Updates two fields under the endpoint spin-lock (+0x38 / +0x40):
        0xA4  -> length (DWORD)   [ *(Pool2+0x8) ]
        0xA8  -> buffer pointer   [ *(Pool2)    ]
    • Releases the lock and, if a larger buffer is needed, frees the old
      pool memory after the update.

2.  AfdExtractAfdSendMsgInfo() (reached by WSASendMsg IRPs)
    • If the caller supplies no user data ( Src == 0 ) the routine falls
      back to the endpoint connect data:
          Size = *(Endp + 0xA4);      // unchecked read
          Ptr  = *(Endp + 0xA8);      // unchecked read
      No lock is held while these values are read and later used.
    • The function then executes
          memmove(Dst, Ptr, Size);
      where Dst is inside a freshly allocated
      AFDSENDMSG_TRACKER structure.

Because there is no synchronisation between the read in
AfdExtractAfdSendMsgInfo() and a concurrent write in
AfdSetConnectData(), a window exists where:

  a. Thread-1 (SetConnectData) replaces the buffer pointer with a new
     allocation and frees the old pool block after releasing the lock;
  b. Thread-2 (SendMsg) reads Size/Ptr while no lock is held and later
     copies from the stale/freed address.

Results:
• Kernel out-of-bounds read → disclosure of freed or uninitialised
  kernel memory to user mode.
• In certain pool reuse scenarios the copy can cross allocation
  boundaries and corrupt adjacent kernel objects → potential elevation
  of privilege.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// AfdExtractAfdSendMsgInfo (before)
if (*... & 0x100) == 0 && ... && !Src  || (!Src && v25)
{
    Size = *(DWORD *)(Endp + 0xA4);   // unchecked
    ...
    memmove(*(void **)(Tracker + 72), *(void **)(Endp + 0xA8), Size);
}
```
```c
// AfdSetConnectData (before)
*Pool2 = ExAllocatePool2(..., newLen, TAG);
if (oldBuf) ExFreePoolWithTag(oldBuf, TAG);
// lock was already released -> race window open
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker thread A:
   • issues IOCTL_AFD_SET_CONNECT_DATA repeatedly with alternating
     sizes, forcing reallocation and free of the internal connect-data
     buffer.
2. Parallel attacker thread B:
   • calls WSASendMsg with no application data so that
     AfdExtractAfdSendMsgInfo() copies the internal buffer.
3. With precise timing, thread B dereferences a pointer that has just
   been freed or replaced by thread A, leading to an arbitrary kernel
   read.


Attack Vector
--------------------------------------------------------------------
Local, authenticated user with the ability to open an AFD socket handle
and issue the documented AFD_SET_CONNECT_DATA ioctl plus WSASendMsg.
No special privileges are required beyond owning the socket.


Patch Description
--------------------------------------------------------------------
1. In AfdExtractAfdSendMsgInfo():
   • Introduces acquisition of the endpoint spin-lock
     (KeAcquireInStackQueuedSpinLock(Endp+0x38)).
   • Re-reads and *validates* that Size equals Endp->ConnectDataLength
     while the lock is still held; returns STATUS_INVALID_PARAMETER if
     the value changes or the pointer is NULL.
   • Performs the memmove while still holding (or after safely releasing)
     the lock, eliminating the TOCTOU window.
   • Adds fallback to old behaviour behind a feature flag so the change
     can be disabled at runtime.
   • On error, frees the partially built tracker with tag 'AfdM'.

2. In AfdSetConnectData():
   • Extends the lock coverage so that the old buffer is freed *before*
     the pointer/length fields are updated, preventing observers from
     seeing an inconsistent state.
   • Adds an extra flag check (0x10000) to deny updates while a FIN is
     pending.
   • Harmonises small-buffer handling and tightens user-pointer probing.


Security Impact
--------------------------------------------------------------------
Prior to the patch an unprivileged local attacker could execute a race
leading to:
• Disclosure of freed kernel memory (information leak);
• Pool corruption with attacker-controlled data, which can be leveraged
  to achieve code execution in kernel mode, resulting in a full local
  privilege escalation.


Fix Effectiveness
--------------------------------------------------------------------
The added spin-lock around both the producer (SetConnectData) and the
consumer (ExtractAfdSendMsgInfo) eliminates the inconsistent view of
pointer/length, closing the TOCTOU gap. Additional validation (non-zero
size, non-NULL pointer) blocks invalid state transitions. The fix fully
addresses the identified race condition; no bypass is evident from the
patch.

