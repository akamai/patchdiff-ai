{'date': 1755089417.4784608, 'change_count': 11, 'patch_store_uid': '2d4fad2a-6929-40c4-8e2b-8117e27bb0cc', 'confidence': 0.07, 'file': 'mqqm.dll', 'cve': 'CVE-2025-50177', 'kb': 'KB5063878'}
--------------------------------------------------------------------
CVE-2025-50177 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Message Queuing (MSMQ) run-time, mqqm.dll – mainly the
ordering/transport layer (CMessageTransport) and the RPC / transaction
context-handle helpers (QMDo*/RPC_INT_*/PCTX_* functions).

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use After Free combined with CWE-362: Race Condition.

Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  Outgoing packet completion is handled in
    CMessageTransport::GetPacketForSendingSucceeded().  The routine
    decides whether the freshly sent packet can be delivered or must be
    held until the correct sequence order is met.

2.  Original logic:
      if( !IsOrderNeeded(pkt) || PreSendProcess(...) == 1 ) {
          …deliver immediately…
      } else {
          …hold…
      }

    •  When ordering *is* required and PreSendProcess() reports the
       packet is *not* ready (return !=1), the first condition still
       becomes true because of the leading logical NOT.  The function
       therefore delivers the packet even though the sequencing engine
       has rejected it.

    •  During that fast-path the code removes the packet from the hash
       map, releases internal references (CReference::Release), and may
       enter outgoing callbacks.  Later, when the sequencing engine
       resumes processing, it accesses the same transport/packet
       structures that were already freed – classic use-after-free.

3.  Because MSMQ networking is asynchronous, an attacker can race the
    two paths by sending specially crafted, out-of-order messages and
    forcing the completion routine to trigger while the sequencing state
    is inconsistent.  The freed memory is still reachable from other
    worker threads, enabling remote code execution within the MSMQ
    service.

4.  Additional, similar lifetime issues existed in the RPC context
    rundown helpers (PCTX_OPENREMOTE_HANDLE_TYPE_rundown,
    RPC_INT_XACT_HANDLE_rundown) and the user-mode transaction helpers
    QMDoAbortTransaction/QMDoCommitTransaction.  Those functions trusted
    attacker-controlled context handles and acted on possibly already
    freed CTransaction objects.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Old (simplified)
DeliveryPacket = CreateDeliveryPacket(this);
if (!IsOrderNeeded(DeliveryPacket) ||
    COutSeqHash::PreSendProcess(hash, DeliveryPacket, 0) == 1)
{
    // deliver – may free transport
} else {
    SafePutPacketOnHold(this, DeliveryPacket);
}

// New
if (IsOrderNeeded(DeliveryPacket) &&
    COutSeqHash::PreSendProcess(hash, DeliveryPacket, 0) != 1)
{
    SafePutPacketOnHold(this, DeliveryPacket);
    GetNextEntry(this);
    …
    return;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Remote attacker sends crafted MSMQ packets with manipulated sequence
   numbers.
2. Worker thread completes the send -> GetPacketForSendingSucceeded()
   executes.
3. Old logic mis-classifies the packet as eligible for delivery.
4. Packet is delivered, internal refcount for CMessageTransport and
   CQmPacket goes to zero, memory freed.
5. Sequencing engine or another worker thread later dereferences the
   freed object -> use-after-free, leading to arbitrary code execution.

Attack Vector
--------------------------------------------------------------------
Unauthenticated network attacker sends a stream of MSMQ messages with
out-of-order sequence IDs to any host with the MSMQ service enabled.
No valid credentials are required; the service processes the messages
before authentication.

Patch Description
--------------------------------------------------------------------
1. Corrected the boolean expression: delivery is now allowed *only* when
   either ordering is not needed, or PreSendProcess() approved the
   packet.
2. Added early return after the SafePutPacketOnHold() path to guarantee
   no further use of the packet/transport once it was queued.
3. Introduced feature-guarded helpers:
      • IsDeliveryAllowed()
      • PrepareAndDeliverPacket()
      • PrepareDelivery()
   providing additional state checks before delivery.
4. Wrapped all *rundown* and *transaction* helper functions with
   CResourceManager::ValidateTransaction() to detect stale or attacker
   supplied handles before dereferencing.
5. Re-instrumented WPP traces to use new GUIDs/IDs but that is cosmetic.

Security Impact
--------------------------------------------------------------------
Prior to the patch, remote attackers could reliably trigger a
use-after-free of CMessageTransport/CQmPacket structures, giving them the
ability to corrupt heap metadata and execute arbitrary code in the
context of the MSMQ service (runs as NETWORK SERVICE by default).  The
issue is remotely exploitable and does not require authentication.

Fix Effectiveness
--------------------------------------------------------------------
The inverted conditional removes the logic flaw that led to premature
packet delivery.  Added guard code, early returns, and transaction
validation prevent further dereference of stale objects.  No remaining
code paths that deliver a packet after PreSendProcess() rejection were
observed in the patched version, suggesting the fix is effective as long
as all callers use the updated routines.
