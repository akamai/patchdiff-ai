{'confidence': 0.26, 'date': 1755089661.059755, 'cve': 'CVE-2025-50168', 'kb': 'KB5063878', 'file': 'win32kfull.sys', 'change_count': 91, 'patch_store_uid': '54c644a3-337f-48f9-839a-fd90425a8708'}
--------------------------------------------------------------------
CVE-2025-50168 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
win32kfull.sys  (kernel-mode GDI).  Affected helpers are:
  • PFTOBJ::HFFToPPFF
  • PUBLIC_PFTOBJ::pPFFGet
  • vLinkEudcPFEsWorker
All three iterate internal Persistent Font File (PFF) hash buckets
and linked lists that store font-file information.

Vulnerability Class
--------------------------------------------------------------------
Type confusion / use-after-free that can lead to heap out-of-bounds
access (CWE-843, CWE-122).

Detailed Root Cause Analysis
--------------------------------------------------------------------
PFF objects are kept in per-process PFTOBJ hash buckets.  Every bucket
contains a singly-linked list whose nodes have the layout
    +0x00   FLINK  (next PFF*)
    +0x20   pwszName (const WCHAR*)
    +0x28   cbName   (ULONG)
    +0x30   DesignVector pointer
    +0x34   cbDesignVector
    +0x34+  misc fields
    +0x58   HFF handle copy  (index 11)
    +0x34   State flags (index 13)

Before the patch the three routines walked these lists exactly as
shown below:
  while (pCurrent) {
      if (wanted == pCurrent->Hff) return pCurrent;
      pCurrent = pCurrent->Flink;
  }

No attempt was made to verify that the pointer really points to a live
PFF.  Once a user process closed the font, the object could be freed
while stale pointers remained inside the bucket or could be replaced
by attacker-controlled memory.  Subsequent traversal therefore
operated on memory of an incompatible type.  Dereferencing fields such
as *(DWORD*)(PFF+0x34) or memcmp(PFF->pwszName, UserBuffer, …) caused
kernel reads/writes using attacker-supplied offsets and lengths.

The issue appears in three independent call paths:
 1. PFTOBJ::HFFToPPFF converts a font handle (HFF) back to a PFF.
 2. PUBLIC_PFTOBJ::pPFFGet performs a hash lookup by name and style.
 3. vLinkEudcPFEsWorker links EUDC (End User Defined Character) PFE
    entries to base fonts.
All of them traverse the same bucket list using untrusted pointers.

Because the objects reside in pageable pool that is both user- and
kernel-writable, an attacker can recycle the freed region with a
fake structure, control the next pointer and the embedded lengths and
thereby redirect further accesses to arbitrary kernel addresses or
create an arbitrary-length memcmp/memcpy beyond pool boundaries.  This
permits elevation of privilege from user mode to SYSTEM.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// PFTOBJ::HFFToPPFF before
for (result = *(PFF **)(v2 + 8 * v3 + 40); result; 
     result = (PFF *)*((QWORD *)result + 1))
{
    if (a2 == *((QWORD *)result + 11))   // uses field offset 0x58
        return result;                   // no validation
}
```
```c
// PUBLIC_PFTOBJ::pPFFGet before
for (j = *v14; j; j = (PFF *)*((QWORD *)j + 1))
{
    if (memcmp(*((void **)j + 3), a2, 2 * v8) == 0 && ...)
        break;                           // j assumed valid
}
```
After patch the traversal looks like:
```c
for (j = *(PFF **)(v2 + 8 * i + 40); ; j = (PFF *)*((QWORD *)res+1))
{
    res = SkipInvalidPff(j);             // new verifier
    if (!res) break;
    if (a2 == *((QWORD *)res + 11))
        return res;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User calls a GDI API that accepts a font handle or requests EUDC
   linking (e.g., NtGdiAddFontResourceW, NtGdiRemoveFontResourceW).
2. Kernel deletes a PFF object but hash bucket still contains the
   pointer, or attacker re-maps memory with controlled data.
3. Later, the same or another API calls PFTOBJ::HFFToPPFF / pPFFGet /
   vLinkEudcPFEsWorker.
4. Traversal follows stale pointer, confuses attacker data for a PFF
   and reads/writes through it, corrupting pool or arbitrary kernel
   memory.

Attack Vector
--------------------------------------------------------------------
Local, authenticated user.  Requires the ability to:
  • Load and unload fonts repeatedly to create freed PFFs;
  • Map or allocate memory at the freed address (pool reuse);
  • Invoke any GDI syscall that triggers the vulnerable look-ups.
No additional privileges are required.

Patch Description
--------------------------------------------------------------------
1. Added helper SkipInvalidPff() that validates a candidate pointer
   (likely checks a signature, reference count and state).
2. All three vulnerable functions now call SkipInvalidPff() before
   each dereference and break out of the loop on failure.
3. Loops rewritten to use safe iterators and the current bucket base
   is re-loaded after an invalid entry is skipped to avoid using stale
   v2.
4. Minor clean-ups: unified hashing through iHash(), converted manual
   variable juggling into for-loops.

Security Impact
--------------------------------------------------------------------
Prior to the fix a low-privilege process could craft or recycle pool
memory so that win32k dereferenced it as a PFF object, enabling:
  • Arbitrary kernel memory read/write;
  • Pool overflow from unchecked length fields;
  • Elevation of privilege to SYSTEM.
Reliability of exploitation is high because the attacker controls the
structure contents and iteration count.

Fix Effectiveness
--------------------------------------------------------------------
The added SkipInvalidPff() gate prevents the immediate dereference of
non-PFF memory inside the three affected helpers and therefore blocks
this specific attack path.  Effectiveness depends on SkipInvalidPff()
correctly authenticating the object.  Other win32k code that touches
PFF lists but did not receive the change might still be vulnerable;
no such paths were visible in the supplied diff.  Based solely on the
shown modifications the patch is judged adequate for these code paths.
