{'patch_store_uid': '230e7c66-244b-4041-b166-2157fff153a1', 'kb': 'KB5063878', 'date': 1755086290.9208658, 'file': 'afd.sys', 'confidence': 0.19, 'change_count': 8, 'cve': 'CVE-2025-53154'}
--------------------------------------------------------------------
CVE-2025-53154 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Ancillary Function Driver for WinSock (afd.sys) – code paths
handling the IOCTL_AFD_UNBIND and related TL-endpoint teardown
routines.


Vulnerability Class
--------------------------------------------------------------------
Null-pointer dereference leading to kernel-mode function-pointer
invocation (NULL-call).  Although formally a NULL-pointer bug, on
Windows this is treated as an Elevation-of-Privilege issue because an
attacker that can map the low address space (or otherwise alias NULL)
can redirect execution to attacker-controlled code.


Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  Every AFD endpoint keeps two opaque transport-layer (TL) objects:
    -  Endpoint->TlHandle        (offset +0x1F0 / +0x200)
    -  Endpoint->TlDispatchTable (offset +0x1F8 / +0x208)
    The dispatch table is an array of kernel function pointers supplied
    by the transport when the TL object is created.

2.  In the legacy unbind path (AfdUnBindSocket) the driver exchanges
    the current TL handle with a freshly created one and *immediately*
    calls the ‘Close’ entry of the *old* dispatch table:

        v18 = *(QWORD *)(Endpoint + 0x1F0);          // old handle
        v19 = *(void ***)(Endpoint + 0x1F8);         // old table
        *(QWORD *)(Endpoint + 0x1F0) = NewHandle;
        *(QWORD *)(Endpoint + 0x1F8) = NewTable;
        ...
        if ((*v19)(v18, Args) == STATUS_PENDING)
            KeWaitForSingleObject(...);

3.  Nothing guarantees that v19 is non-NULL.  A race or a specially
    crafted socket state (e.g., AF_INET/AFD endpoint created without a
    prior successful bind) leaves Endpoint+0x1F8 at NULL.  Dereferencing
    the NULL table produces a kernel bugcheck, but an attacker that can
    map address 0x0 will cause execution of the first QWORD in the page
    with kernel privileges.

4.  The patch introduces an explicit check before the indirect call:

        if ( FeatureGateDisabled || DispatchTable )
            (*DispatchTable)(Handle, Args);
        else
            /* skip – trace only */

    i.e. the call is now executed *only* when the table pointer is
    valid.  All other patched functions (Bind, GetAddress, etc.) add
    similar “table != NULL” or “VA != NULL” guards, but the unbind-path
    bug is the one that allowed control-flow hijacking from user-mode.

Parameters / structures involved:
    Endpoint +0x1F0  : TL handle returned by transport
    Endpoint +0x1F8  : Pointer to TL dispatch table (array of routines)
    IOCTL            : IOCTL_AFD_UNBIND (method buffered)

A malicious unbind issued on an un-initialised endpoint makes
Endpoint->TlDispatchTable == NULL which is then called.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// BEFORE
v18 = *(PVOID *)(ep + 0x1F0);
v19 = *(void ***)(ep + 0x1F8);
*(PVOID *)(ep + 0x1F0) = newHandle;
*(void ***)(ep + 0x1F8) = newTable;
KeResetEvent(ev);
args[0] = (LONG_PTR)AfdSynchronousTlCloseRequestComplete;
args[1] = (LONG_PTR)&ev;
if( (*v19)(v18, args) == STATUS_PENDING )   // <== NULL call
    KeWaitForSingleObject(ev,...);

// AFTER
v21 = *(PVOID *)(ep + 0x1F0);
v22 = *(void ***)(ep + 0x1F8);
*(PVOID *)(ep + 0x1F0) = newHandle;
*(void ***)(ep + 0x1F8) = newTable;
...
if( FeatureGateOff || v22 )
{
    KeResetEvent(ev);
    args[0] = (LONG_PTR)AfdSynchronousTlCloseRequestComplete;
    args[1] = (LONG_PTR)&ev;
    if ( v22 && (*v22)(v21, args) == STATUS_PENDING )
        KeWaitForSingleObject(ev,...);
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User opens \Device\Afd, creates a socket handle.
2. User purposely avoids creating a TL dispatch table (e.g., by closing
   the underlying transport channel prematurely) or forces a race so
   Endpoint->TlDispatchTable == NULL.
3. User calls DeviceIoControl with IOCTL_AFD_UNBIND.
4. AfdUnBindSocket executes and unconditionally calls the first entry
   in the NULL dispatch table.
5. Kernel jumps to address 0x0 + offset, executing attacker data if the
   NULL page is mapped, yielding SYSTEM EoP.


Attack Vector
--------------------------------------------------------------------
Local, authenticated.  The attacker only needs a handle to the AFD
device (available to any user) and the ability to issue crafted socket
/ IOCTL sequences – no special privileges are required.


Patch Description
--------------------------------------------------------------------
• Added explicit NULL-checks before every indirect call through the TL
  dispatch table (v22 != NULL).
• Added feature-gated paths so the closing routine is invoked only when
  the table is valid.
• Similar NULL validations added in auxiliary routines (Bind,
  GetAddress, ExtractSendMsgInfo, etc.) to ensure all driver-managed
  pointers are validated before use.


Security Impact
--------------------------------------------------------------------
Prior to the fix a local attacker could deliberately reach a kernel
NULL-function-pointer dereference and map the 0-page with controlled
shell-code, gaining arbitrary code execution in kernel mode –
resulting in a full local privilege escalation (EoP).


Fix Effectiveness
--------------------------------------------------------------------
The added pointer validity checks eliminate the NULL-call primitive –
if the dispatch table pointer is NULL the driver now skips the call and
returns an error.  The vulnerable path can no longer be exploited to
reach a controllable kernel function-pointer dereference; hence the
patch fully mitigates CVE-2025-53154.
