{'kb': 'KB5063878', 'change_count': 61, 'file': 'storport.sys', 'confidence': 0.13, 'date': 1755086737.1056805, 'patch_store_uid': '575180e9-d4fd-47be-9087-9b43ed83eaa5', 'cve': 'CVE-2025-53156'}
--------------------------------------------------------------------
CVE-2025-53156 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Storage Port driver (storport.sys) – IOCTL handlers
RaUnitGetContiguousPhysicalAddressIoctl / RaUnitUnlockContiguous
PhysicalPagesIoctl and related helper routines.

Vulnerability Class
--------------------------------------------------------------------
Improper access control / information disclosure (CWE-200).

Detailed Root Cause Analysis
--------------------------------------------------------------------
Before the patch, the IOCTL handler
RaUnitGetContiguousPhysicalAddressIoctl() trusted any callers that
opened the device.  The routine:
  1. Parsed the user-supplied input buffer (StructureSize >= 0x18).
  2. Read a user-controlled pointer (offset +8) and called
     MmIsAddressValid() and MmGetPhysicalAddress() on it.
  3. Copied the returned PHYSICAL_ADDRESS back to user space and
     reported success without checking the caller’s privileges, the
     address range, or the request origin.
  4. A similar lack of gating appeared in
     RaUnitUnlockContiguousPhysicalPagesIoctl(), allowing an
     unprivileged caller to unlock pages previously pinned by another
     context.

Because MmGetPhysicalAddress() reveals the real physical frame number,
a regular user could obtain kernel physical addresses of arbitrary
mapped regions (including kernel image sections if the address pointed
into kernel space).  Knowledge of physical addresses breaks KASLR and
facilitates further exploitation (row-hammer, DMA, etc.).

The vulnerable path is reachable through the storage miniport unit
control IOCTL with FunctionId 31 (“get contiguous physical address”).
No check was performed on:
  • Token privileges (SeTcbPrivilege / admin rights)
  • Originating thread vs. IRP thread
  • Address being user-mode versus kernel-mode

Patch behaviour:
  • Introduces an early bailout:
      if !(Feature_IsEnabledDeviceUsage_4()) ||
         (RaidCallerIsAdmin() && CurrentThread == IrpThread)
        … proceed …
      else
        Status = STATUS_ACCESS_DENIED (-1073741790)
  • When the feature flag is set, the pointer is additionally compared
    against MmHighestUserAddress – kernel addresses are rejected.
  • Similar gating was added to UnlockContiguousPhysicalPagesIoctl and
    to helper routines (ForwardIo, CancelPendingRequests, etc.).
  • Status codes are changed to ACCESS_DENIED on failure.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
PhysicalAddress = MmGetPhysicalAddress(UserPtr);
**OutBuffer = PhysicalAddress;            // leak
...
// after
if (!(Feature_IsEnabledDeviceUsage_4()) ||
    (RaidCallerIsAdmin() && KeGetCurrentThread()==IrpThread)) {
    if (Ptr <= MmHighestUserAddress && MmIsAddressValid(Ptr)) {
        PhysicalAddress = MmGetPhysicalAddress(Ptr);
        ...
    }
} else {
    Status = STATUS_ACCESS_DENIED;
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User-mode program opens a device controlled by storport miniport.
2. Sends IOCTL that maps to FunctionId 31.
3. Input buffer contains a crafted pointer P (can be kernel VA).
4. RaUnitGetContiguousPhysicalAddressIoctl() resolves P to a physical
   address and copies it back to user buffer.
5. Attacker reads the physical address from the output buffer.

Attack Vector
--------------------------------------------------------------------
Local, authenticated but non-privileged user issuing the IOCTL to any
storage device whose miniport stack is serviced by storport.sys.
No additional privileges are required.

Patch Description
--------------------------------------------------------------------
1. Added privilege / feature checks:
     • Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage_4()
     • RaidCallerIsAdmin()
     • Thread ownership test.
2. Rejected requests return STATUS_ACCESS_DENIED and skip any physical
   address resolution.
3. If feature flag is enabled, pointers above MmHighestUserAddress are
   disallowed.
4. Similar checks applied to complementary unlock-IOCTL and to helper
   routines; new helper variants (…_5 / …_6) replace the old test.
5. Minor correctness fixes (e.g., constant 8 -> 8i64).

Security Impact
--------------------------------------------------------------------
Prior to the fix an unprivileged caller could disclose arbitrary
physical addresses, undermining KASLR, leaking driver placement, and
potentially assisting further kernel exploits.  The scope is local,
but the confidentiality impact is high; integrity/availability are
unchanged.

Fix Effectiveness
--------------------------------------------------------------------
The new access-control logic blocks unprivileged callers and limits the
accepted virtual address range.  As long as the feature flag is shipped
enabled on supported systems and RaidCallerIsAdmin() is reliable, the
information leak is closed.  Behaviour when the feature flag is
manually disabled is unknown.

