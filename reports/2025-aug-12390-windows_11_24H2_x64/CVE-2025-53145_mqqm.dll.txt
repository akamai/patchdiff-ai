{'confidence': 0.27, 'patch_store_uid': '2d4fad2a-6929-40c4-8e2b-8117e27bb0cc', 'file': 'mqqm.dll', 'cve': 'CVE-2025-53145', 'date': 1755089359.7205603, 'change_count': 11, 'kb': 'KB5063878'}
--------------------------------------------------------------------
CVE-2025-53145 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Message Queuing (MSMQ) user-mode service – mqqm.dll


Vulnerability Class
--------------------------------------------------------------------
Type confusion / access of resource using incompatible type (CWE-843)


Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  Packet delivery uses an async-IO helper object called CSendOv.  In
    CMessageTransport::DeliverPacket the pre-patch code allocates 0x40
    bytes with MmAllocate() and then *manually* populates the buffer
    with function pointers and two reference counters:
        v5[4] = SendSucceeded
        v5[5] = SendFailed
        *(OWORD*)v5      = 0
        *((OWORD*)v5+1)  = 0
        v5[6] = SafeAddRef(this)
        *(QWORD*)(v6+56) = SafeAddRef(v7)
    No constructor is invoked, so the buffer is only
    *assumed* to be a valid CSendOv.  A crafted packet that triggers a
    different code path (e.g. IO completion, rundown, commit/abort
    helpers) can therefore treat the same memory as a different class
    and call virtual functions at uncontrolled offsets.  This is the
    classic type-confusion pattern – an object is used through two
    incompatible layouts.

2.  Additional entry points (RPC_INT_XACT_HANDLE_rundown,
    QMDoCommitTransaction, QMDoAbortTransaction, and
    PCTX_OPENREMOTE_HANDLE_TYPE_rundown) were missing sanity checks for
    caller-supplied context-handle pointers.  The pointers were blindly
    dereferenced, allowing an attacker to pass a forged 64-bit value
    that is later interpreted as a CTransaction/CReference object.  The
    fake object again leads to virtual-function-pointer confusion and
    code execution in the msmq service process.

3.  The patched code eliminates both issues:
    •   A real CSendOv constructor
        (CSendOv::CSendOv) is now invoked, guaranteeing that the memory
        really contains a valid CSendOv layout.
    •   Every RPC-exposed rundown or transaction helper now calls
        CResourceManager::ValidateTransaction() or ValidateContext()
        before touching the pointer.  If validation fails the function
        logs and bails out.

The root cause is therefore an implicit trust in the type of heap
buffers and RPC context handles combined with manual object crafting,
which lets remote, authenticated users confuse MSMQ into executing code
through forged objects.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// 1. Manual object creation (before)
v5 = MmAllocate(0x40ui64);
if (v5) {
    v5[4] = CMessageTransport::SendSucceeded;  // virtuals
    v5[5] = CMessageTransport::SendFailed;
    *(OWORD*)v5 = 0;                           // raw zeroing
    *((OWORD*)v5 + 1) = 0;
    v5[6] = SafeAddRef(this);
    *(QWORD*)(v6 + 56) = SafeAddRef(v7);
}

// 1. Correct object creation (after)
v5 = MmAllocate(0x40ui64);
if (v5)
    v8 = CMessageTransport::CSendOv::CSendOv(...,&v18); // real ctor
```

```c
// 2. Pointer validation added to RPC rundown (after)
if (wil::FeatureEnabled && !CResourceManager::ValidateTransaction(v4,this)) {
    WPP_SF_sq(...);
    LogMsgHR(-1072824313,L"xactrm",2113);
    return;
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Remote client sends crafted MSMQ packet / issues RPC with forged
   context handle.
2. Service thread enters CMessageTransport::DeliverPacket or one of the
   *_rundown helpers.
3. Pre-patch: buffer is cast to CSendOv or CTransaction with no
   validation; virtual functions are invoked.
4. Attacker-controlled memory is executed, yielding RCE in msmq.exe
   (running as service account / LocalSystem by default).


Attack Vector
--------------------------------------------------------------------
Authenticated network attacker (or compromised client machine) sends a
specially crafted message to an MSMQ queue or calls the MSMQ RPC
interface, supplying a malicious context handle that forces the service
to treat attacker-controlled memory as an internal C++ object.


Patch Description
--------------------------------------------------------------------
1. Replaces hand-crafted object initialisation with a call to
   CMessageTransport::CSendOv::CSendOv, ensuring correct vtable and
   member layout.
2. Introduces ValidateContext() and
   CResourceManager::ValidateTransaction() checks in every RPC rundown
   and transaction API before the pointer is dereferenced.
3. Minor logic flips in GetPacketForSendingSucceeded to avoid
   processing of not-yet-validated packets.
4. Feature gates (wil::FeatureImpl) are used so that validation can be
   enabled through a flighting flag without code changes.


Security Impact
--------------------------------------------------------------------
Without the patch an attacker with network access to MSMQ could craft a
message or context handle that results in arbitrary function-pointer
invocation inside the service, leading to remote code execution under
SERVICE / LocalSystem privileges.  This compromises the entire host.


Fix Effectiveness
--------------------------------------------------------------------
The constructor call removes the underlying type confusion in
DeliverPacket.  Added ValidateContext / ValidateTransaction checks stop
forged handles early.  No remaining unsafe casts were observed in the
patched diff, so the fix appears complete for the identified paths.
However, full assurance would require a code-base audit for other
manual object allocations and for callers executed when the new Wil
feature flag is disabled.
