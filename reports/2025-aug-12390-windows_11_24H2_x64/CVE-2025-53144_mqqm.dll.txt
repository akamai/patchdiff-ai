{'confidence': 0.23, 'kb': 'KB5063878', 'change_count': 11, 'patch_store_uid': '2d4fad2a-6929-40c4-8e2b-8117e27bb0cc', 'file': 'mqqm.dll', 'date': 1755086343.31281, 'cve': 'CVE-2025-53144'}
--------------------------------------------------------------------
CVE-2025-53144 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Message Queuing (MSMQ) service – mqqm.dll.  Vulnerable RPC
entry points include
 • PCTX_OPENREMOTE_HANDLE_TYPE_rundown
 • QMDoAbortTransaction / QMDoCommitTransaction
 • RPC_INT_XACT_HANDLE_rundown
 • CMessageTransport::GetPacketForSendingSucceeded
and the helper routines they invoke.


Vulnerability Class
--------------------------------------------------------------------
Type confusion / access of resource using incompatible type
(CWE-843).  The code blindly interprets an un-trusted pointer coming
from an RPC context handle as a valid internal object (CTransaction,
CTX_OPENREMOTE_BASE, CMessageTransport, …).


Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  MSMQ exposes several RPC methods that return opaque context
    handles to a remote caller (e.g. QMOpenRemoteQueue, remote
    transaction APIs).  The context handle is nothing more than a raw
    pointer that later gets passed back to the server during Abort,
    Commit or rundown operations.

2.  Prior to the patch the rundown / control paths trusted this raw
    value and immediately dereferenced it:
      PCTX_OPENREMOTE_HANDLE_TYPE_rundown(CReference *this)
      RPC_INT_XACT_HANDLE_rundown(CTransaction *this)
      QMDoAbortTransaction(CTransaction **a1)
      QMDoCommitTransaction(CTransaction **a1)

    Typical first access:
        if (*((_DWORD*)this + 4)) { … }

    No attempt was made to verify that
      • the pointer is non-NULL, and
      • it really refers to an allocated instance of the expected
        class that is still owned by the current Resource Manager /
        Context Map.

3.  Because the value is fully controlled by an RPC client, an
    attacker can supply an address that:
      a. Points to attacker-mapped user memory in the service process
         (possible through other bugs, shared sections, etc.), or
      b. Aliases a different internal object whose layout is
         incompatible with the expected type.

    When MSMQ reads or writes object fields (counters, VFT pointer,
    list links, critical-section objects, …) memory corruption ensues
    – ultimately enabling arbitrary code execution in the MSMQ
    service (running as NT AUTHORITY\SYSTEM).

4.  Similar trust problem existed in
    CMessageTransport::GetPacketForSendingSucceeded.  The function
    used the EXOVERLAPPED back-pointer (a1 – 488) without confirming
    it still represents a live CMessageTransport instance.  The patch
    added IsDeliveryAllowed / PrepareDelivery gating but, more
    importantly, keeps a consistent pattern: *validate before use*.

Structures / parameters involved
• CTransaction      – 0x30+ bytes, state in dword[2]
• CTX_OPENREMOTE_BASE / CTX_OPENREMOTE_HANDLE_TYPE – ~0xB0 bytes,
  ref-count at +8, map-index at +104.
• CMessageTransport – EXOVERLAPPED embedded at offset 0.
• Global maps: qword_180148A10 (ContextMap), etc.

None of these were checked before, leading directly to type
confusion.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Before
void PCTX_OPENREMOTE_HANDLE_TYPE_rundown(CReference *this) {
    if (*((_DWORD*)this + 4)) {
        …                      // uses fields of attacker pointer
    } else {
        if (!_InterlockedCompareExchange((int*)this + 27,2,0))
            DeleteFromContextMap(this);
        CReference::Release(this);   // virtual call via vftbl
    }
}

// After
if (!this) { … return; }
if (ValidateContext(this)) {
    …  // original logic
} else {
    LogMsgHR(STATUS_INVALID_HANDLE,…);
    return;                 // no dereference
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker connects to MSMQ RPC interface (TCP port 1801 by default).
2. Calls any API that expects a context handle (e.g. QMDoCommit*
   or remote queue rundown) and supplies a crafted 64-bit value.
3. Service invokes corresponding *rundown* or control procedure when
   the handle is used.
4. Pre-patch code treats the value as a valid object, dereferences
   invalid memory, corrupts heap / vtable, and executes arbitrary
   code.


Attack Vector
--------------------------------------------------------------------
Network – authenticated (or otherwise authorised) RPC client sends a
malformed context handle over MSMQ’s private RPC protocol.  No local
code execution on the server is needed.


Patch Description
--------------------------------------------------------------------
1. Introduced ValidateContext(), ValidateTransaction() and
   CMessageTransport::IsDeliveryAllowed / PrepareDelivery gates.
   These functions make sure that the supplied pointer exists in the
   appropriate global ContextMap / ResourceManager list and matches
   the expected object type.
2. Added explicit NULL checks prior to dereference.
3. If validation fails the code logs an error and returns
   MQ_ERROR_INVALID_HANDLE (0xC00E000F / ‑1072824313) instead of
   using the pointer.
4. Refactored GetPacketForSendingSucceeded logic to avoid using a
   potentially dead CMessageTransport instance and to bail out early
   on invalid state.
5. Mechanical changes: feature-flag plumbing, trace-guid updates,
   moved critical section from stru_180147A50 to stru_180148A50.


Security Impact
--------------------------------------------------------------------
Without these checks a remote attacker could craft a bogus context
handle, trigger out-of-bounds reads/writes or virtual-function calls
on a forged vtable, and ultimately achieve remote code execution in
the MSMQ service process (SYSTEM integrity).  Denial of service is
also trivial.


Fix Effectiveness
--------------------------------------------------------------------
All affected entry points now validate the caller-supplied handle
before any field access or virtual call.  If validation fails, the
function aborts with an error and never touches the pointer.  No
further type confusion path is visible in the patched code provided.
Assuming Validate* functions are trustworthy, the patch fully
mitigates the vulnerability.

