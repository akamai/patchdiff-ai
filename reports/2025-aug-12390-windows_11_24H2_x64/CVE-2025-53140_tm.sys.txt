{'change_count': 2, 'confidence': 0.27, 'file': 'tm.sys', 'patch_store_uid': '2e05e9ef-cf22-489d-8416-a4d4c90d9a80', 'kb': 'KB5063878', 'cve': 'CVE-2025-53140', 'date': 1755086330.0185392}
--------------------------------------------------------------------
CVE-2025-53140 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Kernel – Transaction Manager driver (tm.sys)
Function involved: TmpInitializeEnlistment /
TmpInitializeEnlistment$fin$0


Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use-After-Free (dangling pointer on Transaction Manager
object)


Detailed Root Cause Analysis
--------------------------------------------------------------------
TmpInitializeEnlistment is reached from the NtCreateEnlistment system
call when a new enlistment is created for a Resource Manager (RM)
inside a Transaction (KTRANSACTION).

1.  The code copies the RM’s Transaction-Manager pointer found at
    *(RM + 0x168) into the local variable v11 ( type _KTM* ).
    It correctly bumps the reference count with
    ObfReferenceObject(v11).

2.  If the current Transaction already belongs to a different
    Transaction-Manager (Multi-TM scenario) the routine enters a loop
    where it temporarily switches to additional KTM objects stored in
    v14 / v16.

3.  PRIOR TO THE PATCH the additional KTM object was used as follows:
        •  v14/v16 is taken straight from a global list.
        •  TmpAcquireTxTableTransactionManager(v14) is called, which
           only acquires an internal lock – it does not increase the
           reference count.
        •  The pointer is later accessed again (e.g. v11[32]) *after*
           the lock has been released and even after the function has
           restarted the loop.
        •  No ObfReferenceObject was taken for v14/v16, so another
           thread closing the KTM handle could free the memory between
           release and later access.

4.  When the freed memory is dereferenced the kernel operates on
    attacker-controlled data, enabling privilege escalation.

5.  The bug can be triggered reliably by:
        a. Creating two Transaction-Managers.
        b. Opening/closing one KTM handle in a tight loop on a helper
           thread.
        c. From the attacker thread, creating an enlistment that
           forces the Multi-TM path (specific notification mask and
           enlist-sup options).


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// BEFORE – no reference is taken on v14/v16
if (v14) {
    TmpAcquireTxTableTransactionManager(v14); // lock only
    v12 = (_DWORD *)v14;
    i = 0;
    if (*(_DWORD *)(v14 + 0x40) == 5) {
        inserted = STATUS_OBJECT_TYPE_MISMATCH; // bail out
        goto cleanup;
    }
}
...
if (v12 && (v11[32] & 0x10) != 0)   // <== UAF if v11 freed
    Transaction->Flags |= 0x10000;
```
```c
// AFTER – extra lifetime management
if (v16) {
    ObfReferenceObject(v16);        // NEW
    TmpAcquireTxTableTransactionManager((__int64)v16);
    v11 = v16;
    v35 = 0;
    if (v16[16] == 5)
        goto error;
}
...
TmpReleaseTxTableTransactionManager((__int64)v11);
if (FeatureFlag)
    ObfDereferenceObject(v11);      // NEW matched deref
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User-mode calls NtCreateEnlistment with crafted flags.
2. KtmRm creates Resource Manager and enters TmpInitializeEnlistment.
3. Function switches to a secondary KTM without taking a reference.
4. Attacker thread closes the KTM handle -> object is freed.
5. Primary thread resumes, accesses v11/v16 -> Use-After-Free.
6. Corrupted kernel heap structures allow arbitrary code execution in
   kernel context.


Attack Vector
--------------------------------------------------------------------
Local attacker, already running with the ability to open/close
Transaction-Manager handles (no special privilege is required for
NtCreateEnlistment). Exploit runs two cooperating threads to win the
race and elevate to SYSTEM.


Patch Description
--------------------------------------------------------------------
1. Replaced TmpIsNotificationMaskValid() by strict in-line bitmask
   checks, limiting the code paths that reach the vulnerable multi-TM
   logic.
2. Added ObfReferenceObject()/ObfDereferenceObject() around every
   temporary KTM pointer (v16) whenever it is acquired/released.
3. Added new local flags (v24, v34) to guarantee that every mutex and
   reference is released on *all* exit paths.
4. Mirrored changes in the _fin variant so both hot and cold builds are
   protected.


Security Impact
--------------------------------------------------------------------
An unprivileged local user could trigger a race causing the kernel to
use a freed Transaction Manager object, leading to arbitrary code
execution in kernel mode and full privilege escalation.


Fix Effectiveness
--------------------------------------------------------------------
The additional object referencing guarantees that the KTM object’s
reference count remains non-zero while it is being used. Releasing the
reference on every failure/exit path removes the dangling pointer. The
inline mask validation further reduces reachable states. Together these
changes fully eliminate the Use-After-Free condition described above.
