{'change_count': 2, 'file': 'vmwp.exe', 'kb': 'KB5063878', 'patch_store_uid': 'd698b11d-e9a3-4b93-ab09-18cf839553fc', 'date': 1755089593.001235, 'cve': 'CVE-2025-53723', 'confidence': 0.09}
--------------------------------------------------------------------
CVE-2025-53723 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Hyper-V ‑ Virtual Machine Worker Process (vmwp.exe).  The faulty
code is inside the Windows Implementation Library (WIL) feature‐gating
helpers found in vmwp.exe.


Vulnerability Class
--------------------------------------------------------------------
CWE-197: Numeric Truncation Error leading to CWE-122: Heap-based Buffer
Overflow and local elevation of privilege.


Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  The helper wil::details::FeatureImpl<...Feature_TestConfNum>::
    ReportUsage previously had the prototype

        ReportUsage(unsigned int *impl, unsigned __int8 reportingKind)

    even though every caller was compiled with the canonical signature

        ReportUsage(bool enabled, wil::ReportingKind kind,
                    unsigned __int64 usage)

    where wil::ReportingKind is a 32-bit enumeration.

2.  At runtime the second argument therefore arrives in RDX as a full
    32-bit value, but the callee immediately truncates it to an
    8-bit unsigned char:

        v4 = a2;          // a2 is unsigned __int8

3.  The 8-bit value is forwarded, unvalidated, to
    wil::details::ReportUsageToService as its sixth parameter.  The
    service routine expects either a 32- or 64-bit field that controls
    buffer sizes and flags used when building a heap message that is
    sent to the Hyper-V service process.

4.  When a crafted reportingKind value larger than 0xFF is supplied, the
    high three bytes are silently dropped.  ReportUsageToService still
    interprets the remaining low byte as a full flag/length field,
    which can cause the routine to reserve a smaller heap buffer than
    actually needed and subsequently overflow it while marshalling the
    message.

5.  Because vmwp.exe runs as NT VIRTUAL MACHINE\VM Worker Process (a
    highly-privileged service), the overflow enables a local attacker
    who can reach the ReportUsage path to achieve code execution in
    that privileged context, resulting in elevation of privilege on the
    host.

6.  An additional logic error in
    FeatureImpl<...Feature_PerfImpTest>::GetCurrentFeatureEnabledState
    made it possible for untrusted input to reach the vulnerable
    ReportUsage path under normal, non-debug builds.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Before patch – vmwp.exe
__int64 __fastcall ReportUsage(unsigned int *impl, unsigned __int8 a2)
{
    unsigned int v2 = *impl;
    int v4 = a2;                  // truncation to 8 bits
    ...
    return ReportUsageToService(impl + 2,
                                0x033C851F,    // 54237951
                                (v2 >> 10) & 1,
                                (v2 >> 11) & 1,
                                &v7,
                                v4,            // tainted, truncated
                                0);
}
```
```c
// After patch – vmwp.exe
__int64 __fastcall ReportUsage(unsigned int *impl)
{
    ...
    return ReportUsageToService(impl + 2,
                                0x033C851F,
                                (v1 >> 10) & 1,
                                (v1 >> 11) & 1,
                                &v5,
                                1,             // constant, safe
                                0);
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Guest / management component issues command that is handled in
   vmwp.exe (exact entry point unknown).
2. vmwp.exe evaluates feature gates and reaches
   Feature_PerfImpTest::GetCurrentFeatureEnabledState().
3. The old code (pre-patch) eventually calls
   Feature_TestConfNum::ReportUsage(..., uncontrolledReportingKind).
4. ReportUsage truncates the value, then calls
   ReportUsageToService with the truncated byte, triggering an
   undersized heap allocation and buffer overflow.


Attack Vector
--------------------------------------------------------------------
An authenticated local attacker able to send crafted Hyper-V management
or guest messages that influence the wil::ReportingKind value can supply
a value larger than 0xFF.  When processed by vmwp.exe the truncation
occurs, leading to heap corruption and code execution inside the highly
privileged Hyper-V worker process.


Patch Description
--------------------------------------------------------------------
1. Eliminated the numeric type mismatch by removing the second parameter
   from Feature_TestConfNum::ReportUsage; callers now pass only the
   implementation pointer.
2. Inside ReportUsage the constant value 1 is hard-coded for the
   reportingKind argument forwarded to ReportUsageToService.
3. Updated Feature_PerfImpTest::GetCurrentFeatureEnabledState to call
   the fixed ReportUsage routine directly and stripped the now-unused
   logic that relied on the prior IsEnabled call and bit-manipulation
   (v12 / 0x400 clearing path).

Together these changes stop external input from controlling the field
that previously suffered from truncation.


Security Impact
--------------------------------------------------------------------
Prior to the patch a malicious reportingKind (>0xFF) caused heap buffer
mis-sizing inside vmwp.exe, leading to memory corruption and potential
arbitrary code execution in a SYSTEM-equivalent context.  Successful
exploitation gives the attacker local elevation of privilege on the
host machine.


Fix Effectiveness
--------------------------------------------------------------------
The vulnerable numeric truncation site has been completely removed; the
parameter can no longer be influenced by callers and a safe constant is
now used.  No other code paths that accept a wil::ReportingKind value
cast it to an 8-bit type in the patched build.  Therefore the fix is
considered effective for the identified vulnerability.
