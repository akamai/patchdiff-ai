{'change_count': 231, 'confidence': 0.15, 'kb': 'KB5063878', 'patch_store_uid': 'fc627993-4587-4502-834f-627afeb669e1', 'cve': 'CVE-2025-50154', 'file': 'windows.ui.fileexplorer.dll', 'date': 1755086596.682588}
--------------------------------------------------------------------
CVE-2025-50154 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
windows.ui.fileexplorer.dll – specifically the File Explorer Global
Settings WinRT implementation (class
WindowsUdk.UI.Shell.implementation.FileExplorerGlobalSettings) and the
asynchronous helper  GetIsAadAccountAttachedFromTokenBrokerAsync().


Vulnerability Class
--------------------------------------------------------------------
Information Disclosure / Improper Access Control (CWE-200)


Detailed Root Cause Analysis
--------------------------------------------------------------------
Prior to the patch the DLL shipped a full WinRT producer for the public
interface IFileExplorerGlobalSettings.  The automatically generated
produce()/producer() stubs were exported and their v-table contained an
entry for a method named
GetIsAadAccountAttachedFromTokenBrokerAsync().  Because the stubs were
built by the generic winrt::impl::produce/producer templates they did
not add any access-control or feature-gating logic.  Any low-privileged
caller that could activate the class was therefore able to:

1.  Create a FileExplorerGlobalSettings object.
2.  Call GetIsAadAccountAttachedFromTokenBrokerAsync().
3.  Inside that coroutine the code (see next section) runs
    TokenBrokerInternal::FindAllAccountsAsync(), iterates through every
    WebAccount, and returns true when the provider authority equals
    L"organizations" (Azure AD).  This directly reveals whether the
    local user or device is AAD-joined.
4.  The method completes without authentication, capability or feature
    checks, leaking enterprise state information to any process –
    including sandboxed or remote-origin code running on the machine.

The disclosure is amplified because the information is derived from the
internal Token Broker, not from a cached registry bit, so it is always
accurate and up-to-date.

Patch analysis shows that the producer stubs were entirely replaced by
new, **internal-only** coroutine entry points
(GetIsAadAccountAttachedFromTokenBrokerAsync__InitCoro_2 and
__ResumeCoro_1).  These new helpers execute the same enumeration logic
but only run when the WIL feature flag
`Feature_FE_PI_AadAttachedUdkApi` is enabled, otherwise the coroutine is
short-circuited and no token-broker call is made.  In addition, the
public WinRT v-table is no longer exported because the generic
produce()/producer() templates have disappeared.

Finally, RefreshAllGlobalSettings() was updated to cache the result in a
private byte (LOBYTE(this[8].Ptr)) under the same feature flag.  The
lock index was shifted (AcquireSRWLockExclusive( this+6 )) because the
class layout gained this new byte, confirming that the value is now an
internal implementation detail only.

In short, the root cause was **unintended external exposure of a method
that enumerates the user’s AAD accounts without access checks.**


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Old (exported) producer – nothing but a v-table exposure
auto produce(...) {
    winrt::impl::produce_base(...)(a1);
    *a1 = &produce<...>::`vftable'; // leaked public interface
}

// New initialiser – note feature check and internal coroutine handle
void GetIsAadAccountAttachedFromTokenBrokerAsync__InitCoro_2(...) {
    *funcPtr = _ResumeCoro_1;            // coroutine entry
    ...
    if (wil::Feature_FE_PI_AadAttachedUdkApi::IsEnabled())
        _ResumeCoro_1(state);
    else
        tip2::merged_data::on_result(state+400); // early abort
}

// Part of _ResumeCoro_1 – disclosure logic (unchanged)
accountList = TokenBrokerInternal::FindAllAccountsAsync();
for(each account)
    if (provider.Authority() == L"organizations")
        return true; // machine is AAD attached
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker activates the WinRT class
   WindowsUdk.UI.Shell.FileExplorerGlobalSettings.
2. Calls IFileExplorerGlobalSettings::
   GetIsAadAccountAttachedFromTokenBrokerAsync().
3. Producer stub forwards to coroutine; TokenBrokerInternal is queried.
4. Boolean result discloses whether any AAD account exists.


Attack Vector
--------------------------------------------------------------------
Local, unauthenticated code execution (any sandboxed UWP, Win32, script
or malware) could query the API and learn the AAD-join status.  The
information can then be used to tailor social-engineering or network
spoofing attacks.


Patch Description
--------------------------------------------------------------------
• Removed the public winrt::impl::produce / producer templates for the
  IFileExplorerGlobalSettings interface.
• Added internal coroutine helpers
  GetIsAadAccountAttachedFromTokenBrokerAsync__InitCoro_2 and
  __ResumeCoro_1.
• Wrapped all execution paths with a WIL feature gate
  Feature_FE_PI_AadAttachedUdkApi.  When the feature is off the
  coroutine is not executed and the result is never exposed.
• Extended the FileExplorerGlobalSettings object with a private byte
  that caches the AAD-attached state; class layout and locking updated
  accordingly (locks now taken at this+6 instead of this+5).


Security Impact
--------------------------------------------------------------------
Before the fix any low-privileged process could discover whether the
machine/user has an organisational (Azure AD) account attached.  This
violates user privacy and can aid spoofing or targeted phishing.  After
the fix the information is no longer available through the public WinRT
surface unless an internal feature flag is explicitly enabled.


Fix Effectiveness
--------------------------------------------------------------------
The vulnerable interface is gone from the exported v-table and the new
code path is subject to a feature gate that defaults to OFF.  The
sensitive TokenBroker enumeration is therefore unreachable by an
unauthorised actor, fully mitigating the original disclosure.  No
remaining call-sites that bypass the gate were found in the supplied
diffs.  Further testing of alternate activation paths is recommended,
but the patch appears effective.
