{'change_count': 88, 'file': 'windows.graphics.printing.workflow.dll', 'confidence': 0.26, 'date': 1755086563.190009, 'cve': 'CVE-2025-53133', 'patch_store_uid': '913e6232-d9eb-4d3e-9db1-2a47a2c1208e', 'kb': 'KB5063878'}
--------------------------------------------------------------------
CVE-2025-53133 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
PrintWorkflowUserSvc – specifically the method
winrt::Windows::Graphics::Printing::Workflow::implementation::
PrintWorkflowJobActivatedEventArgs::EnsureSession in
windows.graphics.printing.workflow.dll.


Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use-After-Free (dangling internal pointer caused by stale
structure offsets).


Detailed Root Cause Analysis
--------------------------------------------------------------------
PrintWorkflowJobActivatedEventArgs is a C++/WinRT object that owns a
PrintWorkflowJobUISession pointer and an SRWLOCK used to guard it.
A refactor inserted new data members into the class, shifting every
field that followed.  EnsureSession, however, was not recompiled with
the new layout and therefore used hard-coded, outdated offsets:

• Session pointer assumed at offset 0x40  ( *((QWORD*)this + 8) )
• SRWLOCK assumed at offset 0x68         ( this + 0x68 )
• JobId     assumed at offset 0x60       ( *((DWORD*)this + 24) )

At run time those offsets now reference memory that belongs to a
different object or has already been freed.  When EnsureSession
believed the session pointer was null it constructed a new
PrintWorkflowJobUISession instance and wrote the IUnknown* to the
stale location.  Subsequent code that dereferenced the real session
member (now at 0x48) found a dangling value, leading to a classic use
after free.  Because the code runs inside PrintWorkflowUserSvc, which
is started as LocalSystem, the dangling pointer can be re-allocated by
an attacker to gain arbitrary code execution in a high-privilege
context.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Before patch (wrong layout)
wil::RtlAcquireSRWLockShared(v8, (char *)this + 104);   // +0x68
if ( !*((_QWORD *)this + 8) ) {                        // session @0x40
    ...
    winrt::Windows::Foundation::IUnknown::operator=((char *)this + 64, v6);
}

// After patch (correct layout)
wil::RtlAcquireSRWLockShared(v8, (char *)this + 160);   // +0xA0
if ( !*((_QWORD *)this + 9) ) {                        // session @0x48
    ...
    winrt::Windows::Foundation::IUnknown::operator=((char *)this + 72, v6);
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User submits a print job that causes PrintWorkflowUserSvc to raise
   the JobActivated event.
2. The service constructs PrintWorkflowJobActivatedEventArgs and calls
   EnsureSession().
3. EnsureSession acquires the SRW lock, mis-reads the session pointer
   (dangling / previously freed).
4. Dereferencing or overwriting the stale address produces a UAF that
   an attacker can shape via heap grooming.


Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker.  By printing specially crafted content
and manipulating the heap (for example through repeatedly creating and
canceling print jobs) the attacker can reclaim the freed block pointed
to by the stale 0x40 pointer with controlled data, achieving arbitrary
code execution in the PrintWorkflowUserSvc process running as
LocalSystem.


Patch Description
--------------------------------------------------------------------
The patch recompiles EnsureSession with the correct class layout:

• SRWLOCK offset updated from 0x68 to 0xA0.
• Session pointer offset updated from (QWORD*)this+8 (0x40) to
  (QWORD*)this+9 (0x48).
• JobId field offset updated from DWORD index 24 to 27.
• Related ETW provider IDs updated but are not security relevant.

These changes ensure that the method accesses the intended in-object
members rather than stale memory.


Security Impact
--------------------------------------------------------------------
Prior to the patch a local attacker could reliably turn the dangling
pointer into a write-what-where or code execution primitive inside a
SYSTEM process, resulting in elevation of privilege.


Fix Effectiveness
--------------------------------------------------------------------
High.  All hard-coded offsets now align with the current structure
layout, preventing the stale pointer scenario.  No residual pathways
to the same bug are evident in the updated function.  Full resolution
for this specific UAF is therefore achieved.

