{'cve': 'CVE-2025-53778', 'change_count': 12, 'file': 'msv1_0.dll', 'date': 1755086398.079173, 'kb': 'KB5063878', 'patch_store_uid': 'e4f32559-e113-4272-a009-5e5611770f30', 'confidence': 0.22}
--------------------------------------------------------------------
CVE-2025-53778 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows NTLM authentication logic implemented in msv1_0.dll
( SsprHandle* and wil::details::FeatureImpl::<GetCurrentFeatureEnabledState>
 helper functions).


Vulnerability Class
--------------------------------------------------------------------
Improper Authentication / Policy-bypass (CWE-287)


Detailed Root Cause Analysis
--------------------------------------------------------------------
NTLM security policy decisions are taken from a per-feature run-time
flag that is returned by wil::details::FeatureImpl::<GetCurrentFeature
EnabledState>().  The pre-patch algorithms built this 32-bit flag word
by combining the WIL feature state with several helper bits
(0x40 = ENABLED, 0x400 = HAS_USAGE, 0x800 = HAS_STATE, 0x1 = ERROR).

Old code initialised the output word with an *uninitialised* or *zero*
variable and later ‘OR’ed the helper bits, effectively turning the
feature on whenever *any* helper sub-condition evaluated to true. If
WilApi_GetFeatureEnabledState() happened to return the value
FEATURE_DISABLED   (bit-field 0), the helper logic still produced an
output that had bit 0x40 set – meaning **feature enabled** although the
policy explicitly disabled it.

Inside SsprHandleFirstCall() / SsprHandleChallengeMessage() the NTLM
stack consumes this flag via:
    if ((*(_DWORD *)FeatState & 0x40) != 0) { … allow NTLM … }
Consequently a client that is explicitly blocked by the
"NTLMless_Audit / NtlmReturnsBlocked" policy is allowed to authenticate
as long as it can trigger the helper path (e.g. by requesting MIC
flags 0xC00).

New binaries rebuild the word from scratch:
  * they preset it to 64 only when the base state is !=0
  * they clear 0x400 when the ‘usage’ test ultimately fails
  * they only assert bit 0 or 1 after verifying a secondary feature
    (ImplVal / GatePerf / …) is itself enabled.
  * SsprHandle* now re-validates size and timestamp fields before the
    policy flag is honoured.

With this change a disabled feature can no longer be surfaced as
“enabled” and NTLM negotiation is rejected as expected.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
v6  = FeatureEnabledState & 0xFFFFFF3F;
v7  = ((FeatureEnabledState & 3)<<7) | …;
*(_DWORD*)a2 = v7;           // 0x40 may be added later
if (!(FeatureEnabledState & 0xFFFFFF3F))
    v8 = 64;                 // unconditional enable
*(_DWORD*)a2 = v8 | v7;      // 0x40 ends up set even if disabled
…
```
```c
// after
v6  = FeatureEnabledState & 0xFFFFFF3F;
v7  = …;
*(_DWORD*)a2 = v7;           // start with raw bits only
if (v6)
    v8 = (v6==2)?64:0;       // only add 0x40 for explicit state
else
    v8 = 64;                 // legacy fall-back kept but re-checked
*(_DWORD*)a2 = v8|v7;
// secondary feature gate + 0x400 fixup
if (!v10) *(_DWORD*)a2 &= ~0x400u;
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker initiates NTLM session → SsprHandleFirstCall()
2. Function fetches feature flag through
   wil::details::FeatureImpl::<GetCurrentFeatureEnabledState>()
3. Pre-patch function incorrectly sets bit 0x40 (enabled)
4. SsprHandle* sees “feature enabled” and continues NTLM path
5. Attacker authenticates, gaining network privileges forbidden by
   policy (EoP).


Attack Vector
--------------------------------------------------------------------
A domain user who can start an NTLM session to a server that has
**NTLM disabled / audited** can still negotiate NTLM and obtain a
valid session key, bypassing the NTLM-less policy and escalating
privilege across the network.


Patch Description
--------------------------------------------------------------------
• Re-implements flag construction in every
  GetCurrentFeatureEnabledState() template instance:
  – initialise output with canonical WilApi value,
  – conditionally OR helper bits only after validation,
  – clear 0x400 when the secondary usage probe fails,
  – add a secondary feature-enable check.
• SsprHandle* callers were updated to honour the corrected flag and to
  validate message length/time-stamp before accepting NTLM.
• Extra WPP traces added.


Security Impact
--------------------------------------------------------------------
Before the patch, a remote but authenticated attacker could bypass the
“Disable NTLM” or “Audit-only” policy and negotiate NTLM, resulting in
privilege escalation to the target server’s NT AUTHORITY\SYSTEM
context (network EoP).

Fix Effectiveness
--------------------------------------------------------------------
Static diff shows all code paths that previously forced bit 0x40 now
execute only after explicit policy approval; 0x400 clean-up stops false
positives.  Call-site validation logic now rejects malformed messages.
No remaining uncontrolled flag sources were found in the updated
functions, indicating the patch fully addresses the defect.
