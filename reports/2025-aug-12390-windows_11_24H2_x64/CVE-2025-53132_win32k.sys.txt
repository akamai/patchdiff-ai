{'patch_store_uid': '6bf219c7-e158-4eeb-925e-32c7e52da820', 'change_count': 4, 'kb': 'KB5063878', 'confidence': 0.18, 'cve': 'CVE-2025-53132', 'date': 1755086726.7512157, 'file': 'win32k.sys'}
--------------------------------------------------------------------
CVE-2025-53132 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
win32k.sys – Api-set host-resolution logic (functions ApiSetResolve*
/ ApiSetp* dealing with V7 api-set schemas)


Vulnerability Class
--------------------------------------------------------------------
Integer truncation / out-of-bounds index leading to kernel memory
corruption (CWE-190 / CWE-119)


Detailed Root Cause Analysis
--------------------------------------------------------------------
The vulnerable path starts in ApiSetResolveToHost().  When the api-set
schema version byte at *a1 equals 7 the helper
ApiSetResolveToHost_V7() is invoked.  That helper in turn performs a
hash lookup through ApiSetpSearchForSectionIndex_V7() in order to find
the redirect section that matches an incoming contract name.

Inside ApiSetpSearchForSectionIndex_V7() the number of hash entries is
obtained from *(_DWORD *)(a2+4) and stored in v13.

    v13 = *(_DWORD *)(a2 + 4);

No further validation is done; the value is assumed to be sane.  It is
used to compute a memory base and to drive a binary search which later
returns an index value:

    v15 = *(_DWORD *)a2 + v13 * *(BYTE *)(a2+8);
    v17 = v15 + 8 * v16 - *(WORD *)(a1+6);

If v13 is larger than the real table size the computed v17 pointer can
run far past the end of the section that resides inside the win32k
image.  Subsequent dereferences (DWORD reads for the hash and WORD read
for the returned index) therefore cross trusted kernel memory
boundaries and corrupt the kernel address-space layout.

Because the returned index is treated as unsigned in the caller, an
attacker can further use an oversized value to make subsequent address
calculations wrap into controlled data areas.  All downstream
call-sites (v29/v25/v15 calculations in ApiSetResolveToHost_V7) rely on
the index to address secondary arrays that finally yield a UNICODE
string descriptor.  Once an out-of-range index is accepted these paths
perform arbitrary kernel reads and, after length checks, potentially
kernel writes – enabling elevation of privilege.

Key structural fields involved
  * a1 – base of the loaded V7 api-set image (kernel-mode mapping)
  * a2 – section descriptor whose +4 member is the 32-bit entry-count
  * v13 / v14 – mutable loop bounds derived from the attacker-controlled
    32-bit entry count
  * Returned WORD index used by ApiSetResolve* arithmetic

The bug is purely arithmetic: a 32-bit entry count taken from
untrusted memory is never range-checked against the real 16-bit
allocation bounds and is later mixed with 16-bit offsets, opening the
door to pointer past-the-end dereferences.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable (before)
v13 = *(_DWORD *)(a2 + 4);        // untrusted 32-bit count
...
v17 = v15 + 8i64 * v16 - *(WORD *)(a1 + 6); // pointer arithmetic
...
return *(unsigned int *)(v17 + a1 + 4);      // out-of-range read
```

```c
// fixed (after)
v13 = *(unsigned __int16 *)(a2 + 4); // count truncated to 16-bit
...
if (v13 - 1 < 0)
    return 0xFFFF;                    // early fail
...
v17 = v15 + 8i64 * v16 - *(WORD *)(a1 + 18); // new, correct base
return *(unsigned __int16 *)(v17 + a1 + 4);   // safe WORD fetch
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User mode triggers win32k path that resolves an api-set name
   (e.g. CreatePerSessionWin32kCall).
2. ApiSetResolveToHost() detects schema V7 and calls
   ApiSetResolveToHost_V7().
3. ApiSetResolveToHost_V7() calls ApiSetpSearchForSectionIndex_V7() and
   passes a pointer to the untrusted section header.
4. ApiSetpSearchForSectionIndex_V7() reads the 32-bit entry count,
   performs unchecked pointer arithmetic, and returns an out-of-range
   index.
5. Callers use that index to compute further pointers; kernel memory
   past the legitimate api-set image is read/written, corrupting the
   kernel.


Attack Vector
--------------------------------------------------------------------
A local attacker able to feed a crafted Version-7 api-set binary into
win32k (for example by persuading the kernel to map a malicious image
from disk or memory) sets the entry-count field to a large value.  When
any victim thread resolves a contract name, the unchecked arithmetic in
ApiSetpSearchForSectionIndex_V7() is hit, leading to kernel memory
corruption and privilege escalation.

Exact delivery method (how to load an attacker-controlled V7 image) is
not visible in the diff and therefore remains unknown.


Patch Description
--------------------------------------------------------------------
1. ApiSetpSearchForSectionIndex_V7()
   • Treats the entry count at +4 as WORD, not DWORD.
   • Consistently returns 0xFFFF on failure.
   • Uses the correct structure base offset (a1+18) in pointer math.

2. ApiSetpResolveHost()
   • Re-worked version of ApiSetResolveToHost_V7() that recognises the
     0xFFFF failure code and aborts safely.

3. ApiSetpGetContractKeyInfo()
   • Additional character validation; a single leading '-' now causes
     immediate success with bounded indices, and '~' is rejected unless
     preceding fields are valid.  This removes another path that could
     leave uninitialised length values.

4. Call-sites updated to use the new helper and sentinel (0xFFFF),
   preventing accidental use of an invalid index.


Security Impact
--------------------------------------------------------------------
Before the patch an attacker-supplied 32-bit entry count could drive
pointer arithmetic beyond the actual api-set image, resulting in
out-of-bounds kernel reads and writes.  That enables local privilege
escalation (ring-0 arbitrary memory access) and system compromise.

After patch the entry count is clamped to 16-bit, the sentinel 0xFFFF
propagates failure, and all dependent offsets are validated, closing
both read and write primitives.


Fix Effectiveness
--------------------------------------------------------------------
The fix introduces proper width truncation, early bailout, and
consistent failure handling across the whole call chain.  No remaining
code path was observed that still trusts a 32-bit entry count.  The
patch therefore fully mitigates the identified overflow avenue;
residual issues are not apparent from the supplied diff.
