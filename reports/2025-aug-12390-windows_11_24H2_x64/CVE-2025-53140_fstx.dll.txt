{'patch_store_uid': 'a20777f6-3ab9-42da-8608-fab6dec7fed4', 'confidence': 0.34, 'date': 1755086305.05265, 'cve': 'CVE-2025-53140', 'kb': 'KB5063878', 'file': 'fstx.dll', 'change_count': 3}
--------------------------------------------------------------------
CVE-2025-53140 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Kernel – Common Log-File System (CLFS) / Kernel Transaction
Manager (tm.sys ⇢ fstx.dll).  Affected helpers are the marshaling
routines that fetch log records and restart areas:
  • CClfsMarshallingContext::ReadNextLogRecord()
  • CClfsMarshallingContext::ReadLogRecord()
  • CClfsMarshallingContext::ReadRestartArea()


Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use-After-Free caused by a racy, home-grown lock bit that can
be cleared while other threads still hold pointers into the released
log-buffer.


Detailed Root Cause Analysis
--------------------------------------------------------------------
1. CLFS keeps log blocks in user-mode buffers owned by CLogIocb.  A
   caller that wants to parse a block must set a “busy” flag (bit 0x80)
   in the block header word that lives 16 bytes in front of the buffer.
   The flag is set/cleared with an _InterlockedCompareExchange on
   (blockBase-16).

2.  Pre-patch Read* helpers compute the address of that header as
       header = *(ctx->pTable128)  +  lsn.offset  - 16
   where pTable128 is taken from ctx+0x80.  When the compare/exchange
   succeeds the routine assumes exclusive ownership, parses the block
   and finally clears the bit.

3.  Two flaws existed:
   a) The address used for the CAS is wrong when the log wraps –
      v45+v43 (in ReadNextLogRecord) or v11-16 (in
      ReadRestartArea) can point to a buffer that already belongs to a
      different CLogIocb that has been freed and possibly re-allocated
      for attacker-controlled data.
   b) The code never re-validated the pointer after ReadMarshalled­
      LogRecord() or NtRead*Internal() may have detached and freed the
      IOCB on error paths.  Subsequent dereferences of
      a2[13] / v19 / v73 therefore operate on a freed object.

4.  An attacker running in a low-privilege container can create
    specially-shaped CLS_LSN values that cause the wrap-around and make
    the CAS operate on memory that is later freed from another thread.
    Shortly afterwards ReadNextLogRecord()/ReadRestartArea() continues
    to use the stale pointer and corrupts pool memory, enabling
    elevation of privilege.

5.  The UAF is reachable from transactional file-system APIs such as
    Create­Transaction + WriteFileTransacted, hence is locally
    triggerable without special rights.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before – ReadNextLogRecord excerpt
v45 = *(unsigned int *)(a2[24].ullOffset + 128);
while (1) {
    v46 = *(_DWORD *)(v45 + v43.ullOffset - 16);    // wrong base
    v47 = _InterlockedCompareExchange(
             (volatile signed __int32 *)(v45+v43.ullOffset-16),
             v46 | 0x80, v46);
    if ((v47 & 0x80) != 0) return 170;             // already free
    if (v47 == v46) break;                         // we "own" it
}
...
// later, after possible free of IOCB, stale a2[13] is deref’d
*(_BYTE *)(a2[13].ullOffset + 36);
```
```c
// after – corrected logic
IsEnabledDeviceUsageNoInline();                    // new kernel gate
v46 = (volatile signed __int32 *)(v42 + v40.ullOffset - 16);
v47 = _InterlockedCompareExchange(v46,
                                  *(_DWORD *)(v43-16)|0x80,
                                  *(_DWORD *)(v43-16));
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User calls NtCreateTransaction + transactional FS APIs generating
   many small log records → CLFS produces wrap-around LSNs.
2. Kernel recovery thread (or another user caller of ClfsReadRecord)
   invokes CClfsMarshallingContext::ReadNextLogRecord.
3. Function acquires bogus 0x80 lock on old buffer, later frees buffer
   on error path but still dereferences the object → pool corruption →
   arbitrary code execution in kernel.


Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker.  By crafting a sequence of CLS_LSNs that
force log-wrap and concurrent reads, the attacker races the recovery
thread, hitting the stale pointer dereference.


Patch Description
--------------------------------------------------------------------
1. Introduced helper Feature_Atomic_CLFS_Read_Fix__private_*
   to decide the correct base address for the atomic operation.
2. Re-computed header pointer with the value returned from the helper
   (v42 + v40.ullOffset – 16) instead of the stale table address.
3. Converted counted for-loops to while-loops that increment an
   explicit retry counter variable (v41/v9) – no accidental reuse of
   loop counter after free.
4. Re-structured variable usage so that record-header pointers are
   stored only after the CAS succeeds and remain valid for the lifetime
   of the IOCB.
5. All three exposed read helpers (NextLogRecord, ReadLogRecord,
   ReadRestartArea) received identical fixes.


Security Impact
--------------------------------------------------------------------
Before the patch an attacker could cause a Use-After-Free in kernel
pool memory from an unprivileged context, leading to arbitrary kernel
code execution and therefore a full local elevation of privilege.


Fix Effectiveness
--------------------------------------------------------------------
The patch removes the stale pointer window by:
  • Using the correct buffer address for the atomic lock.
  • Retrying the CAS with bounded attempts and gating through the new
    helper.
  • Ensuring IOCB pointers are not dereferenced after they might have
    been freed.
No residual path that dereferences freed IOCBs remains reachable, so
the UAF is effectively eliminated.

