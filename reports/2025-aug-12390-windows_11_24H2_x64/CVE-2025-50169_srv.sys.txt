{'date': 1755086338.684133, 'kb': 'KB5063878', 'file': 'srv.sys', 'change_count': 4, 'cve': 'CVE-2025-50169', 'confidence': 0.26, 'patch_store_uid': '6120763f-a8c7-49e5-a66f-f4ac932e47c8'}
--------------------------------------------------------------------
CVE-2025-50169 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows SMB server driver (srv.sys) – routine
BlockingSessionSetupAndX (down-level Session Setup handling).

Vulnerability Class
--------------------------------------------------------------------
CWE-362: Race condition (concurrent execution using shared resource
with improper synchronisation) leading to CWE-415: double free /
use-after-free.

Detailed Root Cause Analysis
--------------------------------------------------------------------
BlockingSessionSetupAndX is executed in the context of a work-item
for every incoming SMB Session Setup request.  The routine allocates
and later releases a per-session security-context buffer that is
stored in the connection object at offset 0x3D0 (  *(_QWORD)(v4+976)
before patch ).

Before the patch the code flow was:

1.  If no security context is present, the code allocates an opaque
    buffer from non-paged pool:
        NonPagedPool = SrvAllocateNonPagedPool(size,21h, dialect )
        *(_QWORD)(v4+976) = NonPagedPool;

2.  No lock is taken around the "allocate-if-null" test.  Two worker
    threads processing SessionSetup for the same connection at the
    same time can both observe *(_QWORD)(v4+976)==NULL and will both
    allocate their own pool buffer.

3.  Later, when the second thread discovers that its attempt to store
    the buffer failed (because the first one already stored its own
    pointer) it executes the error path that calls
        SrvFreeNonPagedPool( NonPagedPool );
    while the first thread already inserted the very same pointer into
    the live connection object.  This produces a double free and, on a
    subsequent allocation, remote-controlled memory corruption.

4.  Because the whole sequence executes while the connection resource
    (at v4+544) is only held in *shared* mode, the race can be
    triggered remotely by sending two Session Setup requests on two
    different channels aimed at the same connection.

Patch behaviour:
    The rewritten function now enters the connection resource in
    exclusive mode *before* the security-context buffer test and
    allocation.  It also re-checks the pointer after the lock is
    obtained and only allocates when still NULL – eliminating the
    race.  Reference counting of the buffer is preserved and the error
    paths were updated so that only the owner frees the buffer.

Vulnerability Code Snippets
--------------------------------------------------------------------
Before (simplified):
```c
if (!*(_QWORD*)(v4+976)) {                    // 1. unsynchronised
    NonPagedPool = SrvAllocateNonPagedPool(sz,0x21,dial);
    if (!NonPagedPool) goto error;
    *(_QWORD*)(v4+976) = NonPagedPool;        // 2. store
}
...
if (failure) {
    SrvFreeNonPagedPool(NonPagedPool);        // 3. double free
}
```
After:
```c
ExAcquireResourceExclusiveLite(Resource, TRUE); // grab exclusive
if (!*(_QWORD*)(Conn+0x3D0)) {
    buf = SrvAllocateNonPagedPool(sz,0x21);
    if (buf)
        *(_QWORD*)(Conn+0x3D0) = buf;          // safe store
}
ExReleaseResourceLite(Resource);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker opens two SMB channels that share the same connection.
2. Sends two crafted Session Setup AndX requests in close succession.
3. Two worker threads enter BlockingSessionSetupAndX concurrently.
4. Both threads execute the unsynchronised allocate-if-null path.
5. First thread stores pointer; second thread frees its own pointer
   but the first still holds that value – double free.
6. Subsequent pool allocations lead to attacker-controlled memory
   reuse and remote code execution inside kernel.

Attack Vector
--------------------------------------------------------------------
Network.  An unauthenticated attacker sends specially timed SMB
SessionSetup requests over TCP/445 to a target machine running the
vulnerable srv.sys.

Patch Description
--------------------------------------------------------------------
1. Re-organised the allocation logic: the connection resource is now
   acquired exclusively before testing *(_QWORD)(v4+976).
2. Added second check after the lock to prevent double allocation.
3. All error paths updated so that only the thread that successfully
   inserted the buffer frees it; stray allocations are freed locally.
4. Numerous defensive size/offset checks were added, but the core fix
   is the introduction of correct synchronisation and bookkeeping.

Security Impact
--------------------------------------------------------------------
Before the fix a remote attacker could reliably induce a double free
in the non-paged pool of the kernel, leading to pool-use-after-free
and ultimately arbitrary code execution with kernel privileges.
Service crashes (BSOD) are also possible and were easy to reproduce.

Fix Effectiveness
--------------------------------------------------------------------
The exclusive acquisition of the connection resource serialises all
threads that reach the security-context allocation code.  The re-check
under the lock ensures that at most one allocation is performed.  All
follow-up free paths are symmetric and protected by reference counts.
No uncontrolled free of shared memory remains, removing the race
window.  Static analysis shows no remaining code paths where
*(_QWORD)(Conn+0x3D0) can be freed twice.
