{'kb': 'KB5062553', 'date': 1755075752.9789896, 'confidence': 0.14, 'patch_store_uid': '123aea0e-3084-4a8a-b2ab-fd72d1f05f51', 'change_count': 6, 'cve': 'CVE-2025-48807', 'file': 'vmcompute.exe'}
--------------------------------------------------------------------
Unknown-CVE Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Hyper-V host user-mode service vmcompute.exe (Compute Service).  The
changed code is inside the Windows Implementation Library (wil) helper
templates that manage kernel resources and inside the JSON marshal/
unmarshal helpers used by the Hyper-V Virtual-Machine configuration
path.

Vulnerability Class
--------------------------------------------------------------------
Resource-lifetime mismatch / invalid free (incorrect resource release).
The bug allows the service to call CloseHandle on a raw pointer that is
not a kernel handle and to call DestroyThreadPoolTimer on a real kernel
HANDLE, leading to memory corruption or the closure of an attacker
chosen handle.

Detailed Root Cause Analysis
--------------------------------------------------------------------
wil::details::unique_storage<TPolicy>::reset() is the central routine
that releases a previously owned resource and replaces it with a new
one.  Two independent template instantiations exist in vmcompute.exe:

1. unique_storage< resource_policy< PEAX,  CloseHandle …> >
   Expected resource type : generic HANDLE (void* / HANDLE)
   Correct release func   : CloseHandle

2. unique_storage< resource_policy< _TP_TIMER*, DestroyThreadPoolTimer …>
   Expected resource type : _TP_TIMER* (thread-pool timer pointer)
   Correct release func   : DestroyThreadPoolTimer

Before the patch the generated functions were *cross-wired*:
• The HANDLE specialisation executed DestroyThreadPoolTimer().
• The _TP_TIMER* specialisation executed CloseHandle().

That means:
• When a HANDLE (e.g. an RPC binding or event) is reset, the pointer is
  passed to DestroyThreadPoolTimer which treats the value as a pointer
  to an internal NT thread-pool structure, immediately dereferencing an
  invalid address and corrupting memory.
• When a _TP_TIMER* is reset, the raw pointer value is handed to
  CloseHandle/NtClose.  The kernel interprets the pointer as an object
  handle.  Because _TP_TIMER* values are user-mode heap addresses, an
  attacker controlling the earlier allocation can select a value that
  coincides with a valid HANDLE belonging to the vmcompute process, thus
  causing an unintended handle close or in certain circumstances double
  freeing the same underlying kernel object.

vmcompute runs under SYSTEM and communicates with guest VMs over a
privileged management channel; therefore a malicious guest that can
trigger creation and reset of a thread-pool timer or of the affected
unique_any wrappers can cause memory corruption in the service process,
ultimately yielding code-execution in the Hyper-V host context.

Additional hardening was applied to the ProcessorFeature marshalling
helpers: signed indices were changed to unsigned and a dedicated
EnumIndex() range check was added so that negative or oversized enum
values can no longer pass through JSON deserialisation.  This removes
secondary out-of-bounds read/write vectors that could otherwise aid in
exploitation.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// HANDLE specialisation – before (wrong):
if (*this) {
    wil::last_error_context ctx(&v5);
    DestroyThreadPoolTimer(v2);   // wrong function
}

// HANDLE specialisation – after (fixed):
if (*a1) {
    wil::last_error_context ctx(&v6);
    wil::details::CloseHandle(v2, v5); // correct
}

// _TP_TIMER* specialisation – before (wrong):
if (*this) {
    wil::last_error_context ctx(&v6);
    wil::details::CloseHandle(v2, v5); // wrong function
}

// _TP_TIMER* specialisation – after (fixed):
if (*a1) {
    wil::last_error_context ctx(&v5);
    DestroyThreadPoolTimer(v2);        // correct
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Management API (e.g. HCS RPC) causes vmcompute to create a
   thread-pool timer wrapped in unique_any_t.
2. Later, error handling or reconfiguration path calls reset(nullptr).
3. The bugged reset() chooses the wrong deleter:
   • HANDLE  -> DestroyThreadPoolTimer -> memory corruption.
   • _TP_TIMER* -> CloseHandle -> closes attacker-chosen handle or
     produces double-free of kernel object.
4. Corrupted heap / invalid handle state leads to arbitrary code
   execution in the vmcompute.exe process.

Attack Vector
--------------------------------------------------------------------
An authorised guest or management client sends crafted input that
forces vmcompute to allocate and then reset a thread-pool timer or a
HANDLE wrapped by the affected wil::unique_any_t specialisations.
Because timer creation is exposed through several RPC endpoints
(StartSiloContainerWorker, WindowsContainerLaunchAndConnect, etc.) a
guest can reach the vulnerable code remotely.

Patch Description
--------------------------------------------------------------------
1. Corrected the deleter used in each wil::details::unique_storage
   specialisation:
   • HANDLE policy now calls CloseHandle.
   • _TP_TIMER* policy now calls DestroyThreadPoolTimer.
2. Added exact EnumIndex validation for ProcessorFeature enums and
   changed intermediate variables from signed to unsigned to prevent
   negative indices.
3. Updated bounds check in InitializeProcessorFeatureSetProperty from
   0x74 to 0x7D reflecting the extended valid enum set.
4. Replaced destructors to the proper
   Config::VmWorkerProcess::ProcessorFeatureSet class.

Security Impact
--------------------------------------------------------------------
Prior to the fix an attacker could:
• Trigger an invalid pointer dereference leading to exploitable heap
  corruption, or
• Close/double-free an arbitrary kernel handle owned by the Hyper-V host
  process.
Either scenario can be developed into local privilege escalation or
remote code execution inside the host OS from a guest VM context.

Fix Effectiveness
--------------------------------------------------------------------
The patch aligns every resource_policy with its correct release
function, completely removing the cross-wired destructors.  In addition
it introduces defensive range checks when unmarshalling enum values.
No residual paths were observed in the diff; therefore the fix is
considered effective.
