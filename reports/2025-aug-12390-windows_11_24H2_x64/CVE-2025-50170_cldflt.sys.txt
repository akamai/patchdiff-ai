{'file': 'cldflt.sys', 'date': 1755089259.0807269, 'kb': 'KB5063878', 'patch_store_uid': '6bbf5beb-893e-495a-9242-532ac88ce415', 'cve': 'CVE-2025-50170', 'change_count': 3, 'confidence': 0.12}
--------------------------------------------------------------------
CVE-2025-50170 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Cloud Files Mini-Filter Driver (cldflt.sys) – function
HsmpOpCreatePlaceholders / sub_1C005EC54.

Vulnerability Class
--------------------------------------------------------------------
Improper Handling of Insufficient Permissions / Access Control
(CWE-280) leading to privileged write to user memory and local
Elevation of Privilege (EoP).

Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  The helper that creates placeholder files receives a caller-
    supplied buffer (parameter a4, Length) located in user space.
2.  Before the patch the driver did:
        IoAllocateMdl()
        ProbeForRead( userBuf )
        MmProbeAndLockPages( mdl, KernelMode, IoReadAccess )
    The pages are therefore locked **read-only** from the point of
    view of the memory manager.
3.  Later in the same routine the code **writes results back into the
    very same buffer**:
        v52[1]  = ...;
        *(DWORD *)(v25+48) = ...;
        *(QWORD *)(v25+72) = ...;
    `v52` is an element that points directly inside the mapped
    `MappedSystemVa` obtained from the MDL, i.e. the user buffer.
4.  Because the pages were only probed for read access the kernel ends
    up writing to user memory that may be mapped **read-only or even
    executable-only** for the caller.  An unprivileged process can
    therefore:
       • Map a read-only/executable page under its control.
       • Pass its address to the vulnerable IOCTL that reaches this
         routine.
       • Let the kernel fill attacker–controlled data into that page
         irrespective of the page protection.
5.  The write is performed in kernel context, so it bypasses the user
    mode page-protection mechanism, giving the attacker an
    arbitrary-kernel-write-into-read-only-user-page primitive.  The
    attacker can place executable code in such a page and later jump
    to it, effectively executing code with kernel privileges.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – pages locked read-only
MemoryDescriptorList = IoAllocateMdl(a4, Length, 0, 0, NULL);
ProbeForRead(a4, Length, 4);
MmProbeAndLockPages(MemoryDescriptorList, 1, IoReadAccess);
...
// later – kernel writes into user buffer
v52[1] = v72[1];
*(DWORD *)(v25 + 48) = *((DWORD *)EcpContext + 10);
*(QWORD *)(v25 + 72) = *((QWORD *)EcpContext + 6);
```
```c
// after patch – access mode decided dynamically, now writeable
v9  = IoAllocateMdl(a4, Length, 0, 0, NULL);
ProbeForRead(a4, Length, 4);
BOOL writeNeeded = sub_1C001D284() != 0;   // returns TRUE when the
                                           // routine will update the
                                           // buffer
MmProbeAndLockPages(v9, 1, (LOCK_OPERATION)writeNeeded);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User process sends FSCTL/IOCTL that ends in
   HsmpOpCreatePlaceholders.
2. Function locks caller buffer with **IoReadAccess** (pre-patch).
3. Placeholder parsing succeeds and driver updates entries:
      write into mapped buffer (status, timestamps, etc.).
4. If user supplied a read-only or executable page the write bypasses
   intended protection, granting elevation of privilege.

Attack Vector
--------------------------------------------------------------------
Any local user that can open the Cloud Files device (\\.\CldFlt or
mount point) and issue the placeholder-creation request can supply a
specially protected buffer to obtain a privileged write.

Patch Description
--------------------------------------------------------------------
1. Replaces hard-coded IoReadAccess with a runtime decision: helper
   `sub_1C001D284` returns whether the routine will modify the buffer;
   the result is cast to LOCK_OPERATION, selecting IoWriteAccess when
   writing is required.
2. Variable names cleaned up, but functional change is confined to the
   call:
       MmProbeAndLockPages( mdl, KernelMode, IoWriteAccess )
3. No other observable logic changes are necessary for the fix.

Security Impact
--------------------------------------------------------------------
Prior to the patch an attacker had a reliable arbitrary kernel write
into a user-mode page that the attacker controls but marks read-only.
By storing shellcode in an RX page and letting the driver overwrite
it, the attacker executes code in kernel mode, achieving full local
EoP.

Fix Effectiveness
--------------------------------------------------------------------
The new code requests IoWriteAccess when the buffer will be modified.
With this change `MmProbeAndLockPages` raises an exception if the pages
are not writable for the caller, aborting the operation before any
kernel write occurs.  This eliminates the privilege-escalation path.
No further writable operations into inadequately probed pages were
found in the patched routine.
