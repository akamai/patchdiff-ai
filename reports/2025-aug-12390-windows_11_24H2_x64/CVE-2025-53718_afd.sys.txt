{'file': 'afd.sys', 'change_count': 8, 'patch_store_uid': '230e7c66-244b-4041-b166-2157fff153a1', 'cve': 'CVE-2025-53718', 'date': 1755086312.9707887, 'kb': 'KB5063878', 'confidence': 0.3}
--------------------------------------------------------------------
CVE-2025-53718 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Ancillary Function Driver for WinSock (afd.sys) – several IOCTL
handlers (AfdGetAddress, AfdQueryHandles, AfdSetConnectData,
AfdExtractAfdSendMsgInfo, AfdBind and AfdUnBindSocket).

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use After Free (race between socket-operation paths and the
UnBind path allows freed endpoint/transport buffers to be re-used).

Detailed Root Cause Analysis
--------------------------------------------------------------------
An AFD endpoint keeps pointers to transport-layer objects, address and
control-data buffers, security descriptors and other pool allocations.
While a user process is allowed to issue multiple IOCTLs against the
same socket handle, the driver did not properly serialize the lifetime
of those internal allocations with the UnBind path.

1.  In the original AfdQueryHandles(), AfdSetConnectData(),
    AfdExtractAfdSendMsgInfo() and AfdGetAddress() implementations the
    code accesses endpoint fields (e.g.  E+0x18, E+0xF0, E+0x240 – the
    buffer that holds the bound address) without first stopping a
    concurrent AfdUnBindSocket() or without holding the endpoint spin
    lock (AddressHandleSpinLock @ +0x38).

2.  AfdUnBindSocket() frees exactly the same objects:
        * closes the file object at E+0x18 / handle at E+0x100,
        * frees the address buffer at E+0x240 with
          ExFreePoolWithTag(… , 'Fdlc'),
        * zeroes the pointers and marks the endpoint as un-bound
          (*(_BYTE*)E+2 = 1).

3.  A malicious process can, in one thread, call
    NtDeviceIoControlFile(IOCTL_AFD_UNBIND) while another thread is
    inside e.g. IOCTL_AFD_QUERY_HANDLES.  The second thread dereferences
    the now-freed pool pointer or transports table that UnBind has just
    released, leading to a classic UAF on pageable pool memory that is
    controlled by the attacker.

4.  The vulnerability existed because:
      •  Missing calls to AfdPreventUnbind() / AfdReallowUnbind() to
         block unbind during the vulnerable requests.
      •  Missing reference count or spin-lock around the endpoint’s
         buffer pointers (KeAcquireInStackQueuedSpinLock was introduced
         only in the patch).
      •  Early error-exit paths returned after calling
         AfdPreventUnbind() but before the matching AfdReallowUnbind(),
         leaving the endpoint in an inconsistent state.

Once freed memory is re-allocated by the attacker and later used by the
kernel, arbitrary kernel read/write is possible, yielding SYSTEM
privileges.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// AfdQueryHandles – BEFORE (simplified)
if ((word*)(E+0x00)[0] != AFD1 && …)
{
    // no PreventUnbind – endpoint can be freed here
    Src = *(void**)(E+0x18);            // may be dangling
    ObOpenObjectByPointer(Src, …);      // UAF
}

// AFTER
if (FeatureEnabled && must_block_unbind)
{
    if (!AfdPreventUnbind(E))           // new life-time guard
        return STATUS_UNBIND_IN_PROGRESS;
    unbind_blocked = 1;
}
...
// finally
if (unbind_blocked)
    AfdReallowUnbind(E);
```

```c
// AfdExtractAfdSendMsgInfo – AFTER
KeAcquireInStackQueuedSpinLock((PKSPIN_LOCK)(E+0x38), &LockHandle);
Size = *(DWORD*)(E+0xA4);               // safe read of address buffer
...
KeReleaseInStackQueuedSpinLock(&LockHandle);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Thread-A: socket = socket();
2. Thread-A: DeviceIoControl(socket, IOCTL_AFD_QUERY_HANDLES,…)
   -> enters AfdQueryHandles(), dereferences E+0x18.
3. Thread-B (same process): DeviceIoControl(socket, IOCTL_AFD_UNBIND,…)
   -> AfdUnBindSocket() frees pool @E+0x18 / 0x240 and zeroes them.
4. Scheduler switches back to Thread-A – it continues to use the stale
   pointer, causing a use-after-free.

Attack Vector
--------------------------------------------------------------------
Local, non-privileged user code that owns a Winsock socket handle can
issue crafted IOCTLs to \\Device\\Afd while racing an UnBind request.
No special privileges are required beyond the ability to open a socket.

Patch Description
--------------------------------------------------------------------
Microsoft added comprehensive lifetime guards:
1.  Systematic calls to AfdPreventUnbind() on entry and balanced
    AfdReallowUnbind() on every exit path.
2.  Added KeAcquireInStackQueuedSpinLock() around reads of mutable
    endpoint members.
3.  Added extra parameter validation so that early-exit paths happen
    before PreventUnbind(), avoiding imbalance.
4.  Added reference-counting of transport/connection objects before they
    are accessed and ensured they are closed only after use.
5.  Cleaned up error-handling so that all resources are released and the
    unbind lock is always dropped.

Security Impact
--------------------------------------------------------------------
The race allowed kernel-mode use-after-free, giving a local attacker the
ability to corrupt kernel memory and elevate privileges to SYSTEM.
Remote exploitation is not possible, but local EoP breaks the kernel
security boundary.

Fix Effectiveness
--------------------------------------------------------------------
The modified code now guarantees that an endpoint cannot be un-bound
while a vulnerable IOCTL handler operates.  All internal pointers are
used only while the spin lock is held and while an extra reference or
prevent-unbind token is active.  Early-error paths also re-enable
unbind.  As a result the freed memory can no longer be referenced, fully
eliminating the UAF condition.
