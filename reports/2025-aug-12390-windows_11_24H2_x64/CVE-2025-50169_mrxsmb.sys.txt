{'date': 1755086356.2723403, 'file': 'mrxsmb.sys', 'patch_store_uid': 'a2af071f-5a1d-4024-b8f6-c27f25f86710', 'confidence': 0.12, 'change_count': 7, 'cve': 'CVE-2025-50169', 'kb': 'KB5063878'}
--------------------------------------------------------------------
CVE-2025-50169 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows SMB client kernel driver (mrxsmb.sys) – QUIC connect /
disconnect state-machine and redirector connection context
(RX_CONNECTION / SMB_QUIC_CONN) management code.

Vulnerability Class
--------------------------------------------------------------------
CWE-362: Race condition leading to use-after-free / double-free of a
shared kernel object.

Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  Each SMB QUIC connection context keeps an EX_RUNDOWN_REF at offset
    0xD8 (pseudonym “Conn->Rundown”).  Holding rundown protection is the
    only guard that prevents the structure from being freed while
    asynchronous MsQuic callbacks are still operating on it.

2.  In SmbQuicInitiateAsynchronousConnect() the original implementation
    unconditionally acquired two rundown counts:
        ExAcquireRundownProtectionEx(&Conn->Rundown, 2);
    The local variable v4 was set to the constant ‘2’ and, on every
    failure path, the function executed
        ExReleaseRundownProtectionEx(&Conn->Rundown, v4);

3.  Parallel code paths – most importantly
    SmbQuicDisconnectEvent(),
    SmbQuicConnEventPeerCertificateReceived() and
    RxCeCompleteConnectRequest() – released the same rundown reference
    again when they were invoked by MsQuic after a network error.  The
    subsequent double-release could complete rundown while other
    threads still held raw pointers to the connection, generating a
    use-after-free window that an attacker could exploit with network
    traffic that immediately re-allocates the freed memory.

4.  Because the two releases occur on different CPUs and no additional
    synchronisation is present, the window is purely time-of-check vs
    time-of-use – a classic race condition (CWE-362) that leads to a
    double-free (CWE-415) and ultimately to arbitrary kernel code
    execution.

5.  The patch introduces a per-feature reference accounting scheme:
    • The number of rundown counts acquired is now
        n = 2 + Feature_IsEnabledDeviceUsage_5();
    • On failure paths the code only releases the counts when the same
      feature flag is *disabled*, ensuring that every release exactly
      matches a previous acquire.
    • Disconnect, completion and logging routines were updated to test
      the same feature flag before touching the object, eliminating the
      previously uncontrolled extra release.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
v4 = 2;                             // constant
ExAcquireRundownProtectionEx(v1+216, 2u);
...
LABEL_36:
if (v4)
    ExReleaseRundownProtectionEx(v5, v4); // may run twice
```
```c
// after
v4 = ((unsigned int)Feature_IsEnabledDeviceUsage_5() != 0) + 2;
ExAcquireRundownProtectionEx(v1+216, v4);
...
LABEL_36:
if (!Feature_IsEnabledDeviceUsage_5() && v4)
    ExReleaseRundownProtectionEx(v5, v4); // balanced
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Remote host opens many SMB sessions to the victim.
2. Each session forces the client to enter
   SmbQuicInitiateAsynchronousConnect().
3. Crafted traffic immediately resets the QUIC connection causing
   SmbQuicDisconnectEvent() to fire before the initiate path finishes.
4. Initiator and disconnect paths run concurrently:
   • both execute ExReleaseRundownProtectionEx() on the same object.
5. Rundown completes, memory is freed; the still-running callback now
   operates on freed memory – attacker-controlled data – leading to
   kernel RCE.

Attack Vector
--------------------------------------------------------------------
Unauthenticated attacker sends a sequence of specially-timed SMB/QUIC
packets over the network to repeatedly start and abort connections,
probing until the double-release race is won.

Patch Description
--------------------------------------------------------------------
1. Reference accounting rewritten – number of rundown references taken
   is now feature-dependent and decremented only by the thread that
   originally incremented it.
2. All disconnect / completion paths test the same feature flag before
   attempting to drop rundown references.
3. Extra bookkeeping variables (v42 etc.) added so that worker-thread
   dispatch uses the correct NTSTATUS return when updating per-context
   counters, preventing secondary early releases.
4. Non-functional changes (new WPP GUID tables, renamed globals) are
   trace-logging only.

Security Impact
--------------------------------------------------------------------
Prior to the fix, a remote attacker could trigger a use-after-free in
kernel mode and execute arbitrary code with SYSTEM privileges, leading
to full remote compromise (CVE-2025-50169).

Fix Effectiveness
--------------------------------------------------------------------
The patched code guarantees a 1:1 relationship between
ExAcquireRundownProtectionEx() and ExReleaseRundownProtectionEx() even
under simultaneous connect/disconnect activity.  Because rundown now
cannot complete prematurely, the connection object is no longer freed
while still in use, eliminating the previously exploitable race
window.  No alternate path releasing the rundown without an acquire was
found in the updated code, making the fix comprehensive.
