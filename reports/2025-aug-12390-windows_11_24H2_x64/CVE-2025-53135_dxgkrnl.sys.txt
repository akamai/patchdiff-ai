{'cve': 'CVE-2025-53135', 'change_count': 33, 'date': 1755086799.300542, 'patch_store_uid': 'cee7f502-5c15-4036-bc3b-c01349c9ae48', 'file': 'dxgkrnl.sys', 'kb': 'KB5063878', 'confidence': 0.27}
--------------------------------------------------------------------
CVE-2025-53135 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows DirectX graphics kernel driver (dxgkrnl.sys) – routine
DxgkCddDisable().  All desktop GPU vendors are affected because the
routine is part of the generic kernel display infrastructure.

Vulnerability Class
--------------------------------------------------------------------
CWE-362: Race condition leading to use-after-free / elevation of
privilege.

Detailed Root Cause Analysis
--------------------------------------------------------------------
DxgkCddDisable() is entered from user mode (win32k) with a caller
supplied DXGDEVICE handle (parameter a1).  The routine performs the
following sequence:

1.  It validates the handle under a shared push-lock stored at
    DXGPROCESS+0xF8 (code: AcquireShared on Current+248).
2.  After checking the handle type the function fetches the device
    pointer ( DXGDEVICE* ) from the per-process handle table and saves
    it to a local variable (v62 in the old build, v53 in the patched
    build).
3.  The push-lock is immediately released (ExReleasePushLockSharedEx),
    leaving the function with only a raw pointer and **no reference** or
    exclusive synchronisation.
4.  A long and complex sequence of operations that follow (flushing of
    presents, removal of VIDPN paths, SetDisplayModeInfo,
    SetPartOfDesktop, etc.) dereference the device object and the
    underlying ADAPTER_DISPLAY structure many times while other
    threads are free to destroy the same object through
    NtGdiDdDDIDestroyDevice / handle close.

Because no reference is taken and only a shared lock is held during the
brief lookup window, another thread can concurrently drop the last
reference to the DXGDEVICE and free the memory.  DxgkCddDisable()
continues to operate on the stale pointer, yielding a use-after-free.
An attacker running in the same session can win the race by repeatedly
opening / closing the handle while issuing the disable ioctl, leading
to controlled kernel heap corruption and ultimately SYSTEM-level
privilege escalation.

Vulnerability Code Snippets
--------------------------------------------------------------------
Before (simplified):
```c
DXGPUSHLOCK::AcquireShared(Current + 0xF8);
ptr = HandleTable[idx].Object;          // no refcount
ExReleasePushLockSharedEx(Current+0xF8);
KeLeaveCriticalRegion();
// ptr is used for hundreds of lines without further protection
```

After patch:
```c
DXGPUSHLOCK::AcquireShared(Current + 0xF8);
ptr = HandleTable[idx].Object;
ExReleasePushLockSharedEx(Current+0xF8);
KeLeaveCriticalRegion();

// NEW: take an exclusive device lock BEFORE dereference window
DXGDEVICEACCESSLOCKEXCLUSIVECDD lock(ptr);
COREDEVICEACCESS devAcc(ptr, TRUE);     // guarantees lifetime
```
(The lock is released only after all operations are complete.)
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Low-privilege client issues the win32k "CDD_DISABLE" call,
   eventually invoking DxgkCddDisable() in dxgkrnl.
2. Thread A (attacker) holds the ioctl and pauses after the shared lock
   is released.
3. Thread B (same process) closes the same hDevice; reference count
   reaches zero and DxgkDestroyDevice frees the object.
4. Thread A resumes, dereferencing freed memory and corrupting kernel
   data structures under attacker control.

Attack Vector
--------------------------------------------------------------------
Requires local code execution with the ability to open a DXGDEVICE
handle (any desktop application).  No special privileges are needed; a
sandboxed AppContainer can reach the ioctl.  The race is purely
local.

Patch Description
--------------------------------------------------------------------
The security update introduces lifetime-safe access to the DXGDEVICE:

•  Immediately after obtaining the raw pointer the code constructs a
   DXGDEVICEACCESSLOCKEXCLUSIVECDD object and a COREDEVICEACCESS guard,
   both of which increment the device’s reference count and serialise
   against destruction.
•  The reference is held for the whole function scope and released only
   after all dereferences are finished.
•  Additional defensive logging and stricter handle-type checks were
   added, but they are ancillary.

Security Impact
--------------------------------------------------------------------
Prior to the fix an attacker could obtain an arbitrary increment /
write-what-where primitive in kernel space by recycling the freed
DXGDEVICE slab with crafted data, allowing privilege escalation to
SYSTEM.  The bug does not provide initial code execution but converts
any low-integrity execution context into full kernel control.

Fix Effectiveness
--------------------------------------------------------------------
The exclusive device lock together with the reference count eliminates
all time-of-check/time-of-use gaps between handle validation and object
use.  The DXGDEVICE can no longer be freed while DxgkCddDisable()
operates on it, closing the race window and neutralising the
vulnerability.

