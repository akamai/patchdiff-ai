{'patch_store_uid': '6a27cc8b-3828-4b5b-abf8-9eb8f07a708f', 'file': 'rastls.dll', 'confidence': 0.27, 'change_count': 4, 'kb': 'KB5063878', 'date': 1755086332.2642686, 'cve': 'CVE-2025-50159'}
--------------------------------------------------------------------
CVE-2025-50159 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Remote Access Service (RAS) – rastls.dll, Point-to-Point Protocol
(PPP) Extensible Authentication Protocol over TLS/PEAP certificate
handling helper GetCertContextUsingCAPI().

Vulnerability Class
--------------------------------------------------------------------
Use After Free (CWE-416)

Detailed Root Cause Analysis
--------------------------------------------------------------------
GetCertContextUsingCAPI() acquires two dependent CryptoAPI handles:
  • phProv  – HCRYPTPROV (CSP / KSP provider context)
  • phUserKey – HCRYPTKEY obtained from the above provider

According to CryptoAPI contract, every key handle keeps an internal
reference to its provider and therefore **the key must be destroyed
before the provider is released**.

In the pre-patch implementation the cleanup code executes in the
wrong order:
    if (phProv)   CryptReleaseContext(phProv, 0);
    if (phUserKey) CryptDestroyKey(phUserKey);

Consequently CryptDestroyKey() operates on a key whose backing
provider context has already been freed. Inside the CSP this results
in a dangling pointer dereference – a classic use-after-free.  Because
PPP EAP-TLS runs inside the RAS service (LocalSystem), a local attacker
who can cause RAS to load a malicious CSP/KSP or smart-card mini
driver, or merely race heap reuse, can corrupt memory in the service
process and execute arbitrary code with SYSTEM privileges.

The bug is triggered on every error or success exit path; no other
sanity checks exist to prevent the hazardous order.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
LocalFree(v3);
LocalFree((HLOCAL)szContainer);
if (phProv)
    CryptReleaseContext(phProv, 0);   // provider first (wrong)
if (phUserKey)
    CryptDestroyKey(phUserKey);       // key after free => UAF
```
```c
// after (feature-gated)
if (FeatureEnabled()) {
    if (phUserKey)
        CryptDestroyKey(phUserKey);   // key first (correct)
    if (phProv)
        CryptReleaseContext(phProv,0);
} else {                              // legacy path kept for fallback
    if (phProv)
        CryptReleaseContext(phProv,0);
    if (phUserKey)
        CryptDestroyKey(phUserKey);
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker causes RAS to start PEAP/EAP-TLS authentication.
2. rastls.dll -> EapPeap* -> GetCertContextUsingCAPI() to build a
   CERT_CONTEXT.
3. Function allocates provider + key handles.
4. On exit, the old cleanup sequence frees provider then key.
5. Key-destruction runs on freed memory, corrupting heap/CSP data.
6. Crafted CSP can exploit the dangling pointer to execute code in the
   RAS context (LocalSystem).

Attack Vector
--------------------------------------------------------------------
Local authorised attacker registers or supplies a malicious smart card
CSP/KSP and initiates PPP EAP-TLS authentication (e.g., with the
"rasdial" client).  When GetCertContextUsingCAPI() cleans up, the CSP
receives a second call on a dangling provider pointer and gains
arbitrary memory control, leading to privilege elevation.

Patch Description
--------------------------------------------------------------------
The fix simply ensures correct destruction order:
  • Introduces a new Wil feature flag (id 2578215227).
  • When the flag is enabled, CryptDestroyKey() is called **before**
    CryptReleaseContext().
  • Retains legacy order behind a feature switch for staged rollout.
  • Trace-logging GUIDs were regenerated; no functional impact.

Security Impact
--------------------------------------------------------------------
Prior to the patch, any PPP EAP-TLS session could be used to trigger a
use-after-free inside the CryptoAPI provider.  Exploitation allows
arbitrary code execution in the RAS service, yielding SYSTEM level
privilege escalation.

Fix Effectiveness
--------------------------------------------------------------------
Releasing the key before the provider removes the dangling provider
reference and eliminates the UAF condition.  The mitigation is gated
by a feature flag; effectiveness therefore relies on the flag being
active on the target system.  No residual paths calling provider
before key were observed in the patched diff, so the fix is considered
complete when the feature is enabled.
