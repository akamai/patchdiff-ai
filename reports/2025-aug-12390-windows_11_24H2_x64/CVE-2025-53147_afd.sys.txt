{'confidence': 0.15, 'file': 'afd.sys', 'patch_store_uid': '230e7c66-244b-4041-b166-2157fff153a1', 'change_count': 8, 'cve': 'CVE-2025-53147', 'kb': 'KB5063878', 'date': 1755089294.5137217}
--------------------------------------------------------------------
CVE-2025-53147 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Ancillary Function Driver for WinSock (afd.sys) – code paths
handling socket bind / un-bind and various query helpers
(AfdUnBindSocket, AfdGetAddress, AfdQueryHandles, AfdExtractAfdSendMsgInfo,
AfdSetConnectData, AfdBind).

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use-After-Free (time-of-check / time-of-use race on a freed
pool buffer).

Detailed Root Cause Analysis
--------------------------------------------------------------------
1. Every AFD endpoint keeps a pointer to the buffer that describes the
   local address bound to the socket:
      +0x0EC  LocalAddressLength  (DWORD  at offset 0xEC / 236)
      +0x0F0  LocalAddress        (PVOID  at offset 0xF0 / 240)
   (layout name taken from public symbols).

2. AfdUnBindSocket frees that buffer when a user issues the *AFD_IOCTL
   Unbind* request:
   a. The code reaches the *else* branch (no transport-level endpoint).
   b. It calls ExEnterCriticalRegionAndAcquireResourceExclusive on the
      global AFD resource **only**, then immediately:
         ExFreePoolWithTag( Endpoint->LocalAddress, 0x41646C6C );
         Endpoint->LocalAddress        = NULL;
         Endpoint->LocalAddressLength = 0;
   c. The global resource is released, and the request returns.
   No per-endpoint spin-lock is taken while freeing the buffer.

3. Several helper paths (GetAddress, QueryHandles, ExtractSendMsgInfo,
   SetConnectData, …) copy that same buffer back to user or to the
   transport **without any synchronisation** in the original code:
      Length  = *(DWORD *)(Ep + 0xEC);
      memcpy( dst, *(PVOID *)(Ep + 0xF0), Length );

4. A racing sequence therefore exists:
   • Thread A : calls IOCTL_AFD_UNBIND  → frees LocalAddress.
   • Thread B : in parallel issues IOCTL_AFD_GET_ADDRESS (or others) and
                dereferences the stale pointer after the pool block has
                been freed / reused.
   The stale read occurs in arbitrary IRQL and the freed pool block is
   fully attacker-controlled after being re-allocated, leading to kernel
   memory disclosure or, via crafted re-allocation, elevation of
   privilege.

5. The vulnerability is reachable from user mode by any account that
   owns a socket handle – no additional privileges are required.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// AfdUnBindSocket  (before)
ExEnterCriticalRegionAndAcquireResourceExclusive(AfdGlobalData);
ExFreePoolWithTag(*(PVOID *)(Ep + 0xF0), 'AFdL');
*(PVOID *)(Ep + 0xF0) = NULL;           // LocalAddress
*(DWORD *)(Ep + 0xEC) = 0;              // Length
ExReleaseResourceAndLeaveCriticalRegion(AfdGlobalData);
```
```c
// AfdExtractAfdSendMsgInfo  (before)
Size = *(DWORD *)(Ep + 0xEC);
memmove(UserDst, *(PVOID *)(Ep + 0xF0), Size);   // no lock, UAF!
```
```c
// AfdExtractAfdSendMsgInfo  (after)
KeAcquireInStackQueuedSpinLock((PKSPIN_LOCK)(Ep + 0x38), &Lock);
Size = *(DWORD *)(Ep + 0xEC);
Src  = *(PVOID *)(Ep + 0xF0);
KeReleaseInStackQueuedSpinLock(&Lock);
memmove(UserDst, Src, Size);                      // safe
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. T1 : socket-owner calls DeviceIoControl(…, IOCTL_AFD_UNBIND, …)
         → AfdDispatch → AfdUnBindSocket → frees LocalAddress.
2. T2 : concurrently issues IOCTL_AFD_GET_ADDRESS / AFD_SENDMSG /
         AFD_QUERY_HANDLES …
3. Helper routine copies from freed pool block, operating in kernel
   context → use-after-free and controlled memory access.

Attack Vector
--------------------------------------------------------------------
Local user possessing a socket handle starts two threads: one continually
unbinds the socket while the second performs any of the affected AFD
ioctls that read the local address.  By grooming the pool the attacker
can cause privilege escalation or information disclosure.

Patch Description
--------------------------------------------------------------------
Microsoft rewrote all participants of the race:
1. Reader paths (GetAddress, ExtractAfdSendMsgInfo, SetConnectData,
   QueryHandles, …) now acquire the endpoint’s internal spin-lock
   (offset +0x38) before touching LocalAddress/Length and re-validate the
   data after the lock is held.
2. AfdUnBindSocket’s fast path was hardened – extra state checks were
   inserted and, if a transport end-point still exists, the code now
   refuses to unbind (returns STATUS_INVALID_DEVICE_STATE) or performs
   a safe two-phase close.
3. Multiple *AfdPreventUnbind* / *AfdReallowUnbind* and feature-flag
   gates were added so that unbind cannot proceed while another thread
   holds a reference obtained by the reader helpers.
4. Defensive copies and length checks were added for buffers ≤0x100
   bytes and for CMSG handling.

Security Impact
--------------------------------------------------------------------
Before the patch any local user could obtain an arbitrary kernel-pool
use-after-free, leading to EoP (SYSTEM) or information disclosure.  The
race is reliable because both sides execute in arbitrary process
context, no timing constraints exist (standard pool).

Fix Effectiveness
--------------------------------------------------------------------
Synchronising every read of LocalAddress with the same spin-lock that is
implicitly held (or, for the slow path, by blocking unbind) removes the
TOCTOU window; the pointer is now either alive for the whole critical
section or unbind is denied.  No obvious paths remain where the endpoint
structure is accessed without the lock, therefore the fix is considered
complete.
