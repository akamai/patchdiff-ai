{'date': 1755089240.4609733, 'file': 'afd.sys', 'kb': 'KB5063878', 'patch_store_uid': '230e7c66-244b-4041-b166-2157fff153a1', 'cve': 'CVE-2025-53137', 'confidence': 0.14, 'change_count': 8}
--------------------------------------------------------------------
CVE-2025-53137 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows kernel-mode driver  
File: afd.sys (Ancillary Function Driver for WinSock)  
Functions affected: AfdUnBindSocket, AfdGetAddress, AfdQueryHandles, 
AfdExtractAfdSendMsgInfo, AfdBind, AfdTLCreateEndpointComplete, 
DriverEntry and helpers.


Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use-After-Free (UaF)


Detailed Root Cause Analysis
--------------------------------------------------------------------
1. The TL (Transport-Layer) endpoint held inside the AFD endpoint
   structure is changed during socket un-bind.  The original routine
   (AfdUnBindSocket, before patch) performs the following sequence on
   the success path of the TL_CREATE request when the endpoint owns a
   dual-mode transport (EAFL_TL_BASE):

      a.  Builds a synchronous TL_CREATE IRP and waits for completion.
      b.  Stores returned pointers (  v38  &  v39 – TL FILE_OBJECT and
          function table  ) in     local variables only.
      c.  **Replaces**   E+0x10 / E+0x18 (SavedFileObject / FunctionTbl)
          with the newly returned pointers **before** the old pair is
          closed.
      d.  Immediately closes the old TL endpoint through an indirect
          call   (*v15)(oldFileObject, CloseReq)  without keeping any
          reference on that object.

2. Because no extra reference is taken, the close routine may free the
   old TL endpoint and the function-pointer table while the caller is
   still inside AfdUnBindSocket.  Subsequent indirect calls through the
   same table (or access to other fields inside the freed object) are
   therefore made on freed memory – a classic UaF.

3. An unprivileged local client can reliably reach this code path by
   issuing IOCTL_AFD_UNBIND and crafting the address data so that the
   driver enters the   (v9 & 0x100)   branch (IPv6 dual stack / base
   endpoint case).  In parallel the attacker reclaims the freed pool in
   user-controlled data, converting the UaF into an arbitrary kernel
   code execution primitive and elevating privileges.

4. Additional UaF windows existed in the IPv4-mapped branch
   ( (v9 & 0x200) != 0 ) where   (*v19)(oldFileObject, CloseReq)   is
   invoked unconditionally, even when the returned   v19   pointer is
   NULL.

5. No privilege checks are performed; the bug is reachable from any
   user process that holds a Winsock handle.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// afd!AfdUnBindSocket – before patch
v14 = *(_QWORD *)(ep + 0x10);          // old FO
v15 = *(FN **)(ep + 0x18);             // old function table
*(_QWORD *)(ep + 0x10) = v38;          // new FO
*(_QWORD *)(ep + 0x18) = v39;          // new table
...
// close old TL endpoint – UaF window
KeResetEvent(&Evt);
v31[0] = AfdSynchronousTlCloseRequestComplete;
if ( (*v15)(v14, v31) == STATUS_PENDING )   // v15 already freed
    KeWaitForSingleObject(&Evt,...);
```

```c
// after patch
v21  = *(_QWORD *)(ep + 0x10);
v22  = *(FN **)(ep + 0x18);
...
if (FeatureFlag && v22) {              // new NULL / feature gate check
    KeResetEvent(&Evt);
    Req[0] = AfdSynchronousTlCloseRequestComplete;
    if ( (*v22)(v21, Req) == STATUS_PENDING )
        KeWaitForSingleObject(&Evt,...);
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User calls   bind()   then   WSAIoctl( SIO_AF_UNBIND )  on the same
   socket.
2. afd.sys -> AfdDispatchDeviceControl -> AfdUnBindSocket.
3. Driver allocates/initialises synchronous TL_CREATE request.
4. On success, driver swaps the TL endpoint pointers and closes the old
   endpoint via function table obtained from the **freed object**.
5. Freed object memory is re-used – UaF leads to code execution in
   kernel context.


Attack Vector
--------------------------------------------------------------------
Local, authenticated user.  No special privileges are needed beyond the
ability to open a Winsock socket and issue IOCTL_AFD_UNBIND.


Patch Description
--------------------------------------------------------------------
• Added feature-flag gates and NULL checks before indirect calls to
  TL-provider function tables (v22/v15).
• Deferred pointer replacement until **after** successful close, or
  closes only when a valid function table is present.
• Introduced additional reference counting via AfdRefTLBaseEndpoint / 
  AfdDerefTLBaseEndpoint so the old TL FILE_OBJECT cannot be freed
  prematurely.
• Hardened many ancillary paths (Bind, GetAddress, QueryHandles, Send,
  DriverEntry) to block unbind in unsafe states and to re-allow it only
  under guarded conditions (AfdPreventUnbind / AfdReallowUnbind).


Security Impact
--------------------------------------------------------------------
Before the fix a local attacker could trigger a kernel use-after-free
and achieve arbitrary code execution in kernel-mode, yielding SYSTEM
privileges (Elevation of Privilege).


Fix Effectiveness
--------------------------------------------------------------------
The new code ensures that:
• The old TL endpoint is closed only when its function table pointer is
  still valid (non-NULL) and a reference is held.  
• Additional feature gating rejects dangerous unbind requests in mixed
  socket states.  
• Pointer swaps are now atomic with respect to lifetime management.  
No further UaF condition is reachable via IOCTL_AFD_UNBIND under the
same scenario, indicating the patch fully mitigates CVE-2025-53137.
