{'kb': 'KB5063878', 'confidence': 0.19, 'patch_store_uid': '8600729a-0fa6-46e3-abfb-1d30f651940e', 'file': 'msdtcprx.dll', 'change_count': 21, 'date': 1755089313.584256, 'cve': 'CVE-2025-50166'}
--------------------------------------------------------------------
CVE-2025-50166 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Distributed Transaction Coordinator (MSDTC)
user-mode proxy library  "msdtcprx.dll"  – several helper string
routines (StringCchCopy*/StringCchPrintf*/DuplicateString/…)
used by higher-level request-parsing code.

Vulnerability Class
--------------------------------------------------------------------
Integer overflow / wrap-around leading to out-of-bounds copy and
information disclosure.

Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  A family of home-grown “safe” string helpers lived in
    msdtcprx.dll (e.g. StringCchCopyW, StringCchCopyA,
    StringCchPrintfW, DuplicateString).  They attempted to validate
    the destination buffer size with 32-bit arithmetic:
       (unsigned __int64)(cchDest-1) <= 0x7FFFFFFE
       2147483646 ‑ cchDest

2.  The helpers accepted the destination length as 64-bit
    (size_t/ULONGLONG) but later cast it to a 32-bit signed constant
    (0x7FFFFFFE).  If an attacker supplied a very large length value
    (>= 0x80000000) the subtraction wrapped, producing a huge
    *negative* v3/v8 counter.

3.  The subsequent copy loop used that negative counter as the trip
    variable, causing it to execute unbounded until the first NUL is
    encountered in the source.  Data beyond the end of the caller’s
    buffer were therefore written/read, leaking heap contents into
    protocol replies.

4.  The vulnerable helpers were broadly reused:
      • AppendComsvcsFileVersion
      • GetLoadedDllFileVersion
      • DuplicateString
      • ParseResponseFromTm / GetTmInstanceInfoFromTm …
    Any network request that carried an over-sized length field
    ultimately propagated into these helpers and triggered the
    overflow.

5.  Because MSDTC messages are echoed back to the remote caller, the
    out-of-bounds memory is disclosed over the wire – an information
    disclosure flaw.

Parameters / structures involved:
    a2 / cchDest         – user-controlled 64-bit length
    v3/v8 counters       – signed 32-bit result of (0x7FFFFFFE-a2)
    destination buffer   – usually 0x100-0x400 byte stack/heap array

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – StringCchCopyW
if ((unsigned __int64)(a2 - 1) > 0x7FFFFFFE)
    …
else {
    v3 = 2147483646 - a2;   // wraps for a2 > 0x7FFFFFFE
    do {
        if (!(v3 + a2)) break;   // v3 is negative => always true
        *dest = *src++;          // OOB write
    } while (a2--);
}
```
```c
// after patch – StringCchCopyW
result = StringValidateDestW(dest, cchDest, src);
if (result >= 0)
    return StringCopyWorkerW_0_0(...);   // size-checked helper
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Remote client sends crafted MSDTC message with a bogus length.
2. Server-side parser copies the value into  *cchDest*  argument.
3. Vulnerable StringCchCopy*/Printf helper invoked.
4. 2147483646-cchDest wraps ➜ negative loop counter.
5. Copy reads/verifies beyond buffer ➜ memory disclosed in reply.

Attack Vector
--------------------------------------------------------------------
An authenticated network attacker (RPC/COM caller) sends a message
containing an abnormally large length (>= 0x80000000).  When MSDTC
handles the request the integer wrap leads to out-of-bounds memory
being copied into the response, leaking process memory to the
attacker.

Patch Description
--------------------------------------------------------------------
• Entire helper family replaced with central, size-t aware
  primitives  StringValidateDestW/ StringCopyWorker*/ StringVPrintf…
  that strictly validate  (dest_len <= _countof(dest))  using
  64-bit arithmetic.
• Call-sites updated to call the new helpers and to zero-terminate
  the destination on error.
• Additional range checks were added before arithmetic that builds
  variable-sized buffers (e.g. ConstructMsgToTm).

Security Impact
--------------------------------------------------------------------
Prior to the fix, arbitrary portions of the MSDTC process heap/stack
could be copied into protocol responses, giving an attacker insight
into memory layout and potentially sensitive data (addresses, GUIDs,
credentials).  Although no code execution is achieved, the
information disclosure significantly lowers the bar for further
exploitation.

Fix Effectiveness
--------------------------------------------------------------------
The new helpers perform correct 64-bit size validation and bail with
an error code before any copy occurs.  Destination buffers are
explicitly zeroed on failure, preventing accidental leakage.  No
arithmetic uses 32-bit truncation, eliminating the wrap-around
condition.  The patch therefore fully addresses the described
integer-overflow-based disclosure.

--------------------------------------------------------------------
