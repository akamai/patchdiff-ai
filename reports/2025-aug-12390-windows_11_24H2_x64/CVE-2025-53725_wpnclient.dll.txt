{'patch_store_uid': '819abf3b-35e3-41a3-8188-2e7b6c64fe43', 'file': 'wpnclient.dll', 'cve': 'CVE-2025-53725', 'change_count': 2, 'date': 1755089301.2520633, 'confidence': 0.37, 'kb': 'KB5063878'}
--------------------------------------------------------------------
CVE-2025-53725 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Push Notifications client library (wpnclient.dll) – feature
management helpers wil::details::FeatureImpl<*>.

Vulnerability Class
--------------------------------------------------------------------
Type confusion / width-mismatch when interpreting feature state data
(CWE-843).

Detailed Root Cause Analysis
--------------------------------------------------------------------
wil::details::FeatureImpl<__WilFeatureTraits_Feature_PerfImpTest>::
GetCurrentFeatureEnabledState() receives the feature state returned by
WilApi_GetFeatureEnabledState().  The value is a 64-bit bitmask that is
written into the caller-supplied QWORD *a2.  In the vulnerable code the
state is immediately truncated:

    unsigned int v6 = FeatureEnabledState & 0xFFFFFF3F;   // 32-bit

All subsequent policy decisions (lines that set or clear 0x40 / 0x400 /
0x800 flags) rely on v6 and other 32-bit temporaries.  Any bits located
above bit 31 are silently discarded, so the routine may treat a state
that should be “disabled” (bit 33 == 1, for example) as “enabled”.

Later, if the result indicates a conflicted state (0xC00 == 0xC00 or
0x40 == 1) the code reports usage through
FeatureImpl<…Feature_TestConfNum>::ReportUsage().  The original
ReportUsage() prototype expected
    (DWORD *this, bool IsEnabled, wil::ReportingKind, UINT64 flags)
However the call site supplied a 32-bit feature flag value in place of
IsEnabled (a one-byte boolean), producing an incompatible interpretation
of the second parameter when the callee treated it as a byte.  This is a
classic type confusion: 32-bit data is re-interpreted as boolean, and
stack/register slot alignment hides the error on x64.

Because the boolean is always non-zero when any upper bit of the flag
value is set, the internal logic inside ReportUsageToService() skips the
cache-refresh branch (`if (*this & 4)==0`) and later passes attacker
controlled bits (now in v6) directly to the cloud service call.  When
combined with the earlier truncation, a local, low-privileged process
can forge an arbitrary FEATURE_ENABLED_STATE and trick the Push
Notification service (running with higher privileges) into acting on a
mis-classified feature, effectively elevating the caller’s privileges.

Patch 2024-05-14 widens every truncated variable to 64-bit:
    - v6 : unsigned int  -> __int64
    - v9 : int           -> __int64
It also rewrites the conflict branch:
    if ( (v9 & 0xC00) == 3072 || (v9 & 0x40) != 0 )
so that both checks now use the full 64-bit value.

Finally the ReportUsage() prototype is fixed: the second parameter is
now a 64-bit value, the boolean argument is supplied as the constant 1,
and internal bookkeeping fields (v9/v8) are initialised with correct
sizes.  With the width mismatch removed, no attacker-controlled data is
re-interpreted as a different type.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable – GetCurrentFeatureEnabledState() (before)
unsigned int v6 = FeatureEnabledState & 0xFFFFFF3F; // truncates 64-bit
...
if ((v9 & 0xC00) == 3072) {
    v12 = 1;
}
...
// type confusion at call site – 32-bit v9 passed as bool
Feature_TestConfNum::ReportUsage(impl, v9, 3072i64, v6);
```
```c
// patched
__int64 v6 = FeatureEnabledState & 0xFFFFFF3F; // 64-bit safe
...
if ( (v9 & 0xC00) == 3072 || (v9 & 0x40) != 0 ) {
    Feature_TestConfNum::ReportUsage(impl, v9, 3072i64, v6);
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Low-privileged app supplies crafted feature ID / state to Push
   Notification API.
2. wpnclient.dll calls GetCurrentFeatureEnabledState().
3. 64-bit state is truncated to 32 bits (v6) -> incorrect evaluation.
4. Conflict path reached; v9 (32-bit) passed to ReportUsage() as bool.
5. ReportUsage() mis-interprets v9, builds a manipulated structure and
   forwards it to wil::details::ReportUsageToService().
6. Higher-privileged service acts on the forged state, leading to local
   elevation of privilege.

Attack Vector
--------------------------------------------------------------------
Any user-mode process that is authorised to use the Windows Push
Notification API can supply a crafted feature identifier/state that
contains malicious bits above bit 31.  No special privileges beyond
standard application permissions are required.

Patch Description
--------------------------------------------------------------------
1. Replaced all 32-bit temporaries involved in state handling with
   64-bit (__int64) types.
2. Simplified the conflict predicate so that both earlier test cases
   share a single branch that cannot be bypassed via truncation.
3. Corrected the signature of Feature_TestConfNum::ReportUsage(): the
   boolean parameter is removed; the 64-bit state is now passed in its
   own 64-bit slot; hard-coded constant 1 is supplied for the boolean.
4. Adjusted initialisation of local structs (v9/v8) to proper sizes.

Security Impact
--------------------------------------------------------------------
Before the patch an attacker could abuse the width mismatch to force the
client library to treat disabled or restricted features as enabled and
report that state to the Push Notification service under system
context, enabling privilege escalation.  Successful exploitation grants
local EoP to SYSTEM or the service account running the Push Notification
service.

Fix Effectiveness
--------------------------------------------------------------------
The patch eliminates the truncation by using 64-bit variables and
ensures matching parameter types between caller and callee, removing the
possibility of type confusion.  No alternate path that re-introduces the
width mismatch was observed, so the fix is judged effective for the
identified vulnerability.
