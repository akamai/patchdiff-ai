{'file': 'mrxsmb20.sys', 'kb': 'KB5063878', 'change_count': 3, 'confidence': 0.33, 'cve': 'CVE-2025-50169', 'date': 1755086332.7389183, 'patch_store_uid': 'ae5e0625-c9d6-4297-9b0b-81e666d6aa17'}
--------------------------------------------------------------------
CVE-2025-50169 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows client SMBv2 driver (mrxsmb20.sys) – function
Smb2ProcessNegotiateResponse, responsible for parsing a server’s SMB2
NEGOTIATE_RESPONSE and updating the shared MRxSmb SERVER_ENTRY
structure.

Vulnerability Class
--------------------------------------------------------------------
CWE-362: Concurrent execution using shared resource with improper
synchronisation (race condition)

Detailed Root Cause Analysis
--------------------------------------------------------------------
Smb2ProcessNegotiateResponse must exclusively update fields inside the
shared SERVER_ENTRY (offsets 0x290 – 0x2D0: dialect, capability flags,
cryptographic material, etc.).  Exclusive ownership is normally
obtained with

    SmbCeAcquireSpinLock(<serverEntry>)

which returns at IRQL DISPATCH_LEVEL and serialises all writers.

In the vulnerable build the call site is wrongly declared:

    SmbCeAcquireSpinLock(v81, 0x785, v22, v14);

Four parameters – three of them originating from attacker-controlled
input – are supplied, while the routine’s prototype expects only one or
two (RCX = server, optionally RDX = tag).  On x64 the surplus registers
(R8/R9) are ignored and the value 0x785 is interpreted as the tag, **but
no lock is actually taken**, leaving the shared structure unprotected.

Because the following code immediately writes to the structure

  * WORD 0x2A0  (ServerDialect)      = *(WORD *)(a5+0x44);
  * DWORD0x2A4  (CapabilitiesFlags)  = v34;            
  * WORD 0x2A2  (SecMode)            = v17;            
  * 16-byte blob 0x290 (GUID)        = *(OWORD *)(a5+0x48);
  * BYTE 0x2E0  (Flags)              |= 0x20           
  * DWORD0x2CC  (FeatureFlags)       = v49;            

two or more NEGOTIATE_RESPONSE handlers that run in parallel can race
and overwrite each other’s values.  While one thread later frees and
re-creates cryptographic state (hash objects, pre-auth integrity
buffers), another may still hold pointers to the previous buffers.  The
result is use-after-free, double free and ultimately kernel memory
corruption that can be driven to code execution from remote.

The absence of synchronisation applies to both authenticated and
unauthenticated sessions; a single unauthenticated attacker can exploit
this by opening multiple TCP connections and racing the NEGOTIATE
hand-shake.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable – lock called with four arguments, not acquired
LOBYTE(v74) = SmbCeAcquireSpinLock(v81, 0x785, v22, v14);

// fixed – correct prototype, lock really taken
v43 = SmbCeAcquireSpinLock(v92, 1i64);
```

```c
// secondary cosmetic but related clean-ups
// before: extra parameter supplied to ExAllocatePool2
Pool2 = ExAllocatePool2(66, v20, 0x734D7253, v14);
// after: correct 3-argument form
Pool2 = ExAllocatePool2(66, v30, 0x734D7253);
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker establishes several SMB sessions in parallel.
2. Each session sends a crafted SMB2 NEGOTIATE_RESPONSE with
   predictable dialect/capability values.
3. All worker threads enter Smb2ProcessNegotiateResponse concurrently.
4. Because the spin lock is not acquired, threads enter the critical
   section simultaneously and race while:
     – modifying SERVER_ENTRY fields
     – allocating and freeing hash buffers
     – updating global capabilities flags.
5. One thread uses stale freed memory or corrupted flags, leading to
   arbitrary kernel memory write → RCE.

Attack Vector
--------------------------------------------------------------------
Remote, unauthenticated network access over TCP ports 445/139.  No
credentials are required – only the ability to send SMB2 NEGOTIATE and
NEGOTIATE_RESPONSE messages quickly in parallel.

Patch Description
--------------------------------------------------------------------
Microsoft removed the surplus arguments from synchronisation and
allocation helpers, bringing the call signatures back in line with the
authoritative prototypes:
  • SmbCeAcquireSpinLock now called with only (ServerEntry,Tag),
    guaranteeing exclusive ownership of the spin lock.
  • ExAllocatePool2 and MRxSmbGetConfigurationBlock likewise fixed.
  • Related variable re-organisation to avoid accidental re-use of
    attacker-influenced values.
No other logic is changed.

Security Impact
--------------------------------------------------------------------
Without the fix, attackers can trigger data races that corrupt kernel
heap objects referenced by the SMB client driver, yielding elevation to
arbitrary kernel-mode code execution from the network (Remote Code
Execution).  The bug affects all supported Windows versions that ship
mrxsmb20.sys.

Fix Effectiveness
--------------------------------------------------------------------
The corrected call guarantees that the spin lock is truly obtained
before the shared SERVER_ENTRY is modified, removing the window for
parallel, conflicting updates.  Because the only unprotected write site
was inside this function, the patch is sufficient; nevertheless, full
protection depends on all other callers using the correct prototype –
that remains unverified in this diff (state: unknown).
