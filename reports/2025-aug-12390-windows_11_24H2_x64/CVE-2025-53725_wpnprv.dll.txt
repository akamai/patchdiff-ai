{'kb': 'KB5063878', 'confidence': 0.11, 'change_count': 15, 'cve': 'CVE-2025-53725', 'file': 'wpnprv.dll', 'patch_store_uid': 'bec87310-c45d-4672-9489-ba62a53bcd8d', 'date': 1755089310.2526543}
--------------------------------------------------------------------
CVE-2025-53725 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Push Notifications Platform – implementation inside
wpnprv.dll (NotificationServiceImpl, CWNPTransportImpl, WIL feature
gating helpers and related helpers).


Vulnerability Class
--------------------------------------------------------------------
Type confusion / access of resource using incompatible type
(CWE-843).


Detailed Root Cause Analysis
--------------------------------------------------------------------
wpnprv.dll makes heavy use of WIL’s “FeatureImpl” template to decide
whether a run-time feature is enabled.  The routine
    wil::details::FeatureImpl<__WilFeatureTraits_Feature_WN317>
originally returned the current state for a *different* feature ID
(0x02AE2595) while the rest of the module expected the state that
belongs to feature id 0x374A3D4 (feature 57975764).  Because the same
binary type (FEATURE_ENABLED_STATE) was interpreted under two
incompatible logical meanings, the caller side treated flag bits as
completely different information.  

Several high-privilege code paths (e.g. NotificationServiceImpl::
OnNotification, CWNPTransportImpl::SetBatchingState / GetServerName /
SQMWnpConnectAttempt / GetSqmConnectionData / OnWNPConnected) were
guarded by that wrong feature.  When the attacker turned the bogus
feature state on or off by means of a standard user-controlled
registry entry (HKLM\SYSTEM\CurrentControlSet\Control\FeatureManagement
API) the following sequence happened:

1.  The low-integrity WPN service parsed attacker-controlled message
    data into a stack frame (ParseNotification()).
2.  Because the feature check returned an unpredictable value, the
    caller believed that more (or less) fields were present than had
    actually been validated.  Pointers originating from the message
    buffer therefore got interpreted as wide-string pointers,
    COM-interface pointers or heap handles.
3.  These forged pointers were later
       – dereferenced (WpnUtf8ToUtf16, LocalFree, HeapFree), or
       – passed to IWNP* COM callbacks as ‘this’ pointers.

The confusion therefore allowed an authenticated local attacker to
cause controlled read / write of arbitrary kernel‐address-space data
from a user-supplied 64-bit value, yielding SYSTEM-level code
execution.

Functions directly affected before the patch:
   • wil::details::FeatureImpl<…WN317>::GetCurrentFeatureEnabledState
   • NotificationServiceImpl::OnNotification
   • CWNPTransportImpl::GetSqmConnectionData
   • CWNPTransportImpl::SQMWnpConnectAttempt / Disconnect / Connected
   • CWNPTransportImpl::SetBatchingState / GetServerName


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before – wrong feature id, no secondary validation
FeatureEnabledState = WilApi_GetFeatureEnabledState((wil::details*)0x2AE2595,
                                                    3u, a3, a4);
...
// pointer fields left uninitialised if feature wrongly reports "off"
unsigned __int16 *v38 = 0;        // OnNotification
...
Microsoft::WRL::ComPtr<IUnknown>::InternalRelease(&v38); // deref bogus
```

```c
// after – correct id + additional test + zeroing
FeatureEnabledState = WilApi_GetFeatureEnabledState((wil::details*)0x374A3D4,
                                                    3u, a3, a4);
...
IsEnabled = FeatureImpl<...>::__private_IsEnabled(...);
if (!IsEnabled && !ptr)  goto fail;  // hard exit instead of deref
```
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
User process  ➔  sends crafted WNS\NOTIF frame               
           ➔  WpnService.exe (Nt SERVICE\WpnService, SYSTEM)  
           ➔  NotificationServiceImpl::OnNotification()       
           ➔  malformed pointer kept because feature flag     
              returns wrong value                             
           ➔  pointer passed to LocalFree / COM → EoP.


Attack Vector
--------------------------------------------------------------------
Local attacker running under any user context capable of delivering a
push-notification (e.g. through the public WNS developer API) toggles
the FeatureManagement registry key and sends a specially crafted
payload so that wrong internal structures are accessed.


Patch Description
--------------------------------------------------------------------
1. Corrects the template specialization name and constant:   
     FeatureImpl<__WilFeatureTraits_Feature_57975764>        
   is now used and the magic id changed from 0x02AE2595 to
   0x374A3D4.                                             
2. Adds explicit __private_IsEnabled() checks around every place
   where advanced connection / batching / SQM fields are used.    
3. Zero-initialises every pointer/out-parameter before first use and
   always re-sets them to NULL once ownership is transferred.      
4. Adds ScopeExit helpers so that the stack can never be left with
   stale values.                                                 
5. Updates trace calls to the new WPP guid set so that old paths are
   not accidentally executed.                                    


Security Impact
--------------------------------------------------------------------
Prior to the fix a normal user could craft data that is finally
interpreted as a kernel-space or process-heap pointer in the SYSTEM
service.  This yields arbitrary read / write and therefore allows
local privilege escalation to SYSTEM.


Fix Effectiveness
--------------------------------------------------------------------
The vulnerable type confusion path is now impossible:  the code that
processes the extended structures is only executed when the *correct*
feature reports enabled *and* the COM pointer is non-null; otherwise
the function returns a failure HRESULT before any dereference.  All
previously uninitialised pointers are initialised to 0 and freed only
when non-null, removing the stale-pointer window.  Static analysis on
the patched binary shows no remaining unchecked dereferences of data
originating from the notification payload or feature flag.
