{'kb': 'KB5063878', 'change_count': 36, 'file': 'ntfs.sys', 'date': 1755089577.0925736, 'confidence': 0.23, 'cve': 'CVE-2025-50158', 'patch_store_uid': '4de21077-08da-4b9c-98f4-e9a52d2ce0f5'}
--------------------------------------------------------------------
CVE-2025-50158 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows NTFS driver (ntfs.sys) – routine NtfsReadUsnJournal
handles the FSCTL_READ_USN_JOURNAL request and copies USN records to a
caller-supplied output buffer.


Vulnerability Class
--------------------------------------------------------------------
Time-of-check Time-of-use (TOCTOU) race condition leading to kernel
information disclosure (CWE-367).


Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  User space passes an IRP for FSCTL_READ_USN_JOURNAL.  The IRP
    contains an output buffer pointer that resides in user memory
    (offset a2+8).

2.  NtfsReadUsnJournal validates the buffer once with ProbeForRead /
    ProbeForWrite but does not lock or re-validate it afterwards.  The
    routine then maps the pointer by calling NtfsMapUserBuffer and
    stores it in v18 (pre-patch) / Address (post-patch).

3.  While processing every USN record the old code performs
        memmove(v27, v35, v40);            // v27 == user buffer
    or, for special case records,
        memmove(v27+20, (char*)Src+24, size);
    The copy is executed *after* locks (VCB/ERESOURCE) have been
    dropped and re-acquired multiple times (see long error-handling and
    wait-for-new-length path).  Between the first ProbeForWrite and the
    final memmove an attacker-controlled thread can remap the user
    pages or substitute the pointer through APC delivery.

4.  Because memmove operates with kernel privileges it will read from
    kernel-only addresses if the pointer now references them, and will
    relay that data back to the attacker once the buffer is returned to
    user mode.  No size checks are bypassed – the bug is purely a race
    between validation and use.

5.  The disclosure is amplified for type-2 USN records where up to 0x50
    bytes are copied, including stack-resident or pool-resident padding
    that may contain sensitive kernel data.

Affected parameters / structures:
    – IRP.MdlAddress / SystemBuffer (output buffer)
    – local variables v18 / v27 (destination) and Src (source)
    – USN_RECORD_V2 / V3 layout copy paths.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – unsafe copy once validation window has passed
if ((unsigned __int16)v17 >= 3 && v41 == 2) {
    memmove(v27 + 20, (char*)Src + 24,
            *(_DWORD*)Src - *((unsigned __int16*)Src + 28) - 24);
} else {
    memmove(v27, v35, v40);   // v27 points to user buffer
}

// after patch – safe, atomic user access helpers
if (UserBufferIsMapped) {
    RtlCopyToUser(v43, Src, copyLen);
} else {
    RtlCopyVolatileMemory(v43, Src, copyLen);
}

/* All reads of user data now use RtlReadUShortFromUser /
   RtlCopyFromUser and all writes use RtlWrite*ToUser helpers. */
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker opens a handle to a NTFS volume.
2. Sends FSCTL_READ_USN_JOURNAL with Method = Buffered and supplies a
   user pointer as DestinationBuffer.
3. While NtfsReadUsnJournal is in the long processing loop it releases
   the ERESOURCE & VCB locks.
4. Attacker uses VirtualProtect / NtMapViewOfSection to remap the same
   user VA to a kernel-only physical page.
5. Kernel resumes, executes memmove, and copies arbitrary kernel memory
   into the attacker’s address space.


Attack Vector
--------------------------------------------------------------------
Local, low-privileged user with the ability to issue USN journal IOCTLs
against an NTFS volume.  No additional privileges are required.


Patch Description
--------------------------------------------------------------------
1. Replaced raw memmove/memcpy with RtlCopyToUser and
   RtlCopyVolatileMemory for all writes to user buffers.
2. All reads of user-supplied structures now use RtlCopyFromUser or
   RtlReadUShortFromUser ensuring the data is fetched *after* it is
   committed and within user address space.
3. Added corresponding RtlWriteULong*/RtlWriteULong64ToUser helpers for
   scalar stores.
4. Minor prototype change (a4 is now unsigned char) to convey boolean
   semantics clearly.
5. New feature-flag path (Feature_H2E_WPA3SAE__private…) gates the safe
   copy routines but defaults to enabled on supported builds.


Security Impact
--------------------------------------------------------------------
The flaw allows a non-admin local attacker to read arbitrary kernel
memory fragments, possibly leaking credential material, KASLR offsets or
other sensitive data.  Although no direct elevation of privilege is
performed, the disclosed information can be chained with other bugs to
achieve full kernel compromise.


Fix Effectiveness
--------------------------------------------------------------------
The patch removes the TOCTOU window by performing every user buffer
access through safe helper routines that verify the pointer belongs to
user space at the moment of the access.  No remaining unprotected
memmove/memcpy calls targeting the user buffer exist in the updated
function, so the original race is effectively closed.
