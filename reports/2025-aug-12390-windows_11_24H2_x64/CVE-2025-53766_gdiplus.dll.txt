{'cve': 'CVE-2025-53766', 'date': 1755086675.1674235, 'kb': 'KB5063878', 'confidence': 0.19, 'change_count': 265, 'patch_store_uid': 'd50325ae-616f-4796-902a-e4b6ee56c962', 'file': 'gdiplus.dll'}
--------------------------------------------------------------------
CVE-2025-53766 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows GDI+ (gdiplus.dll) – rectangle conversion and rendering helpers
BoundsFToRect(), GpGraphics::RenderDrawPath(),
GpTexture::IsPictureFill()

Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow caused by incorrect numeric conversion /
integer-wraparound (CWE-122, CWE-681).

Detailed Root Cause Analysis
--------------------------------------------------------------------
The helper BoundsFToRect() converts a floating-point RectF input into an
integer GpRect structure that is subsequently used by many GDI+
rendering primitives.

Pre-patch logic:
 1. The left/top coordinates were obtained with floorf().
 2. Width and height were then derived with the expression
      1 - left - floorf( -(left + size) )
    where the sign was flipped with a XOR to _xmm (0x80000000).
 3. The resulting width/height were written into *a2 (int) without any
    additional range test.

The algorithm assumes IEEE-754 binary representation and depends on the
exact behaviour of floorf().  When the input values are very close to an
integer boundary (e.g. 0.99999994, 1.00000006 or ‑0.00000006) the
floating-point error causes floorf() to return an unexpected value.  For
example, with left == 0.0 and width == 1.9999999
    floorf(-(left+width)) → ‑1 instead of ‑2
    stored width        → 1-0-(-1) = 2   (expected 1)
If width becomes 0 or negative, the signed subtraction underflows when
later converted to an unsigned field in downstream functions.  The value
therefore expands to a very large positive integer which is used as the
extent of heap allocations and memory moves inside the driver
(DrvStrokePath / Blt operations).

Consequences:
• A rectangle with an attacker-controlled, wrap-around size can be
  produced.
• Subsequent drawing or texturing routines allocate a small buffer (or
  none) but iterate using the huge width/height, writing far beyond the
  end of the heap block.
• The corruption is controllable because the rectangle coordinates come
  directly from the image file or drawing command.

Patch changes:
• Replaced every floorf()-based conversion with _mm_round_ss(...,9) or
  10 which performs a well-defined, correctly rounded cast.
• Explicitly recomputes width / height as
      round(right) - round(left) + 1
  and performs full range validation ( <0 , > 0x3FFF_FFF8 ).
• Added early bailout labels (LABEL_22 etc.) that zero the rectangle and
  return error 11 if any intermediate check fails.
• RenderDrawPath() now calls the new safety helper
  GpGraphics::IsTotallyClipped() before issuing the driver call.
• IsPictureFill() updated with the same rounding helper and bound checks.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// Before
v14 = 1 - v11 - (int)floorf_0(
        COERCE_FLOAT(COERCE_UNSIGNED_INT(v9 + v7) ^ _xmm));
...
a2[2] = 1 - v5 - (int)floorf_0(
        COERCE_FLOAT(COERCE_UNSIGNED_INT(v8 + *a1) ^ _xmm));
```
```c
// After
v10 = (int)_mm_round_ss(v9, v9, 10).m128_f32[0];
a2[2] = v10 - *a2 + 1;            // width
...
v18 = (int)_mm_round_ss(v11, v11, 10).m128_f32[0];
v23[3] = v18 - (int)v16 + 1;      // height
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
Malformed image / EMF → GDI+ parses → GpGraphics::RenderDrawPath()
 → BoundsFToRect() produces wrapped width/height
 → GpGraphics::DrvStrokePath() allocates buffer using signed size
 → rendering loop iterates with huge unsigned extent
 → heap memory beyond allocation overwritten
 → attacker gains code execution.

Attack Vector
--------------------------------------------------------------------
A remote attacker crafts a picture (e.g. EMF, WMF, GIF) that embeds
coordinates exploiting the rounding edge case.  Displaying or thumbnail
previewing the image through any application that links to GDI+
(Outlook, Office, Edge, Explorer preview pane, etc.) triggers the
vulnerable code path without user interaction beyond opening the file.

Patch Description
--------------------------------------------------------------------
1. Introduced SSE _mm_round_ss based conversions that obey the CPU
   rounding-to-nearest rule independent of sub-normal drift.
2. Rewrote width/height computation to simple subtraction ensuring
   non-negative result and added explicit range checks.
3. Added IsTotallyClipped() guard to skip rendering when rectangle is
   fully outside the clip region.
4. Updated GpTexture::IsPictureFill() to use the same safe rounding logic
   for picture brush optimisation.
5. Reflective changes are gated by the global
   Feature_GdiPlusOptimizations_Misc_IsEnabled flag for compatibility.

Security Impact
--------------------------------------------------------------------
Pre-patch, an attacker could reliably corrupt heap metadata and
application objects leading to arbitrary code execution in the context
of the calling process.  Because the defect is located in a ubiquitous
system DLL (gdiplus.dll) the impact spans all modern Windows versions
and many third-party applications.

Fix Effectiveness
--------------------------------------------------------------------
The patch eliminates the vulnerable conversion pattern in all known call
sites and introduces comprehensive boundary validation.  Unless the
Feature_GdiPlusOptimizations_Misc_IsEnabled flag is manually disabled,
all paths now use the safe rounding routine.  No obvious way remains to
obtain a negative or excessively large rectangle; therefore the fix is
considered effective.

