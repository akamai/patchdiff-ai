{'cve': 'CVE-2025-50176', 'date': 1755089625.7686925, 'file': 'dxgmms2.sys', 'patch_store_uid': '689b7332-8ef4-4284-8807-a098fd03a7fa', 'change_count': 76, 'kb': 'KB5063878', 'confidence': 0.16}
--------------------------------------------------------------------
CVE-2025-50176 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows ‑ dxgmms2.sys (DirectX Graphics Kernel Scheduler)
Affected helpers:
 • UnwaitCpuWaitersHelper()
 • HwQueueStagingList::ProcessHwQueues()
 • VidSchiProcessDpcCompletedPacket()
 • VidSchiCheckHeadTimeout()
 • VidSchiProcessDpcPreemptedPacket()
 • VidSchiExecuteMmIoFlipAtPassiveLevel()


Vulnerability Class
--------------------------------------------------------------------
Type-confusion / use-after-free leading to pool corruption (heap based
buffer overflow).  Root cause is the destruction of a live
HwQueueStagingList object while its embedded doubly-linked list still
contains active queue entries.


Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  UnwaitCpuWaitersHelper() creates a temporary HwQueueStagingList on
    the stack (variable v3).  After VidSchiRundownMonitoredFenceCpuWaiters()
    it immediately executed:
        HwQueueStagingList::~HwQueueStagingList(&v3);

2.  At this point v5==0 and v6==2 indicate that the list still holds
    outstanding VIDSCH_HW_QUEUE nodes.  The destructor therefore walks
    those nodes and unlinks them from global scheduling lists while the
    objects are *still owned* by other data structures protected by the
    same spin-lock.

3.  Because the list nodes are still referenced elsewhere, the
    destructor’s unlink converts them into HwQueueStagingList linkage
    (BLINK/FLINK) – a classic type confusion: code later treats a
    VIDSCH_HW_QUEUE object as a staging-list link.  Subsequent insert or
    remove operations write attacker-controlled pointer values to pool
    memory (Write-What-Where), causing heap corruption and ultimately
    kernel code execution.

4.  The same unsafe pattern existed in several other call-sites where a
    staging list was destroyed while entries were pending (completed
    packet, pre-empted packet, head-timeout path, MPU flip path).

Parameters / structures involved
  - HwQueueStagingList::Head (doubly-linked list)
  - this->State  (DWORD at offset +0x1C)  == 2  ("Busy")
  - local flags:  char v5 ("empty?"), int v6 (state) used to decide
    whether it is safe to tear-down.
  - Spin-lock *(queueBase+1984) guarding the scheduling lists.

Leaving the list in an inconsistent state lets an unprivileged user
build fake list entries from user-mode controlled VRAM / DMA buffers,
redirecting kernel writes.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// original UnwaitCpuWaitersHelper
VidSchiRundownMonitoredFenceCpuWaiters(&v3, a1, 0);
HwQueueStagingList::~HwQueueStagingList((HwQueueStagingList *)&v3); // <- unsafe

// patched
VidSchiRundownMonitoredFenceCpuWaiters(&v3, a1, 0);
if (!v5 && v6)
    HwQueueStagingList::ProcessHwQueues((HwQueueStagingList *)&v3, 0);
```

```c
// head of old ProcessHwQueues
if (*((DWORD*)this + 7) != 1) goto LABEL_2;
...
// new version
if (*((DWORD*)this + 7) == 1) { ... safer walk ... }
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User-mode submits GPU work that blocks on a monitored fence.
2. Scheduler unwinds waiters -> UnwaitCpuWaitersHelper() executes.
3. Temporary staging list still contains HW_QUEUE records (v5==0,
   v6==2).
4. Old code destructs the list, unlinking active nodes → corrupted
   BLINK/FLINK in shared list.
5. Later scheduler path (e.g. VidSchiProcessDpcCompletedPacket) touches
   the list, follows poisoned pointers → arbitrary kernel write / crash
   → potential code execution in kernel context.


Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker with D3DKMT / Direct3D access programs GPU
command streams that create long-lived HW queues and monitored fences.
By forcing the race in UnwaitCpuWaitersHelper the attacker gains a
write-what-where primitive inside nt!ExRemoveHeadList style list ops,
allowing escalation to kernel-mode arbitrary code execution.


Patch Description
--------------------------------------------------------------------
1. Gate the destructor call: only execute when the list is *really*
   empty (condition `if(!v5 && v6) ProcessHwQueues()` instead).
2. Introduce HwQueueStagingList::ProcessHwQueues() fast-path that
   properly walks each queue and clears it, then sets ListEmpty flag
   before destruction.
3. Replace every unconditional `~HwQueueStagingList` in the affected
   paths (completed packet, pre-empted packet, timeout, flip) with the
   new safe processing routine.
4. Added additional integrity checks; if mismatch is detected code now
   aborts early or fast-fails instead of corrupting memory.


Security Impact
--------------------------------------------------------------------
Prior to the patch a user could deliberately create a non-empty staging
list and cause its premature destruction, leading to pool memory
corruption, system crash, or arbitrary kernel code execution.  Because
operations originate from GPU command submission, exploitation can be
performed from a low-privilege sandbox, turning it into a Local
Privilege Escalation or, when combined with a malicious driver, a Remote
Code Execution vector.


Fix Effectiveness
--------------------------------------------------------------------
The new guards prevent the destructor from running on non-empty lists
and ensure that all remaining HW_QUEUE nodes are safely processed first.
All previous call-sites were updated; additionally, ProcessHwQueues now
validates list integrity and uses controlled fast-fail on mismatch.
The fix fully removes the type-confusion window and no further unsafe
unlink patterns are observable in the patched binary.
