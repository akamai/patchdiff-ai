{'kb': 'KB5063878', 'date': 1755086334.7790911, 'file': 'bfs.sys', 'change_count': 2, 'patch_store_uid': '551f5526-61e2-4a1e-9bf8-0c09a9d5426b', 'cve': 'CVE-2025-53142', 'confidence': 0.05}
--------------------------------------------------------------------
CVE-2025-53142 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Brokering File System (bfs.sys) – policy-management code
that lives in the kernel driver and is reached through routine
BfsGetPolicyEntry.


Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use After Free


Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  BfsGetPolicyEntry() first attempts to locate a policy entry in a
    hash table protected by a push-lock.  When the entry does not yet
    exist, the routine releases the lock and calls
    BfsInsertPolicyEntry() in order to allocate and initialise a new
    BFS_POLICY_ENTRY structure; the address of that structure is
    returned through the out-parameter P.

2.  BfsInsertPolicyEntry() returns STATUS_SUCCESS on success, or a
    negative NTSTATUS when allocation/initialisation fails.  When the
    function fails it frees the partially-built entry before
    returning, but it still leaves the now-stale pointer value in the
    caller-supplied variable P.

3.  In the original (vulnerable) implementation the caller executes

        if (P) BfsDereferencePolicyEntryEx(P);

    on every error path, assuming that P is still a valid, referenced
    object.  Because the entry has already been freed by
    BfsInsertPolicyEntry(), this second dereference operates on freed
    pool memory.  The result is a classic UAF/double-free that corrupts
    the kernel pool and yields arbitrary kernel-mode read/write
    primitives.

4.  An attacker running in a normal user context can reliably force the
    failing path by exhausting PagedPool, by providing extremely large
    SIDs, or by racing two threads so that the second thread receives
    STATUS_OBJECT_NAME_EXISTS from BfsInsertPolicyEntry().  After the
    entry is freed, the attacker can re-allocate the same memory with
    controlled data and wait for the spurious dereference to gain code
    execution in kernel mode.

5.  The issue is entirely inside bfs.sys and does not require admin
    privileges – only the ability to create files that make the filter
    driver execute the policy lookup path.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before patch – error path unconditionally dereferences freed object
inserted = BfsInsertPolicyEntry(..., &P);
...
if (inserted < 0) {
    ...
    if (P)
        BfsDereferencePolicyEntryEx(P);   // <== UAF
    return inserted;
}

// after patch – early exit, no dereference after failure
inserted = BfsInsertPolicyEntry(..., &P);
if (Feature_IsEnabled() && inserted < 0)
    return inserted;                      // safe
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User provokes a call to BfsPreCreateOperation() -> BfsCheckAndApply
   Policy() -> BfsGetPolicyEntry().
2. Inside BfsGetPolicyEntry():
   a. Entry not found, lock is released.
   b. BfsInsertPolicyEntry() fails (e.g., STATUS_INSUFFICIENT_RESOURCES
      or STATUS_OBJECT_NAME_EXISTS) and frees the newly allocated
      entry.
   c. Function returns to BfsGetPolicyEntry() with P pointing at freed
      memory and status < 0.
   d. Original code calls BfsDereferencePolicyEntryEx(P) – UAF.


Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker.  By exhausting pool or racing duplicate
policy insertions the attacker triggers the failure path and forces the
driver to dereference attacker-controlled, freed memory from kernel
context, leading to elevation of privilege.


Patch Description
--------------------------------------------------------------------
The update makes two defensive changes in BfsGetPolicyEntry():
1. Reverses the success test so that the routine reaches the allocation
   only when strictly necessary.
2. Most importantly, after BfsInsertPolicyEntry() returns a failure
   status (<0) the function now exits immediately (when the new feature
   gate is enabled) and therefore never touches the stale pointer.
   This removes the double-dereference of an already-freed object.

No structural changes are made to the underlying POLICY_ENTRY – only
control-flow is altered to prevent use of freed memory.


Security Impact
--------------------------------------------------------------------
A local attacker can execute arbitrary code in kernel mode, thereby
achieving a full elevation of privilege and escaping any sandbox or
user-mode restrictions.  System integrity and confidentiality are
compromised.


Fix Effectiveness
--------------------------------------------------------------------
The early-return added after the failed insert ensures that the pointer
is not reused after it has been freed, eliminating the immediate UAF
window.  No remaining paths in BfsGetPolicyEntry() dereference P when
status < 0, so the specific vulnerability is resolved.  Effectiveness
is contingent on the controlling feature flag being enabled by default;
this appears to be the case in supported Windows builds.  Full
regression-testing would still be required to confirm that no parallel
error paths re-introduce the bug elsewhere.

