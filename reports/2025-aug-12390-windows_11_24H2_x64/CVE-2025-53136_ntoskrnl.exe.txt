{'cve': 'CVE-2025-53136', 'date': 1755089707.9361336, 'patch_store_uid': '203c1d43-d415-4c93-8448-a2d4f1c0abdd', 'kb': 'KB5063878', 'file': 'ntoskrnl.exe', 'confidence': 0.33, 'change_count': 184}
--------------------------------------------------------------------
Unknown-CVE Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows NT kernel memory-manager routine MiGetPerfectColorHeadPage.
The routine is used during page allocation to pull a page with the
"perfect colour" from a per-colour free/zero queue.


Vulnerability Class
--------------------------------------------------------------------
Logical error / faulty validation that can lead to information
disclosure (CWE-200).


Detailed Root Cause Analysis
--------------------------------------------------------------------
MiGetPerfectColorHeadPage walks a set of per-colour PFN queues and
returns a page frame whose colour matches the caller-supplied value
(a1+0x20, named Colour).  For correctness, the routine must also
ensure that the PFN belongs to the same memory-partition / NUMA
node that the caller is currently operating on ( *a1 points to the
MI_PARTITION structure, field 0x3A98).  In the original code the
check that enforces this partition match is expressed as

   if ( MmInitSectionResAvailLeakFixEnabled &&
        PartitionArray[index] != CurrentPartitionPointer ||
        (PFN->Color & 7) != Colour )
       { reject page }

The leading boolean operator chain is wrong:  whenever the global
flag MmInitSectionResAvailLeakFixEnabled is *clear* (the normal
runtime case) the whole left sub-expression collapses to FALSE and
only the colour comparison remains significant.  A page that has
the right colour but belongs to another partition therefore passes
validation and is returned to the caller while still containing the
previous partition’s contents.  Because pages on the Free list are
not guaranteed to be zeroed, user mode code that later maps the page
receives stale kernel data.

Patch reverses the logic and removes the dependency on the global
flag.  The new code accepts a page only when *both* conditions are
true:

   if ( (PFN->Color & 7) == Colour )
       if ( PartitionArray[index] == CurrentPartitionPointer )
            { accept page }

If either the colour or the partition pointer does not match the
request, the PFN lock is released and the search continues.

Additional hardening changes introduced together with the fix:
1. Function signature now takes the MI_PARTITION pointer by value to
   make aliasing explicit.
2. Validation and spin-lock operations are re-structured and
   instrumented, but these are secondary to the logical correction
   above.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
if ( MmInitSectionResAvailLeakFixEnabled &&
     *((_QWORD *)qword_140E2FCC8 +
       ((*(_QWORD *)(v10 + 40) >> 43) & 0x3FF)) !=
       *(_QWORD *)(v19 + 14984)
     || (*(_BYTE *)(v10 + 34) & 7) != (DWORD)v4 )
{
    /* reject */
}

// after
if ( (*(_BYTE *)(v11 + 34) & 7) == v25 )
{
    if ( *((_QWORD *)qword_140E2FD88 +
           ((*(_QWORD *)(v11 + 40) >> 43) & 0x3FF)) ==
         *(_QWORD *)(v26 + 14984) )
    {
        /* accept */
    }
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User process requests memory (e.g. VirtualAlloc / page-fault). 
2. Kernel ultimately calls MiGetPerfectColorHeadPage to pull a page
   from the per-colour free queue.
3. On an affected build the colour matches but the partition pointer
   does not; the faulty OR logic still deems the PFN acceptable.
4. PFN is unlinked and mapped into the caller’s address space without
   being zeroed, exposing residual data.


Attack Vector
--------------------------------------------------------------------
Local, low-privileged attacker repeatedly allocates and reads large
anonymous memory regions.  Some returned pages will belong to a
foreign partition and contain leftover kernel information which can
be harvested from user mode.


Patch Description
--------------------------------------------------------------------
• Re-wrote validation as a strict two-step AND comparison that
  requires both page colour and partition match.
• Removed dependency on the runtime flag
  MmInitSectionResAvailLeakFixEnabled.
• Added helper MiGetColorHeadBase and updated signature to pass the
  partition pointer by value.
• Replaced raw spin-lock sequences with instrumented variants for
  additional robustness; unrelated to the leak but hardens the code.


Security Impact
--------------------------------------------------------------------
Prior to the patch, memory pages from another memory partition could
be handed to an untrusted user process still containing sensitive
kernel data, allowing disclosure of kernel pointers, object content
or other privileged information.  The flaw does not grant direct
code execution but undermines KASLR and can aid further attacks.


Fix Effectiveness
--------------------------------------------------------------------
The corrected Boolean logic ensures a page is returned only when
both colour and partition match, eliminating the possibility of
returning a foreign PFN.  No alternative path in the function can
bypass the new check, therefore the patch fully addresses the
information disclosure issue.
