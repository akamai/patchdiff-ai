{'file': 'wpnclient.dll', 'confidence': 0.22, 'patch_store_uid': '819abf3b-35e3-41a3-8188-2e7b6c64fe43', 'change_count': 2, 'date': 1755089171.137152, 'kb': 'KB5063878', 'cve': 'CVE-2025-53724'}
--------------------------------------------------------------------
CVE-2025-53724 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Push Notifications client (wpnclient.dll) â€“ specifically the
helper routine
wil::details::FeatureImpl<__WilFeatureTraits_Feature_PerfImpTest>::
GetCurrentFeatureEnabledState() that decodes the FEATURE_ENABLED_STATE
bit-field returned by WilApi_GetFeatureEnabledState.


Vulnerability Class
--------------------------------------------------------------------
Type confusion / width-truncation (CWE-843: access of resource using
incompatible type).
32-bit integers were used to hold and process a 64-bit flag value,
causing silent truncation and mis-interpretation of security bits.


Detailed Root Cause Analysis
--------------------------------------------------------------------
1. WilApi_GetFeatureEnabledState() returns a 64-bit mask that encodes
   per-feature enablement and gating metadata (on/off, policy-forced,
   flighting, servicing, etc.).  The mask is consumed by
   GetCurrentFeatureEnabledState() and copied back to the caller via
   the out-parameter *a2.

2. In the vulnerable build the returned value is stored in local
   variables typed as unsigned int / int (v6, v7, v8, v9).  Only the
   low 32 bits are therefore preserved.  High-order bits are silently
   discarded.
      FeatureEnabledState  ->  v6 (unsigned int)

3. Subsequent logic evaluates the low bits to decide whether the
   caller is authorised to use the feature and whether additional
   telemetry (ReportUsage) must run.  Because the mask is already
   truncated, any control information carried in bits 32-63 is
   forgotten.  An attacker able to influence the stored flag (for
   instance through the Feature Management registry overlay that is
   writable by Administrators) can force the routine down unintended
   branches.

4. The most security-relevant consequence is the clearing or setting
   of the 0x400 and 0x40 bits in the out-mask that represents
   FEATURE_ENABLED_STATE_User_Sid and FEATURE_ENABLED_STATE_Friendly
   respectively.  When these bits are mishandled the notification
   framework later trusts data that actually belongs to a different
   security context, effectively leading to an Elevation of Privilege
   in the push-notification helper process running as SYSTEM.

5. Because the bitfield now represents a different semantic size than
   the variables that carry it, the issue falls under classic type
   confusion: the same memory region is interpreted as 32-bit in the
   vulnerable code path but as 64-bit in the producer and consumer.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable excerpt (before)
unsigned int v6; // r9d
...
v6 = FeatureEnabledState & 0xFFFFFF3F;   // 64-bit value cut to 32
...
int v9; // edx
v9 = v8 | v7;                            // v9 still 32-bit
*(_DWORD *)a2 = v9;                      // written back to caller
```
```c
// fixed excerpt (after)
__int64 v6;  // r9
...
if ((_DWORD)v6)                         // still uses low dword but
                                        // high bits are preserved
__int64 v9; // rdx
v9 = v8 | (unsigned int)v7;            // 64-bit destination
*(_DWORD *)a2 = v9;                    // logical decision based on
                                       // un-truncated data
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Third-party or inbox app issues a toast/notification.
2. wpnclient.dll -> CNotificationValueSet::get_PayloadForUser()
3. ... -> FeatureImpl<PerfImpTest>::GetCurrentFeatureEnabledState()
4. Vulnerable routine mis-parses 64-bit flag -> incorrect privilege
   bits returned.
5. Subsequent notification processing trusts the corrupted mask,
   ultimately executing privileged helper tasks under SYSTEM.


Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker able to change Feature Management
configuration (registry HKLM\SOFTWARE\Microsoft\WindowsNT\CurrentVer-
sion\FeatureManagement\Overrides or via the undocumented
featureconfiguration API) injects a 64-bit value that relies on bits
above 31.  When the vulnerable code truncates the value, the attacker
circumvents policy checks and gains SYSTEM-level execution through the
push-notification service path.


Patch Description
--------------------------------------------------------------------
1. All intermediates that hold FEATURE_ENABLED_STATE are widened from
   32-bit int/unsigned int to 64-bit (v6, v9).
2. Branch logic is consolidated; the redundant v12 flag and unneeded
   LABEL_14 path are removed, eliminating stale or partially initial-
   ised variables.
3. Reporting calls are updated to use the correct 64-bit parameters.
4. Overall, the routine now preserves the full width of the flag and
   no longer performs contradictory writes to *a2.


Security Impact
--------------------------------------------------------------------
Before the patch a local attacker could abuse flag truncation to bypass
feature-gating decisions made by wpnclient.dll and indirectly execute
code with the privilege of the Windows Push Notification Service
(NT AUTHORITY\SYSTEM), resulting in a local Elevation of Privilege.
Confidentiality, integrity, and availability of the system are
compromised.


Fix Effectiveness
--------------------------------------------------------------------
The widening of all relevant variables to 64-bit removes the immediate
truncation defect and aligns consumer and producer type expectations.
No residual 32-bit copies of the flag remain in the function, so the
specific type confusion detailed above is resolved.  Adequacy of other
callers is unknown, but for this code path the patch appears
complete.
