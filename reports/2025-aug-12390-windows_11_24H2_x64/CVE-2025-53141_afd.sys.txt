{'date': 1755089272.0840704, 'patch_store_uid': '230e7c66-244b-4041-b166-2157fff153a1', 'cve': 'CVE-2025-53141', 'file': 'afd.sys', 'kb': 'KB5063878', 'change_count': 8, 'confidence': 0.22}
--------------------------------------------------------------------
CVE-2025-53141 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows kernel – afd.sys (Ancillary Function Driver for WinSock)


Vulnerability Class
--------------------------------------------------------------------
NULL-pointer / NULL function-pointer dereference leading to
Elevation-of-Privilege (CWE-476)


Detailed Root Cause Analysis
--------------------------------------------------------------------
The AFD endpoint structure (typ. struct _AFD_ENDPOINT) contains two
callback-tables that are supplied by the underlying transport layer
(TL) driver:
  + offset +0x1E0 (0x480)  ->  TL handle
  + offset +0x1E8 (0x488)  ->  pointer to a table of close / IO
                               completion routines

During the AFD_UNBIND ioctl (handled by AfdUnBindSocket) the driver
has to tear-down an eventually created dual-stack TL endpoint.  When
the socket was opened with the AFD_ENDPOINT_FLAG_TL_PROVIDER (bit
0x200) set, the legacy code performed the following sequence:

  1.  v21  = *(endpoint  + 0x480);          // TL handle
  2.  v19  = *(endpoint  + 0x488);          // **function table**
  3.  (*v19)(v21, params);                  // unconditional call

If the transport layer initialisation had never completed, field
0x488 stayed NULL.  Step 3 therefore dereferenced address 0x0, causing
an exception in kernel context.  Because user-mode code can reach this
path with only a socket handle, the crash is fully triggerable from a
least-privileged account.  Mapping user controlled data to address 0x0
(nowadays restricted but still possible on some systems / configs)
turns the crash into a controlled function-pointer call and therefore
an elevation of privilege.

Conditions that lead to a NULL callback pointer:
•   Create IPv6 socket, call IOCTL_AFD_BIND/CONNECT so that the IPv4
    “shadow” TL endpoint is requested but fails early.
•   The 0x200 flag is set, but the TL provider never returns its
    dispatch table – endpoint->TlDispatch becomes NULL.
•   Invoke IOCTL_AFD_UNBIND.

Because AfdUnBindSocket executed the callback unconditionally, the
kernel dereferenced NULL every time the above sequence was followed.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// afd!AfdUnBindSocket  (before)
...
v19 = *(unsigned int (__fastcall ***)(__int64, __int64 *))(ep + 0x488);
...
if ( (*v19)(v18, v32) == STATUS_PENDING )   // <== v19 may be NULL
    KeWaitForSingleObject(...);
```
```c
// afd!AfdUnBindSocket  (after)
...
v22 = *(unsigned int (__fastcall ***)(__int64, __int64 *))(ep + 0x488);
...
if ( !FeatureGuard || v22 )                 // new null-check
{
    KeResetEvent(...);
    args[0] = AfdSynchronousTlCloseRequestComplete;
    args[1] = (INT64)&Evt;
    if ( (*v22)(v21, args) == STATUS_PENDING )
        KeWaitForSingleObject(...);
}
else                                         // pointer was NULL
{
    WPP_SF_(40, TraceGuid);                  // trace & skip call
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User process
   └─ ioctl( AFD_UNBIND, sockHandle, bufWithSockaddr )
2. afd.sys : AfdUnBindSocket
   └─ enters path for TL-provider sockets (flag 0x200)
3. Endpoint->TlDispatch is still NULL
4. NULL call *TlDispatch->Close()  ➜ kernel exception / EoP


Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker with the ability to create and control
WinSock sockets.  No special privileges are required; any user can
open a socket and issue the crafted IOCTL sequence.


Patch Description
--------------------------------------------------------------------
The patch adds explicit validation before the indirect call:
•   reads the function-pointer table into a local variable (v22)
•   executes the close routine only if v22 is non-NULL or if the new
    feature-guard is disabled
•   otherwise emits a trace message and skips the call
Similar defensive checks were inserted in other code-paths that used
endpoint callback pointers (AfdGetAddress, AfdQueryHandles, etc.).


Security Impact
--------------------------------------------------------------------
Prior to the patch a user-controlled NULL function-pointer dereference
allowed local DoS and, on systems where a NULL page can be mapped
(e.g. through a driver bug or incompatible mitigation), arbitrary code
execution in kernel mode, resulting in full privilege escalation.


Fix Effectiveness
--------------------------------------------------------------------
The vulnerable call site is now guarded by a concrete NULL test,
ensuring that no indirect call is issued when the callback table is
absent.  No additional paths to the same function pointer were found
in the updated binary, making the fix comprehensive for this flaw.
