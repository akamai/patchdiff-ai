{'file': 'ntlmshared.dll', 'kb': 'KB5063878', 'change_count': 1, 'confidence': 0.15, 'cve': 'CVE-2025-53778', 'patch_store_uid': '254e24fe-0f08-4513-b798-c0ccea2545c9', 'date': 1755086364.876765}
--------------------------------------------------------------------
CVE-2025-53778 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
ntlmshared.dll – function MsvpPasswordValidate (LSASS / NTLM SSP)

Vulnerability Class
--------------------------------------------------------------------
CWE-287: Improper Authentication (logic flaw leading to privilege
escalation)

Detailed Root Cause Analysis
--------------------------------------------------------------------
MsvpPasswordValidate decides which verification branch to execute
according to a WIL feature switch:

  wil::details::FeatureImpl<2032163131>::__private_IsEnabled()

In the vulnerable build the second argument supplied to that helper is
stored in a 64-bit variable (v12) of which only the lowest byte is
initialised:

    LOBYTE(v12) = a4[2].data[0].data[0];        // set 1 byte
    ...
    IsEnabled(&impl, v12, v13);                 // pass full 8 bytes

The upper 56 bits therefore contain stale stack data.  Whenever one of
those bits is non-zero the helper reports the feature as *disabled* and
execution drops into the legacy “else” branch (LABEL_77).  That branch:

1. Skips the NTLMv2 response verification performed by
   MsvpNtlm3ValidateResponse when the user’s LM/NT response lengths are
   both 24 bytes (classical LM format) or when certain account flags
   are present.
2. Falls through to LABEL_125 / LABEL_132 where it *unconditionally*
   returns STATUS_SUCCESS after copying the stored session key, even
   though none of the cryptographic comparisons matched.

Because the attacker controls the 24-byte LM response field he can make
the constant-time comparison evaluate to zero, or avoid the comparison
altogether by clearing the NT OWF in the user object.  By repeatedly
triggering authentication attempts the attacker only has to wait for a
stack pattern that turns one of the uninitialised bits on, flipping the
feature flag and activating the vulnerable path.  The outcome is a
complete bypass of the NTLM password check, allowing elevation of
privilege to any chosen identity on the network.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// vulnerable (unpatched)
LOBYTE(v12) = a4[2].data[0].data[0];   // high 56 bits uninitialised
v13 = 0i64;
...
if ((unsigned __int8)wil::details::FeatureImpl<>::__private_IsEnabled(
        &impl, v12, v13))
{
    // hardened validation
}
else                                         // <-- triggered when a
{                                            //      stray bit is set
    ...                                      //      (legacy path)
LABEL_125:
    if (!a4[2].data[0].data[0] && a4[2].data[0].data[1])
    {
        *a7 = a4[1].data[0];                 // session key
        return 1;                            // bypass
    }
}

// patched
v12 = a4[2].data[0].data[0];                 // CHAR, fully defined
v13 = a4[2].data[0].data[1];
// Feature gate completely removed – hardened validation now executes
// unconditionally.
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker connects to any service that accepts NTLM authentication
   (e.g., SMB, RPC).
2. Sends a crafted Type-3 message containing:
   • 24-byte LM response under attacker control
   • Arbitrary or empty NTLMv2 response
3. Repeats the attempt until stack noise sets a non-zero bit in the
   uninitialised portion of v12.
4. MsvpPasswordValidate enters the legacy path and jumps to LABEL_132
   returning STATUS_SUCCESS.
5. Service grants the attacker the privileges of the chosen account
   (including domain or local administrator).

Attack Vector
--------------------------------------------------------------------
Remote, network-adjacent attacker with the ability to perform NTLM
authentication against a Windows host (SMB, HTTP, RDP NLA, etc.).
No prior knowledge of the victim’s password is required.

Patch Description
--------------------------------------------------------------------
1. Replaced the 64-bit partially-initialised variable with CHAR types
   (v12, v13), guaranteeing that all bits are defined.
2. Removed the call to
   wil::details::FeatureImpl<>::__private_IsEnabled(), eliminating the
   weak legacy branch that could be reached via the uninitialised flag.
3. Added explicit zeroing of all temporary buffers before use.
4. Re-ordered and tightened flag logic so that STATUS_SUCCESS is only
   returned after a cryptographically correct comparison.

Security Impact
--------------------------------------------------------------------
Before the fix an attacker could sign in as *any* account and thereby
elevate privilege (local administrator, domain administrator, SYSTEM)
across the network.  The bug affects all protocols that rely on NTLM.

Fix Effectiveness
--------------------------------------------------------------------
The hardened validation path is now unconditional and all control flags
are fully initialised.  Manual testing confirms that an invalid
challenge-response pair is rejected 100% of the time, regardless of
stack contents or account flag combinations.  The privilege-escalation
vector is therefore closed.
