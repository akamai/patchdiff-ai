{'confidence': 0.12, 'patch_store_uid': 'bec87310-c45d-4672-9489-ba62a53bcd8d', 'file': 'wpnprv.dll', 'cve': 'CVE-2025-50155', 'date': 1755089363.619809, 'kb': 'KB5063878', 'change_count': 15}
--------------------------------------------------------------------
CVE-2025-50155 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Push Notifications Platform (wpnprv.dll) – internal service
classes NotificationServiceImpl and CWNPTransportImpl that parse and
process incoming WNS messages and SQM/telemetry data.


Vulnerability Class
--------------------------------------------------------------------
Type confusion / access of a resource using an incompatible type
(CWE-843) that ultimately leads to a heap use-after-free / invalid
free (CWE-122).


Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  Incoming WNS messages are received in
    NotificationServiceImpl::OnNotification().  The message parser
    returns several primitive fields (booleans, integers) plus many
    heap-allocated UTF-16 strings that are stored in local pointer
    variables (e.g. unsigned __int16 *v42).

2.  In the buggy build the same stack variable is re-used both as a
    pointer and as an integer flag:
       LODWORD(v42) = v35;          // v35 == AckRequired (byte)
    v42 is later assumed to be a real wchar_t* and released through a
    wil::unique_storage destructor.  When AckRequired is 1, v42 holds
    the value 0x00000001 – an invalid heap pointer.

3.  If any subsequent operation fails (ParseNotification, logging,
    COM calls, etc.) the function unwinds.  wil::unique_storage’s
    destructor executes and blindly calls HeapFree() on the corrupted
    value stored in v42.  This is a classic type confusion that
    converts a small integer into a heap pointer.

4.  Exactly the same pattern existed in other paths (e.g.
    CWNPTransportImpl::SQMWnpConnectAttempt and
    CWNPTransportImpl::GetSqmConnectionData).  Integer values were
    written into pointer variables via LODWORD/LOBYTE macros and those
    variables were later freed, leading to arbitrary-pointer-free.

5.  The attacker controls the execution flow that triggers the error
    (for example by providing a malformed notification that forces one
    of the many Throw_Hr() paths).  When the integer 1 is freed the
    kernel’s heap manager treats it as a pointer inside the current
    process heap, resulting in memory corruption and ultimately
    elevation of privilege inside the Push Notifications service.

Affected structures / data:
    • unsigned __int16 *v42 / v61 (notification channel URI)
    • LPVOID lpMem / v29 / v31 in SQMWnpConnectAttempt()
    • local wil::unique_storage<> and HeapFree() clean-up blocks


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
v35 = *((BYTE *)v51 + 32);   // boolean AckRequired
LODWORD(v42) = v35;          // **pointer overwritten with int**
...
// function may throw -> clean-up:
wil::details::unique_storage<...>::~unique_storage(&v42); // HeapFree(0x1)

// after (patch)
v36 = *((BYTE *)v51 + 32);   // store flag in its own byte
// pointer variable never overwritten
```

```c
// CWNPTransportImpl::SQMWnpConnectAttempt – before
p_lpMem = &lpMem;
...
LODWORD(p_lpMem) = v5;       // tick-count inserted into pointer
...
HeapFree(ProcessHeap, 0, lpMem); // lpMem still valid but *p_lpMem abused

// after – dedicated integer variables added, no pointer smashing
```
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker sends a specially crafted WNS payload to the target system.
2. NotificationServiceImpl::OnNotification() parses the payload; a
   boolean field is extracted (AckRequired).
3. The buggy cast writes that boolean into a pointer variable.
4. Attacker influences code to hit an error path (e.g. invalid UTF-8
   string, feature gate mismatch) causing Throw_Hr() / exception.
5. Stack unwinds, wil destructors run and free the poisoned pointer.
6. Heap metadata corruption -> arbitrary memory write -> local EoP.


Attack Vector
--------------------------------------------------------------------
Any local user capable of delivering a malicious push notification to
his own registered toast channel (or to another local app running
under the Push Notifications service) can trigger the bug.  No admin
rights are required; the service runs with higher privileges so the
bug enables elevation.


Patch Description
--------------------------------------------------------------------
• Introduced separate, correctly typed local variables for every
  primitive field returned by the parser / transport layer (v36, v37,
  v38, etc.).
• Removed all LODWORD/LOBYTE writes that mixed integers into pointer
  variables.
• Added new scope-guard helpers (wil::ScopeExit…) to ensure correct
  lifetime management without re-using variables.
• Updated WPP trace calls to use the new primitives instead of casting
  pointer variables.


Security Impact
--------------------------------------------------------------------
Prior to the patch an attacker-controlled boolean could be turned into
an arbitrary pointer passed to HeapFree/LocalFree.  This enables heap
corruption and reliable privilege escalation from a normal user context
into SYSTEM (the Push Notifications service account).


Fix Effectiveness
--------------------------------------------------------------------
The patched build keeps all pointer variables untouched by integer
assignments and only frees memory that has been allocated.  No code
path writes primitive values into pointer storage.  Therefore the type
confusion and resulting invalid free are eliminated and the EoP vector
is closed.

