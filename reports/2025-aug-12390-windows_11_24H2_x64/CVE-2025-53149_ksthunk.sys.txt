{'kb': 'KB5063878', 'patch_store_uid': 'cfd25660-cbce-42b2-816e-22a3968aaf50', 'cve': 'CVE-2025-53149', 'date': 1755086291.2022102, 'change_count': 3, 'confidence': 0.36, 'file': 'ksthunk.sys'}
--------------------------------------------------------------------
CVE-2025-53149 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows Kernel Streaming WOW-Thunk Service Driver
(ksthunk.sys), specifically the automation/streaming helper
routines:
  • CKSAutomationThunk::HandleArrayProperty()
  • CKSThunkDevice::CheckIrpForStackAdjustmentNative()
  • CKSThunkPin::ThunkStreamingIrp()


Vulnerability Class
--------------------------------------------------------------------
Heap-based buffer overflow / improper size validation (CWE-122)
leading to kernel memory corruption and local elevation of
privilege.


Detailed Root Cause Analysis
--------------------------------------------------------------------
1. HandleArrayProperty(GET path)
   • For property queries where Flags bit 1 is clear
     (a2->Flags & 2 == 0) the routine receives a variable-length
     array from the underlying KS filter.
   • BytesReturned (length provided by the lower driver) is used
     verbatim to allocate PoolWithTag.
   • After the second KsSynchronousIoControlDevice() call the
     buffer layout is assumed to be:
          DWORD Count           (PoolWithTag[0])
          DWORD Padding
          DWORD Data[Count]     (PoolWithTag+2 … )
   • The driver immediately performs the copy
          for i in 0..Count-1
              *(a3+1+i) = PoolWithTag[2+2*i]
     without checking that:
       – Count * sizeof(DWORD) is actually present inside
         BytesReturned; or
       – the caller-supplied output buffer length
         (CurrentStackLocation->Parameters.Read.Length) is large
         enough for Count+1 DWORDS.
   • A malicious user mode client can supply a small output buffer
     length yet make the lower filter return an arbitrarily large
     Count value.  The loop therefore writes past the end of the
     caller’s buffer and corrupts kernel heap memory because the
     copy is performed with a kernel pointer (MmProbeForWrite has
     already succeeded).

2. CheckIrpForStackAdjustmentNative & ThunkStreamingIrp
   • Similar patterns existed: user-controlled size fields taken
     from CREATE_PIPE parameters or KSSTREAM_HEADER structures are
     trusted when allocating pool or building MDLs.
   • Copies were performed with memmove() / RtlCopyFromUser() with
     no secondary range checks, allowing integer truncation or
     length mismatches to overflow the destination allocations.

3. Patch corrections
   • Introduces precise integer-overflow checks     
         new variables v20 / v21 etc. ensure
        (Count + 1) * 4 < 2^32 and no wrap-around.
   • Verifies that Read.Length ≥ 4*(Count+1) before copying.
   • On failure the code now returns STATUS_INVALID_PARAMETER
     (-0x7FF8F009) and logs with RtlLogUnexpectedCodepath().
   • Replaces blind memmove with RtlCopyVolatileMemory() to remove
     stale-data TOCTOU windows and adds feature-gated paths for
     hardened probing.

Structures / parameters affected
   KSARRAY property blob :
       DWORD ElementCount;
       DWORD Elements[...];
   KSSTREAM_HEADER        : size / FrameExtent / DataUsed / Flags
   NAMED_PIPE_CREATE_PARAMETERS inside IRP_MJ_CREATE ioctl path.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
*a3 = *v15;                     // v15 == PoolWithTag
if (*(_QWORD *)v15) {
    do {
        ++v5;
        *v4 = *v19;            // v4 = a3+1, v19 = PoolWithTag+2
        v19 += 2;
        ++v4;
    } while ((unsigned __int64)v5 < *(_QWORD *)v15);
}

// after (excerpt)
v20 = *PoolWithTag + 1;
if ((uint)v20 < *PoolWithTag ||           // underflow
    4*v20 > 0xFFFFFFFF ||                 // 32-bit limit
    CurrentStackLocation->Parameters.Read.Length < 4*v20)
{
    RtlLogUnexpectedCodepath(...);
    v17 = STATUS_INVALID_PARAMETER;
    goto cleanup;
}
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User process opens a KS filter via ksproxy and obtains a handle
   to ksthunk.sys.
2. Sends IOCTL_KS_PROPERTY with KSPROPERTY_TYPE_GET and crafted
   property id that is handled by HandleArrayProperty().
3. Lower filter returns a large element count; user supplies a
   small output buffer.
4. Driver copies Count*4 bytes past the end of its pool-allocated
   buffer, corrupting pool metadata.
5. Corrupted heap objects allow execution of arbitrary kernel
   code, yielding SYSTEM privileges.


Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker running in a 32-bit user-mode
process on a 64-bit Windows system.  Requires only the ability to
issue DeviceIoControl calls to the publicly accessible KS device
interface (no special privileges).  No user-interaction needed.


Patch Description
--------------------------------------------------------------------
• Added strict integer arithmetic checks (overflow & truncation)
  on element counts, sizes, and IRP buffer lengths.
• Added CurrentStackLocation->Parameters.Read.Length comparison
  before copying results back to caller.
• Replaced memmove/ProbeForRead paths with
  RtlCopyVolatileMemory / additional ProbeForRead/Write to avoid
  TOCTOU.
• Hardened metadata handling in
  CheckIrpForStackAdjustmentNative() and ThunkStreamingIrp(),
  including new IoAllocateMdl() guards.
• Failure paths now free allocations and return proper NTSTATUS
  errors instead of silently continuing.


Security Impact
--------------------------------------------------------------------
Prior to the patch a malformed KS property/stream request allowed
arbitrary heap overwrite in the kernel’s non-paged pool.  An
attacker could craft the overwrite to:
  – Modify function pointers or OBJECT_HEADER fields
  – Achieve arbitrary kernel-mode code execution
  – Escalate from normal user privileges to SYSTEM

No mitigations blocked the primitive because the copy occurred
entirely in kernel context after ProbeForWrite succeeded.


Fix Effectiveness
--------------------------------------------------------------------
The added arithmetic checks guarantee that the driver never copies
more than the caller-supplied buffer length and that all size
calculations stay within 32-bit limits; loops now operate only on
validated counts.  Pool freeing logic is executed on all error
exits.  No residual uncontrolled copy paths were found in the
modified routines, making the patch effective against the reported
heap overflow.

