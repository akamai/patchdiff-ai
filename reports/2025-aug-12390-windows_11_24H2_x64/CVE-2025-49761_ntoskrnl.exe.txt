{'kb': 'KB5063878', 'cve': 'CVE-2025-49761', 'date': 1755086868.8876605, 'patch_store_uid': '203c1d43-d415-4c93-8448-a2d4f1c0abdd', 'confidence': 0.23, 'file': 'ntoskrnl.exe', 'change_count': 184}
--------------------------------------------------------------------
CVE-2025-49761 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows NT kernel (ntoskrnl.exe) – I/O manager routine
IopDequeueIrpFromFileObject().  This helper is used when an IRP is
removed from the per-FILE_OBJECT IRP queue (FsRtlCancelQueue etc.).


Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use After Free caused by incorrect manual reference
counting / premature object destruction.


Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  An IRP contains a Tail.Overlay.OriginalFileObject pointer at
    offset +0x58 (88).  The pointer is stored in the IRP with the low
    three flag bits set; the real kernel object address is therefore
      v8 = *(irp+88) & ~7.

2.  Prior to the patch, IopDequeueIrpFromFileObject() attempted to
    dereference that FILE_OBJECT *inside the file-object spin lock* and
    *inline*, bypassing the Object Manager helpers:
       _InterlockedExchangeAdd64(v8-0x30, -1)
       if (newcount <= 0) ObpRemoveObjectRoutine(...)

3.  The code therefore:
    • Performs the final decrement while still holding the
      FILE_OBJECT->SpinLock at IRQL DISPATCH_LEVEL.
    • Immediately invokes the heavy object-destruction path
      (ObpRemoveObjectRoutine / ObpDeregisterObject / free).

4.  If the IRP’s OriginalFileObject is identical to the file object
    whose lock is held (the normal case), the routine frees the object
    that owns the currently-held spin lock.  The lock word becomes
    stale freed memory, but the routine continues to touch it when it
    later releases the lock and lowers IRQL.  Concurrent threads that
    attempt to acquire the same spin lock now operate on freed memory
    – classic use-after-free.

5.  An attacker controlling a user thread can race two I/O paths so
    that one thread dequeues the last IRP (triggering the free) while
    another thread is about to acquire the same lock, leading to
    arbitrary kernel memory corruption and ultimately local
    privilege-escalation.

6.  The root cause is thus *premature object destruction inside a
    critical section* instead of using the exported ObDereference
    helpers which defer final deletion until it is safe.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// pre-patch excerpt (simplified)
v8 = *(irp + 0x58) & ~7ULL;              // OriginalFileObject
...
count = _InterlockedExchangeAdd64((volatile LONGLONG *)(v8-0x30), -1);
if (count <= 1) {
    /* object finalisation & free while holding spin lock */
    ObpRemoveObjectRoutine(v8-0x30, 0);
}
...
_InterlockedAnd64(FileObj->SpinLock, 0); // operates on freed memory
```

```c
// fixed version
if (IopVelocityFlags & 1)
    ObFastDereferenceObject(&KeGetCurrentThread()->...
                             ,v8, TAG);
else
    ObfDereferenceObjectWithTag((PVOID)v8, TAG);  // safe helper
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
User thread
  -> NtDeviceIoControlFile / ReadFile / CancelIo etc.
  -> IoCancelFileOpen / IopCancelIrp / FsRtlCancelQueue IRP path
  -> IopDequeueIrpFromFileObject()
       (last IRP for the file)      <-- vulnerability triggers
  -> freed FILE_OBJECT still has active spin-lock waiters
  -> subsequent kernel access -> UAF & memory corruption.


Attack Vector
--------------------------------------------------------------------
Local attacker with the ability to open any file handle and issue
parallel I/O requests can cause two threads to dequeue the same FILE
OBJECT’s final IRP concurrently.  A precise race frees the object
while its spin lock is still in use, allowing controlled reuse of the
freed kernel pool memory and escalation to SYSTEM.


Patch Description
--------------------------------------------------------------------
1. Replaced custom spin-lock logic with
      KeAcquireSpinLockRaiseToDpc / KiReleaseSpinLockInstrumented.
   This guarantees balanced IRQL handling and standard lock rules.

2. Removed the inline reference-count decrement and object-finalisation
   sequence.  All reference handling is now delegated to
      ObfDereferenceObjectWithTag() or the fast dereference path when
   IopVelocityFlags indicates it is safe.

3. The object is therefore *never* destroyed while the file object’s
   spin lock is held; final deletion is deferred until after the lock
   is released, eliminating the UAF window.

4. Miscellaneous clean-ups (return type, 64-bit lock word) are
   secondary but further harden the code.


Security Impact
--------------------------------------------------------------------
Prior to the patch a local attacker could obtain arbitrary kernel
memory write primitives via UAF, leading to elevation of privilege to
SYSTEM.  The issue is reachable without special privileges beyond the
ability to issue I/O to a file handle.


Fix Effectiveness
--------------------------------------------------------------------
The unsafe inline dereference path has been completely removed and
replaced with the well-tested Object Manager helper, which defers final
freeing until the object is no longer in critical sections.  Locking
is now handled by standard kernel APIs.  No residual code path still
performs manual object destruction, so the specific vulnerability is
considered fully remediated.

