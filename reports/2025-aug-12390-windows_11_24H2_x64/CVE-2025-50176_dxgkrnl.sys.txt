{'patch_store_uid': 'cee7f502-5c15-4036-bc3b-c01349c9ae48', 'confidence': 0.08, 'kb': 'KB5063878', 'file': 'dxgkrnl.sys', 'change_count': 33, 'cve': 'CVE-2025-50176', 'date': 1755089796.6052814}
--------------------------------------------------------------------
CVE-2025-50176 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Windows DirectX Graphics Kernel (dxgkrnl.sys)
Functions affected:
 • DxgGetHandleDataCB
 • ValidateDestroyAllocation
Handle-table processing of DXGRESOURCE / DXGALLOCATION objects.


Vulnerability Class
--------------------------------------------------------------------
Type-confusion / use-after-free caused by accepting a handle whose
underlying entry has an incompatible or destroyed object type.
(CWE-843, maps to the published CVE description).


Detailed Root Cause Analysis
--------------------------------------------------------------------
Graphics objects (resources, allocations, etc.) are tracked in a per
process handle table.  For each entry the low 5 bits describe the
object type, bit 0x2000 marks a "Destroyed" entry, and bit 0x4000 is a
secondary “device usage” state that indicates the entry has already
been transitioned by the driver.

1. DxgGetHandleDataCB (code path "case 2" – resource handles)
   Before the patch the code accepted a table entry when:
     a) The caller-supplied handle matched the high-order security
        bits 0x60, and
     b) (EntryFlags & 0x2000) == 0               (not Destroyed)
        and
     c) (EntryFlags & 0x1F) != 0                 (any non-zero type)
   The pointer stored in the entry was then returned to the caller
   without any further validation.

   If the driver recycled the entry by setting bit 0x4000 but left
   0x2000 cleared, the routine treated the slot as valid and returned a
   pointer that no longer represented the original object.  Subsequent
   use of that stale pointer produced type confusion inside the kernel
   and allowed controlled memory corruption.

2. ValidateDestroyAllocation performed an almost identical test when
   walking an array of allocation handles.  The same missing check for
   the 0x4000 transition bit let a stale or mismatched allocation
   pointer pass validation, leading to the same primitive while the
   function held various internal locks.

Both paths ran while holding only a shared lock; therefore another
thread (or the GPU driver itself) could free or repurpose the backing
object between the time validation completed and the pointer was
used, turning the logical type confusion into a Use-After-Free that is
reliably exploitable for kernel RCE.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// DxgGetHandleDataCB  (before)
if (((h >> 25) & 0x60) == (EntryFlags & 0x60) &&
    (EntryFlags & 0x2000) == 0 &&          // ONLY 0x2000 checked
    (EntryFlags & 0x1F) != 0)              // any non-zero type
{
    pRes = *(DXGRESOURCE **)(Table + Index*16);
}

// after
if (((h >> 25) & 0x60) == (EntryFlags & 0x60) &&
    ((EntryFlags & 0x2000) == 0 ||          // accept only if not
     (EntryFlags & 0x4000) != 0) &&         // OR specially flagged
    (EntryFlags & 0x1F) == 4)               // exact type check
{
    pRes = *(DXGRESOURCE **)(Table + Index*16);
}
```
Same pattern appears in ValidateDestroyAllocation for allocation type
(0x1F == 5).


Trigger Flow (Top-Down)
--------------------------------------------------------------------
User / driver code → D3DKMT / DXG syscall →
  DxgGetHandleDataCB or ValidateDestroyAllocation →
  Handle table entry validated with outdated rules →
  Stale pointer for freed or wrong-type object returned →
  Kernel continues operating on bogus object → memory corruption.


Attack Vector
--------------------------------------------------------------------
A local, authenticated attacker (or a compromised user-mode graphics
component) frees a resource/ allocation, re-uses the handle after the
driver sets the 0x4000 transition bit, and calls the affected kernel
DDIs.  Because the stale pointer is now interpreted as a different
kernel object type, the attacker controls subsequent kernel memory
writes and can execute arbitrary code in kernel context.


Patch Description
--------------------------------------------------------------------
1. Introduced Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage_8() gate
   that switches the stricter validation on.
2. Validation now allows an entry only when
      (Destroyed == 0)   OR   (TransitionBit 0x4000 is set)
   *and* the exact expected object type matches (4 for resources, 5
   for allocations).
3. Added defensive logging (new line numbers 318, 131, etc.) and early
   bail-out paths when a mismatched / transitioned entry is detected.
4. Same tightening applied throughout ValidateDestroyAllocation.
5. Additional clean-up: widened local variables, ensured all failure
   paths drop acquired rundown protection and locks.


Security Impact
--------------------------------------------------------------------
Prior to the fix, a malicious handle could bypass type checks and hand
back an arbitrary, potentially freed pointer to the graphics kernel.
The subsequent use of that pointer permits:
  • Kernel pool use-after-free
  • Type confusion between DXGRESOURCE / DXGALLOCATION objects
  • Elevation to kernel execution (Local Privilege Escalation)
  • In graphics-remoting scenarios, Remote Code Execution in the guest
    VM (per MSRC classification).


Fix Effectiveness
--------------------------------------------------------------------
The new logic blocks entries whose object type is wrong or whose state
has been transitioned without the additional 0x4000 flag, eliminating
the stale-pointer window that enabled the exploit. The same strict
checks are applied in every caller that walks or destroys allocation
handles, preventing alternative paths to the bug.
No bypass or obvious regression was observed in the patched code.

