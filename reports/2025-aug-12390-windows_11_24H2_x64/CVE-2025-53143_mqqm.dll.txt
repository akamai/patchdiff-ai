{'confidence': 0.18, 'cve': 'CVE-2025-53143', 'change_count': 11, 'kb': 'KB5063878', 'date': 1755089406.5024087, 'file': 'mqqm.dll', 'patch_store_uid': '2d4fad2a-6929-40c4-8e2b-8117e27bb0cc'}
--------------------------------------------------------------------
CVE-2025-53143 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft Message Queuing (MSMQ)
User-mode service binary: mqqm.dll
Functions affected:  
 • CMessageTransport::DeliverPacket  
 • CMessageTransport::GetPacketForSendingSucceeded  
 • RPC_INT_XACT_HANDLE_rundown / QMDo*Transaction helpers  
 • PCTX_OPENREMOTE_HANDLE_TYPE_rundown


Vulnerability Class
--------------------------------------------------------------------
Type confusion – Access of resource using incompatible type (CWE-843).
An EXOVERLAPPED pointer returned by I/O completion is interpreted as a
CMessageTransport object that never actually owns that memory.


Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  When MSMQ sends data it builds an extended OVERLAPPED structure and
    submits it with WSASend/WriteFile.

2.  Before the patch the send routine allocates only the EXOVERLAPPED
    object itself (0x40 bytes) on the heap:
        v5 = MmAllocate(0x40);
        /* fill a few fields and submit */

3.  Upon completion the runtime calls
    CMessageTransport::GetPacketForSendingSucceeded(EXOVERLAPPED *ov).
    The routine tries to recover the owning transport object with
        owner = (char*)ov – 0x1E8;   // 0x1E8 = 488 dec

    This assumes that the EXOVERLAPPED is *embedded* inside a much
    larger CMessageTransport object at offset 0x1E8.  In reality the
    pointer handed back by the I/O subsystem is the heap buffer that was
    just allocated in DeliverPacket, so the arithmetic produces a
    pointer 488 bytes *before* the real allocation.

4.  The resulting mis-typed pointer is immediately dereferenced for:
        • virtual-method dispatch (function-pointer call)
        • reference-count updates
        • critical-section access
    Because the memory region is outside the allocated buffer the
    attacker can influence its contents through heap shaping or payload
    data, ultimately controlling the function pointer and achieving
    remote code execution in the MSMQ service (runs under the service
    account).

5.  The same incorrect assumption affects the error path
    GetPacketForSendingFailed (not shown) and other helpers that use the
    same cast pattern.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
v5 = MmAllocate(0x40ui64);          // allocate only EXOVERLAPPED
...
// callback
char *owner = (char*)ov - 488;      // treat as CMessageTransport
...
(*(void (__fastcall **)(_QWORD, CQmPacket *))(**((_QWORD **)owner+10)+8))(...);
```
```c
// after
void *buf = MmAllocate(0x40ui64);
CSendOv *ov = CSendOv::CSendOv(buf, this, &reqBuf);      // builds
                                                         //   full wrapper
// callback logic unchanged; subtraction now lands inside CSendOv
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. Attacker causes MSMQ to establish an outgoing session.
2. CMessageTransport::DeliverPacket allocates 0x40-byte OVERLAPPED and
   submits async send.
3. Completion arrives -> GetPacketForSendingSucceeded is invoked with
   pointer to that buffer.
4. Pointer arithmetic under-flows, creating forged CMessageTransport*.
5. Forged object’s vtable / fields are used, leading to controlled
   code execution.


Attack Vector
--------------------------------------------------------------------
A network client with permission to interact with the remote queue sends
crafted traffic that forces the service to send a packet back. When the
packet completes, the malformed bookkeeping causes type confusion. No
local privileges are required; exploit works over the network via the
MSMQ protocol (TCP port 1801).


Patch Description
--------------------------------------------------------------------
1. Introduced class CSendOv whose first member is the EXOVERLAPPED; the
   object size is at least 0x1E8+0x40, so `ov-0x1E8` now points to the
   CSendOv header that deliberately carries a back-pointer to the owning
   CMessageTransport.
2. DeliverPacket now calls the CSendOv constructor instead of manually
   zeroing memory, guaranteeing correct layout and initialisation.
3. Additional state/feature checks (IsDeliveryAllowed, Validate*() )
   were added to refuse invalid objects early but are secondary.


Security Impact
--------------------------------------------------------------------
Before the fix an authenticated MSMQ peer could trigger a function-
pointer dereference through heap-based type confusion, yielding
arbitrary code execution in the MSMQ service process (RCE, same
privilege as mqsvc.exe, typically NT AUTHORITY\NETWORK SERVICE).


Fix Effectiveness
--------------------------------------------------------------------
The patched code guarantees that the EXOVERLAPPED handed to the I/O
API is embedded in a correctly-sized CSendOv wrapper, eliminating the
invalid pointer calculation and thereby removing the primitive needed
for type confusion.  No residual paths to the old layout were observed
in the provided diff, so the remediation appears complete.

