{'file': 'printworkflowservice.dll', 'date': 1755086574.261769, 'cve': 'CVE-2025-53133', 'confidence': 0.19, 'patch_store_uid': 'a60bcf44-1bda-4d1c-b416-ff9675a6f222', 'change_count': 7, 'kb': 'KB5063878'}
--------------------------------------------------------------------
CVE-2025-53133 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows PrintWorkflowUserSvc, implemented in printworkflowservice.dll.
Affected routines include
 • PrintSupportSession::LaunchUIForJob
 • several wil::details::FeatureImpl::<GetCurrentFeatureEnabledState>()
   helpers that gate the LaunchUIForJob code path.

Vulnerability Class
--------------------------------------------------------------------
Use-after-free (CWE-416).

Detailed Root Cause Analysis
--------------------------------------------------------------------
LaunchUIForJob is responsible for
1. switching the PrintSupportSession state to “UI-launch”,
2. creating a WorkflowJobActivationEventArgs COM object, and
3. passing that object to PrintSupportSessionCommon::LaunchAppUI,
   which schedules asynchronous work that continues to reference the
   same object.

In the vulnerable build the function keeps the object in local variable
`v23` and *releases* it immediately after LaunchAppUI returns when the
normal (non-error) path is taken:
    if (!error) {
        if (v23) v23->Release();   //<< premature free
    }
The later call to
    PrintSupportSessionCommon::WaitForEventOrProcessExit(...)
still allows code running in other threads – started via LaunchAppUI –
to dereference the just-freed object.  Because the object’s memory can
be re-allocated by an attacker-controlled print job, this results in a
use-after-free in the PrintWorkflowUserSvc process running with service
privileges.

Attack pre-conditions
• Session state bit 0x20 must not be set (normal case).
• FEATURE_PrintIppPsaStabilityFixes_2505 (and, in the old build, only
  that feature) must be enabled so the vulnerable branch is executed.

Patch changes reveal two corrective measures:
1.  Ownership Fix
    The patched function stores the pointer in `v28` and does *not*
    release it until **all** work is finished (cleanup is done via the
    final lambda after WaitForEventOrProcessExit).  The boolean `v32`
    tracks the lifetime so the object is never released prematurely.
2.  Feature Gating Tightened
    The call chain is now additionally conditioned on
    Feature_FileExplorer_InMarket_24A_Backport and
    Feature_PrintPlatformStabilizationFixes_2508.  This prevents the
    vulnerable path from running unless all new feature bits are on.

Together these changes ensure that the asynchronous code keeps a valid
reference for its whole lifetime and that the dangerous branch is no
longer reachable on systems where the fix is not present.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before – object released too early
v12 = (...)->as<IInspectable>(&v23, &v24);
LaunchAppUI(...);
if (!error) {
    if (v23)   // still used elsewhere
        v23->Release();   // UAF trigger
}
...
WaitForEventOrProcessExit(...); // other thread may deref freed obj
```
```c
// after – pointer kept until final cleanup
v17 = (...)->as<IInspectable>(&v28, &v29);
LaunchAppUI(...);
if (!error) {
    // object NOT released here any more
}
...
WaitForEventOrProcessExit(...);
...
if (v28)
    v28->Release();  // done only after all work finished
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. A normal user submits / resumes a print job.
2. PrintWorkflowUserSvc calls PrintSupportSession::LaunchUIForJob.
3. WorkflowJobActivationEventArgs is created and given to
   LaunchAppUI, which posts work to another thread.
4. Vulnerable code releases the object immediately.
5. The worker thread subsequently dereferences a dangling pointer –
   use-after-free.

Attack Vector
--------------------------------------------------------------------
Local.  Any authenticated user who can start a print job can trigger
LaunchUIForJob in the service context and race the premature release to
achieve controlled memory reuse.

Patch Description
--------------------------------------------------------------------
• Re-worked local variable layout so the activation-argument COM pointer
  (`v28`) is retained until after WaitForEventOrProcessExit.
• Added lifetime flag (`v32`) and consolidated all cleanup in the final
  lambda to guarantee single, late release.
• Added additional feature checks (FileExplorer_InMarket_24A_Backport
  and PrintPlatformStabilizationFixes_2508) so the risky code path is
  disabled unless the patched feature set is active.
• Minor refactors to wil::FeatureImpl helper functions to support the
  new gating logic; they are not security-relevant themselves.

Security Impact
--------------------------------------------------------------------
Exploiting the UAF allows an attacker running as a normal user to gain
code execution inside PrintWorkflowUserSvc, which runs with elevated
service privileges.  Successful exploitation therefore results in a
local elevation-of-privilege.

Fix Effectiveness
--------------------------------------------------------------------
The patched build keeps a valid reference to the activation event args
object for the complete duration of all asynchronous operations,
removing the dangling pointer entirely.  Because the object is only
released after all work is finished, the previously exploitable race no
longer exists.  Additional feature gating further reduces any residual
risk of accidentally re-enabling the vulnerable path, so the fix is
considered effective.
