{'file': 'ntoskrnl.exe', 'cve': 'CVE-2025-53151', 'kb': 'KB5063878', 'date': 1755089720.1652136, 'confidence': 0.55, 'change_count': 184, 'patch_store_uid': '203c1d43-d415-4c93-8448-a2d4f1c0abdd'}
--------------------------------------------------------------------
CVE-2025-53151 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
NTOSKRNL – NT-filesystem run-time library (FsRtl), specifically the
oplock read-handle (RH) code paths in
  • FsRtlpRemoveAndCompleteRHIrp
  • FsRtlCheckOplockEx2

Vulnerability Class
--------------------------------------------------------------------
CWE-416: Use-after-free (dangling pool pointer)

Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  The RH_OP_CONTEXT structure (symbolised as variable ‘P’) is
    allocated from non-paged pool and threaded through several oplock
    helper lists (Owner, RH queue, etc.).
2.  Prior to the patch FsRtlpRemoveAndCompleteRHIrp unconditionally
        ExFreePoolWithTag(P, 0);
    once the routine decided the IRP should be completed.  The free is
    performed before the IRP (v12) is finally completed via
    IofCompleteRequest and before other code paths have finished using
    the same context pointer.
3.  FsRtlCheckOplockEx2 as well as timeout / ack helpers still hold
    references to the same RH_OP_CONTEXT entry after
    FsRtlpRemoveAndCompleteRHIrp returns.  Any later access (for
    instance through FsRtlpOplockBreakToII / BreakToNone or the ack
    timeout worker) dereferences freed memory, creating a race-window
    UAF in the kernel.
4.  The bug is reachable from user-mode because a normal file handle
    can issue a crafted sequence of IRP_MJ_CREATE
    (FILE_OPEN_REPARSE_POINT, etc.) plus FSCTL_REQUEST_OPLOCK and the
    subsequent ACK/close pattern that exercises the code paths where
    *(_BYTE *)(IrpCtx+68)==0 and (a5 & 1)==0.
5.  Attackers can recycle the freed pool allocation with controlled
    data and obtain arbitrary read/write in kernel context, leading to
    privilege escalation.

Structures / fields involved
  RH_OP_CONTEXT (P)
    +0x00   List entries (owner & RH queue)
    +0x20   Flags (bit 0 ==> *(_BYTE *)(v12+68))
    +0x40   Owner file object pointer  (*((PVOID*)P+3))
    +0x28   Secondary owner pointer    (*((PVOID*)P+5))

Previously these pointers were cleared but the object was nonetheless
freed while still published in multiple lists.

Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
if (*(_BYTE *)(v12 + 68)) {
    ...
    ExFreePoolWithTag(P, 0);          // <--- freed early
} else {
    ...
    ExFreePoolWithTag(P, 0);          // <--- also freed early
}
...
IofCompleteRequest((PIRP)v12, 1);     // later users may still touch P
```
```c
// after (simplified)
char FreeLater = 0;
...
if (*(_BYTE *)(v12 + 68)) {
    ...
    if (FeatureFlagEnabled())         // new runtime gate
        FreeLater = 1;
    else
        ExFreePoolWithTag(P, 0);
} else {
    ...
    if (FeatureFlagEnabled())
        FreeLater = 1;
    else
        ExFreePoolWithTag(P, 0);
}
...
if (FeatureFlagEnabled() && FreeLater) {
    if (a8) *((_QWORD*)P + 11) = 0;   // clear timer context
    FsRtlpFreeRHOpContext(P);         // centralised, safe free
}
```

Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User process opens a file and requests an RH oplock (FSCTL)
2. Kernel queues RH_OP_CONTEXT ‘P’
3. Later user issues an ACK or closes the handle →
   FsRtlpRemoveAndCompleteRHIrp is executed
4. In the original build the function frees ‘P’ immediately
5. FsRtlCheckOplockEx2 or the ack-timeout DPC still owns ‘P’ and
   executes → dereference of freed memory → crash / arbitrary R/W

Attack Vector
--------------------------------------------------------------------
Local, authenticated attacker.  By manipulating ordinary file system
operations (open, oplock, read, close/ack) from user-mode they can
trigger the vulnerable RH completion path and race list processing to
achieve kernel-mode use-after-free.

Patch Description
--------------------------------------------------------------------
• Added a new boolean parameter (a8) to
  FsRtlpRemoveAndCompleteRHIrp allowing the caller to tell the routine
  whether the context is still referenced elsewhere.
• Introduced Feature_H2E_WPA3SAE__private_IsEnabledDeviceUsage_29()
  gate; when enabled the code defers freeing and instead records a flag
  (v13/FreeLater).
• After IRP completion the object is freed through a new helper
  FsRtlpFreeRHOpContext that performs proper reference counting and
  list removal.
• Similar lifetime fixes applied to FsRtlCheckOplockEx2; direct pool
  frees were replaced with synchronisation helpers and
  FsRtlpSyncWithAckTimeout.
• Massive refactor removed raw ExFreePoolWithTag calls in these paths.

Security Impact
--------------------------------------------------------------------
Before the patch an attacker could exploit the dangling pointer to
execute arbitrary code in kernel mode, thereby elevating privileges to
SYSTEM.  The vulnerability is therefore an Elevation-of-Privilege (EoP)
issue.

Fix Effectiveness
--------------------------------------------------------------------
The object is no longer freed while still reachable: all exit paths now
ensure either
  a) the feature flag is disabled → object is freed only when no
     external reference exists, or
  b) the flag is enabled → freeing is postponed to
     FsRtlpFreeRHOpContext after reference clearing.
No early free sites remain in the patched diff, so the original UAF
condition is removed.  No new obvious lifetimes issues are introduced
by the added helper.
