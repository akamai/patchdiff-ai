{'file': 'win32k.sys', 'cve': 'CVE-2025-50168', 'date': 1755089597.7626705, 'change_count': 4, 'confidence': 0.29, 'patch_store_uid': '6bf219c7-e158-4eeb-925e-32c7e52da820', 'kb': 'KB5063878'}
--------------------------------------------------------------------
CVE-2025-50168 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Microsoft win32k.sys – Api-set host-resolution helpers
(ApiSetpResolveHost, ApiSetResolveToHost, ApiSetpGetContractKeyInfo
and, most importantly, ApiSetpSearchForSectionIndex_V7).
The code is executed whenever a win32k system call needs to resolve
an Api-set DLL name (for example during client/server base‐API calls
originating from a user-mode process).


Vulnerability Class
--------------------------------------------------------------------
Type confusion that results in an out-of-bounds read/heap write
(CWE-843, leads to CWE-122 heap overflow / memory corruption).


Detailed Root Cause Analysis
--------------------------------------------------------------------
1. ApiSetpSearchForSectionIndex_V7 performs a binary search over a
   section table that is part of the kernel-resident Api-set schema.

2. The table header contains a 16-bit field that stores the element
   count.  In the vulnerable build the function read that field as a
   32-bit DWORD :
        v13 = *(DWORD *)(a2 + 4);
   Consequently the high 16 bits were interpreted as valid data even
   though they are uninitialised/attacker-controlled.

3. The routine therefore believed the section contained up to 2^32 –1
   entries, while only 0…65 535 really exist.  The derived index is
   then multiplied with the element stride taken from *(BYTE*)(a2+8)
   and added to the base pointer:
        v17 = base + 8 * idx – *(WORD *)(a1 + 6);
   The bogus idx causes v17 to point far beyond the legitimate table
   (or even before it because the code also used a wrong base offset
   of +6 instead of +18).

4. Two DWORDs are read from the computed address and returned as the
   matching section index.  ApiSetpResolveHost subsequently trusts this
   value and uses it to calculate further structure addresses that are
   later copied back to a caller-supplied output buffer.  The mix-up
   between WORD and DWORD therefore constitutes a classic type
   confusion that turns a logical value into a 32-bit pointer offset.

5. Because the Api-set binary blob is mapped from user memory, a local
   attacker can craft the header so that the upper half of the 32-bit
   count overflows into any chosen value.  This yields arbitrary read
   and limited write capabilities in kernel space and allows elevation
   to SYSTEM.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// before
v13 = *(_DWORD *)(a2 + 4);          // uses 32-bit count
...
return *(unsigned int *)(v17 + a1 + 4); // 32-bit index

// after
v13 = *(unsigned __int16 *)(a2 + 4); // correct 16-bit count
...
return *(unsigned __int16 *)(v17 + a1 + 4); // 16-bit index
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User process supplies a specially formatted api-set DLL name to a
   win32k syscall.
2. ApiSetResolveToHost → ApiSetpResolveHost → ApiSetpSearchForSection
   Index_V7.
3. Malicious header causes v13 (count) to overflow, index becomes
   attacker-controlled.
4. Out-of-range v17 is dereferenced; corrupted data propagates back to
   ApiSetpResolveHost.
5. Kernel copies data derived from the corrupt pointer into a user
   buffer, allowing privilege escalation or information disclosure.


Attack Vector
--------------------------------------------------------------------
From a low-privileged session, supply a crafted Api-set DLL string that
is at least eight characters long and embeds a forged api-set contract
key.  The name is parsed by ApiSetpGetContractKeyInfo and handed to
ApiSetpSearchForSectionIndex_V7 without having validated the 16-bit vs
32-bit field width, leading to controlled memory corruption in the
kernel address space.


Patch Description
--------------------------------------------------------------------
1. Correct data-type usage:
   • Count field read as unsigned __int16.
   • Function now returns an unsigned __int16 index; sentinel changed
     from 0xFFFFFFFF to 0xFFFF.
2. Pointer arithmetic fixed: offset uses *(WORD*)(a1+18) instead of +6.
3. Additional validation in ApiSetpGetContractKeyInfo (early accept of
   leading '-', explicit ban on '~', stricter digit handling).
4. Wrapper code (ApiSetpResolveHost / ApiSetResolveToHost) updated to
   recognise the 0xFFFF sentinel and to perform extra bounds checks
   before copying results to the caller.


Security Impact
--------------------------------------------------------------------
A local attacker could craft an api-set name that forces win32k to
compute an out-of-range index, leading to arbitrary kernel memory read
and limited write.  Because win32k runs in ring-0, this allows the
attacker to escalate privileges from standard user to SYSTEM and to
bypass Kernel Address Space Layout Randomisation (KASLR).


Fix Effectiveness
--------------------------------------------------------------------
The patch removes the type confusion by aligning variable widths with
structure definitions and by introducing consistent 16-bit sentinels.
All pointer arithmetic now uses the correct header offset.  Extra
validation in the helpers prevents malformed contract keys from being
processed.  No remaining code path was found that still interprets the
count as 32-bit, therefore the fix appears complete and effective.
